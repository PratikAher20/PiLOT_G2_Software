
PiLOT_sb_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  00000000  00000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  00000190  00000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000b4f0  000004c0  000004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000350  2000b000  0000b9b0  0001b000  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000012c0  2000b350  0000bd00  0001b350  2**4
                  ALLOC
  5 .heap         00007000  20000000  20000000  00020000  2**4
                  ALLOC
  6 .stack        00001000  20007000  20007000  00020000  2**4
                  ALLOC
  7 .comment      00000433  00000000  00000000  0001b350  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000de0  00000000  00000000  0001b783  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000267b  00000000  00000000  0001c563  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00015847  00000000  00000000  0001ebde  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000027cc  00000000  00000000  00034425  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed0e  00000000  00000000  00036bf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002ed4  00000000  00000000  00045900  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00005714  00000000  00000000  000487d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00004fc1  00000000  00000000  0004dee8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 000bbb08  00000000  00000000  00052ea9  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  0010e9b1  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00000dd0  00000000  00000000  0010e9d6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

00000000 <__vector_table_start>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   0:	20008000 	.word	0x20008000

uint8_t cmd_cntr = 0;
//uint16_t data_test[256] = {0};

void timer_intr_dis(){
	NVIC_DisableIRQ(FabricIrq4_IRQn);
   4:	00000191 	.word	0x00000191
   8:	0000037f 	.word	0x0000037f
}
   c:	00000381 	.word	0x00000381

void delay ( volatile unsigned int n)
{
	while(n!=0)
	{
		n--;
  10:	00000383 	.word	0x00000383

}

void delay ( volatile unsigned int n)
{
	while(n!=0)
  14:	00000385 	.word	0x00000385
	{
		n--;
	}
}
  18:	00000387 	.word	0x00000387
	...
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
}
  2c:	00000389 	.word	0x00000389
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
}
  30:	0000038b 	.word	0x0000038b
  34:	00000000 	.word	0x00000000

uint8_t vc_write_reg(i2c_instance_t* I2C, uint8_t vc_addr, uint8_t reg_addr,uint8_t *tx,uint8_t tx_size) {
    if((vc_write(I2C, vc_addr,&reg_addr,sizeof(reg_addr))) >= 10) {
        return 1;
    }
    if((vc_write(I2C, vc_addr,(uint8_t*)tx,tx_size)) >= 10) {
  38:	0000038d 	.word	0x0000038d
  3c:	0000038f 	.word	0x0000038f
  40:	00000391 	.word	0x00000391
  44:	00000393 	.word	0x00000393
        return 1;
  48:	000080c9 	.word	0x000080c9
    }

    return 0;
  4c:	000080ed 	.word	0x000080ed
}
  50:	00000399 	.word	0x00000399
  54:	0000039b 	.word	0x0000039b
  58:	0000039d 	.word	0x0000039d
	tx_buffer[1]=0x00; //byte 1 for free register 0
	tx_buffer[2]=0x00; //byte 2 for free register 0
	tx_buffer[3]=0x02;  //byte 3 for free register 00000010 RST2=0, RST1=1, RST0=0 for resetting
	I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_RELEASE_BUS);
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
	return status;
  5c:	0000039f 	.word	0x0000039f
}
  60:	000003a1 	.word	0x000003a1
  64:	000003a3 	.word	0x000003a3
    //Using old drivers
    //ADF_SPI_SLAVE_SELECT(adf_spi,0);
    //Using new drivers
    ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);

    return 0;
  68:	00006749 	.word	0x00006749

}
  6c:	0000676d 	.word	0x0000676d

	do{
		timer_dis();
		adf_read_from_memory(RMODE_1, IRQ_CTRL_STATUS0, rx_buf, 4);
		timer_ena();
		if(rx_buf[5] == 0xDF){
  70:	000003a9 	.word	0x000003a9
	adf_write_to_memory(WMODE_1, GPIO_CONFIG_ADDR1, data1, sizeof(data1));	// Power On LNA connected to GPIO_0 in older design and GPIO_1 in newer version.
																			// Power On PA connected to GPIO_1 in older design and GPIO_2 in newer version
	while((rx_buffer[0] == 0x00) && tries++ < 100){
		adf_read_from_memory(RMODE_1, GPIO_CONFIG_ADDR1, rx_buffer, 6);
	}
	if(tries >= 100) {
  74:	000003ab 	.word	0x000003ab
		return 1;
  78:	000003ad 	.word	0x000003ad
  7c:	000003af 	.word	0x000003af
	}

	rx_buffer[0] = 0x00;
  80:	000003b1 	.word	0x000003b1
	tries = 0;
  84:	000003b3 	.word	0x000003b3
	   ADF_SPI_BLOCK_READ(adf_spi,&nop,1, &check_val,1);
	   if((check_val & CMD_READY) != 0) {
		   break;
	   }
   }while(tries++ < 100);
   if(tries >= 100) {
  88:	000003b5 	.word	0x000003b5
	}

	rx_buffer[0] = 0x00;
	tries = 0;
	while((rx_buffer[0] == 0x00) && tries++ < 100){
		adf_read_from_memory(RMODE_1, TX_CONFIG1_REG, rx_buffer, 6);
  8c:	0000b005 	.word	0x0000b005
	do{
		timer_dis();
		adf_read_from_memory(RMODE_1, IRQ_CTRL_STATUS0, rx_buf, 4);
		timer_ena();
		if(rx_buf[5] == 0xDF){
			break;
  90:	000003b9 	.word	0x000003b9
   }while(tries++ < 100);
   if(tries >= 100) {
	   return ERR_CMD_FAILED;
   }

   ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
  94:	000003bb 	.word	0x000003bb
  98:	000003bd 	.word	0x000003bd
//	}		//Give number of tries

//	chk_status();
	//If tries<100 read from rx_buffer! or else do not
	if(tries < 100){
		*cmd_rx_flg = 1;
  9c:	000003bf 	.word	0x000003bf
  a0:	000003c1 	.word	0x000003c1


		adf_read_from_memory(RMODE_1, RX_BUFFER, rx_buf, 4);
  a4:	000003c3 	.word	0x000003c3
	   return ERR_CMD_FAILED;
   }

   ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);

   rdata = check_val;
  a8:	000003c5 	.word	0x000003c5
   while(rdata){
  ac:	000003c7 	.word	0x000003c7
//   	echo_str("Data: \0");
//	echo_str(op_data);
//	echo_str("\n\r\0");

   return 0;
}
  b0:	000003c9 	.word	0x000003c9
  b4:	000003cb 	.word	0x000003cb
   ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);

   rdata = check_val;
   while(rdata){
   		rem = rdata%16;
   		if(rem<10) {
  b8:	000003cd 	.word	0x000003cd
   			op_data[i] = rem + '0';
  bc:	000003cf 	.word	0x000003cf
	uint8_t clr_tx[4];
	uint8_t i=0;
	uint8_t tx_buf[*size];

	for(;i<*size;i++){
		tx_buf[i] = tx_buffer[*size - (i+1)];
  c0:	000003d1 	.word	0x000003d1
	rx_buffer[0] = 0x00;
	tries = 0;
	while((rx_buffer[0] == 0x00) && tries++ < 100){
		adf_read_from_memory(RMODE_1, TX_CONFIG1_REG, rx_buffer, 6);
	}
	if(tries >= 100) {
  c4:	000003d3 	.word	0x000003d3
  c8:	00003831 	.word	0x00003831

		adf_read_from_memory(RMODE_1, RX_BUFFER, rx_buf, 4);

		cmd[0] = rx_buf[5];
		cmd[1] = rx_buf[4];
		cmd[2] = rx_buf[3];
  cc:	00003845 	.word	0x00003845


	uint8_t data2[4];


	data2[0] = rx_buffer[2] | 0x01;
  d0:	00003859 	.word	0x00003859
   while(rdata){
   		rem = rdata%16;
   		if(rem<10) {
   			op_data[i] = rem + '0';
   		} else {
   			op_data[i] = rem + 'A' - 10;
  d4:	0000386d 	.word	0x0000386d
		adf_read_from_memory(RMODE_1, RX_BUFFER, rx_buf, 4);

		cmd[0] = rx_buf[5];
		cmd[1] = rx_buf[4];
		cmd[2] = rx_buf[3];
		cmd[3] = rx_buf[2];
  d8:	00003881 	.word	0x00003881

	uint8_t data2[4];


	data2[0] = rx_buffer[2] | 0x01;
	data2[1] = rx_buffer[3] | 0x07;
  dc:	0000388d 	.word	0x0000388d
		cmd[3] = rx_buf[2];

//		adf_read_from_memory(RMODE_1, RX_BUFFER + 4, rx_buf, cmd_list[cmd[0] - 1].length - 3);	TODO Rectify This..Gives HardFualt Handler
//		cmd[4] = rx_buf[5];

		if(cmd_list[cmd[0] - 1].length > 4 && cmd_list[cmd[0] - 1].length <= 8){
  e0:	00003899 	.word	0x00003899
	uint8_t data2[4];


	data2[0] = rx_buffer[2] | 0x01;
	data2[1] = rx_buffer[3] | 0x07;
	data2[2] = rx_buffer[4];
  e4:	000038a5 	.word	0x000038a5
	data2[3] = rx_buffer[5];
  e8:	000038b1 	.word	0x000038b1

	adf_write_to_memory(WMODE_1, TX_CONFIG1_REG, data2, sizeof(data2));
  ec:	000003e7 	.word	0x000003e7
   			op_data[i] = rem + '0';
   		} else {
   			op_data[i] = rem + 'A' - 10;
   		}
   		i--;
   		rdata/=16;
  f0:	000003e9 	.word	0x000003e9
  f4:	000003eb 	.word	0x000003eb
   }

   ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);

   rdata = check_val;
   while(rdata){
  f8:	000003ed 	.word	0x000003ed
   			op_data[i] = rem + 'A' - 10;
   		}
   		i--;
   		rdata/=16;
   	}
   	op_data[1] = '\0';
  fc:	000003ef 	.word	0x000003ef
 100:	000003f1 	.word	0x000003f1

   	echo_str("\n\r\0");
 104:	000003f3 	.word	0x000003f3
	data2[3] = rx_buffer[5];

	adf_write_to_memory(WMODE_1, TX_CONFIG1_REG, data2, sizeof(data2));

	while((rx_buffer[0] == 0x00) && tries++ < 100){
		adf_read_from_memory(RMODE_1, TX_CONFIG1_REG, rx_buffer, 6);
 108:	000003f5 	.word	0x000003f5
 10c:	00003ea5 	.word	0x00003ea5
   		rdata/=16;
   	}
   	op_data[1] = '\0';

   	echo_str("\n\r\0");
   	echo_str("Data: \0");
 110:	000003f9 	.word	0x000003f9
 114:	00003efd 	.word	0x00003efd
 118:	000003fd 	.word	0x000003fd
	echo_str(op_data);
 11c:	000003ff 	.word	0x000003ff
 120:	00000401 	.word	0x00000401
	data2[2] = rx_buffer[4];
	data2[3] = rx_buffer[5];

	adf_write_to_memory(WMODE_1, TX_CONFIG1_REG, data2, sizeof(data2));

	while((rx_buffer[0] == 0x00) && tries++ < 100){
 124:	00000403 	.word	0x00000403
	clr_tx[2] = 0xff;
	clr_tx[3] = 0xff;

	adf_read_from_memory(RMODE_1, GENERIC_PKT_FRAME_CFG1, rx_buf, 4);

	set_size[0] = rx_buf[2];
 128:	00000405 	.word	0x00000405
	set_size[1] = rx_buf[3];
 12c:	00000407 	.word	0x00000407
	set_size[2] = rx_buf[4];
 130:	00000409 	.word	0x00000409
	set_size[3] = *size;
 134:	0000040b 	.word	0x0000040b
 138:	0000040d 	.word	0x0000040d

//		adf_read_from_memory(RMODE_1, RX_BUFFER + 4, rx_buf, cmd_list[cmd[0] - 1].length - 3);	TODO Rectify This..Gives HardFualt Handler
//		cmd[4] = rx_buf[5];

		if(cmd_list[cmd[0] - 1].length > 4 && cmd_list[cmd[0] - 1].length <= 8){
			adf_read_from_memory(RMODE_1, RX_BUFFER + 4, rx_buf, 4);
 13c:	0000040f 	.word	0x0000040f
	adf_write_to_memory(WMODE_1, TX_CONFIG1_REG, data2, sizeof(data2));

	while((rx_buffer[0] == 0x00) && tries++ < 100){
		adf_read_from_memory(RMODE_1, TX_CONFIG1_REG, rx_buffer, 6);
	}
	tries = 0;
 140:	00000411 	.word	0x00000411
 144:	00000413 	.word	0x00000413
	if(tries >= 100) {
 148:	00000415 	.word	0x00000415
		return 1;
 14c:	00000417 	.word	0x00000417
 150:	00000419 	.word	0x00000419
	set_size[2] = rx_buf[4];
	set_size[3] = *size;

	adf_write_to_memory(WMODE_1, GENERIC_PKT_FRAME_CFG1, set_size, 4);

	adf_write_to_memory(WMODE_1, TX_BUFFER, tx_buf, 4);
 154:	0000041b 	.word	0x0000041b
	if(tries >= 100) {
		return 1;
	}
	return 0;

}
 158:	0000041d 	.word	0x0000041d
 15c:	0000041f 	.word	0x0000041f
//		cmd[4] = rx_buf[5];

		if(cmd_list[cmd[0] - 1].length > 4 && cmd_list[cmd[0] - 1].length <= 8){
			adf_read_from_memory(RMODE_1, RX_BUFFER + 4, rx_buf, 4);
			cmd[4] = rx_buf[5];
			cmd[5] = rx_buf[4];
 160:	00000421 	.word	0x00000421
 164:	00000423 	.word	0x00000423
 168:	00000425 	.word	0x00000425

	adf_write_to_memory(WMODE_1, GENERIC_PKT_FRAME_CFG1, set_size, 4);

	adf_write_to_memory(WMODE_1, TX_BUFFER, tx_buf, 4);

	chk_status();
 16c:	00000427 	.word	0x00000427

	adf_send_cmd(CMD_PHY_TX);
 170:	00000429 	.word	0x00000429
		if(cmd_list[cmd[0] - 1].length > 4 && cmd_list[cmd[0] - 1].length <= 8){
			adf_read_from_memory(RMODE_1, RX_BUFFER + 4, rx_buf, 4);
			cmd[4] = rx_buf[5];
			cmd[5] = rx_buf[4];
			cmd[6] = rx_buf[3];
			cmd[7] = rx_buf[2];
 174:	0000042b 	.word	0x0000042b

	chk_status();

	adf_send_cmd(CMD_PHY_TX);

	chk_status();
 178:	0000042d 	.word	0x0000042d

	if(adf_get_state() == PHY_ON){
 17c:	0000042f 	.word	0x0000042f
			cmd[5] = rx_buf[4];
			cmd[6] = rx_buf[3];
			cmd[7] = rx_buf[2];
		}

		else if(cmd_list[cmd[0] - 1].length > 8 && cmd_list[cmd[0] - 1].length <= 16){
 180:	00000431 	.word	0x00000431
 184:	00000433 	.word	0x00000433
	...

Disassembly of section .boot_code:

00000190 <Reset_Handler>:
	adf_send_cmd(CMD_PHY_TX);

	chk_status();

	if(adf_get_state() == PHY_ON){
		adf_write_to_memory(WMODE_1, TX_BUFFER, clr_tx, 4);
 190:	f04f 0b00 	mov.w	fp, #0
 194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 456 <SF2_MDDR_MODE_CR>
 198:	6800      	ldr	r0, [r0, #0]
 19a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 452 <SF2_EDAC_CR>
 19e:	6809      	ldr	r1, [r1, #0]
	}


	return 0;
 1a0:	f001 0103 	and.w	r1, r1, #3
 1a4:	f000 001c 	and.w	r0, r0, #28
}
 1a8:	2814      	cmp	r0, #20
 1aa:	d101      	bne.n	1b0 <check_esram_edac>
 1ac:	f04b 0b02 	orr.w	fp, fp, #2

000001b0 <check_esram_edac>:
 1b0:	2900      	cmp	r1, #0

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
 1b2:	d001      	beq.n	1b8 <check_stack_init>
 1b4:	f04b 0b01 	orr.w	fp, fp, #1

000001b8 <check_stack_init>:
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
 1b8:	f1bb 0f00 	cmp.w	fp, #0
 1bc:	d005      	beq.n	1ca <system_init>

000001be <clear_stack>:
 1be:	48a7      	ldr	r0, [pc, #668]	; (45c <SF2_MDDR_MODE_CR+0x6>)
 1c0:	49a7      	ldr	r1, [pc, #668]	; (460 <SF2_MDDR_MODE_CR+0xa>)
 1c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 436 <RAM_INIT_PATTERN>
 1c6:	f000 f89f 	bl	308 <fill_memory>

000001ca <system_init>:
        sequence = determine_seq(divisor[2], &len);
 1ca:	48a6      	ldr	r0, [pc, #664]	; (464 <SF2_MDDR_MODE_CR+0xe>)
 1cc:	4780      	blx	r0
 1ce:	f00b 0a02 	and.w	sl, fp, #2
 1d2:	f1ba 0f00 	cmp.w	sl, #0
 1d6:	d00c      	beq.n	1f2 <remap_memory>
 1d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 44a <SF2_DDRB_NB_SIZE>
 1dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 44e <SF2_DDRB_CR>
 1e0:	6802      	ldr	r2, [r0, #0]
 1e2:	680b      	ldr	r3, [r1, #0]
 1e4:	b40f      	push	{r0, r1, r2, r3}
        
        for(var = 1; var < len; var++)
 1e6:	f04f 0200 	mov.w	r2, #0
 1ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
 1ee:	6002      	str	r2, [r0, #0]
 1f0:	600b      	str	r3, [r1, #0]

000001f2 <remap_memory>:
 1f2:	489d      	ldr	r0, [pc, #628]	; (468 <SF2_MDDR_MODE_CR+0x12>)
 1f4:	4a9d      	ldr	r2, [pc, #628]	; (46c <SF2_MDDR_MODE_CR+0x16>)
 1f6:	4b9e      	ldr	r3, [pc, #632]	; (470 <SF2_MDDR_MODE_CR+0x1a>)
 1f8:	2802      	cmp	r0, #2
 1fa:	d108      	bne.n	20e <check_esram_remap>
            temp &= 0xFFFFF1FFu;
 1fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 43e <SF2_ESRAM_CR>
 200:	600a      	str	r2, [r1, #0]
 202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 446 <SF2_ENVM_REMAP_CR>
            temp |= ((uint32_t)(sequence[var]) << 9);
 206:	600a      	str	r2, [r1, #0]
 208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 442 <SF2_DDR_CR>
 20c:	600b      	str	r3, [r1, #0]

0000020e <check_esram_remap>:
 20e:	2801      	cmp	r0, #1
 210:	d108      	bne.n	224 <check_mirrored_nvm>
 212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 442 <SF2_DDR_CR>
 216:	600a      	str	r2, [r1, #0]
            SYSREG->MSSDDR_FACC1_CR = temp;
 218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 446 <SF2_ENVM_REMAP_CR>
 21c:	600a      	str	r2, [r1, #0]
 21e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 43e <SF2_ESRAM_CR>
 222:	600b      	str	r3, [r1, #0]

00000224 <check_mirrored_nvm>:
 224:	4893      	ldr	r0, [pc, #588]	; (474 <SF2_MDDR_MODE_CR+0x1e>)

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
 226:	2800      	cmp	r0, #0
 228:	d109      	bne.n	23e <copy_data>
 22a:	4893      	ldr	r0, [pc, #588]	; (478 <SF2_MDDR_MODE_CR+0x22>)
 22c:	4993      	ldr	r1, [pc, #588]	; (47c <SF2_MDDR_MODE_CR+0x26>)
 22e:	4a94      	ldr	r2, [pc, #592]	; (480 <SF2_MDDR_MODE_CR+0x2a>)
 230:	f000 f832 	bl	298 <block_copy>

00000234 <copy_text>:
 234:	4893      	ldr	r0, [pc, #588]	; (484 <SF2_MDDR_MODE_CR+0x2e>)
 236:	4994      	ldr	r1, [pc, #592]	; (488 <SF2_MDDR_MODE_CR+0x32>)
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
 238:	4a94      	ldr	r2, [pc, #592]	; (48c <SF2_MDDR_MODE_CR+0x36>)
 23a:	f000 f82d 	bl	298 <block_copy>

0000023e <copy_data>:
 23e:	4894      	ldr	r0, [pc, #592]	; (490 <SF2_MDDR_MODE_CR+0x3a>)
 240:	4994      	ldr	r1, [pc, #592]	; (494 <SF2_MDDR_MODE_CR+0x3e>)
 242:	4a95      	ldr	r2, [pc, #596]	; (498 <SF2_MDDR_MODE_CR+0x42>)
 244:	f000 f828 	bl	298 <block_copy>

00000248 <clear_bss>:
 248:	4894      	ldr	r0, [pc, #592]	; (49c <SF2_MDDR_MODE_CR+0x46>)
 24a:	4995      	ldr	r1, [pc, #596]	; (4a0 <SF2_MDDR_MODE_CR+0x4a>)
        sequence = determine_seq(divisor[3], &len);
 24c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 436 <RAM_INIT_PATTERN>
 250:	f000 f85a 	bl	308 <fill_memory>

00000254 <clear_heap>:
 254:	f1bb 0f00 	cmp.w	fp, #0
 258:	d012      	beq.n	280 <call_glob_ctor>
 25a:	4892      	ldr	r0, [pc, #584]	; (4a4 <SF2_MDDR_MODE_CR+0x4e>)
 25c:	4992      	ldr	r1, [pc, #584]	; (4a8 <SF2_MDDR_MODE_CR+0x52>)
 25e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 43a <HEAP_INIT_PATTERN>
 262:	f000 f851 	bl	308 <fill_memory>
 266:	f00b 0a02 	and.w	sl, fp, #2
        for(var = 1; var < len; var++)
 26a:	f1ba 0f00 	cmp.w	sl, #0
 26e:	d007      	beq.n	280 <call_glob_ctor>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
 270:	bc0f      	pop	{r0, r1, r2, r3}
 272:	6002      	str	r2, [r0, #0]
 274:	600b      	str	r3, [r1, #0]
 276:	bf00      	nop
 278:	f3af 8000 	nop.w
 27c:	f3af 8000 	nop.w

00000280 <call_glob_ctor>:
            temp &= 0xFFC7FFFFu;
 280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 4ac <SF2_MDDR_MODE_CR+0x56>
 284:	f20f 0e03 	addw	lr, pc, #3
            temp |= ((uint32_t)(sequence[var]) << 19);
 288:	4700      	bx	r0

0000028a <branch_to_main>:
 28a:	f04f 0000 	mov.w	r0, #0
 28e:	f04f 0100 	mov.w	r1, #0
 292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 4b0 <SF2_MDDR_MODE_CR+0x5a>

00000296 <ExitLoop>:
 296:	e7fe      	b.n	296 <ExitLoop>

00000298 <block_copy>:
 298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
            SYSREG->MSSDDR_FACC1_CR = temp;
 29c:	4288      	cmp	r0, r1
 29e:	d025      	beq.n	2ec <block_copy_exit>
 2a0:	ebb2 0201 	subs.w	r2, r2, r1
 2a4:	d500      	bpl.n	2a8 <block_copy_address_ok>
 2a6:	e7fe      	b.n	2a6 <block_copy+0xe>

000002a8 <block_copy_address_ok>:
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
 2a8:	ea40 0301 	orr.w	r3, r0, r1
 2ac:	f013 0303 	ands.w	r3, r3, #3
 2b0:	d002      	beq.n	2b8 <block_copy_continue>

000002b2 <block_copy_byte_copy>:
 2b2:	f000 f81d 	bl	2f0 <block_copy_byte>
 2b6:	e019      	b.n	2ec <block_copy_exit>

000002b8 <block_copy_continue>:
 2b8:	f04f 0300 	mov.w	r3, #0

        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 1 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from CLK_STANDBY
         * clock.
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR | 0x00001000u;
 2bc:	4690      	mov	r8, r2
 2be:	1112      	asrs	r2, r2, #4
 2c0:	d0f7      	beq.n	2b2 <block_copy_byte_copy>

000002c2 <block_copy_loop>:
 2c2:	429a      	cmp	r2, r3
 2c4:	bf1c      	itt	ne
 2c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
 2c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
 2ca:	f103 0301 	add.w	r3, r3, #1
 2ce:	d1f8      	bne.n	2c2 <block_copy_loop>
 2d0:	f008 080f 	and.w	r8, r8, #15
 2d4:	f1b8 0f00 	cmp.w	r8, #0
        
        status = CLOCK_SWITCHING_SUCCESS;
 2d8:	d008      	beq.n	2ec <block_copy_exit>

000002da <copy_spare_bytes>:
 2da:	7804      	ldrb	r4, [r0, #0]
 2dc:	700c      	strb	r4, [r1, #0]
    }
    /* For 060 devices */
    else if(0xF808u == device_version)
 2de:	f100 0001 	add.w	r0, r0, #1
 2e2:	f101 0101 	add.w	r1, r1, #1
 2e6:	f1b8 0801 	subs.w	r8, r8, #1
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
 2ea:	d1f6      	bne.n	2da <copy_spare_bytes>

000002ec <block_copy_exit>:
 2ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

000002f0 <block_copy_byte>:
 2f0:	b508      	push	{r3, lr}
 2f2:	f04f 0300 	mov.w	r3, #0

000002f6 <block_copy_byte_loop>:
 2f6:	7803      	ldrb	r3, [r0, #0]
 2f8:	700b      	strb	r3, [r1, #0]
 2fa:	f100 0001 	add.w	r0, r0, #1
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
 2fe:	f101 0101 	add.w	r1, r1, #1
 302:	3a01      	subs	r2, #1
 304:	d1f7      	bne.n	2f6 <block_copy_byte_loop>
 306:	bd08      	pop	{r3, pc}

00000308 <fill_memory>:
 308:	4288      	cmp	r0, r1
 30a:	d037      	beq.n	37c <fill_memory_exit>
 30c:	f000 0603 	and.w	r6, r0, #3
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
 310:	2e00      	cmp	r6, #0
 312:	d014      	beq.n	33e <fill_memory_end_start>
 314:	f04f 0504 	mov.w	r5, #4
 318:	eba5 0406 	sub.w	r4, r5, r6
 31c:	f04f 0708 	mov.w	r7, #8
 320:	fb07 f806 	mul.w	r8, r7, r6
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
 324:	4691      	mov	r9, r2
 326:	fa69 f908 	ror.w	r9, r9, r8

0000032a <fill_memory_spare_bytes_start>:
 32a:	2c00      	cmp	r4, #0
 32c:	d007      	beq.n	33e <fill_memory_end_start>
 32e:	f880 9000 	strb.w	r9, [r0]
 332:	fa69 f907 	ror.w	r9, r9, r7
 336:	f100 0001 	add.w	r0, r0, #1
       
        for(var = 1; var < 4; var++)
 33a:	3c01      	subs	r4, #1
 33c:	e7f5      	b.n	32a <fill_memory_spare_bytes_start>

0000033e <fill_memory_end_start>:
 33e:	f04f 0600 	mov.w	r6, #0
        {
            if((divisor[var] != divisor[0]) || \
 342:	460f      	mov	r7, r1
 344:	1a09      	subs	r1, r1, r0
 346:	4688      	mov	r8, r1
 348:	1109      	asrs	r1, r1, #4
 34a:	4691      	mov	r9, r2
 34c:	4614      	mov	r4, r2
 34e:	4615      	mov	r5, r2
 350:	42b1      	cmp	r1, r6
 352:	d006      	beq.n	362 <fill_memory_spare_bytes_end>

00000354 <fill_memory_loop>:
 354:	bf18      	it	ne
 356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
 35a:	f106 0601 	add.w	r6, r6, #1
               (divisor[0] > 5) || (divisor[var] > 5))
 35e:	42b1      	cmp	r1, r6
 360:	d1f8      	bne.n	354 <fill_memory_loop>

00000362 <fill_memory_spare_bytes_end>:
 362:	f008 080f 	and.w	r8, r8, #15

00000366 <fill_memory_spare_end_loop>:
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
 366:	f1b8 0f00 	cmp.w	r8, #0
               (divisor[0] > 5) || (divisor[var] > 5))
 36a:	d007      	beq.n	37c <fill_memory_exit>
 36c:	7002      	strb	r2, [r0, #0]
 36e:	ea4f 2232 	mov.w	r2, r2, ror #8
 372:	f100 0001 	add.w	r0, r0, #1
 376:	f1b8 0801 	subs.w	r8, r8, #1
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
 37a:	e7f4      	b.n	366 <fill_memory_spare_end_loop>

0000037c <fill_memory_exit>:
               (divisor[0] > 5) || (divisor[var] > 5))
            {
                /* If the divisor value does meet the criteria, log the clock 
                 * switching error.
                 */
                status = CLOCK_SWITCHING_ERROR;
 37c:	4770      	bx	lr

0000037e <NMI_Handler>:
 37e:	e7fe      	b.n	37e <NMI_Handler>

00000380 <HardFault_Handler>:
 380:	e7fe      	b.n	380 <HardFault_Handler>

00000382 <MemManage_Handler>:
                break;
 382:	e7fe      	b.n	382 <MemManage_Handler>

00000384 <BusFault_Handler>:
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
 384:	e7fe      	b.n	384 <BusFault_Handler>

00000386 <UsageFault_Handler>:
 386:	e7fe      	b.n	386 <UsageFault_Handler>

00000388 <SVC_Handler>:
 388:	e7fe      	b.n	388 <SVC_Handler>

0000038a <DebugMon_Handler>:
 38a:	e7fe      	b.n	38a <DebugMon_Handler>

0000038c <PendSV_Handler>:
 38c:	e7fe      	b.n	38c <PendSV_Handler>

0000038e <SysTick_Handler>:
 38e:	e7fe      	b.n	38e <SysTick_Handler>

00000390 <WdogWakeup_IRQHandler>:
 390:	e7fe      	b.n	390 <WdogWakeup_IRQHandler>

00000392 <RTC_Wakeup_IRQHandler>:
    else
    {
         /* Do Nothing. */
    }
    
    return status;
 392:	e7fe      	b.n	392 <RTC_Wakeup_IRQHandler>
}
 394:	e7fe      	b.n	394 <RTC_Wakeup_IRQHandler+0x2>
 396:	e7fe      	b.n	396 <RTC_Wakeup_IRQHandler+0x4>

00000398 <I2C0_IRQHandler>:
 398:	e7fe      	b.n	398 <I2C0_IRQHandler>

0000039a <I2C0_SMBAlert_IRQHandler>:
 39a:	e7fe      	b.n	39a <I2C0_SMBAlert_IRQHandler>

0000039c <I2C0_SMBus_IRQHandler>:
 39c:	e7fe      	b.n	39c <I2C0_SMBus_IRQHandler>

0000039e <I2C1_IRQHandler>:
            {
                this_spi->cmd_handler( this_spi->slave_rx_buffer, this_spi->slave_rx_idx );
            }
            this_spi->cmd_done = 1u;
            /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL2_INTCMD, DISABLE );
 39e:	e7fe      	b.n	39e <I2C1_IRQHandler>

000003a0 <I2C1_SMBAlert_IRQHandler>:
 3a0:	e7fe      	b.n	3a0 <I2C1_SMBAlert_IRQHandler>

000003a2 <I2C1_SMBus_IRQHandler>:
 3a2:	e7fe      	b.n	3a2 <I2C1_SMBus_IRQHandler>
 3a4:	e7fe      	b.n	3a4 <I2C1_SMBus_IRQHandler+0x2>
 3a6:	e7fe      	b.n	3a6 <I2C1_SMBus_IRQHandler+0x4>

000003a8 <EthernetMAC_IRQHandler>:
 3a8:	e7fe      	b.n	3a8 <EthernetMAC_IRQHandler>

000003aa <DMA_IRQHandler>:
 3aa:	e7fe      	b.n	3aa <DMA_IRQHandler>

000003ac <Timer1_IRQHandler>:
 3ac:	e7fe      	b.n	3ac <Timer1_IRQHandler>

000003ae <Timer2_IRQHandler>:
 3ae:	e7fe      	b.n	3ae <Timer2_IRQHandler>

000003b0 <CAN_IRQHandler>:
            HAL_set_8bit_reg_field( this_spi->base_addr, INTCLR_CMDINT, ENABLE );
 3b0:	e7fe      	b.n	3b0 <CAN_IRQHandler>

000003b2 <ENVM0_IRQHandler>:
 3b2:	e7fe      	b.n	3b2 <ENVM0_IRQHandler>

000003b4 <ENVM1_IRQHandler>:
 3b4:	e7fe      	b.n	3b4 <ENVM1_IRQHandler>
 3b6:	e7fe      	b.n	3b6 <ENVM1_IRQHandler+0x2>

000003b8 <USB_IRQHandler>:
 3b8:	e7fe      	b.n	3b8 <USB_IRQHandler>

000003ba <USB_DMA_IRQHandler>:
 3ba:	e7fe      	b.n	3ba <USB_DMA_IRQHandler>

000003bc <PLL_Lock_IRQHandler>:
 3bc:	e7fe      	b.n	3bc <PLL_Lock_IRQHandler>

000003be <PLL_LockLost_IRQHandler>:
 3be:	e7fe      	b.n	3be <PLL_LockLost_IRQHandler>

000003c0 <CommSwitchError_IRQHandler>:
 3c0:	e7fe      	b.n	3c0 <CommSwitchError_IRQHandler>

000003c2 <CacheError_IRQHandler>:
 3c2:	e7fe      	b.n	3c2 <CacheError_IRQHandler>

000003c4 <DDR_IRQHandler>:
 3c4:	e7fe      	b.n	3c4 <DDR_IRQHandler>

000003c6 <HPDMA_Complete_IRQHandler>:
 3c6:	e7fe      	b.n	3c6 <HPDMA_Complete_IRQHandler>

000003c8 <HPDMA_Error_IRQHandler>:
 3c8:	e7fe      	b.n	3c8 <HPDMA_Error_IRQHandler>

000003ca <ECC_Error_IRQHandler>:
        }

        /* Handle slave select becoming de-asserted. */
        if( ENABLE == HAL_get_8bit_reg_field( this_spi->base_addr, INTMASK_SSEND) )
 3ca:	e7fe      	b.n	3ca <ECC_Error_IRQHandler>

000003cc <MDDR_IOCalib_IRQHandler>:
 3cc:	e7fe      	b.n	3cc <MDDR_IOCalib_IRQHandler>

000003ce <FAB_PLL_Lock_IRQHandler>:
 3ce:	e7fe      	b.n	3ce <FAB_PLL_Lock_IRQHandler>

000003d0 <FAB_PLL_LockLost_IRQHandler>:
 3d0:	e7fe      	b.n	3d0 <FAB_PLL_LockLost_IRQHandler>

000003d2 <FIC64_IRQHandler>:
 3d2:	e7fe      	b.n	3d2 <FIC64_IRQHandler>
 3d4:	e7fe      	b.n	3d4 <FIC64_IRQHandler+0x2>
 3d6:	e7fe      	b.n	3d6 <FIC64_IRQHandler+0x4>
 3d8:	e7fe      	b.n	3d8 <FIC64_IRQHandler+0x6>
 3da:	e7fe      	b.n	3da <FIC64_IRQHandler+0x8>
 3dc:	e7fe      	b.n	3dc <FIC64_IRQHandler+0xa>
 3de:	e7fe      	b.n	3de <FIC64_IRQHandler+0xc>
 3e0:	e7fe      	b.n	3e0 <FIC64_IRQHandler+0xe>
 3e2:	e7fe      	b.n	3e2 <FIC64_IRQHandler+0x10>
 3e4:	e7fe      	b.n	3e4 <FIC64_IRQHandler+0x12>

000003e6 <FabricIrq9_IRQHandler>:
        {
            /* Only supposed to do all this if transferring blocks... */
            if(SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
 3e6:	e7fe      	b.n	3e6 <FabricIrq9_IRQHandler>

000003e8 <FabricIrq10_IRQHandler>:
 3e8:	e7fe      	b.n	3e8 <FabricIrq10_IRQHandler>

000003ea <FabricIrq11_IRQHandler>:
 3ea:	e7fe      	b.n	3ea <FabricIrq11_IRQHandler>

000003ec <FabricIrq12_IRQHandler>:
 3ec:	e7fe      	b.n	3ec <FabricIrq12_IRQHandler>

000003ee <FabricIrq13_IRQHandler>:
 3ee:	e7fe      	b.n	3ee <FabricIrq13_IRQHandler>

000003f0 <FabricIrq14_IRQHandler>:
            {
                uint32_t rx_size;

                /* Empty any remaining bytes in RX FIFO */
                read_slave_rx_fifo( this_spi );
 3f0:	e7fe      	b.n	3f0 <FabricIrq14_IRQHandler>

000003f2 <FabricIrq15_IRQHandler>:
 3f2:	e7fe      	b.n	3f2 <FabricIrq15_IRQHandler>

000003f4 <GPIO0_IRQHandler>:
 3f4:	e7fe      	b.n	3f4 <GPIO0_IRQHandler>
                rx_size = this_spi->slave_rx_idx;
 3f6:	e7fe      	b.n	3f6 <GPIO0_IRQHandler+0x2>

000003f8 <GPIO2_IRQHandler>:
 3f8:	e7fe      	b.n	3f8 <GPIO2_IRQHandler>
 3fa:	e7fe      	b.n	3fa <GPIO2_IRQHandler+0x2>

000003fc <GPIO4_IRQHandler>:
                /*
                 * Re-enable command interrupt if required. 
                 * Must be done before re loading FIFO to ensure stale response
                 * data is not pushed into the FIFO.
                 */
                if(NULL_SLAVE_CMD_HANDLER != this_spi->cmd_handler)
 3fc:	e7fe      	b.n	3fc <GPIO4_IRQHandler>

000003fe <GPIO5_IRQHandler>:
 3fe:	e7fe      	b.n	3fe <GPIO5_IRQHandler>

00000400 <GPIO6_IRQHandler>:
 400:	e7fe      	b.n	400 <GPIO6_IRQHandler>

00000402 <GPIO7_IRQHandler>:
 402:	e7fe      	b.n	402 <GPIO7_IRQHandler>

00000404 <GPIO8_IRQHandler>:
                {
                    this_spi->cmd_done = 0u;
 404:	e7fe      	b.n	404 <GPIO8_IRQHandler>

00000406 <GPIO9_IRQHandler>:
 406:	e7fe      	b.n	406 <GPIO9_IRQHandler>

00000408 <GPIO10_IRQHandler>:
 408:	e7fe      	b.n	408 <GPIO10_IRQHandler>

0000040a <GPIO11_IRQHandler>:
 40a:	e7fe      	b.n	40a <GPIO11_IRQHandler>

0000040c <GPIO12_IRQHandler>:
                    this_spi->resp_tx_buffer = 0u;
 40c:	e7fe      	b.n	40c <GPIO12_IRQHandler>

0000040e <GPIO13_IRQHandler>:
 40e:	e7fe      	b.n	40e <GPIO13_IRQHandler>

00000410 <GPIO14_IRQHandler>:
 410:	e7fe      	b.n	410 <GPIO14_IRQHandler>

00000412 <GPIO15_IRQHandler>:
 412:	e7fe      	b.n	412 <GPIO15_IRQHandler>

00000414 <GPIO16_IRQHandler>:
                    this_spi->resp_buff_size = 0u;
 414:	e7fe      	b.n	414 <GPIO16_IRQHandler>

00000416 <GPIO17_IRQHandler>:
 416:	e7fe      	b.n	416 <GPIO17_IRQHandler>

00000418 <GPIO18_IRQHandler>:
 418:	e7fe      	b.n	418 <GPIO18_IRQHandler>

0000041a <GPIO19_IRQHandler>:
 41a:	e7fe      	b.n	41a <GPIO19_IRQHandler>

0000041c <GPIO20_IRQHandler>:
                    this_spi->resp_buff_tx_idx = 0u;
 41c:	e7fe      	b.n	41c <GPIO20_IRQHandler>

0000041e <GPIO21_IRQHandler>:
 41e:	e7fe      	b.n	41e <GPIO21_IRQHandler>

00000420 <GPIO22_IRQHandler>:
 420:	e7fe      	b.n	420 <GPIO22_IRQHandler>

00000422 <GPIO23_IRQHandler>:
 422:	e7fe      	b.n	422 <GPIO23_IRQHandler>

00000424 <GPIO24_IRQHandler>:
                    HAL_set_8bit_reg_field( this_spi->base_addr, INTCLR_CMDINT, ENABLE );
 424:	e7fe      	b.n	424 <GPIO24_IRQHandler>

00000426 <GPIO25_IRQHandler>:
 426:	e7fe      	b.n	426 <GPIO25_IRQHandler>

00000428 <GPIO26_IRQHandler>:
 428:	e7fe      	b.n	428 <GPIO26_IRQHandler>

0000042a <GPIO27_IRQHandler>:
 42a:	e7fe      	b.n	42a <GPIO27_IRQHandler>

0000042c <GPIO28_IRQHandler>:
 42c:	e7fe      	b.n	42c <GPIO28_IRQHandler>

0000042e <GPIO29_IRQHandler>:
 42e:	e7fe      	b.n	42e <GPIO29_IRQHandler>

00000430 <GPIO30_IRQHandler>:
 430:	e7fe      	b.n	430 <GPIO30_IRQHandler>

00000432 <GPIO31_IRQHandler>:
 432:	e7fe      	b.n	432 <GPIO31_IRQHandler>

00000434 <mscc_post_hw_cfg_init>:
 434:	4770      	bx	lr

00000436 <RAM_INIT_PATTERN>:
 436:	0000      	.short	0x0000
	...

0000043a <HEAP_INIT_PATTERN>:
 43a:	a2a2      	.short	0xa2a2
 43c:	a2a2      	.short	0xa2a2

0000043e <SF2_ESRAM_CR>:
                    HAL_set_8bit_reg_field( this_spi->base_addr, CTRL2_INTCMD, ENABLE );
 43e:	8000      	.short	0x8000
 440:	4003      	.short	0x4003

00000442 <SF2_DDR_CR>:
 442:	8008      	.short	0x8008
 444:	4003      	.short	0x4003

00000446 <SF2_ENVM_REMAP_CR>:
 446:	8010      	.short	0x8010
 448:	4003      	.short	0x4003

0000044a <SF2_DDRB_NB_SIZE>:
 44a:	8030      	.short	0x8030
 44c:	4003      	.short	0x4003

0000044e <SF2_DDRB_CR>:
 44e:	8034      	.short	0x8034
 450:	4003      	.short	0x4003

00000452 <SF2_EDAC_CR>:
 452:	8038      	.short	0x8038
 454:	4003      	.short	0x4003

00000456 <SF2_MDDR_MODE_CR>:
 456:	0818      	.short	0x0818
                /*
                 * Reset the transmit index to 0 to restart transmit at the start of the
                 * transmit buffer in the next transaction. This also requires flushing
                 * the Tx FIFO and refilling it with the start of Tx data buffer.
                 */
                this_spi->slave_tx_idx = 0u;
 458:	00004002 	.word	0x00004002
 45c:	20007000 	.word	0x20007000
                HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
 460:	20008000 	.word	0x20008000
 464:	0000ab31 	.word	0x0000ab31
	...
 470:	00000001 	.word	0x00000001
	...
                /* Prepare to receive next packet. */
                this_spi->slave_rx_idx = 0u;
                /*
                 * Call the receive handler if one exists.
                 */
                if( NULL_BLOCK_HANDLER != this_spi->block_rx_handler )
 480:	00000190 	.word	0x00000190
 484:	000004c0 	.word	0x000004c0
                {
                    this_spi->block_rx_handler( this_spi->slave_rx_buffer, rx_size );
 488:	000004c0 	.word	0x000004c0
 48c:	0000b9b0 	.word	0x0000b9b0
 490:	0000b9b0 	.word	0x0000b9b0
 494:	2000b000 	.word	0x2000b000
                }

                HAL_set_8bit_reg_field( this_spi->base_addr, INTCLR_RXDATA, ENABLE );
 498:	2000b350 	.word	0x2000b350
 49c:	2000b350 	.word	0x2000b350
 4a0:	2000c610 	.word	0x2000c610
 4a4:	20000000 	.word	0x20000000
 4a8:	20007000 	.word	0x20007000
 4ac:	0000b77d 	.word	0x0000b77d
            }

            HAL_set_8bit_reg_field( this_spi->base_addr, INTCLR_SSEND, ENABLE );
 4b0:	00003441 	.word	0x00003441
 4b4:	f3af 8000 	nop.w
 4b8:	f3af 8000 	nop.w
 4bc:	f3af 8000 	nop.w

Disassembly of section .text:

000004c0 <__do_global_dtors_aux>:
     4c0:	f24b 3350 	movw	r3, #45904	; 0xb350
     4c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4c8:	781a      	ldrb	r2, [r3, #0]
        }
    }
}
     4ca:	b90a      	cbnz	r2, 4d0 <__do_global_dtors_aux+0x10>
     4cc:	2001      	movs	r0, #1
     4ce:	7018      	strb	r0, [r3, #0]
     4d0:	4770      	bx	lr
     4d2:	bf00      	nop

000004d4 <frame_dummy>:
     4d4:	f24b 0000 	movw	r0, #45056	; 0xb000
     4d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
     4dc:	b508      	push	{r3, lr}
     4de:	6803      	ldr	r3, [r0, #0]
     4e0:	b12b      	cbz	r3, 4ee <frame_dummy+0x1a>
     4e2:	f240 0300 	movw	r3, #0
     4e6:	f2c0 0300 	movt	r3, #0
     4ea:	b103      	cbz	r3, 4ee <frame_dummy+0x1a>
     4ec:	4798      	blx	r3
     4ee:	bd08      	pop	{r3, pc}

000004f0 <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
     4f0:	b480      	push	{r7}
     4f2:	b083      	sub	sp, #12
     4f4:	af00      	add	r7, sp, #0
     4f6:	6078      	str	r0, [r7, #4]
     4f8:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
     4fa:	f244 0300 	movw	r3, #16384	; 0x4000
     4fe:	f2c4 0300 	movt	r3, #16384	; 0x4000
     502:	6b5a      	ldr	r2, [r3, #52]	; 0x34
     504:	683b      	ldr	r3, [r7, #0]
     506:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
     508:	f244 0300 	movw	r3, #16384	; 0x4000
     50c:	f2c4 0300 	movt	r3, #16384	; 0x4000
     510:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     512:	687b      	ldr	r3, [r7, #4]
     514:	601a      	str	r2, [r3, #0]
}
     516:	f107 070c 	add.w	r7, r7, #12
     51a:	46bd      	mov	sp, r7
     51c:	bc80      	pop	{r7}
     51e:	4770      	bx	lr

00000520 <MSS_WD_current_value>:
  @return
    This function returns the current value of the watchdog’s down-counter as
    a 32-bit unsigned integer.
 */
static __INLINE uint32_t MSS_WD_current_value(void)
{
     520:	b480      	push	{r7}
     522:	af00      	add	r7, sp, #0
    return WATCHDOG->WDOGVALUE;
     524:	f245 0300 	movw	r3, #20480	; 0x5000
     528:	f2c4 0300 	movt	r3, #16384	; 0x4000
     52c:	681b      	ldr	r3, [r3, #0]
}
     52e:	4618      	mov	r0, r3
     530:	46bd      	mov	sp, r7
     532:	bc80      	pop	{r7}
     534:	4770      	bx	lr
     536:	bf00      	nop

00000538 <store_pkt>:

void timer_intr_en(){
	NVIC_EnableIRQ(FabricIrq4_IRQn);
}

void store_pkt(){
     538:	b580      	push	{r7, lr}
     53a:	b082      	sub	sp, #8
     53c:	af00      	add	r7, sp, #0
	uint16_t i = 0;
     53e:	f04f 0300 	mov.w	r3, #0
     542:	80fb      	strh	r3, [r7, #6]


		for(;i<256;i++){
     544:	e01e      	b.n	584 <store_pkt+0x4c>

			HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) blck_pkt[active_blck - 1][i]);
     546:	f24b 3357 	movw	r3, #45911	; 0xb357
     54a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     54e:	781b      	ldrb	r3, [r3, #0]
     550:	f103 31ff 	add.w	r1, r3, #4294967295
     554:	88fa      	ldrh	r2, [r7, #6]
     556:	f64b 034c 	movw	r3, #47180	; 0xb84c
     55a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     55e:	ea4f 2101 	mov.w	r1, r1, lsl #8
     562:	440a      	add	r2, r1
     564:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
     568:	f245 0000 	movw	r0, #20480	; 0x5000
     56c:	f2c5 0000 	movt	r0, #20480	; 0x5000
     570:	4619      	mov	r1, r3
     572:	f005 ff87 	bl	6484 <HW_set_16bit_reg>

			if(i == 255){
     576:	88fb      	ldrh	r3, [r7, #6]
     578:	2bff      	cmp	r3, #255	; 0xff
     57a:	d007      	beq.n	58c <store_pkt+0x54>

void store_pkt(){
	uint16_t i = 0;


		for(;i<256;i++){
     57c:	88fb      	ldrh	r3, [r7, #6]
     57e:	f103 0301 	add.w	r3, r3, #1
     582:	80fb      	strh	r3, [r7, #6]
     584:	88fb      	ldrh	r3, [r7, #6]
     586:	2bff      	cmp	r3, #255	; 0xff
     588:	d9dd      	bls.n	546 <store_pkt+0xe>
     58a:	e000      	b.n	58e <store_pkt+0x56>

			HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) blck_pkt[active_blck - 1][i]);

			if(i == 255){
				return;
     58c:	bf00      	nop
			}
		}


}
     58e:	f107 0708 	add.w	r7, r7, #8
     592:	46bd      	mov	sp, r7
     594:	bd80      	pop	{r7, pc}
     596:	bf00      	nop

00000598 <p1_init>:


void p1_init(){
     598:	b580      	push	{r7, lr}
     59a:	af00      	add	r7, sp, #0
	I2C_init(VC_SENSOR_I2C, COREI2C_0_0, VC1, I2C_PCLK_DIV_256);	//VC_Sensor
     59c:	f24b 4038 	movw	r0, #46136	; 0xb438
     5a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5a4:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
     5a8:	f04f 0240 	mov.w	r2, #64	; 0x40
     5ac:	f04f 0300 	mov.w	r3, #0
     5b0:	f009 fa80 	bl	9ab4 <I2C_init>
	I2C_init(IMU_CORE_I2C, COREI2C_3_0, IMU_ADDR, I2C_PCLK_DIV_256);	//IMU_Sensor
     5b4:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
     5b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5bc:	f243 0100 	movw	r1, #12288	; 0x3000
     5c0:	f2c5 0100 	movt	r1, #20480	; 0x5000
     5c4:	f04f 026a 	mov.w	r2, #106	; 0x6a
     5c8:	f04f 0300 	mov.w	r3, #0
     5cc:	f009 fa72 	bl	9ab4 <I2C_init>
	I2C_init(TEMP_ADC_CORE_I2C, COREI2C_1_0, ADC_ADDR, I2C_BCLK_DIV_8);	//Temp_ADC_Sensor
     5d0:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
     5d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5d8:	f241 0100 	movw	r1, #4096	; 0x1000
     5dc:	f2c5 0100 	movt	r1, #20480	; 0x5000
     5e0:	f04f 0223 	mov.w	r2, #35	; 0x23
     5e4:	f04f 0307 	mov.w	r3, #7
     5e8:	f009 fa64 	bl	9ab4 <I2C_init>
}
     5ec:	bd80      	pop	{r7, pc}
     5ee:	bf00      	nop

000005f0 <vGetPktStruct>:


void vGetPktStruct(pkt_name_t pktname, void* pktdata, uint8_t pktsize){
     5f0:	b580      	push	{r7, lr}
     5f2:	b086      	sub	sp, #24
     5f4:	af00      	add	r7, sp, #0
     5f6:	60b9      	str	r1, [r7, #8]
     5f8:	4613      	mov	r3, r2
     5fa:	4602      	mov	r2, r0
     5fc:	73fa      	strb	r2, [r7, #15]
     5fe:	71fb      	strb	r3, [r7, #7]

	uint8_t i =0;
     600:	f04f 0300 	mov.w	r3, #0
     604:	74fb      	strb	r3, [r7, #19]
	uint8_t* pkt_data;
	pkt_data = (uint8_t* )pktdata;
     606:	68bb      	ldr	r3, [r7, #8]
     608:	617b      	str	r3, [r7, #20]

//	xQueueSend(Data_PKT_Queue, &pkt, 0);
	if(pktsize + wri_ptr >= 255){
     60a:	79fa      	ldrb	r2, [r7, #7]
     60c:	f24b 3358 	movw	r3, #45912	; 0xb358
     610:	f2c2 0300 	movt	r3, #8192	; 0x2000
     614:	781b      	ldrb	r3, [r3, #0]
     616:	4413      	add	r3, r2
     618:	2bfe      	cmp	r3, #254	; 0xfe
     61a:	dd50      	ble.n	6be <vGetPktStruct+0xce>
//		send_pkt_flg = 1;
		active_blck += 1;
     61c:	f24b 3357 	movw	r3, #45911	; 0xb357
     620:	f2c2 0300 	movt	r3, #8192	; 0x2000
     624:	781b      	ldrb	r3, [r3, #0]
     626:	f103 0301 	add.w	r3, r3, #1
     62a:	b2da      	uxtb	r2, r3
     62c:	f24b 3357 	movw	r3, #45911	; 0xb357
     630:	f2c2 0300 	movt	r3, #8192	; 0x2000
     634:	701a      	strb	r2, [r3, #0]
		store_pkt();
     636:	f7ff ff7f 	bl	538 <store_pkt>
//		MSS_GPIO_set_output(MSS_GPIO_8, 1);
		wri_ptr = 0;
     63a:	f24b 3358 	movw	r3, #45912	; 0xb358
     63e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     642:	f04f 0200 	mov.w	r2, #0
     646:	701a      	strb	r2, [r3, #0]
		if(active_blck == 4){
     648:	f24b 3357 	movw	r3, #45911	; 0xb357
     64c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     650:	781b      	ldrb	r3, [r3, #0]
     652:	2b04      	cmp	r3, #4
     654:	d133      	bne.n	6be <vGetPktStruct+0xce>
			active_blck = 0;
     656:	f24b 3357 	movw	r3, #45911	; 0xb357
     65a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     65e:	f04f 0200 	mov.w	r2, #0
     662:	701a      	strb	r2, [r3, #0]
		}
	}

	// Storing the packets

	for(;i<pktsize;i++){
     664:	e02b      	b.n	6be <vGetPktStruct+0xce>
		blck_pkt[active_blck][wri_ptr + i] = pkt_data[i] | (pkt_data[i] << 8);
     666:	f24b 3357 	movw	r3, #45911	; 0xb357
     66a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     66e:	781b      	ldrb	r3, [r3, #0]
     670:	4618      	mov	r0, r3
     672:	f24b 3358 	movw	r3, #45912	; 0xb358
     676:	f2c2 0300 	movt	r3, #8192	; 0x2000
     67a:	781b      	ldrb	r3, [r3, #0]
     67c:	461a      	mov	r2, r3
     67e:	7cfb      	ldrb	r3, [r7, #19]
     680:	441a      	add	r2, r3
     682:	7cf9      	ldrb	r1, [r7, #19]
     684:	697b      	ldr	r3, [r7, #20]
     686:	440b      	add	r3, r1
     688:	781b      	ldrb	r3, [r3, #0]
     68a:	4619      	mov	r1, r3
     68c:	f897 c013 	ldrb.w	ip, [r7, #19]
     690:	697b      	ldr	r3, [r7, #20]
     692:	4463      	add	r3, ip
     694:	781b      	ldrb	r3, [r3, #0]
     696:	ea4f 2303 	mov.w	r3, r3, lsl #8
     69a:	b29b      	uxth	r3, r3
     69c:	ea41 0303 	orr.w	r3, r1, r3
     6a0:	b29b      	uxth	r3, r3
     6a2:	b299      	uxth	r1, r3
     6a4:	f64b 034c 	movw	r3, #47180	; 0xb84c
     6a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6ac:	ea4f 2000 	mov.w	r0, r0, lsl #8
     6b0:	4402      	add	r2, r0
     6b2:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
		}
	}

	// Storing the packets

	for(;i<pktsize;i++){
     6b6:	7cfb      	ldrb	r3, [r7, #19]
     6b8:	f103 0301 	add.w	r3, r3, #1
     6bc:	74fb      	strb	r3, [r7, #19]
     6be:	7cfa      	ldrb	r2, [r7, #19]
     6c0:	79fb      	ldrb	r3, [r7, #7]
     6c2:	429a      	cmp	r2, r3
     6c4:	d3cf      	bcc.n	666 <vGetPktStruct+0x76>
		blck_pkt[active_blck][wri_ptr + i] = pkt_data[i] | (pkt_data[i] << 8);
	}
	wri_ptr += pktsize;
     6c6:	f24b 3358 	movw	r3, #45912	; 0xb358
     6ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6ce:	781a      	ldrb	r2, [r3, #0]
     6d0:	79fb      	ldrb	r3, [r7, #7]
     6d2:	4413      	add	r3, r2
     6d4:	b2da      	uxtb	r2, r3
     6d6:	f24b 3358 	movw	r3, #45912	; 0xb358
     6da:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6de:	701a      	strb	r2, [r3, #0]

}
     6e0:	f107 0718 	add.w	r7, r7, #24
     6e4:	46bd      	mov	sp, r7
     6e6:	bd80      	pop	{r7, pc}

000006e8 <make_FLetcher>:
//
//	vGetPktStruct(pld, (void*) data_test, sizeof(data_test));
//}


uint16_t make_FLetcher(uint8_t *data,uint16_t len) {
     6e8:	b480      	push	{r7}
     6ea:	b085      	sub	sp, #20
     6ec:	af00      	add	r7, sp, #0
     6ee:	6078      	str	r0, [r7, #4]
     6f0:	460b      	mov	r3, r1
     6f2:	807b      	strh	r3, [r7, #2]
	uint8_t sumA = 0,sumB = 0,temp = 0;
     6f4:	f04f 0300 	mov.w	r3, #0
     6f8:	733b      	strb	r3, [r7, #12]
     6fa:	f04f 0300 	mov.w	r3, #0
     6fe:	737b      	strb	r3, [r7, #13]
     700:	f04f 0300 	mov.w	r3, #0
     704:	73bb      	strb	r3, [r7, #14]
	uint8_t i = 0;
     706:	f04f 0300 	mov.w	r3, #0
     70a:	73fb      	strb	r3, [r7, #15]
	for(i = 0;i<len;i++) {
     70c:	f04f 0300 	mov.w	r3, #0
     710:	73fb      	strb	r3, [r7, #15]
     712:	e03a      	b.n	78a <make_FLetcher+0xa2>
		sumA = (sumA + data[i]) % 255;
     714:	7b3a      	ldrb	r2, [r7, #12]
     716:	7bf9      	ldrb	r1, [r7, #15]
     718:	687b      	ldr	r3, [r7, #4]
     71a:	440b      	add	r3, r1
     71c:	781b      	ldrb	r3, [r3, #0]
     71e:	eb02 0103 	add.w	r1, r2, r3
     722:	f248 0381 	movw	r3, #32897	; 0x8081
     726:	f2c8 0380 	movt	r3, #32896	; 0x8080
     72a:	fb83 2301 	smull	r2, r3, r3, r1
     72e:	440b      	add	r3, r1
     730:	ea4f 12e3 	mov.w	r2, r3, asr #7
     734:	ea4f 73e1 	mov.w	r3, r1, asr #31
     738:	ebc3 0202 	rsb	r2, r3, r2
     73c:	4613      	mov	r3, r2
     73e:	ea4f 2303 	mov.w	r3, r3, lsl #8
     742:	ebc2 0303 	rsb	r3, r2, r3
     746:	ebc3 0201 	rsb	r2, r3, r1
     74a:	4613      	mov	r3, r2
     74c:	733b      	strb	r3, [r7, #12]
		sumB = (sumB + sumA) % 255;
     74e:	7b7a      	ldrb	r2, [r7, #13]
     750:	7b3b      	ldrb	r3, [r7, #12]
     752:	eb02 0103 	add.w	r1, r2, r3
     756:	f248 0381 	movw	r3, #32897	; 0x8081
     75a:	f2c8 0380 	movt	r3, #32896	; 0x8080
     75e:	fb83 2301 	smull	r2, r3, r3, r1
     762:	440b      	add	r3, r1
     764:	ea4f 12e3 	mov.w	r2, r3, asr #7
     768:	ea4f 73e1 	mov.w	r3, r1, asr #31
     76c:	ebc3 0202 	rsb	r2, r3, r2
     770:	4613      	mov	r3, r2
     772:	ea4f 2303 	mov.w	r3, r3, lsl #8
     776:	ebc2 0303 	rsb	r3, r2, r3
     77a:	ebc3 0201 	rsb	r2, r3, r1
     77e:	4613      	mov	r3, r2
     780:	737b      	strb	r3, [r7, #13]


uint16_t make_FLetcher(uint8_t *data,uint16_t len) {
	uint8_t sumA = 0,sumB = 0,temp = 0;
	uint8_t i = 0;
	for(i = 0;i<len;i++) {
     782:	7bfb      	ldrb	r3, [r7, #15]
     784:	f103 0301 	add.w	r3, r3, #1
     788:	73fb      	strb	r3, [r7, #15]
     78a:	7bfb      	ldrb	r3, [r7, #15]
     78c:	887a      	ldrh	r2, [r7, #2]
     78e:	429a      	cmp	r2, r3
     790:	d8c0      	bhi.n	714 <make_FLetcher+0x2c>
		sumA = (sumA + data[i]) % 255;
		sumB = (sumB + sumA) % 255;
	}
	temp = 255 - ((sumA + sumB) % 255);
     792:	7b3a      	ldrb	r2, [r7, #12]
     794:	7b7b      	ldrb	r3, [r7, #13]
     796:	eb02 0103 	add.w	r1, r2, r3
     79a:	f248 0381 	movw	r3, #32897	; 0x8081
     79e:	f2c8 0380 	movt	r3, #32896	; 0x8080
     7a2:	fb83 2301 	smull	r2, r3, r3, r1
     7a6:	440b      	add	r3, r1
     7a8:	ea4f 12e3 	mov.w	r2, r3, asr #7
     7ac:	ea4f 73e1 	mov.w	r3, r1, asr #31
     7b0:	ebc3 0202 	rsb	r2, r3, r2
     7b4:	4613      	mov	r3, r2
     7b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
     7ba:	ebc2 0303 	rsb	r3, r2, r3
     7be:	ebc3 0201 	rsb	r2, r3, r1
     7c2:	b2d3      	uxtb	r3, r2
     7c4:	ea6f 0303 	mvn.w	r3, r3
     7c8:	73bb      	strb	r3, [r7, #14]
	sumB = 255 - ((sumA + temp) % 255);
     7ca:	7b3a      	ldrb	r2, [r7, #12]
     7cc:	7bbb      	ldrb	r3, [r7, #14]
     7ce:	eb02 0103 	add.w	r1, r2, r3
     7d2:	f248 0381 	movw	r3, #32897	; 0x8081
     7d6:	f2c8 0380 	movt	r3, #32896	; 0x8080
     7da:	fb83 2301 	smull	r2, r3, r3, r1
     7de:	440b      	add	r3, r1
     7e0:	ea4f 12e3 	mov.w	r2, r3, asr #7
     7e4:	ea4f 73e1 	mov.w	r3, r1, asr #31
     7e8:	ebc3 0202 	rsb	r2, r3, r2
     7ec:	4613      	mov	r3, r2
     7ee:	ea4f 2303 	mov.w	r3, r3, lsl #8
     7f2:	ebc2 0303 	rsb	r3, r2, r3
     7f6:	ebc3 0201 	rsb	r2, r3, r1
     7fa:	b2d3      	uxtb	r3, r2
     7fc:	ea6f 0303 	mvn.w	r3, r3
     800:	737b      	strb	r3, [r7, #13]

	return ((sumB << 8) | temp);
     802:	7b7b      	ldrb	r3, [r7, #13]
     804:	ea4f 2303 	mov.w	r3, r3, lsl #8
     808:	b29a      	uxth	r2, r3
     80a:	7bbb      	ldrb	r3, [r7, #14]
     80c:	ea42 0303 	orr.w	r3, r2, r3
     810:	b29b      	uxth	r3, r3
     812:	b29b      	uxth	r3, r3

}
     814:	4618      	mov	r0, r3
     816:	f107 0714 	add.w	r7, r7, #20
     81a:	46bd      	mov	sp, r7
     81c:	bc80      	pop	{r7}
     81e:	4770      	bx	lr

00000820 <get_hk>:

uint16_t get_hk(){
     820:	b590      	push	{r4, r7, lr}
     822:	b08f      	sub	sp, #60	; 0x3c
     824:	af00      	add	r7, sp, #0
	hk_pkt = (hk_pkt_t* )data;
     826:	f24b 6238 	movw	r2, #46648	; 0xb638
     82a:	f2c2 0200 	movt	r2, #8192	; 0x2000
     82e:	f24b 5310 	movw	r3, #46352	; 0xb510
     832:	f2c2 0300 	movt	r3, #8192	; 0x2000
     836:	601a      	str	r2, [r3, #0]
	uint16_t ax, ay, az;
	uint16_t roll_rate, pitch_rate, yaw_rate;
	uint16_t CDH_VC[2];
	uint16_t PIS_VC[2];
	uint16_t imu_temp;
	uint16_t result=0;
     838:	f04f 0300 	mov.w	r3, #0
     83c:	867b      	strh	r3, [r7, #50]	; 0x32
	uint8_t flag;
	uint8_t i = 0 ;
     83e:	f04f 0300 	mov.w	r3, #0
     842:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	uint8_t msg[18] = "\n\rGot HK Readings\0";
     846:	f64b 03a0 	movw	r3, #47264	; 0xb8a0
     84a:	f2c0 0300 	movt	r3, #0
     84e:	f107 0c04 	add.w	ip, r7, #4
     852:	469e      	mov	lr, r3
     854:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
     858:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     85c:	f8de 3000 	ldr.w	r3, [lr]
     860:	f8ac 3000 	strh.w	r3, [ip]
	uint16_t hk_status;

	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
     864:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
     868:	f2c2 0200 	movt	r2, #8192	; 0x2000
     86c:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
     870:	f2c2 0300 	movt	r3, #8192	; 0x2000
     874:	4610      	mov	r0, r2
     876:	4619      	mov	r1, r3
     878:	f7ff fe3a 	bl	4f0 <MSS_TIM64_get_current_value>

	result = (get_IMU_acc(&ax, &ay, &az) == 0 ? 0 : 1);
     87c:	f107 0130 	add.w	r1, r7, #48	; 0x30
     880:	f107 022e 	add.w	r2, r7, #46	; 0x2e
     884:	f107 032c 	add.w	r3, r7, #44	; 0x2c
     888:	4608      	mov	r0, r1
     88a:	4611      	mov	r1, r2
     88c:	461a      	mov	r2, r3
     88e:	f003 fef3 	bl	4678 <get_IMU_acc>
     892:	4603      	mov	r3, r0
     894:	2b00      	cmp	r3, #0
     896:	bf0c      	ite	eq
     898:	2300      	moveq	r3, #0
     89a:	2301      	movne	r3, #1
     89c:	867b      	strh	r3, [r7, #50]	; 0x32
	result |= ((get_IMU_gyro(&roll_rate, &pitch_rate, &yaw_rate) == 0 ? 0 : 1) << 1);
     89e:	f107 012a 	add.w	r1, r7, #42	; 0x2a
     8a2:	f107 0228 	add.w	r2, r7, #40	; 0x28
     8a6:	f107 0326 	add.w	r3, r7, #38	; 0x26
     8aa:	4608      	mov	r0, r1
     8ac:	4611      	mov	r1, r2
     8ae:	461a      	mov	r2, r3
     8b0:	f004 f86e 	bl	4990 <get_IMU_gyro>
     8b4:	4603      	mov	r3, r0
     8b6:	2b00      	cmp	r3, #0
     8b8:	d002      	beq.n	8c0 <get_hk+0xa0>
     8ba:	f04f 0302 	mov.w	r3, #2
     8be:	e001      	b.n	8c4 <get_hk+0xa4>
     8c0:	f04f 0300 	mov.w	r3, #0
     8c4:	8e79      	ldrh	r1, [r7, #50]	; 0x32
     8c6:	461a      	mov	r2, r3
     8c8:	460b      	mov	r3, r1
     8ca:	ea42 0303 	orr.w	r3, r2, r3
     8ce:	b29b      	uxth	r3, r3
     8d0:	867b      	strh	r3, [r7, #50]	; 0x32
	result |= ((get_IMU_temp(&imu_temp) == 0 ? : 1) << 2);
     8d2:	f107 031a 	add.w	r3, r7, #26
     8d6:	4618      	mov	r0, r3
     8d8:	f004 f9cc 	bl	4c74 <get_IMU_temp>
     8dc:	4603      	mov	r3, r0
     8de:	2b00      	cmp	r3, #0
     8e0:	bf14      	ite	ne
     8e2:	2300      	movne	r3, #0
     8e4:	2301      	moveq	r3, #1
     8e6:	2b00      	cmp	r3, #0
     8e8:	d003      	beq.n	8f2 <get_hk+0xd2>
     8ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
     8ee:	b29b      	uxth	r3, r3
     8f0:	e001      	b.n	8f6 <get_hk+0xd6>
     8f2:	f04f 0304 	mov.w	r3, #4
     8f6:	8e79      	ldrh	r1, [r7, #50]	; 0x32
     8f8:	461a      	mov	r2, r3
     8fa:	460b      	mov	r3, r1
     8fc:	ea42 0303 	orr.w	r3, r2, r3
     900:	b29b      	uxth	r3, r3
     902:	867b      	strh	r3, [r7, #50]	; 0x32
//	CDH_VC[0] = read_bus_voltage( VC1,  2, &flag);
//	PIS_VC[0] = read_bus_voltage(VC1, 3, &flag);
//	CDH_VC[1] = read_shunt_voltage(VC1, 2, &flag);
//	PIS_VC[1] = read_shunt_voltage(VC1, 3, &flag);

	hk_pkt->IMG_ID = IMG_ID;
     904:	f24b 5310 	movw	r3, #46352	; 0xb510
     908:	f2c2 0300 	movt	r3, #8192	; 0x2000
     90c:	681a      	ldr	r2, [r3, #0]
     90e:	f24b 0304 	movw	r3, #45060	; 0xb004
     912:	f2c2 0300 	movt	r3, #8192	; 0x2000
     916:	781b      	ldrb	r3, [r3, #0]
     918:	7453      	strb	r3, [r2, #17]
	hk_pkt->CLK_RATE = MSS_SYS_M3_CLK_FREQ / 1000;
     91a:	f24b 5310 	movw	r3, #46352	; 0xb510
     91e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     922:	681b      	ldr	r3, [r3, #0]
     924:	f04f 0200 	mov.w	r2, #0
     928:	f042 0230 	orr.w	r2, r2, #48	; 0x30
     92c:	749a      	strb	r2, [r3, #18]
     92e:	f04f 0200 	mov.w	r2, #0
     932:	f042 0275 	orr.w	r2, r2, #117	; 0x75
     936:	74da      	strb	r2, [r3, #19]
	hk_pkt->Command_Loss_Timer = MSS_WD_current_value();
     938:	f24b 5310 	movw	r3, #46352	; 0xb510
     93c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     940:	681c      	ldr	r4, [r3, #0]
     942:	f7ff fded 	bl	520 <MSS_WD_current_value>
     946:	4603      	mov	r3, r0
     948:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     94c:	f04f 0100 	mov.w	r1, #0
     950:	ea41 0202 	orr.w	r2, r1, r2
     954:	7522      	strb	r2, [r4, #20]
     956:	ea4f 2213 	mov.w	r2, r3, lsr #8
     95a:	f002 02ff 	and.w	r2, r2, #255	; 0xff
     95e:	f04f 0100 	mov.w	r1, #0
     962:	ea41 0202 	orr.w	r2, r1, r2
     966:	7562      	strb	r2, [r4, #21]
     968:	ea4f 4213 	mov.w	r2, r3, lsr #16
     96c:	f002 02ff 	and.w	r2, r2, #255	; 0xff
     970:	f04f 0100 	mov.w	r1, #0
     974:	ea41 0202 	orr.w	r2, r1, r2
     978:	75a2      	strb	r2, [r4, #22]
     97a:	ea4f 6313 	mov.w	r3, r3, lsr #24
     97e:	f04f 0200 	mov.w	r2, #0
     982:	ea42 0303 	orr.w	r3, r2, r3
     986:	75e3      	strb	r3, [r4, #23]
	hk_pkt->Reset_Counts = reset_counts[0];
     988:	f24b 5310 	movw	r3, #46352	; 0xb510
     98c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     990:	681a      	ldr	r2, [r3, #0]
     992:	f24b 3370 	movw	r3, #45936	; 0xb370
     996:	f2c2 0300 	movt	r3, #8192	; 0x2000
     99a:	781b      	ldrb	r3, [r3, #0]
     99c:	7693      	strb	r3, [r2, #26]
	hk_pkt->PREV_CMD_RX = rx_cmd_pkt->cmd_id;
     99e:	f24b 5310 	movw	r3, #46352	; 0xb510
     9a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9a6:	681a      	ldr	r2, [r3, #0]
     9a8:	f24c 33e0 	movw	r3, #50144	; 0xc3e0
     9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9b0:	681b      	ldr	r3, [r3, #0]
     9b2:	781b      	ldrb	r3, [r3, #0]
     9b4:	7613      	strb	r3, [r2, #24]
	hk_pkt->Cmd_ADF_counts = cmd_rx_count;
     9b6:	f24b 5310 	movw	r3, #46352	; 0xb510
     9ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9be:	681a      	ldr	r2, [r3, #0]
     9c0:	f24b 3369 	movw	r3, #45929	; 0xb369
     9c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9c8:	781b      	ldrb	r3, [r3, #0]
     9ca:	7393      	strb	r3, [r2, #14]

	for(;i<16;i++){
     9cc:	e016      	b.n	9fc <get_hk+0x1dc>
		hk_pkt->RTM[i] = RTM[i];
     9ce:	f24b 5310 	movw	r3, #46352	; 0xb510
     9d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9d6:	6819      	ldr	r1, [r3, #0]
     9d8:	f897 0035 	ldrb.w	r0, [r7, #53]	; 0x35
     9dc:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
     9e0:	f24c 03b8 	movw	r3, #49336	; 0xc0b8
     9e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     9e8:	5c9a      	ldrb	r2, [r3, r2]
     9ea:	eb00 0301 	add.w	r3, r0, r1
     9ee:	76da      	strb	r2, [r3, #27]
	hk_pkt->Command_Loss_Timer = MSS_WD_current_value();
	hk_pkt->Reset_Counts = reset_counts[0];
	hk_pkt->PREV_CMD_RX = rx_cmd_pkt->cmd_id;
	hk_pkt->Cmd_ADF_counts = cmd_rx_count;

	for(;i<16;i++){
     9f0:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
     9f4:	f103 0301 	add.w	r3, r3, #1
     9f8:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
     9fc:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
     a00:	2b0f      	cmp	r3, #15
     a02:	d9e4      	bls.n	9ce <get_hk+0x1ae>
		hk_pkt->RTM[i] = RTM[i];
	}

	hk_pkt->Cmd_RS485_Succ_counts = cmd_rs485_succ_count;
     a04:	f24b 5310 	movw	r3, #46352	; 0xb510
     a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a0c:	681a      	ldr	r2, [r3, #0]
     a0e:	f24b 336c 	movw	r3, #45932	; 0xb36c
     a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a16:	781b      	ldrb	r3, [r3, #0]
     a18:	73d3      	strb	r3, [r2, #15]
	hk_pkt->Cmd_RS485_Fail_counts = cmd_rs485_fail_count;
     a1a:	f24b 5310 	movw	r3, #46352	; 0xb510
     a1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a22:	681a      	ldr	r2, [r3, #0]
     a24:	f24b 336d 	movw	r3, #45933	; 0xb36d
     a28:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a2c:	781b      	ldrb	r3, [r3, #0]
     a2e:	7413      	strb	r3, [r2, #16]
	hk_pkt->Acc[0] = ((ax));
     a30:	f24b 5310 	movw	r3, #46352	; 0xb510
     a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a38:	681b      	ldr	r3, [r3, #0]
     a3a:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
     a3c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     a40:	f04f 0000 	mov.w	r0, #0
     a44:	ea40 0101 	orr.w	r1, r0, r1
     a48:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
     a4c:	ea4f 2212 	mov.w	r2, r2, lsr #8
     a50:	b292      	uxth	r2, r2
     a52:	f04f 0100 	mov.w	r1, #0
     a56:	ea41 0202 	orr.w	r2, r1, r2
     a5a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
	hk_pkt->Acc[1] = ((ay));
     a5e:	f24b 5310 	movw	r3, #46352	; 0xb510
     a62:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a66:	681b      	ldr	r3, [r3, #0]
     a68:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
     a6a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     a6e:	f04f 0000 	mov.w	r0, #0
     a72:	ea40 0101 	orr.w	r1, r0, r1
     a76:	f883 102d 	strb.w	r1, [r3, #45]	; 0x2d
     a7a:	ea4f 2212 	mov.w	r2, r2, lsr #8
     a7e:	b292      	uxth	r2, r2
     a80:	f04f 0100 	mov.w	r1, #0
     a84:	ea41 0202 	orr.w	r2, r1, r2
     a88:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
	hk_pkt->Acc[2] = ((az));
     a8c:	f24b 5310 	movw	r3, #46352	; 0xb510
     a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
     a94:	681b      	ldr	r3, [r3, #0]
     a96:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
     a98:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     a9c:	f04f 0000 	mov.w	r0, #0
     aa0:	ea40 0101 	orr.w	r1, r0, r1
     aa4:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
     aa8:	ea4f 2212 	mov.w	r2, r2, lsr #8
     aac:	b292      	uxth	r2, r2
     aae:	f04f 0100 	mov.w	r1, #0
     ab2:	ea41 0202 	orr.w	r2, r1, r2
     ab6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	hk_pkt->Angular_Rate[0] = roll_rate;
     aba:	f24b 5310 	movw	r3, #46352	; 0xb510
     abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ac2:	681b      	ldr	r3, [r3, #0]
     ac4:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
     ac6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     aca:	f04f 0000 	mov.w	r0, #0
     ace:	ea40 0101 	orr.w	r1, r0, r1
     ad2:	f883 1031 	strb.w	r1, [r3, #49]	; 0x31
     ad6:	ea4f 2212 	mov.w	r2, r2, lsr #8
     ada:	b292      	uxth	r2, r2
     adc:	f04f 0100 	mov.w	r1, #0
     ae0:	ea41 0202 	orr.w	r2, r1, r2
     ae4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	hk_pkt->Angular_Rate[1] = pitch_rate;
     ae8:	f24b 5310 	movw	r3, #46352	; 0xb510
     aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
     af0:	681b      	ldr	r3, [r3, #0]
     af2:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
     af4:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     af8:	f04f 0000 	mov.w	r0, #0
     afc:	ea40 0101 	orr.w	r1, r0, r1
     b00:	f883 1033 	strb.w	r1, [r3, #51]	; 0x33
     b04:	ea4f 2212 	mov.w	r2, r2, lsr #8
     b08:	b292      	uxth	r2, r2
     b0a:	f04f 0100 	mov.w	r1, #0
     b0e:	ea41 0202 	orr.w	r2, r1, r2
     b12:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	hk_pkt->Angular_Rate[2] = yaw_rate;
     b16:	f24b 5310 	movw	r3, #46352	; 0xb510
     b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b1e:	681b      	ldr	r3, [r3, #0]
     b20:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
     b22:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     b26:	f04f 0000 	mov.w	r0, #0
     b2a:	ea40 0101 	orr.w	r1, r0, r1
     b2e:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
     b32:	ea4f 2212 	mov.w	r2, r2, lsr #8
     b36:	b292      	uxth	r2, r2
     b38:	f04f 0100 	mov.w	r1, #0
     b3c:	ea41 0202 	orr.w	r2, r1, r2
     b40:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	hk_pkt->imu_temp = imu_temp;
     b44:	f24b 5310 	movw	r3, #46352	; 0xb510
     b48:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b4c:	681b      	ldr	r3, [r3, #0]
     b4e:	8b7a      	ldrh	r2, [r7, #26]
     b50:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     b54:	f04f 0000 	mov.w	r0, #0
     b58:	ea40 0101 	orr.w	r1, r0, r1
     b5c:	f883 1037 	strb.w	r1, [r3, #55]	; 0x37
     b60:	ea4f 2212 	mov.w	r2, r2, lsr #8
     b64:	b292      	uxth	r2, r2
     b66:	f04f 0100 	mov.w	r1, #0
     b6a:	ea41 0202 	orr.w	r2, r1, r2
     b6e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

//	hk_pkt->Sensor_Board_VC[0] = read_bus_voltage(VC1, 1, &flag);
//	hk_pkt->CDH_VC[0] = read_bus_voltage( VC1,  2, &flag);
//	hk_pkt->PIS_VC[0] = read_bus_voltage( VC1,  3, &flag);
	hk_pkt->Voltages[0] = read_bus_voltage(VC_SENSOR_I2C, VC1, 2, &flag);
     b72:	f24b 5310 	movw	r3, #46352	; 0xb510
     b76:	f2c2 0300 	movt	r3, #8192	; 0x2000
     b7a:	681c      	ldr	r4, [r3, #0]
     b7c:	f107 0319 	add.w	r3, r7, #25
     b80:	f24b 4038 	movw	r0, #46136	; 0xb438
     b84:	f2c2 0000 	movt	r0, #8192	; 0x2000
     b88:	f04f 0140 	mov.w	r1, #64	; 0x40
     b8c:	f04f 0202 	mov.w	r2, #2
     b90:	f003 fbe8 	bl	4364 <read_bus_voltage>
     b94:	4603      	mov	r3, r0
     b96:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     b9a:	f04f 0100 	mov.w	r1, #0
     b9e:	ea41 0202 	orr.w	r2, r1, r2
     ba2:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
     ba6:	ea4f 2313 	mov.w	r3, r3, lsr #8
     baa:	b29b      	uxth	r3, r3
     bac:	f04f 0200 	mov.w	r2, #0
     bb0:	ea42 0303 	orr.w	r3, r2, r3
     bb4:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
	result |= flag << 3;
     bb8:	7e7b      	ldrb	r3, [r7, #25]
     bba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     bbe:	b29a      	uxth	r2, r3
     bc0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
     bc2:	ea42 0303 	orr.w	r3, r2, r3
     bc6:	b29b      	uxth	r3, r3
     bc8:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Voltages[1] = read_bus_voltage(VC_SENSOR_I2C, VC1, 3, &flag);
     bca:	f24b 5310 	movw	r3, #46352	; 0xb510
     bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bd2:	681c      	ldr	r4, [r3, #0]
     bd4:	f107 0319 	add.w	r3, r7, #25
     bd8:	f24b 4038 	movw	r0, #46136	; 0xb438
     bdc:	f2c2 0000 	movt	r0, #8192	; 0x2000
     be0:	f04f 0140 	mov.w	r1, #64	; 0x40
     be4:	f04f 0203 	mov.w	r2, #3
     be8:	f003 fbbc 	bl	4364 <read_bus_voltage>
     bec:	4603      	mov	r3, r0
     bee:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     bf2:	f04f 0100 	mov.w	r1, #0
     bf6:	ea41 0202 	orr.w	r2, r1, r2
     bfa:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
     bfe:	ea4f 2313 	mov.w	r3, r3, lsr #8
     c02:	b29b      	uxth	r3, r3
     c04:	f04f 0200 	mov.w	r2, #0
     c08:	ea42 0303 	orr.w	r3, r2, r3
     c0c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	result |= flag << 4;
     c10:	7e7b      	ldrb	r3, [r7, #25]
     c12:	ea4f 1303 	mov.w	r3, r3, lsl #4
     c16:	b29a      	uxth	r2, r3
     c18:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
     c1a:	ea42 0303 	orr.w	r3, r2, r3
     c1e:	b29b      	uxth	r3, r3
     c20:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Voltages[2] = read_bus_voltage(TEMP_ADC_CORE_I2C, VC1, 1, &flag);
     c22:	f24b 5310 	movw	r3, #46352	; 0xb510
     c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c2a:	681c      	ldr	r4, [r3, #0]
     c2c:	f107 0319 	add.w	r3, r7, #25
     c30:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
     c34:	f2c2 0000 	movt	r0, #8192	; 0x2000
     c38:	f04f 0140 	mov.w	r1, #64	; 0x40
     c3c:	f04f 0201 	mov.w	r2, #1
     c40:	f003 fb90 	bl	4364 <read_bus_voltage>
     c44:	4603      	mov	r3, r0
     c46:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     c4a:	f04f 0100 	mov.w	r1, #0
     c4e:	ea41 0202 	orr.w	r2, r1, r2
     c52:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
     c56:	ea4f 2313 	mov.w	r3, r3, lsr #8
     c5a:	b29b      	uxth	r3, r3
     c5c:	f04f 0200 	mov.w	r2, #0
     c60:	ea42 0303 	orr.w	r3, r2, r3
     c64:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
//	result |= flag << 5;
	hk_pkt->Voltages[3] = read_bus_voltage(TEMP_ADC_CORE_I2C, VC1, 2, &flag);
     c68:	f24b 5310 	movw	r3, #46352	; 0xb510
     c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c70:	681c      	ldr	r4, [r3, #0]
     c72:	f107 0319 	add.w	r3, r7, #25
     c76:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
     c7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
     c7e:	f04f 0140 	mov.w	r1, #64	; 0x40
     c82:	f04f 0202 	mov.w	r2, #2
     c86:	f003 fb6d 	bl	4364 <read_bus_voltage>
     c8a:	4603      	mov	r3, r0
     c8c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     c90:	f04f 0100 	mov.w	r1, #0
     c94:	ea41 0202 	orr.w	r2, r1, r2
     c98:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
     c9c:	ea4f 2313 	mov.w	r3, r3, lsr #8
     ca0:	b29b      	uxth	r3, r3
     ca2:	f04f 0200 	mov.w	r2, #0
     ca6:	ea42 0303 	orr.w	r3, r2, r3
     caa:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
//	result |= flag << 6;
	hk_pkt->Voltages[4] = read_bus_voltage(TEMP_ADC_CORE_I2C, VC1, 3, &flag);
     cae:	f24b 5310 	movw	r3, #46352	; 0xb510
     cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cb6:	681c      	ldr	r4, [r3, #0]
     cb8:	f107 0319 	add.w	r3, r7, #25
     cbc:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
     cc0:	f2c2 0000 	movt	r0, #8192	; 0x2000
     cc4:	f04f 0140 	mov.w	r1, #64	; 0x40
     cc8:	f04f 0203 	mov.w	r2, #3
     ccc:	f003 fb4a 	bl	4364 <read_bus_voltage>
     cd0:	4603      	mov	r3, r0
     cd2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     cd6:	f04f 0100 	mov.w	r1, #0
     cda:	ea41 0202 	orr.w	r2, r1, r2
     cde:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
     ce2:	ea4f 2313 	mov.w	r3, r3, lsr #8
     ce6:	b29b      	uxth	r3, r3
     ce8:	f04f 0200 	mov.w	r2, #0
     cec:	ea42 0303 	orr.w	r3, r2, r3
     cf0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

//	hk_pkt->Sensor_Board_VC[1] = read_shunt_voltage(VC1, 1, &flag);
//	hk_pkt->CDH_VC[1] = read_shunt_voltage( VC1,  2, &flag);
//	hk_pkt->PIS_VC[1] = read_shunt_voltage( VC1,  3, &flag);

	hk_pkt->HK_Write_Pointer = hk_partition.write_pointer;
     cf4:	f24b 5310 	movw	r3, #46352	; 0xb510
     cf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     cfc:	681b      	ldr	r3, [r3, #0]
     cfe:	f24c 420c 	movw	r2, #50188	; 0xc40c
     d02:	f2c2 0200 	movt	r2, #8192	; 0x2000
     d06:	68d2      	ldr	r2, [r2, #12]
     d08:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     d0c:	f04f 0000 	mov.w	r0, #0
     d10:	ea40 0101 	orr.w	r1, r0, r1
     d14:	f883 1051 	strb.w	r1, [r3, #81]	; 0x51
     d18:	ea4f 2112 	mov.w	r1, r2, lsr #8
     d1c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     d20:	f04f 0000 	mov.w	r0, #0
     d24:	ea40 0101 	orr.w	r1, r0, r1
     d28:	f883 1052 	strb.w	r1, [r3, #82]	; 0x52
     d2c:	ea4f 4112 	mov.w	r1, r2, lsr #16
     d30:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     d34:	f04f 0000 	mov.w	r0, #0
     d38:	ea40 0101 	orr.w	r1, r0, r1
     d3c:	f883 1053 	strb.w	r1, [r3, #83]	; 0x53
     d40:	ea4f 6212 	mov.w	r2, r2, lsr #24
     d44:	f04f 0100 	mov.w	r1, #0
     d48:	ea41 0202 	orr.w	r2, r1, r2
     d4c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	hk_pkt->HK_Read_Pointer = hk_partition.read_pointer;
     d50:	f24b 5310 	movw	r3, #46352	; 0xb510
     d54:	f2c2 0300 	movt	r3, #8192	; 0x2000
     d58:	681b      	ldr	r3, [r3, #0]
     d5a:	f24c 420c 	movw	r2, #50188	; 0xc40c
     d5e:	f2c2 0200 	movt	r2, #8192	; 0x2000
     d62:	6892      	ldr	r2, [r2, #8]
     d64:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     d68:	f04f 0000 	mov.w	r0, #0
     d6c:	ea40 0101 	orr.w	r1, r0, r1
     d70:	f883 104d 	strb.w	r1, [r3, #77]	; 0x4d
     d74:	ea4f 2112 	mov.w	r1, r2, lsr #8
     d78:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     d7c:	f04f 0000 	mov.w	r0, #0
     d80:	ea40 0101 	orr.w	r1, r0, r1
     d84:	f883 104e 	strb.w	r1, [r3, #78]	; 0x4e
     d88:	ea4f 4112 	mov.w	r1, r2, lsr #16
     d8c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     d90:	f04f 0000 	mov.w	r0, #0
     d94:	ea40 0101 	orr.w	r1, r0, r1
     d98:	f883 104f 	strb.w	r1, [r3, #79]	; 0x4f
     d9c:	ea4f 6212 	mov.w	r2, r2, lsr #24
     da0:	f04f 0100 	mov.w	r1, #0
     da4:	ea41 0202 	orr.w	r2, r1, r2
     da8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	hk_pkt->COMMS_Write_Pointer = comms_partition.write_pointer;
     dac:	f24b 5310 	movw	r3, #46352	; 0xb510
     db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     db4:	681b      	ldr	r3, [r3, #0]
     db6:	f24c 32fc 	movw	r2, #50172	; 0xc3fc
     dba:	f2c2 0200 	movt	r2, #8192	; 0x2000
     dbe:	68d2      	ldr	r2, [r2, #12]
     dc0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     dc4:	f04f 0000 	mov.w	r0, #0
     dc8:	ea40 0101 	orr.w	r1, r0, r1
     dcc:	f883 1061 	strb.w	r1, [r3, #97]	; 0x61
     dd0:	ea4f 2112 	mov.w	r1, r2, lsr #8
     dd4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     dd8:	f04f 0000 	mov.w	r0, #0
     ddc:	ea40 0101 	orr.w	r1, r0, r1
     de0:	f883 1062 	strb.w	r1, [r3, #98]	; 0x62
     de4:	ea4f 4112 	mov.w	r1, r2, lsr #16
     de8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     dec:	f04f 0000 	mov.w	r0, #0
     df0:	ea40 0101 	orr.w	r1, r0, r1
     df4:	f883 1063 	strb.w	r1, [r3, #99]	; 0x63
     df8:	ea4f 6212 	mov.w	r2, r2, lsr #24
     dfc:	f04f 0100 	mov.w	r1, #0
     e00:	ea41 0202 	orr.w	r2, r1, r2
     e04:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
	hk_pkt->COMMS_Read_Pointer = comms_partition.read_pointer;
     e08:	f24b 5310 	movw	r3, #46352	; 0xb510
     e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e10:	681b      	ldr	r3, [r3, #0]
     e12:	f24c 32fc 	movw	r2, #50172	; 0xc3fc
     e16:	f2c2 0200 	movt	r2, #8192	; 0x2000
     e1a:	6892      	ldr	r2, [r2, #8]
     e1c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     e20:	f04f 0000 	mov.w	r0, #0
     e24:	ea40 0101 	orr.w	r1, r0, r1
     e28:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
     e2c:	ea4f 2112 	mov.w	r1, r2, lsr #8
     e30:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     e34:	f04f 0000 	mov.w	r0, #0
     e38:	ea40 0101 	orr.w	r1, r0, r1
     e3c:	f883 105e 	strb.w	r1, [r3, #94]	; 0x5e
     e40:	ea4f 4112 	mov.w	r1, r2, lsr #16
     e44:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     e48:	f04f 0000 	mov.w	r0, #0
     e4c:	ea40 0101 	orr.w	r1, r0, r1
     e50:	f883 105f 	strb.w	r1, [r3, #95]	; 0x5f
     e54:	ea4f 6212 	mov.w	r2, r2, lsr #24
     e58:	f04f 0100 	mov.w	r1, #0
     e5c:	ea41 0202 	orr.w	r2, r1, r2
     e60:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
	hk_pkt->Thermistor_Write_Pointer = thermistor_partition.write_pointer;
     e64:	f24b 5310 	movw	r3, #46352	; 0xb510
     e68:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e6c:	681b      	ldr	r3, [r3, #0]
     e6e:	f24c 32e8 	movw	r2, #50152	; 0xc3e8
     e72:	f2c2 0200 	movt	r2, #8192	; 0x2000
     e76:	68d2      	ldr	r2, [r2, #12]
     e78:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     e7c:	f04f 0000 	mov.w	r0, #0
     e80:	ea40 0101 	orr.w	r1, r0, r1
     e84:	f883 1059 	strb.w	r1, [r3, #89]	; 0x59
     e88:	ea4f 2112 	mov.w	r1, r2, lsr #8
     e8c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     e90:	f04f 0000 	mov.w	r0, #0
     e94:	ea40 0101 	orr.w	r1, r0, r1
     e98:	f883 105a 	strb.w	r1, [r3, #90]	; 0x5a
     e9c:	ea4f 4112 	mov.w	r1, r2, lsr #16
     ea0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     ea4:	f04f 0000 	mov.w	r0, #0
     ea8:	ea40 0101 	orr.w	r1, r0, r1
     eac:	f883 105b 	strb.w	r1, [r3, #91]	; 0x5b
     eb0:	ea4f 6212 	mov.w	r2, r2, lsr #24
     eb4:	f04f 0100 	mov.w	r1, #0
     eb8:	ea41 0202 	orr.w	r2, r1, r2
     ebc:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	hk_pkt->Thermistor_Read_Pointer = thermistor_partition.read_pointer;
     ec0:	f24b 5310 	movw	r3, #46352	; 0xb510
     ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ec8:	681b      	ldr	r3, [r3, #0]
     eca:	f24c 32e8 	movw	r2, #50152	; 0xc3e8
     ece:	f2c2 0200 	movt	r2, #8192	; 0x2000
     ed2:	6892      	ldr	r2, [r2, #8]
     ed4:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     ed8:	f04f 0000 	mov.w	r0, #0
     edc:	ea40 0101 	orr.w	r1, r0, r1
     ee0:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
     ee4:	ea4f 2112 	mov.w	r1, r2, lsr #8
     ee8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     eec:	f04f 0000 	mov.w	r0, #0
     ef0:	ea40 0101 	orr.w	r1, r0, r1
     ef4:	f883 1056 	strb.w	r1, [r3, #86]	; 0x56
     ef8:	ea4f 4112 	mov.w	r1, r2, lsr #16
     efc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     f00:	f04f 0000 	mov.w	r0, #0
     f04:	ea40 0101 	orr.w	r1, r0, r1
     f08:	f883 1057 	strb.w	r1, [r3, #87]	; 0x57
     f0c:	ea4f 6212 	mov.w	r2, r2, lsr #24
     f10:	f04f 0100 	mov.w	r1, #0
     f14:	ea41 0202 	orr.w	r2, r1, r2
     f18:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

	hk_pkt->Currents[0] = read_shunt_voltage(VC_SENSOR_I2C, VC1,  2, &flag);
     f1c:	f24b 5310 	movw	r3, #46352	; 0xb510
     f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f24:	681c      	ldr	r4, [r3, #0]
     f26:	f107 0319 	add.w	r3, r7, #25
     f2a:	f24b 4038 	movw	r0, #46136	; 0xb438
     f2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
     f32:	f04f 0140 	mov.w	r1, #64	; 0x40
     f36:	f04f 0202 	mov.w	r2, #2
     f3a:	f003 fa73 	bl	4424 <read_shunt_voltage>
     f3e:	4603      	mov	r3, r0
     f40:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     f44:	f04f 0100 	mov.w	r1, #0
     f48:	ea41 0202 	orr.w	r2, r1, r2
     f4c:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
     f50:	ea4f 2313 	mov.w	r3, r3, lsr #8
     f54:	b29b      	uxth	r3, r3
     f56:	f04f 0200 	mov.w	r2, #0
     f5a:	ea42 0303 	orr.w	r3, r2, r3
     f5e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	result |= flag << 5;
     f62:	7e7b      	ldrb	r3, [r7, #25]
     f64:	ea4f 1343 	mov.w	r3, r3, lsl #5
     f68:	b29a      	uxth	r2, r3
     f6a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
     f6c:	ea42 0303 	orr.w	r3, r2, r3
     f70:	b29b      	uxth	r3, r3
     f72:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Currents[1] = read_shunt_voltage(VC_SENSOR_I2C, VC1,  3, &flag);
     f74:	f24b 5310 	movw	r3, #46352	; 0xb510
     f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
     f7c:	681c      	ldr	r4, [r3, #0]
     f7e:	f107 0319 	add.w	r3, r7, #25
     f82:	f24b 4038 	movw	r0, #46136	; 0xb438
     f86:	f2c2 0000 	movt	r0, #8192	; 0x2000
     f8a:	f04f 0140 	mov.w	r1, #64	; 0x40
     f8e:	f04f 0203 	mov.w	r2, #3
     f92:	f003 fa47 	bl	4424 <read_shunt_voltage>
     f96:	4603      	mov	r3, r0
     f98:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     f9c:	f04f 0100 	mov.w	r1, #0
     fa0:	ea41 0202 	orr.w	r2, r1, r2
     fa4:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
     fa8:	ea4f 2313 	mov.w	r3, r3, lsr #8
     fac:	b29b      	uxth	r3, r3
     fae:	f04f 0200 	mov.w	r2, #0
     fb2:	ea42 0303 	orr.w	r3, r2, r3
     fb6:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
	result |= flag << 6;
     fba:	7e7b      	ldrb	r3, [r7, #25]
     fbc:	ea4f 1383 	mov.w	r3, r3, lsl #6
     fc0:	b29a      	uxth	r2, r3
     fc2:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
     fc4:	ea42 0303 	orr.w	r3, r2, r3
     fc8:	b29b      	uxth	r3, r3
     fca:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Currents[2] = read_shunt_voltage(TEMP_ADC_CORE_I2C, VC1,  1, &flag);
     fcc:	f24b 5310 	movw	r3, #46352	; 0xb510
     fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fd4:	681c      	ldr	r4, [r3, #0]
     fd6:	f107 0319 	add.w	r3, r7, #25
     fda:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
     fde:	f2c2 0000 	movt	r0, #8192	; 0x2000
     fe2:	f04f 0140 	mov.w	r1, #64	; 0x40
     fe6:	f04f 0201 	mov.w	r2, #1
     fea:	f003 fa1b 	bl	4424 <read_shunt_voltage>
     fee:	4603      	mov	r3, r0
     ff0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     ff4:	f04f 0100 	mov.w	r1, #0
     ff8:	ea41 0202 	orr.w	r2, r1, r2
     ffc:	f884 2047 	strb.w	r2, [r4, #71]	; 0x47
    1000:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1004:	b29b      	uxth	r3, r3
    1006:	f04f 0200 	mov.w	r2, #0
    100a:	ea42 0303 	orr.w	r3, r2, r3
    100e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
//	result |= flag << 9;
	hk_pkt->Currents[3] = read_shunt_voltage(TEMP_ADC_CORE_I2C, VC1,  2, &flag);
    1012:	f24b 5310 	movw	r3, #46352	; 0xb510
    1016:	f2c2 0300 	movt	r3, #8192	; 0x2000
    101a:	681c      	ldr	r4, [r3, #0]
    101c:	f107 0319 	add.w	r3, r7, #25
    1020:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    1024:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1028:	f04f 0140 	mov.w	r1, #64	; 0x40
    102c:	f04f 0202 	mov.w	r2, #2
    1030:	f003 f9f8 	bl	4424 <read_shunt_voltage>
    1034:	4603      	mov	r3, r0
    1036:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    103a:	f04f 0100 	mov.w	r1, #0
    103e:	ea41 0202 	orr.w	r2, r1, r2
    1042:	f884 2049 	strb.w	r2, [r4, #73]	; 0x49
    1046:	ea4f 2313 	mov.w	r3, r3, lsr #8
    104a:	b29b      	uxth	r3, r3
    104c:	f04f 0200 	mov.w	r2, #0
    1050:	ea42 0303 	orr.w	r3, r2, r3
    1054:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
//	result |= flag << 10;
	hk_pkt->Currents[4] = read_shunt_voltage(TEMP_ADC_CORE_I2C, VC1,  3, &flag);
    1058:	f24b 5310 	movw	r3, #46352	; 0xb510
    105c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1060:	681c      	ldr	r4, [r3, #0]
    1062:	f107 0319 	add.w	r3, r7, #25
    1066:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    106a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    106e:	f04f 0140 	mov.w	r1, #64	; 0x40
    1072:	f04f 0203 	mov.w	r2, #3
    1076:	f003 f9d5 	bl	4424 <read_shunt_voltage>
    107a:	4603      	mov	r3, r0
    107c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1080:	f04f 0100 	mov.w	r1, #0
    1084:	ea41 0202 	orr.w	r2, r1, r2
    1088:	f884 204b 	strb.w	r2, [r4, #75]	; 0x4b
    108c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1090:	b29b      	uxth	r3, r3
    1092:	f04f 0200 	mov.w	r2, #0
    1096:	ea42 0303 	orr.w	r3, r2, r3
    109a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
//	result |= flag << 10;

	hk_pkt->latest_codeword_rx = latest_codeword;
    109e:	f24b 5310 	movw	r3, #46352	; 0xb510
    10a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10a6:	681a      	ldr	r2, [r3, #0]
    10a8:	f24b 3356 	movw	r3, #45910	; 0xb356
    10ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10b0:	781b      	ldrb	r3, [r3, #0]
    10b2:	7653      	strb	r3, [r2, #25]

	i = 0;
    10b4:	f04f 0300 	mov.w	r3, #0
    10b8:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	get_time_vector();
    10bc:	f002 ff50 	bl	3f60 <get_time_vector>
	for(;i<32;i++){
    10c0:	e017      	b.n	10f2 <MAIN_STACK_SIZE+0xf2>
		hk_pkt->HKGTime_SVector[i] = Time_Vector[i];
    10c2:	f24b 5310 	movw	r3, #46352	; 0xb510
    10c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10ca:	6819      	ldr	r1, [r3, #0]
    10cc:	f897 0035 	ldrb.w	r0, [r7, #53]	; 0x35
    10d0:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    10d4:	f24c 4320 	movw	r3, #50208	; 0xc420
    10d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    10dc:	5c9a      	ldrb	r2, [r3, r2]
    10de:	eb00 0301 	add.w	r3, r0, r1
    10e2:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66

	hk_pkt->latest_codeword_rx = latest_codeword;

	i = 0;
	get_time_vector();
	for(;i<32;i++){
    10e6:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    10ea:	f103 0301 	add.w	r3, r3, #1
    10ee:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    10f2:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    10f6:	2b1f      	cmp	r3, #31
    10f8:	d9e3      	bls.n	10c2 <MAIN_STACK_SIZE+0xc2>
		hk_pkt->HKGTime_SVector[i] = Time_Vector[i];
	}

	hk_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, HK_API_ID))));
    10fa:	f24b 5310 	movw	r3, #46352	; 0xb510
    10fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1102:	681b      	ldr	r3, [r3, #0]
    1104:	f04f 0200 	mov.w	r2, #0
    1108:	f042 0208 	orr.w	r2, r2, #8
    110c:	701a      	strb	r2, [r3, #0]
    110e:	f04f 0200 	mov.w	r2, #0
    1112:	f042 0201 	orr.w	r2, r2, #1
    1116:	705a      	strb	r2, [r3, #1]
	hk_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((hk_seq_num++)))));
    1118:	f24b 5310 	movw	r3, #46352	; 0xb510
    111c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1120:	6818      	ldr	r0, [r3, #0]
    1122:	f24b 3352 	movw	r3, #45906	; 0xb352
    1126:	f2c2 0300 	movt	r3, #8192	; 0x2000
    112a:	8819      	ldrh	r1, [r3, #0]
    112c:	460b      	mov	r3, r1
    112e:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    1132:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    1136:	b29b      	uxth	r3, r3
    1138:	b29b      	uxth	r3, r3
    113a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    113e:	fa1f fc83 	uxth.w	ip, r3
    1142:	f24b 3352 	movw	r3, #45906	; 0xb352
    1146:	f2c2 0300 	movt	r3, #8192	; 0x2000
    114a:	881a      	ldrh	r2, [r3, #0]
    114c:	4613      	mov	r3, r2
    114e:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    1152:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    1156:	b29b      	uxth	r3, r3
    1158:	b29b      	uxth	r3, r3
    115a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    115e:	b29b      	uxth	r3, r3
    1160:	ea4c 0303 	orr.w	r3, ip, r3
    1164:	b29b      	uxth	r3, r3
    1166:	b29b      	uxth	r3, r3
    1168:	f003 0cff 	and.w	ip, r3, #255	; 0xff
    116c:	f04f 0e00 	mov.w	lr, #0
    1170:	ea4e 0c0c 	orr.w	ip, lr, ip
    1174:	f880 c002 	strb.w	ip, [r0, #2]
    1178:	ea4f 2313 	mov.w	r3, r3, lsr #8
    117c:	b29b      	uxth	r3, r3
    117e:	f04f 0c00 	mov.w	ip, #0
    1182:	ea4c 0303 	orr.w	r3, ip, r3
    1186:	70c3      	strb	r3, [r0, #3]
    1188:	f101 0301 	add.w	r3, r1, #1
    118c:	b299      	uxth	r1, r3
    118e:	f24b 3352 	movw	r3, #45906	; 0xb352
    1192:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1196:	8019      	strh	r1, [r3, #0]
    1198:	f102 0301 	add.w	r3, r2, #1
    119c:	b29a      	uxth	r2, r3
    119e:	f24b 3352 	movw	r3, #45906	; 0xb352
    11a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11a6:	801a      	strh	r2, [r3, #0]
	hk_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(HK_PKT_LENGTH))));
    11a8:	f24b 5310 	movw	r3, #46352	; 0xb510
    11ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11b0:	681a      	ldr	r2, [r3, #0]
    11b2:	f04f 0300 	mov.w	r3, #0
    11b6:	7113      	strb	r3, [r2, #4]
    11b8:	f04f 0300 	mov.w	r3, #0
    11bc:	ea6f 0303 	mvn.w	r3, r3
    11c0:	f003 0377 	and.w	r3, r3, #119	; 0x77
    11c4:	ea6f 0303 	mvn.w	r3, r3
    11c8:	7153      	strb	r3, [r2, #5]
	hk_pkt->ccsds_s2 = current_time_lower;
    11ca:	f24b 5310 	movw	r3, #46352	; 0xb510
    11ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    11d2:	681b      	ldr	r3, [r3, #0]
    11d4:	f24c 32c8 	movw	r2, #50120	; 0xc3c8
    11d8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    11dc:	e9d2 0100 	ldrd	r0, r1, [r2]
    11e0:	4602      	mov	r2, r0
    11e2:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    11e6:	f04f 0000 	mov.w	r0, #0
    11ea:	ea40 0101 	orr.w	r1, r0, r1
    11ee:	7299      	strb	r1, [r3, #10]
    11f0:	ea4f 2112 	mov.w	r1, r2, lsr #8
    11f4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    11f8:	f04f 0000 	mov.w	r0, #0
    11fc:	ea40 0101 	orr.w	r1, r0, r1
    1200:	72d9      	strb	r1, [r3, #11]
    1202:	ea4f 4112 	mov.w	r1, r2, lsr #16
    1206:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    120a:	f04f 0000 	mov.w	r0, #0
    120e:	ea40 0101 	orr.w	r1, r0, r1
    1212:	7319      	strb	r1, [r3, #12]
    1214:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1218:	f04f 0100 	mov.w	r1, #0
    121c:	ea41 0202 	orr.w	r2, r1, r2
    1220:	735a      	strb	r2, [r3, #13]
	hk_pkt->ccsds_s1 = current_time_upper;
    1222:	f24b 5310 	movw	r3, #46352	; 0xb510
    1226:	f2c2 0300 	movt	r3, #8192	; 0x2000
    122a:	681b      	ldr	r3, [r3, #0]
    122c:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1230:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1234:	e9d2 0100 	ldrd	r0, r1, [r2]
    1238:	4602      	mov	r2, r0
    123a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    123e:	f04f 0000 	mov.w	r0, #0
    1242:	ea40 0101 	orr.w	r1, r0, r1
    1246:	7199      	strb	r1, [r3, #6]
    1248:	ea4f 2112 	mov.w	r1, r2, lsr #8
    124c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1250:	f04f 0000 	mov.w	r0, #0
    1254:	ea40 0101 	orr.w	r1, r0, r1
    1258:	71d9      	strb	r1, [r3, #7]
    125a:	ea4f 4112 	mov.w	r1, r2, lsr #16
    125e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1262:	f04f 0000 	mov.w	r0, #0
    1266:	ea40 0101 	orr.w	r1, r0, r1
    126a:	7219      	strb	r1, [r3, #8]
    126c:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1270:	f04f 0100 	mov.w	r1, #0
    1274:	ea41 0202 	orr.w	r2, r1, r2
    1278:	725a      	strb	r2, [r3, #9]

	if(cmd_cntr == 20){
    127a:	f24b 335a 	movw	r3, #45914	; 0xb35a
    127e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1282:	781b      	ldrb	r3, [r3, #0]
    1284:	2b14      	cmp	r3, #20
    1286:	d10e      	bne.n	12a6 <MAIN_STACK_SIZE+0x2a6>
		cmd_cntr = 1;
    1288:	f24b 335a 	movw	r3, #45914	; 0xb35a
    128c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1290:	f04f 0201 	mov.w	r2, #1
    1294:	701a      	strb	r2, [r3, #0]
		CHK_CMD = 0;
    1296:	f24b 3376 	movw	r3, #45942	; 0xb376
    129a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    129e:	f04f 0200 	mov.w	r2, #0
    12a2:	701a      	strb	r2, [r3, #0]
    12a4:	e00c      	b.n	12c0 <MAIN_STACK_SIZE+0x2c0>
	}
	else{
		cmd_cntr++ ;
    12a6:	f24b 335a 	movw	r3, #45914	; 0xb35a
    12aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12ae:	781b      	ldrb	r3, [r3, #0]
    12b0:	f103 0301 	add.w	r3, r3, #1
    12b4:	b2da      	uxtb	r2, r3
    12b6:	f24b 335a 	movw	r3, #45914	; 0xb35a
    12ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12be:	701a      	strb	r2, [r3, #0]
	}

	if(store_in_sd_card){
    12c0:	f24b 3359 	movw	r3, #45913	; 0xb359
    12c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12c8:	781b      	ldrb	r3, [r3, #0]
    12ca:	2b00      	cmp	r3, #0
    12cc:	d055      	beq.n	137a <MAIN_STACK_SIZE+0x37a>
		sd_dump = 1;
    12ce:	f24b 336e 	movw	r3, #45934	; 0xb36e
    12d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12d6:	f04f 0201 	mov.w	r2, #1
    12da:	701a      	strb	r2, [r3, #0]
		hk_pkt->sd_dump = sd_dump;
    12dc:	f24b 5310 	movw	r3, #46352	; 0xb510
    12e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12e4:	681a      	ldr	r2, [r3, #0]
    12e6:	f24b 336e 	movw	r3, #45934	; 0xb36e
    12ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12ee:	781b      	ldrb	r3, [r3, #0]
    12f0:	f882 3065 	strb.w	r3, [r2, #101]	; 0x65
		hk_pkt->Fletcher_Code = make_FLetcher(data, sizeof(hk_pkt_t) - 2);
    12f4:	f24b 5310 	movw	r3, #46352	; 0xb510
    12f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    12fc:	681c      	ldr	r4, [r3, #0]
    12fe:	f24b 6038 	movw	r0, #46648	; 0xb638
    1302:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1306:	f04f 0186 	mov.w	r1, #134	; 0x86
    130a:	f7ff f9ed 	bl	6e8 <make_FLetcher>
    130e:	4603      	mov	r3, r0
    1310:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1314:	f04f 0100 	mov.w	r1, #0
    1318:	ea41 0202 	orr.w	r2, r1, r2
    131c:	f884 2086 	strb.w	r2, [r4, #134]	; 0x86
    1320:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1324:	b29b      	uxth	r3, r3
    1326:	f04f 0200 	mov.w	r2, #0
    132a:	ea42 0303 	orr.w	r3, r2, r3
    132e:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
		result |= ((store_data(&hk_partition, data) == 0 ? 0 : 1) << 7);
    1332:	f24c 400c 	movw	r0, #50188	; 0xc40c
    1336:	f2c2 0000 	movt	r0, #8192	; 0x2000
    133a:	f24b 6138 	movw	r1, #46648	; 0xb638
    133e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1342:	f004 f949 	bl	55d8 <store_data>
    1346:	4603      	mov	r3, r0
    1348:	2b00      	cmp	r3, #0
    134a:	d002      	beq.n	1352 <MAIN_STACK_SIZE+0x352>
    134c:	f04f 0380 	mov.w	r3, #128	; 0x80
    1350:	e001      	b.n	1356 <MAIN_STACK_SIZE+0x356>
    1352:	f04f 0300 	mov.w	r3, #0
    1356:	8e79      	ldrh	r1, [r7, #50]	; 0x32
    1358:	461a      	mov	r2, r3
    135a:	460b      	mov	r3, r1
    135c:	ea42 0303 	orr.w	r3, r2, r3
    1360:	b29b      	uxth	r3, r3
    1362:	867b      	strh	r3, [r7, #50]	; 0x32
		store_data(&hk_partition, data);
    1364:	f24c 400c 	movw	r0, #50188	; 0xc40c
    1368:	f2c2 0000 	movt	r0, #8192	; 0x2000
    136c:	f24b 6138 	movw	r1, #46648	; 0xb638
    1370:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1374:	f004 f930 	bl	55d8 <store_data>
    1378:	e03d      	b.n	13f6 <MAIN_STACK_SIZE+0x3f6>
	}
	else{
		sd_dump = 0;
    137a:	f24b 336e 	movw	r3, #45934	; 0xb36e
    137e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1382:	f04f 0200 	mov.w	r2, #0
    1386:	701a      	strb	r2, [r3, #0]
		hk_pkt->sd_dump = sd_dump;
    1388:	f24b 5310 	movw	r3, #46352	; 0xb510
    138c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1390:	681a      	ldr	r2, [r3, #0]
    1392:	f24b 336e 	movw	r3, #45934	; 0xb36e
    1396:	f2c2 0300 	movt	r3, #8192	; 0x2000
    139a:	781b      	ldrb	r3, [r3, #0]
    139c:	f882 3065 	strb.w	r3, [r2, #101]	; 0x65
		hk_pkt->Fletcher_Code = make_FLetcher(data, sizeof(hk_pkt_t) - 2);
    13a0:	f24b 5310 	movw	r3, #46352	; 0xb510
    13a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13a8:	681c      	ldr	r4, [r3, #0]
    13aa:	f24b 6038 	movw	r0, #46648	; 0xb638
    13ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
    13b2:	f04f 0186 	mov.w	r1, #134	; 0x86
    13b6:	f7ff f997 	bl	6e8 <make_FLetcher>
    13ba:	4603      	mov	r3, r0
    13bc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    13c0:	f04f 0100 	mov.w	r1, #0
    13c4:	ea41 0202 	orr.w	r2, r1, r2
    13c8:	f884 2086 	strb.w	r2, [r4, #134]	; 0x86
    13cc:	ea4f 2313 	mov.w	r3, r3, lsr #8
    13d0:	b29b      	uxth	r3, r3
    13d2:	f04f 0200 	mov.w	r2, #0
    13d6:	ea42 0303 	orr.w	r3, r2, r3
    13da:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
		vGetPktStruct(hk, (void*) hk_pkt, sizeof(hk_pkt_t));
    13de:	f24b 5310 	movw	r3, #46352	; 0xb510
    13e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    13e6:	681b      	ldr	r3, [r3, #0]
    13e8:	f04f 0000 	mov.w	r0, #0
    13ec:	4619      	mov	r1, r3
    13ee:	f04f 0288 	mov.w	r2, #136	; 0x88
    13f2:	f7ff f8fd 	bl	5f0 <vGetPktStruct>
//		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
	}

	return result;
    13f6:	8e7b      	ldrh	r3, [r7, #50]	; 0x32


//	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
//	MSS_UART_polled_tx_string(&g_mss_uart0, msg);
}
    13f8:	4618      	mov	r0, r3
    13fa:	f107 073c 	add.w	r7, r7, #60	; 0x3c
    13fe:	46bd      	mov	sp, r7
    1400:	bd90      	pop	{r4, r7, pc}
    1402:	bf00      	nop

00001404 <get_temp>:


uint16_t get_temp(){
    1404:	b5b0      	push	{r4, r5, r7, lr}
    1406:	b082      	sub	sp, #8
    1408:	af00      	add	r7, sp, #0
	uint8_t i = 0;
    140a:	f04f 0300 	mov.w	r3, #0
    140e:	713b      	strb	r3, [r7, #4]
	uint8_t flag;
	uint8_t sd_dump_thermistor = 0;
    1410:	f04f 0300 	mov.w	r3, #0
    1414:	717b      	strb	r3, [r7, #5]
	uint16_t res = 0;
    1416:	f04f 0300 	mov.w	r3, #0
    141a:	80fb      	strh	r3, [r7, #6]
	thermistor_pkt = (thermistor_pkt_t*) data;
    141c:	f24b 6238 	movw	r2, #46648	; 0xb638
    1420:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1424:	f24b 6334 	movw	r3, #46644	; 0xb634
    1428:	f2c2 0300 	movt	r3, #8192	; 0x2000
    142c:	601a      	str	r2, [r3, #0]

	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    142e:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1432:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1436:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    143a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    143e:	4610      	mov	r0, r2
    1440:	4619      	mov	r1, r3
    1442:	f7ff f855 	bl	4f0 <MSS_TIM64_get_current_value>

	thermistor_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, THERMISTOR_API_ID))));
    1446:	f24b 6334 	movw	r3, #46644	; 0xb634
    144a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    144e:	681b      	ldr	r3, [r3, #0]
    1450:	f04f 0200 	mov.w	r2, #0
    1454:	f042 0208 	orr.w	r2, r2, #8
    1458:	701a      	strb	r2, [r3, #0]
    145a:	f04f 0200 	mov.w	r2, #0
    145e:	f042 0204 	orr.w	r2, r2, #4
    1462:	705a      	strb	r2, [r3, #1]
	thermistor_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((temp_seq_num++)))));
    1464:	f24b 6334 	movw	r3, #46644	; 0xb634
    1468:	f2c2 0300 	movt	r3, #8192	; 0x2000
    146c:	6818      	ldr	r0, [r3, #0]
    146e:	f24b 3354 	movw	r3, #45908	; 0xb354
    1472:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1476:	8819      	ldrh	r1, [r3, #0]
    1478:	460b      	mov	r3, r1
    147a:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    147e:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    1482:	b29b      	uxth	r3, r3
    1484:	b29b      	uxth	r3, r3
    1486:	ea4f 2303 	mov.w	r3, r3, lsl #8
    148a:	fa1f fc83 	uxth.w	ip, r3
    148e:	f24b 3354 	movw	r3, #45908	; 0xb354
    1492:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1496:	881a      	ldrh	r2, [r3, #0]
    1498:	4613      	mov	r3, r2
    149a:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    149e:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    14a2:	b29b      	uxth	r3, r3
    14a4:	b29b      	uxth	r3, r3
    14a6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    14aa:	b29b      	uxth	r3, r3
    14ac:	ea4c 0303 	orr.w	r3, ip, r3
    14b0:	b29b      	uxth	r3, r3
    14b2:	b29b      	uxth	r3, r3
    14b4:	f003 0cff 	and.w	ip, r3, #255	; 0xff
    14b8:	f04f 0e00 	mov.w	lr, #0
    14bc:	ea4e 0c0c 	orr.w	ip, lr, ip
    14c0:	f880 c002 	strb.w	ip, [r0, #2]
    14c4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    14c8:	b29b      	uxth	r3, r3
    14ca:	f04f 0c00 	mov.w	ip, #0
    14ce:	ea4c 0303 	orr.w	r3, ip, r3
    14d2:	70c3      	strb	r3, [r0, #3]
    14d4:	f101 0301 	add.w	r3, r1, #1
    14d8:	b299      	uxth	r1, r3
    14da:	f24b 3354 	movw	r3, #45908	; 0xb354
    14de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14e2:	8019      	strh	r1, [r3, #0]
    14e4:	f102 0301 	add.w	r3, r2, #1
    14e8:	b29a      	uxth	r2, r3
    14ea:	f24b 3354 	movw	r3, #45908	; 0xb354
    14ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14f2:	801a      	strh	r2, [r3, #0]
	thermistor_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(THERMISTOR_PKT_LENGTH))));
    14f4:	f24b 6334 	movw	r3, #46644	; 0xb634
    14f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14fc:	681b      	ldr	r3, [r3, #0]
    14fe:	f04f 0200 	mov.w	r2, #0
    1502:	711a      	strb	r2, [r3, #4]
    1504:	f04f 0200 	mov.w	r2, #0
    1508:	f042 0241 	orr.w	r2, r2, #65	; 0x41
    150c:	715a      	strb	r2, [r3, #5]
	thermistor_pkt->ccsds_s2 = current_time_lower;
    150e:	f24b 6334 	movw	r3, #46644	; 0xb634
    1512:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1516:	681b      	ldr	r3, [r3, #0]
    1518:	f24c 32c8 	movw	r2, #50120	; 0xc3c8
    151c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1520:	e9d2 0100 	ldrd	r0, r1, [r2]
    1524:	4602      	mov	r2, r0
    1526:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    152a:	f04f 0000 	mov.w	r0, #0
    152e:	ea40 0101 	orr.w	r1, r0, r1
    1532:	7299      	strb	r1, [r3, #10]
    1534:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1538:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    153c:	f04f 0000 	mov.w	r0, #0
    1540:	ea40 0101 	orr.w	r1, r0, r1
    1544:	72d9      	strb	r1, [r3, #11]
    1546:	ea4f 4112 	mov.w	r1, r2, lsr #16
    154a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    154e:	f04f 0000 	mov.w	r0, #0
    1552:	ea40 0101 	orr.w	r1, r0, r1
    1556:	7319      	strb	r1, [r3, #12]
    1558:	ea4f 6212 	mov.w	r2, r2, lsr #24
    155c:	f04f 0100 	mov.w	r1, #0
    1560:	ea41 0202 	orr.w	r2, r1, r2
    1564:	735a      	strb	r2, [r3, #13]
	thermistor_pkt->ccsds_s1 = current_time_upper;
    1566:	f24b 6334 	movw	r3, #46644	; 0xb634
    156a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    156e:	681b      	ldr	r3, [r3, #0]
    1570:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1574:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1578:	e9d2 0100 	ldrd	r0, r1, [r2]
    157c:	4602      	mov	r2, r0
    157e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1582:	f04f 0000 	mov.w	r0, #0
    1586:	ea40 0101 	orr.w	r1, r0, r1
    158a:	7199      	strb	r1, [r3, #6]
    158c:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1590:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1594:	f04f 0000 	mov.w	r0, #0
    1598:	ea40 0101 	orr.w	r1, r0, r1
    159c:	71d9      	strb	r1, [r3, #7]
    159e:	ea4f 4112 	mov.w	r1, r2, lsr #16
    15a2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    15a6:	f04f 0000 	mov.w	r0, #0
    15aa:	ea40 0101 	orr.w	r1, r0, r1
    15ae:	7219      	strb	r1, [r3, #8]
    15b0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    15b4:	f04f 0100 	mov.w	r1, #0
    15b8:	ea41 0202 	orr.w	r2, r1, r2
    15bc:	725a      	strb	r2, [r3, #9]

	for(;i<8;i++){
    15be:	e03a      	b.n	1636 <get_temp+0x232>
		thermistor_pkt->Temperature_Values[i] = get_ADC_value(TEMP_ADC_CORE_I2C, ADC_ADDR, i, &flag);
    15c0:	f24b 6334 	movw	r3, #46644	; 0xb634
    15c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    15c8:	681c      	ldr	r4, [r3, #0]
    15ca:	793d      	ldrb	r5, [r7, #4]
    15cc:	793a      	ldrb	r2, [r7, #4]
    15ce:	f107 0303 	add.w	r3, r7, #3
    15d2:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    15d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    15da:	f04f 0123 	mov.w	r1, #35	; 0x23
    15de:	f002 fffb 	bl	45d8 <get_ADC_value>
    15e2:	4603      	mov	r3, r0
    15e4:	4619      	mov	r1, r3
    15e6:	f105 0204 	add.w	r2, r5, #4
    15ea:	f001 00ff 	and.w	r0, r1, #255	; 0xff
    15ee:	ea4f 0342 	mov.w	r3, r2, lsl #1
    15f2:	4423      	add	r3, r4
    15f4:	f04f 0c00 	mov.w	ip, #0
    15f8:	ea4c 0000 	orr.w	r0, ip, r0
    15fc:	7198      	strb	r0, [r3, #6]
    15fe:	ea4f 2311 	mov.w	r3, r1, lsr #8
    1602:	b298      	uxth	r0, r3
    1604:	ea4f 0342 	mov.w	r3, r2, lsl #1
    1608:	4423      	add	r3, r4
    160a:	f04f 0200 	mov.w	r2, #0
    160e:	4611      	mov	r1, r2
    1610:	4602      	mov	r2, r0
    1612:	ea41 0202 	orr.w	r2, r1, r2
    1616:	71da      	strb	r2, [r3, #7]
		res |= (flag << i);
    1618:	78fb      	ldrb	r3, [r7, #3]
    161a:	461a      	mov	r2, r3
    161c:	793b      	ldrb	r3, [r7, #4]
    161e:	fa02 f303 	lsl.w	r3, r2, r3
    1622:	b29a      	uxth	r2, r3
    1624:	88fb      	ldrh	r3, [r7, #6]
    1626:	ea42 0303 	orr.w	r3, r2, r3
    162a:	b29b      	uxth	r3, r3
    162c:	80fb      	strh	r3, [r7, #6]
	thermistor_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((temp_seq_num++)))));
	thermistor_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(THERMISTOR_PKT_LENGTH))));
	thermistor_pkt->ccsds_s2 = current_time_lower;
	thermistor_pkt->ccsds_s1 = current_time_upper;

	for(;i<8;i++){
    162e:	793b      	ldrb	r3, [r7, #4]
    1630:	f103 0301 	add.w	r3, r3, #1
    1634:	713b      	strb	r3, [r7, #4]
    1636:	793b      	ldrb	r3, [r7, #4]
    1638:	2b07      	cmp	r3, #7
    163a:	d9c1      	bls.n	15c0 <get_temp+0x1bc>
		thermistor_pkt->Temperature_Values[i] = get_ADC_value(TEMP_ADC_CORE_I2C, ADC_ADDR, i, &flag);
		res |= (flag << i);
	}

	i = 0;
    163c:	f04f 0300 	mov.w	r3, #0
    1640:	713b      	strb	r3, [r7, #4]
	get_time_vector();
    1642:	f002 fc8d 	bl	3f60 <get_time_vector>
	for(;i<32;i++){
    1646:	e012      	b.n	166e <get_temp+0x26a>
		thermistor_pkt->TempGTime_SVector[i] = Time_Vector[i];
    1648:	f24b 6334 	movw	r3, #46644	; 0xb634
    164c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1650:	6819      	ldr	r1, [r3, #0]
    1652:	7938      	ldrb	r0, [r7, #4]
    1654:	793a      	ldrb	r2, [r7, #4]
    1656:	f24c 4320 	movw	r3, #50208	; 0xc420
    165a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    165e:	5c9a      	ldrb	r2, [r3, r2]
    1660:	eb00 0301 	add.w	r3, r0, r1
    1664:	77da      	strb	r2, [r3, #31]
		res |= (flag << i);
	}

	i = 0;
	get_time_vector();
	for(;i<32;i++){
    1666:	793b      	ldrb	r3, [r7, #4]
    1668:	f103 0301 	add.w	r3, r3, #1
    166c:	713b      	strb	r3, [r7, #4]
    166e:	793b      	ldrb	r3, [r7, #4]
    1670:	2b1f      	cmp	r3, #31
    1672:	d9e9      	bls.n	1648 <get_temp+0x244>
		thermistor_pkt->TempGTime_SVector[i] = Time_Vector[i];
	}


	if(store_in_sd_card){
    1674:	f24b 3359 	movw	r3, #45913	; 0xb359
    1678:	f2c2 0300 	movt	r3, #8192	; 0x2000
    167c:	781b      	ldrb	r3, [r3, #0]
    167e:	2b00      	cmp	r3, #0
    1680:	d033      	beq.n	16ea <get_temp+0x2e6>
		sd_dump_thermistor = 1;
    1682:	f04f 0301 	mov.w	r3, #1
    1686:	717b      	strb	r3, [r7, #5]
		thermistor_pkt->sd_dump = sd_dump_thermistor;
    1688:	f24b 6334 	movw	r3, #46644	; 0xb634
    168c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1690:	681b      	ldr	r3, [r3, #0]
    1692:	797a      	ldrb	r2, [r7, #5]
    1694:	779a      	strb	r2, [r3, #30]
		thermistor_pkt->Fletcher_Code = make_FLetcher(data, sizeof(thermistor_pkt_t) - 2);
    1696:	f24b 6334 	movw	r3, #46644	; 0xb634
    169a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    169e:	681c      	ldr	r4, [r3, #0]
    16a0:	f24b 6038 	movw	r0, #46648	; 0xb638
    16a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    16a8:	f04f 013f 	mov.w	r1, #63	; 0x3f
    16ac:	f7ff f81c 	bl	6e8 <make_FLetcher>
    16b0:	4603      	mov	r3, r0
    16b2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    16b6:	f04f 0100 	mov.w	r1, #0
    16ba:	ea41 0202 	orr.w	r2, r1, r2
    16be:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
    16c2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    16c6:	b29b      	uxth	r3, r3
    16c8:	f04f 0200 	mov.w	r2, #0
    16cc:	ea42 0303 	orr.w	r3, r2, r3
    16d0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		store_data(&thermistor_partition, data);
    16d4:	f24c 30e8 	movw	r0, #50152	; 0xc3e8
    16d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    16dc:	f24b 6138 	movw	r1, #46648	; 0xb638
    16e0:	f2c2 0100 	movt	r1, #8192	; 0x2000
    16e4:	f003 ff78 	bl	55d8 <store_data>
    16e8:	e034      	b.n	1754 <get_temp+0x350>
	}
	else{
		sd_dump_thermistor = 0;
    16ea:	f04f 0300 	mov.w	r3, #0
    16ee:	717b      	strb	r3, [r7, #5]
		thermistor_pkt->sd_dump = sd_dump_thermistor;
    16f0:	f24b 6334 	movw	r3, #46644	; 0xb634
    16f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16f8:	681b      	ldr	r3, [r3, #0]
    16fa:	797a      	ldrb	r2, [r7, #5]
    16fc:	779a      	strb	r2, [r3, #30]
		thermistor_pkt->Fletcher_Code = make_FLetcher(data, sizeof(thermistor_pkt_t) - 2);
    16fe:	f24b 6334 	movw	r3, #46644	; 0xb634
    1702:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1706:	681c      	ldr	r4, [r3, #0]
    1708:	f24b 6038 	movw	r0, #46648	; 0xb638
    170c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1710:	f04f 013f 	mov.w	r1, #63	; 0x3f
    1714:	f7fe ffe8 	bl	6e8 <make_FLetcher>
    1718:	4603      	mov	r3, r0
    171a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    171e:	f04f 0100 	mov.w	r1, #0
    1722:	ea41 0202 	orr.w	r2, r1, r2
    1726:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
    172a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    172e:	b29b      	uxth	r3, r3
    1730:	f04f 0200 	mov.w	r2, #0
    1734:	ea42 0303 	orr.w	r3, r2, r3
    1738:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		vGetPktStruct(thermistor, (void*) thermistor_pkt, sizeof(thermistor_pkt_t));
    173c:	f24b 6334 	movw	r3, #46644	; 0xb634
    1740:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1744:	681b      	ldr	r3, [r3, #0]
    1746:	f04f 0002 	mov.w	r0, #2
    174a:	4619      	mov	r1, r3
    174c:	f04f 0241 	mov.w	r2, #65	; 0x41
    1750:	f7fe ff4e 	bl	5f0 <vGetPktStruct>
//		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(thermistor_pkt_t));
	}

	return res;
    1754:	88fb      	ldrh	r3, [r7, #6]
}
    1756:	4618      	mov	r0, r3
    1758:	f107 0708 	add.w	r7, r7, #8
    175c:	46bd      	mov	sp, r7
    175e:	bdb0      	pop	{r4, r5, r7, pc}

00001760 <get_sd_data>:

void get_sd_data(){
    1760:	b580      	push	{r7, lr}
    1762:	af00      	add	r7, sp, #0
	read_data(&hk_partition, data);
    1764:	f24c 400c 	movw	r0, #50188	; 0xc40c
    1768:	f2c2 0000 	movt	r0, #8192	; 0x2000
    176c:	f24b 6138 	movw	r1, #46648	; 0xb638
    1770:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1774:	f003 ff5e 	bl	5634 <read_data>
	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
    1778:	f24c 40c0 	movw	r0, #50368	; 0xc4c0
    177c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1780:	f24b 6138 	movw	r1, #46648	; 0xb638
    1784:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1788:	f04f 0288 	mov.w	r2, #136	; 0x88
    178c:	f004 ff6a 	bl	6664 <MSS_UART_polled_tx>
}
    1790:	bd80      	pop	{r7, pc}
    1792:	bf00      	nop

00001794 <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
    1794:	b480      	push	{r7}
    1796:	b083      	sub	sp, #12
    1798:	af00      	add	r7, sp, #0
    179a:	6078      	str	r0, [r7, #4]
    179c:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
    179e:	f244 0300 	movw	r3, #16384	; 0x4000
    17a2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    17a6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    17a8:	683b      	ldr	r3, [r7, #0]
    17aa:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
    17ac:	f244 0300 	movw	r3, #16384	; 0x4000
    17b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    17b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    17b6:	687b      	ldr	r3, [r7, #4]
    17b8:	601a      	str	r2, [r3, #0]
}
    17ba:	f107 070c 	add.w	r7, r7, #12
    17be:	46bd      	mov	sp, r7
    17c0:	bc80      	pop	{r7}
    17c2:	4770      	bx	lr

000017c4 <get_gmc>:

uint8_t status;
uint16_t ADC_voltages[8];


uint8_t get_gmc(){
    17c4:	b590      	push	{r4, r7, lr}
    17c6:	b083      	sub	sp, #12
    17c8:	af00      	add	r7, sp, #0
	uint16_t i = 0;
    17ca:	f04f 0300 	mov.w	r3, #0
    17ce:	80fb      	strh	r3, [r7, #6]
	gmc_pkt = (gmc_pkt_t*) data;
    17d0:	f24b 6238 	movw	r2, #46648	; 0xb638
    17d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    17d8:	f24c 1334 	movw	r3, #49460	; 0xc134
    17dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    17e0:	601a      	str	r2, [r3, #0]
	status = get_count(&counter_i2c, count_val);
    17e2:	f24c 004c 	movw	r0, #49228	; 0xc04c
    17e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    17ea:	f24c 1150 	movw	r1, #49488	; 0xc150
    17ee:	f2c2 0100 	movt	r1, #8192	; 0x2000
    17f2:	f003 ff7f 	bl	56f4 <get_count>
    17f6:	4603      	mov	r3, r0
    17f8:	461a      	mov	r2, r3
    17fa:	f24c 137c 	movw	r3, #49532	; 0xc17c
    17fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1802:	701a      	strb	r2, [r3, #0]
	status = status << 1;
    1804:	f24c 137c 	movw	r3, #49532	; 0xc17c
    1808:	f2c2 0300 	movt	r3, #8192	; 0x2000
    180c:	781b      	ldrb	r3, [r3, #0]
    180e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1812:	b2da      	uxtb	r2, r3
    1814:	f24c 137c 	movw	r3, #49532	; 0xc17c
    1818:	f2c2 0300 	movt	r3, #8192	; 0x2000
    181c:	701a      	strb	r2, [r3, #0]
	gmc_radiation_count = count_val[0];
    181e:	f24c 1350 	movw	r3, #49488	; 0xc150
    1822:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1826:	781b      	ldrb	r3, [r3, #0]
    1828:	461a      	mov	r2, r3
    182a:	f24c 134c 	movw	r3, #49484	; 0xc14c
    182e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1832:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count << 8;
    1834:	f24c 134c 	movw	r3, #49484	; 0xc14c
    1838:	f2c2 0300 	movt	r3, #8192	; 0x2000
    183c:	681b      	ldr	r3, [r3, #0]
    183e:	ea4f 2203 	mov.w	r2, r3, lsl #8
    1842:	f24c 134c 	movw	r3, #49484	; 0xc14c
    1846:	f2c2 0300 	movt	r3, #8192	; 0x2000
    184a:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count | count_val[1];
    184c:	f24c 1350 	movw	r3, #49488	; 0xc150
    1850:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1854:	785b      	ldrb	r3, [r3, #1]
    1856:	461a      	mov	r2, r3
    1858:	f24c 134c 	movw	r3, #49484	; 0xc14c
    185c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1860:	681b      	ldr	r3, [r3, #0]
    1862:	ea42 0203 	orr.w	r2, r2, r3
    1866:	f24c 134c 	movw	r3, #49484	; 0xc14c
    186a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    186e:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count << 8;
    1870:	f24c 134c 	movw	r3, #49484	; 0xc14c
    1874:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1878:	681b      	ldr	r3, [r3, #0]
    187a:	ea4f 2203 	mov.w	r2, r3, lsl #8
    187e:	f24c 134c 	movw	r3, #49484	; 0xc14c
    1882:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1886:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count | count_val[2];
    1888:	f24c 1350 	movw	r3, #49488	; 0xc150
    188c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1890:	789b      	ldrb	r3, [r3, #2]
    1892:	461a      	mov	r2, r3
    1894:	f24c 134c 	movw	r3, #49484	; 0xc14c
    1898:	f2c2 0300 	movt	r3, #8192	; 0x2000
    189c:	681b      	ldr	r3, [r3, #0]
    189e:	ea42 0203 	orr.w	r2, r2, r3
    18a2:	f24c 134c 	movw	r3, #49484	; 0xc14c
    18a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18aa:	601a      	str	r2, [r3, #0]



	status = get_free_res(&counter_i2c, free_res);
    18ac:	f24c 004c 	movw	r0, #49228	; 0xc04c
    18b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    18b4:	f24c 1154 	movw	r1, #49492	; 0xc154
    18b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
    18bc:	f003 ff44 	bl	5748 <get_free_res>
    18c0:	4603      	mov	r3, r0
    18c2:	461a      	mov	r2, r3
    18c4:	f24c 137c 	movw	r3, #49532	; 0xc17c
    18c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18cc:	701a      	strb	r2, [r3, #0]
	status = status << 1;
    18ce:	f24c 137c 	movw	r3, #49532	; 0xc17c
    18d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18d6:	781b      	ldrb	r3, [r3, #0]
    18d8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    18dc:	b2da      	uxtb	r2, r3
    18de:	f24c 137c 	movw	r3, #49532	; 0xc17c
    18e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18e6:	701a      	strb	r2, [r3, #0]
	gmc_free_res_value = count_val[0];
    18e8:	f24c 1350 	movw	r3, #49488	; 0xc150
    18ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18f0:	781b      	ldrb	r3, [r3, #0]
    18f2:	461a      	mov	r2, r3
    18f4:	f24c 1378 	movw	r3, #49528	; 0xc178
    18f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    18fc:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value << 8;
    18fe:	f24c 1378 	movw	r3, #49528	; 0xc178
    1902:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1906:	681b      	ldr	r3, [r3, #0]
    1908:	ea4f 2203 	mov.w	r2, r3, lsl #8
    190c:	f24c 1378 	movw	r3, #49528	; 0xc178
    1910:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1914:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value | count_val[1];
    1916:	f24c 1350 	movw	r3, #49488	; 0xc150
    191a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    191e:	785b      	ldrb	r3, [r3, #1]
    1920:	461a      	mov	r2, r3
    1922:	f24c 1378 	movw	r3, #49528	; 0xc178
    1926:	f2c2 0300 	movt	r3, #8192	; 0x2000
    192a:	681b      	ldr	r3, [r3, #0]
    192c:	ea42 0203 	orr.w	r2, r2, r3
    1930:	f24c 1378 	movw	r3, #49528	; 0xc178
    1934:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1938:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value << 8;
    193a:	f24c 1378 	movw	r3, #49528	; 0xc178
    193e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1942:	681b      	ldr	r3, [r3, #0]
    1944:	ea4f 2203 	mov.w	r2, r3, lsl #8
    1948:	f24c 1378 	movw	r3, #49528	; 0xc178
    194c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1950:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value | count_val[2];
    1952:	f24c 1350 	movw	r3, #49488	; 0xc150
    1956:	f2c2 0300 	movt	r3, #8192	; 0x2000
    195a:	789b      	ldrb	r3, [r3, #2]
    195c:	461a      	mov	r2, r3
    195e:	f24c 1378 	movw	r3, #49528	; 0xc178
    1962:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1966:	681b      	ldr	r3, [r3, #0]
    1968:	ea42 0203 	orr.w	r2, r2, r3
    196c:	f24c 1378 	movw	r3, #49528	; 0xc178
    1970:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1974:	601a      	str	r2, [r3, #0]

	get_gmc_voltages(&counter_i2c, ADC_voltages);
    1976:	f24c 1338 	movw	r3, #49464	; 0xc138
    197a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    197e:	f24c 004c 	movw	r0, #49228	; 0xc04c
    1982:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1986:	4619      	mov	r1, r3
    1988:	f003 ff24 	bl	57d4 <get_gmc_voltages>

	gmc_pkt->IMG_ID = IMG_ID;
    198c:	f24c 1334 	movw	r3, #49460	; 0xc134
    1990:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1994:	681a      	ldr	r2, [r3, #0]
    1996:	f24b 0304 	movw	r3, #45060	; 0xb004
    199a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    199e:	781b      	ldrb	r3, [r3, #0]
    19a0:	7393      	strb	r3, [r2, #14]
	gmc_pkt->Radiation_Counts = gmc_radiation_count;
    19a2:	f24c 1334 	movw	r3, #49460	; 0xc134
    19a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19aa:	681b      	ldr	r3, [r3, #0]
    19ac:	f24c 124c 	movw	r2, #49484	; 0xc14c
    19b0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    19b4:	6812      	ldr	r2, [r2, #0]
    19b6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    19ba:	f04f 0000 	mov.w	r0, #0
    19be:	ea40 0101 	orr.w	r1, r0, r1
    19c2:	73d9      	strb	r1, [r3, #15]
    19c4:	ea4f 2112 	mov.w	r1, r2, lsr #8
    19c8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    19cc:	f04f 0000 	mov.w	r0, #0
    19d0:	ea40 0101 	orr.w	r1, r0, r1
    19d4:	7419      	strb	r1, [r3, #16]
    19d6:	ea4f 4112 	mov.w	r1, r2, lsr #16
    19da:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    19de:	f04f 0000 	mov.w	r0, #0
    19e2:	ea40 0101 	orr.w	r1, r0, r1
    19e6:	7459      	strb	r1, [r3, #17]
    19e8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    19ec:	f04f 0100 	mov.w	r1, #0
    19f0:	ea41 0202 	orr.w	r2, r1, r2
    19f4:	749a      	strb	r2, [r3, #18]
	gmc_pkt->Counter_Free_Register = gmc_free_res_value;
    19f6:	f24c 1334 	movw	r3, #49460	; 0xc134
    19fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19fe:	681b      	ldr	r3, [r3, #0]
    1a00:	f24c 1278 	movw	r2, #49528	; 0xc178
    1a04:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1a08:	6812      	ldr	r2, [r2, #0]
    1a0a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1a0e:	f04f 0000 	mov.w	r0, #0
    1a12:	ea40 0101 	orr.w	r1, r0, r1
    1a16:	74d9      	strb	r1, [r3, #19]
    1a18:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1a1c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1a20:	f04f 0000 	mov.w	r0, #0
    1a24:	ea40 0101 	orr.w	r1, r0, r1
    1a28:	7519      	strb	r1, [r3, #20]
    1a2a:	ea4f 4112 	mov.w	r1, r2, lsr #16
    1a2e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1a32:	f04f 0000 	mov.w	r0, #0
    1a36:	ea40 0101 	orr.w	r1, r0, r1
    1a3a:	7559      	strb	r1, [r3, #21]
    1a3c:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1a40:	f04f 0100 	mov.w	r1, #0
    1a44:	ea41 0202 	orr.w	r2, r1, r2
    1a48:	759a      	strb	r2, [r3, #22]
	for (i=0; i<8; i++){
    1a4a:	f04f 0300 	mov.w	r3, #0
    1a4e:	80fb      	strh	r3, [r7, #6]
    1a50:	e02a      	b.n	1aa8 <get_gmc+0x2e4>
	gmc_pkt->GMC_Voltage_ADC[i] = ADC_voltages[i];
    1a52:	f24c 1334 	movw	r3, #49460	; 0xc134
    1a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a5a:	681a      	ldr	r2, [r3, #0]
    1a5c:	88f9      	ldrh	r1, [r7, #6]
    1a5e:	88f8      	ldrh	r0, [r7, #6]
    1a60:	f24c 1338 	movw	r3, #49464	; 0xc138
    1a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1a68:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
    1a6c:	f101 0108 	add.w	r1, r1, #8
    1a70:	f000 0cff 	and.w	ip, r0, #255	; 0xff
    1a74:	ea4f 0341 	mov.w	r3, r1, lsl #1
    1a78:	4413      	add	r3, r2
    1a7a:	f04f 0e00 	mov.w	lr, #0
    1a7e:	ea4e 0c0c 	orr.w	ip, lr, ip
    1a82:	f883 c007 	strb.w	ip, [r3, #7]
    1a86:	ea4f 2310 	mov.w	r3, r0, lsr #8
    1a8a:	b298      	uxth	r0, r3
    1a8c:	ea4f 0341 	mov.w	r3, r1, lsl #1
    1a90:	4413      	add	r3, r2
    1a92:	f04f 0200 	mov.w	r2, #0
    1a96:	4611      	mov	r1, r2
    1a98:	4602      	mov	r2, r0
    1a9a:	ea41 0202 	orr.w	r2, r1, r2
    1a9e:	721a      	strb	r2, [r3, #8]
	get_gmc_voltages(&counter_i2c, ADC_voltages);

	gmc_pkt->IMG_ID = IMG_ID;
	gmc_pkt->Radiation_Counts = gmc_radiation_count;
	gmc_pkt->Counter_Free_Register = gmc_free_res_value;
	for (i=0; i<8; i++){
    1aa0:	88fb      	ldrh	r3, [r7, #6]
    1aa2:	f103 0301 	add.w	r3, r3, #1
    1aa6:	80fb      	strh	r3, [r7, #6]
    1aa8:	88fb      	ldrh	r3, [r7, #6]
    1aaa:	2b07      	cmp	r3, #7
    1aac:	d9d1      	bls.n	1a52 <get_gmc+0x28e>
	gmc_pkt->GMC_Voltage_ADC[i] = ADC_voltages[i];
	}

	get_time_vector();
    1aae:	f002 fa57 	bl	3f60 <get_time_vector>

	i = 0;
    1ab2:	f04f 0300 	mov.w	r3, #0
    1ab6:	80fb      	strh	r3, [r7, #6]
	for(;i<32;i++){
    1ab8:	e013      	b.n	1ae2 <get_gmc+0x31e>
		gmc_pkt->GMC_GTime_SVector[i] = Time_Vector[i];
    1aba:	f24c 1334 	movw	r3, #49460	; 0xc134
    1abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ac2:	6819      	ldr	r1, [r3, #0]
    1ac4:	88f8      	ldrh	r0, [r7, #6]
    1ac6:	88fa      	ldrh	r2, [r7, #6]
    1ac8:	f24c 4320 	movw	r3, #50208	; 0xc420
    1acc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ad0:	5c9a      	ldrb	r2, [r3, r2]
    1ad2:	eb00 0301 	add.w	r3, r0, r1
    1ad6:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	}

	get_time_vector();

	i = 0;
	for(;i<32;i++){
    1ada:	88fb      	ldrh	r3, [r7, #6]
    1adc:	f103 0301 	add.w	r3, r3, #1
    1ae0:	80fb      	strh	r3, [r7, #6]
    1ae2:	88fb      	ldrh	r3, [r7, #6]
    1ae4:	2b1f      	cmp	r3, #31
    1ae6:	d9e8      	bls.n	1aba <get_gmc+0x2f6>
		gmc_pkt->GMC_GTime_SVector[i] = Time_Vector[i];
	}

	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    1ae8:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1aec:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1af0:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    1af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1af8:	4610      	mov	r0, r2
    1afa:	4619      	mov	r1, r3
    1afc:	f7ff fe4a 	bl	1794 <MSS_TIM64_get_current_value>

	gmc_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, GMC_API_ID))));
    1b00:	f24c 1334 	movw	r3, #49460	; 0xc134
    1b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b08:	681b      	ldr	r3, [r3, #0]
    1b0a:	f04f 0200 	mov.w	r2, #0
    1b0e:	f042 0208 	orr.w	r2, r2, #8
    1b12:	701a      	strb	r2, [r3, #0]
    1b14:	f04f 0200 	mov.w	r2, #0
    1b18:	f042 0202 	orr.w	r2, r2, #2
    1b1c:	705a      	strb	r2, [r3, #1]
	gmc_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((gmc_seq_num++)))));
    1b1e:	f24c 1334 	movw	r3, #49460	; 0xc134
    1b22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b26:	6818      	ldr	r0, [r3, #0]
    1b28:	f24b 3360 	movw	r3, #45920	; 0xb360
    1b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b30:	8819      	ldrh	r1, [r3, #0]
    1b32:	460b      	mov	r3, r1
    1b34:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    1b38:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    1b3c:	b29b      	uxth	r3, r3
    1b3e:	b29b      	uxth	r3, r3
    1b40:	ea4f 2303 	mov.w	r3, r3, lsl #8
    1b44:	fa1f fc83 	uxth.w	ip, r3
    1b48:	f24b 3360 	movw	r3, #45920	; 0xb360
    1b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b50:	881a      	ldrh	r2, [r3, #0]
    1b52:	4613      	mov	r3, r2
    1b54:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    1b58:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    1b5c:	b29b      	uxth	r3, r3
    1b5e:	b29b      	uxth	r3, r3
    1b60:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1b64:	b29b      	uxth	r3, r3
    1b66:	ea4c 0303 	orr.w	r3, ip, r3
    1b6a:	b29b      	uxth	r3, r3
    1b6c:	b29b      	uxth	r3, r3
    1b6e:	f003 0cff 	and.w	ip, r3, #255	; 0xff
    1b72:	f04f 0e00 	mov.w	lr, #0
    1b76:	ea4e 0c0c 	orr.w	ip, lr, ip
    1b7a:	f880 c002 	strb.w	ip, [r0, #2]
    1b7e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1b82:	b29b      	uxth	r3, r3
    1b84:	f04f 0c00 	mov.w	ip, #0
    1b88:	ea4c 0303 	orr.w	r3, ip, r3
    1b8c:	70c3      	strb	r3, [r0, #3]
    1b8e:	f101 0301 	add.w	r3, r1, #1
    1b92:	b299      	uxth	r1, r3
    1b94:	f24b 3360 	movw	r3, #45920	; 0xb360
    1b98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1b9c:	8019      	strh	r1, [r3, #0]
    1b9e:	f102 0301 	add.w	r3, r2, #1
    1ba2:	b29a      	uxth	r2, r3
    1ba4:	f24b 3360 	movw	r3, #45920	; 0xb360
    1ba8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bac:	801a      	strh	r2, [r3, #0]
	gmc_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(GMC_PKT_LENGTH))));
    1bae:	f24c 1334 	movw	r3, #49460	; 0xc134
    1bb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bb6:	681b      	ldr	r3, [r3, #0]
    1bb8:	f04f 0200 	mov.w	r2, #0
    1bbc:	711a      	strb	r2, [r3, #4]
    1bbe:	f04f 0200 	mov.w	r2, #0
    1bc2:	f042 024a 	orr.w	r2, r2, #74	; 0x4a
    1bc6:	715a      	strb	r2, [r3, #5]
	gmc_pkt->ccsds_s1 = current_time_upper;
    1bc8:	f24c 1334 	movw	r3, #49460	; 0xc134
    1bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1bd0:	681b      	ldr	r3, [r3, #0]
    1bd2:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1bd6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1bda:	e9d2 0100 	ldrd	r0, r1, [r2]
    1bde:	4602      	mov	r2, r0
    1be0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1be4:	f04f 0000 	mov.w	r0, #0
    1be8:	ea40 0101 	orr.w	r1, r0, r1
    1bec:	7199      	strb	r1, [r3, #6]
    1bee:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1bf2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1bf6:	f04f 0000 	mov.w	r0, #0
    1bfa:	ea40 0101 	orr.w	r1, r0, r1
    1bfe:	71d9      	strb	r1, [r3, #7]
    1c00:	ea4f 4112 	mov.w	r1, r2, lsr #16
    1c04:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1c08:	f04f 0000 	mov.w	r0, #0
    1c0c:	ea40 0101 	orr.w	r1, r0, r1
    1c10:	7219      	strb	r1, [r3, #8]
    1c12:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1c16:	f04f 0100 	mov.w	r1, #0
    1c1a:	ea41 0202 	orr.w	r2, r1, r2
    1c1e:	725a      	strb	r2, [r3, #9]

	gmc_pkt->ccsds_s2 = current_time_lower;
    1c20:	f24c 1334 	movw	r3, #49460	; 0xc134
    1c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c28:	681b      	ldr	r3, [r3, #0]
    1c2a:	f24c 32c8 	movw	r2, #50120	; 0xc3c8
    1c2e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1c32:	e9d2 0100 	ldrd	r0, r1, [r2]
    1c36:	4602      	mov	r2, r0
    1c38:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1c3c:	f04f 0000 	mov.w	r0, #0
    1c40:	ea40 0101 	orr.w	r1, r0, r1
    1c44:	7299      	strb	r1, [r3, #10]
    1c46:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1c4a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1c4e:	f04f 0000 	mov.w	r0, #0
    1c52:	ea40 0101 	orr.w	r1, r0, r1
    1c56:	72d9      	strb	r1, [r3, #11]
    1c58:	ea4f 4112 	mov.w	r1, r2, lsr #16
    1c5c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1c60:	f04f 0000 	mov.w	r0, #0
    1c64:	ea40 0101 	orr.w	r1, r0, r1
    1c68:	7319      	strb	r1, [r3, #12]
    1c6a:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1c6e:	f04f 0100 	mov.w	r1, #0
    1c72:	ea41 0202 	orr.w	r2, r1, r2
    1c76:	735a      	strb	r2, [r3, #13]

	if(store_in_sd_card){
    1c78:	f24b 3359 	movw	r3, #45913	; 0xb359
    1c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c80:	781b      	ldrb	r3, [r3, #0]
    1c82:	2b00      	cmp	r3, #0
    1c84:	d03c      	beq.n	1d00 <get_gmc+0x53c>
			sd_dump_gmc = 1;
    1c86:	f24b 335c 	movw	r3, #45916	; 0xb35c
    1c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c8e:	f04f 0201 	mov.w	r2, #1
    1c92:	701a      	strb	r2, [r3, #0]
			gmc_pkt->GMC_sd_dump = sd_dump_gmc;
    1c94:	f24c 1334 	movw	r3, #49460	; 0xc134
    1c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1c9c:	681a      	ldr	r2, [r3, #0]
    1c9e:	f24b 335c 	movw	r3, #45916	; 0xb35c
    1ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ca6:	781b      	ldrb	r3, [r3, #0]
    1ca8:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
			gmc_pkt->Fletcher_Code = make_FLetcher(data, sizeof(gmc_pkt_t) - 2);
    1cac:	f24c 1334 	movw	r3, #49460	; 0xc134
    1cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1cb4:	681c      	ldr	r4, [r3, #0]
    1cb6:	f24b 6038 	movw	r0, #46648	; 0xb638
    1cba:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1cbe:	f04f 0148 	mov.w	r1, #72	; 0x48
    1cc2:	f7fe fd11 	bl	6e8 <make_FLetcher>
    1cc6:	4603      	mov	r3, r0
    1cc8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1ccc:	f04f 0100 	mov.w	r1, #0
    1cd0:	ea41 0202 	orr.w	r2, r1, r2
    1cd4:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
    1cd8:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1cdc:	b29b      	uxth	r3, r3
    1cde:	f04f 0200 	mov.w	r2, #0
    1ce2:	ea42 0303 	orr.w	r3, r2, r3
    1ce6:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
			store_data(&gmc_partition, data);
    1cea:	f24c 10a0 	movw	r0, #49568	; 0xc1a0
    1cee:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1cf2:	f24b 6138 	movw	r1, #46648	; 0xb638
    1cf6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    1cfa:	f003 fc6d 	bl	55d8 <store_data>
    1cfe:	e03d      	b.n	1d7c <get_gmc+0x5b8>
		}
		else{
			sd_dump_gmc = 0;
    1d00:	f24b 335c 	movw	r3, #45916	; 0xb35c
    1d04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d08:	f04f 0200 	mov.w	r2, #0
    1d0c:	701a      	strb	r2, [r3, #0]
			gmc_pkt->GMC_sd_dump = sd_dump_gmc;
    1d0e:	f24c 1334 	movw	r3, #49460	; 0xc134
    1d12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d16:	681a      	ldr	r2, [r3, #0]
    1d18:	f24b 335c 	movw	r3, #45916	; 0xb35c
    1d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d20:	781b      	ldrb	r3, [r3, #0]
    1d22:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
			gmc_pkt->Fletcher_Code = make_FLetcher(data, sizeof(gmc_pkt_t) - 2);
    1d26:	f24c 1334 	movw	r3, #49460	; 0xc134
    1d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d2e:	681c      	ldr	r4, [r3, #0]
    1d30:	f24b 6038 	movw	r0, #46648	; 0xb638
    1d34:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1d38:	f04f 0148 	mov.w	r1, #72	; 0x48
    1d3c:	f7fe fcd4 	bl	6e8 <make_FLetcher>
    1d40:	4603      	mov	r3, r0
    1d42:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1d46:	f04f 0100 	mov.w	r1, #0
    1d4a:	ea41 0202 	orr.w	r2, r1, r2
    1d4e:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
    1d52:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1d56:	b29b      	uxth	r3, r3
    1d58:	f04f 0200 	mov.w	r2, #0
    1d5c:	ea42 0303 	orr.w	r3, r2, r3
    1d60:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
			vGetPktStruct(gmc, (void*) gmc_pkt, sizeof(gmc_pkt_t));
    1d64:	f24c 1334 	movw	r3, #49460	; 0xc134
    1d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d6c:	681b      	ldr	r3, [r3, #0]
    1d6e:	f04f 0003 	mov.w	r0, #3
    1d72:	4619      	mov	r1, r3
    1d74:	f04f 024a 	mov.w	r2, #74	; 0x4a
    1d78:	f7fe fc3a 	bl	5f0 <vGetPktStruct>
//			MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(gmc_pkt_t));
		}


	return status;
    1d7c:	f24c 137c 	movw	r3, #49532	; 0xc17c
    1d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1d84:	781b      	ldrb	r3, [r3, #0]
}
    1d86:	4618      	mov	r0, r3
    1d88:	f107 070c 	add.w	r7, r7, #12
    1d8c:	46bd      	mov	sp, r7
    1d8e:	bd90      	pop	{r4, r7, pc}

00001d90 <get_comms>:

uint16_t get_comms(){
    1d90:	b590      	push	{r4, r7, lr}
    1d92:	b083      	sub	sp, #12
    1d94:	af00      	add	r7, sp, #0
	uint16_t i = 0;
    1d96:	f04f 0300 	mov.w	r3, #0
    1d9a:	80fb      	strh	r3, [r7, #6]
	comms_pkt = (comms_pkt_t*) data;
    1d9c:	f24b 6238 	movw	r2, #46648	; 0xb638
    1da0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1da4:	f24c 1348 	movw	r3, #49480	; 0xc148
    1da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dac:	601a      	str	r2, [r3, #0]
//	data_test[0]++;
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    1dae:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    1db2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1db6:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    1dba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dbe:	4610      	mov	r0, r2
    1dc0:	4619      	mov	r1, r3
    1dc2:	f7ff fce7 	bl	1794 <MSS_TIM64_get_current_value>
	for(;i<8;i++){
    1dc6:	e00c      	b.n	1de2 <get_comms+0x52>
		cmd_adf_data[i] = 0;
    1dc8:	88fa      	ldrh	r2, [r7, #6]
    1dca:	f24c 1358 	movw	r3, #49496	; 0xc158
    1dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1dd2:	f04f 0100 	mov.w	r1, #0
    1dd6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
uint16_t get_comms(){
	uint16_t i = 0;
	comms_pkt = (comms_pkt_t*) data;
//	data_test[0]++;
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
	for(;i<8;i++){
    1dda:	88fb      	ldrh	r3, [r7, #6]
    1ddc:	f103 0301 	add.w	r3, r3, #1
    1de0:	80fb      	strh	r3, [r7, #6]
    1de2:	88fb      	ldrh	r3, [r7, #6]
    1de4:	2b07      	cmp	r3, #7
    1de6:	d9ef      	bls.n	1dc8 <get_comms+0x38>
		cmd_adf_data[i] = 0;
	}
	i = 0;
    1de8:	f04f 0300 	mov.w	r3, #0
    1dec:	80fb      	strh	r3, [r7, #6]
	get_rssi_data(&rssi);
    1dee:	f24c 30f8 	movw	r0, #50168	; 0xc3f8
    1df2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    1df6:	f004 fa21 	bl	623c <get_rssi_data>
	comms_pkt->IMG_ID = IMG_ID;
    1dfa:	f24c 1348 	movw	r3, #49480	; 0xc148
    1dfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e02:	681a      	ldr	r2, [r3, #0]
    1e04:	f24b 0304 	movw	r3, #45060	; 0xb004
    1e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e0c:	781b      	ldrb	r3, [r3, #0]
    1e0e:	7393      	strb	r3, [r2, #14]
	comms_pkt->comms_adf_rssi = rssi;
    1e10:	f24c 1348 	movw	r3, #49480	; 0xc148
    1e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e18:	681a      	ldr	r2, [r3, #0]
    1e1a:	f24c 33f8 	movw	r3, #50168	; 0xc3f8
    1e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e22:	881b      	ldrh	r3, [r3, #0]
    1e24:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    1e28:	f04f 0000 	mov.w	r0, #0
    1e2c:	ea40 0101 	orr.w	r1, r0, r1
    1e30:	7511      	strb	r1, [r2, #20]
    1e32:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1e36:	b29b      	uxth	r3, r3
    1e38:	f04f 0100 	mov.w	r1, #0
    1e3c:	ea41 0303 	orr.w	r3, r1, r3
    1e40:	7553      	strb	r3, [r2, #21]
	comms_pkt->comms_adf_cmd_rx = cmd_rx_count;
    1e42:	f24c 1348 	movw	r3, #49480	; 0xc148
    1e46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e4a:	681a      	ldr	r2, [r3, #0]
    1e4c:	f24b 3369 	movw	r3, #45929	; 0xb369
    1e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e54:	781b      	ldrb	r3, [r3, #0]
    1e56:	73d3      	strb	r3, [r2, #15]
	comms_pkt->comms_adf_cmd_succ = cmd_succ_count;
    1e58:	f24c 1348 	movw	r3, #49480	; 0xc148
    1e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e60:	681a      	ldr	r2, [r3, #0]
    1e62:	f24b 336a 	movw	r3, #45930	; 0xb36a
    1e66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e6a:	781b      	ldrb	r3, [r3, #0]
    1e6c:	7413      	strb	r3, [r2, #16]
	comms_pkt->comms_adf_cmd_reject = cmd_reject_count;
    1e6e:	f24c 1348 	movw	r3, #49480	; 0xc148
    1e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e76:	681a      	ldr	r2, [r3, #0]
    1e78:	f24b 336b 	movw	r3, #45931	; 0xb36b
    1e7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e80:	781b      	ldrb	r3, [r3, #0]
    1e82:	7453      	strb	r3, [r2, #17]
	comms_pkt->comms_adf_rssi_cca = rssi_cca;
    1e84:	f24c 1348 	movw	r3, #49480	; 0xc148
    1e88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e8c:	681a      	ldr	r2, [r3, #0]
    1e8e:	f24c 33e4 	movw	r3, #50148	; 0xc3e4
    1e92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1e96:	881b      	ldrh	r3, [r3, #0]
    1e98:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    1e9c:	f04f 0000 	mov.w	r0, #0
    1ea0:	ea40 0101 	orr.w	r1, r0, r1
    1ea4:	7491      	strb	r1, [r2, #18]
    1ea6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    1eaa:	b29b      	uxth	r3, r3
    1eac:	f04f 0100 	mov.w	r1, #0
    1eb0:	ea41 0303 	orr.w	r3, r1, r3
    1eb4:	74d3      	strb	r3, [r2, #19]
	comms_pkt->comms_adf_preamble_patt = get_preamble_pkt();
    1eb6:	f24c 1348 	movw	r3, #49480	; 0xc148
    1eba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ebe:	681c      	ldr	r4, [r3, #0]
    1ec0:	f004 fa60 	bl	6384 <get_preamble_pkt>
    1ec4:	4603      	mov	r3, r0
    1ec6:	75a3      	strb	r3, [r4, #22]
	comms_pkt->comms_adf_sync_word = get_sync_word();
    1ec8:	f24c 1348 	movw	r3, #49480	; 0xc148
    1ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ed0:	681c      	ldr	r4, [r3, #0]
    1ed2:	f004 fa6f 	bl	63b4 <get_sync_word>
    1ed6:	4603      	mov	r3, r0
    1ed8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1edc:	f04f 0100 	mov.w	r1, #0
    1ee0:	ea41 0202 	orr.w	r2, r1, r2
    1ee4:	75e2      	strb	r2, [r4, #23]
    1ee6:	ea4f 2213 	mov.w	r2, r3, lsr #8
    1eea:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    1eee:	f04f 0100 	mov.w	r1, #0
    1ef2:	ea41 0202 	orr.w	r2, r1, r2
    1ef6:	7622      	strb	r2, [r4, #24]
    1ef8:	ea4f 4213 	mov.w	r2, r3, lsr #16
    1efc:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    1f00:	f04f 0100 	mov.w	r1, #0
    1f04:	ea41 0202 	orr.w	r2, r1, r2
    1f08:	7662      	strb	r2, [r4, #25]
    1f0a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    1f0e:	f04f 0200 	mov.w	r2, #0
    1f12:	ea42 0303 	orr.w	r3, r2, r3
    1f16:	76a3      	strb	r3, [r4, #26]
	comms_pkt->comms_adf_freq = get_freq();
    1f18:	f24c 1348 	movw	r3, #49480	; 0xc148
    1f1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f20:	681c      	ldr	r4, [r3, #0]
    1f22:	f004 fa6f 	bl	6404 <get_freq>
    1f26:	4603      	mov	r3, r0
    1f28:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1f2c:	f04f 0100 	mov.w	r1, #0
    1f30:	ea41 0202 	orr.w	r2, r1, r2
    1f34:	76e2      	strb	r2, [r4, #27]
    1f36:	ea4f 2213 	mov.w	r2, r3, lsr #8
    1f3a:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    1f3e:	f04f 0100 	mov.w	r1, #0
    1f42:	ea41 0202 	orr.w	r2, r1, r2
    1f46:	7722      	strb	r2, [r4, #28]
    1f48:	ea4f 4213 	mov.w	r2, r3, lsr #16
    1f4c:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    1f50:	f04f 0100 	mov.w	r1, #0
    1f54:	ea41 0202 	orr.w	r2, r1, r2
    1f58:	7762      	strb	r2, [r4, #29]
    1f5a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    1f5e:	f04f 0200 	mov.w	r2, #0
    1f62:	ea42 0303 	orr.w	r3, r2, r3
    1f66:	77a3      	strb	r3, [r4, #30]
	comms_pkt->comms_adf_read_reg_addr = cmd_adf_read_addr;
    1f68:	f24c 1348 	movw	r3, #49480	; 0xc148
    1f6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1f70:	681b      	ldr	r3, [r3, #0]
    1f72:	f24b 3264 	movw	r2, #45924	; 0xb364
    1f76:	f2c2 0200 	movt	r2, #8192	; 0x2000
    1f7a:	6812      	ldr	r2, [r2, #0]
    1f7c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    1f80:	f04f 0000 	mov.w	r0, #0
    1f84:	ea40 0101 	orr.w	r1, r0, r1
    1f88:	77d9      	strb	r1, [r3, #31]
    1f8a:	ea4f 2112 	mov.w	r1, r2, lsr #8
    1f8e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1f92:	f04f 0000 	mov.w	r0, #0
    1f96:	ea40 0101 	orr.w	r1, r0, r1
    1f9a:	f883 1020 	strb.w	r1, [r3, #32]
    1f9e:	ea4f 4112 	mov.w	r1, r2, lsr #16
    1fa2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    1fa6:	f04f 0000 	mov.w	r0, #0
    1faa:	ea40 0101 	orr.w	r1, r0, r1
    1fae:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
    1fb2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    1fb6:	f04f 0100 	mov.w	r1, #0
    1fba:	ea41 0202 	orr.w	r2, r1, r2
    1fbe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	comms_pkt->comms_adf_read_No_double_words = cmd_adf_read_No_double_words;
    1fc2:	f24c 1348 	movw	r3, #49480	; 0xc148
    1fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fca:	681a      	ldr	r2, [r3, #0]
    1fcc:	f24b 3368 	movw	r3, #45928	; 0xb368
    1fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fd4:	781b      	ldrb	r3, [r3, #0]
    1fd6:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
	comms_pkt->comms_adf_state = adf_get_state();
    1fda:	f24c 1348 	movw	r3, #49480	; 0xc148
    1fde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fe2:	681c      	ldr	r4, [r3, #0]
    1fe4:	f004 f8dc 	bl	61a0 <adf_get_state>
    1fe8:	4603      	mov	r3, r0
    1fea:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44

	for(;i<cmd_adf_read_No_double_words;i++){
    1fee:	e043      	b.n	2078 <get_comms+0x2e8>
		comms_pkt->comms_adf_data[i] =	cmd_adf_data[i];
    1ff0:	f24c 1348 	movw	r3, #49480	; 0xc148
    1ff4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1ff8:	681b      	ldr	r3, [r3, #0]
    1ffa:	88f8      	ldrh	r0, [r7, #6]
    1ffc:	88f9      	ldrh	r1, [r7, #6]
    1ffe:	f24c 1258 	movw	r2, #49496	; 0xc158
    2002:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2006:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    200a:	f100 0208 	add.w	r2, r0, #8
    200e:	f001 0cff 	and.w	ip, r1, #255	; 0xff
    2012:	ea4f 0082 	mov.w	r0, r2, lsl #2
    2016:	4418      	add	r0, r3
    2018:	f04f 0e00 	mov.w	lr, #0
    201c:	ea4e 0c0c 	orr.w	ip, lr, ip
    2020:	f880 c004 	strb.w	ip, [r0, #4]
    2024:	ea4f 2011 	mov.w	r0, r1, lsr #8
    2028:	f000 0cff 	and.w	ip, r0, #255	; 0xff
    202c:	ea4f 0082 	mov.w	r0, r2, lsl #2
    2030:	4418      	add	r0, r3
    2032:	f04f 0e00 	mov.w	lr, #0
    2036:	ea4e 0c0c 	orr.w	ip, lr, ip
    203a:	f880 c005 	strb.w	ip, [r0, #5]
    203e:	ea4f 4011 	mov.w	r0, r1, lsr #16
    2042:	f000 0cff 	and.w	ip, r0, #255	; 0xff
    2046:	ea4f 0082 	mov.w	r0, r2, lsl #2
    204a:	4418      	add	r0, r3
    204c:	f04f 0e00 	mov.w	lr, #0
    2050:	ea4e 0c0c 	orr.w	ip, lr, ip
    2054:	f880 c006 	strb.w	ip, [r0, #6]
    2058:	ea4f 6011 	mov.w	r0, r1, lsr #24
    205c:	ea4f 0282 	mov.w	r2, r2, lsl #2
    2060:	441a      	add	r2, r3
    2062:	f04f 0300 	mov.w	r3, #0
    2066:	4619      	mov	r1, r3
    2068:	4603      	mov	r3, r0
    206a:	ea41 0303 	orr.w	r3, r1, r3
    206e:	71d3      	strb	r3, [r2, #7]
	comms_pkt->comms_adf_freq = get_freq();
	comms_pkt->comms_adf_read_reg_addr = cmd_adf_read_addr;
	comms_pkt->comms_adf_read_No_double_words = cmd_adf_read_No_double_words;
	comms_pkt->comms_adf_state = adf_get_state();

	for(;i<cmd_adf_read_No_double_words;i++){
    2070:	88fb      	ldrh	r3, [r7, #6]
    2072:	f103 0301 	add.w	r3, r3, #1
    2076:	80fb      	strh	r3, [r7, #6]
    2078:	f24b 3368 	movw	r3, #45928	; 0xb368
    207c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2080:	781b      	ldrb	r3, [r3, #0]
    2082:	88fa      	ldrh	r2, [r7, #6]
    2084:	429a      	cmp	r2, r3
    2086:	d3b3      	bcc.n	1ff0 <get_comms+0x260>
		comms_pkt->comms_adf_data[i] =	cmd_adf_data[i];
	}
	i = 0;
    2088:	f04f 0300 	mov.w	r3, #0
    208c:	80fb      	strh	r3, [r7, #6]


//	comms_pkt->comms_adf_state = adf_get_state();

	comms_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, COMMS_API_ID))));
    208e:	f24c 1348 	movw	r3, #49480	; 0xc148
    2092:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2096:	681b      	ldr	r3, [r3, #0]
    2098:	f04f 0200 	mov.w	r2, #0
    209c:	f042 0208 	orr.w	r2, r2, #8
    20a0:	701a      	strb	r2, [r3, #0]
    20a2:	f04f 0200 	mov.w	r2, #0
    20a6:	f042 0203 	orr.w	r2, r2, #3
    20aa:	705a      	strb	r2, [r3, #1]
	comms_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((comms_seq_num++)))));
    20ac:	f24c 1348 	movw	r3, #49480	; 0xc148
    20b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20b4:	6818      	ldr	r0, [r3, #0]
    20b6:	f24b 335e 	movw	r3, #45918	; 0xb35e
    20ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20be:	8819      	ldrh	r1, [r3, #0]
    20c0:	460b      	mov	r3, r1
    20c2:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    20c6:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    20ca:	b29b      	uxth	r3, r3
    20cc:	b29b      	uxth	r3, r3
    20ce:	ea4f 2303 	mov.w	r3, r3, lsl #8
    20d2:	fa1f fc83 	uxth.w	ip, r3
    20d6:	f24b 335e 	movw	r3, #45918	; 0xb35e
    20da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    20de:	881a      	ldrh	r2, [r3, #0]
    20e0:	4613      	mov	r3, r2
    20e2:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    20e6:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    20ea:	b29b      	uxth	r3, r3
    20ec:	b29b      	uxth	r3, r3
    20ee:	ea4f 2313 	mov.w	r3, r3, lsr #8
    20f2:	b29b      	uxth	r3, r3
    20f4:	ea4c 0303 	orr.w	r3, ip, r3
    20f8:	b29b      	uxth	r3, r3
    20fa:	b29b      	uxth	r3, r3
    20fc:	f003 0cff 	and.w	ip, r3, #255	; 0xff
    2100:	f04f 0e00 	mov.w	lr, #0
    2104:	ea4e 0c0c 	orr.w	ip, lr, ip
    2108:	f880 c002 	strb.w	ip, [r0, #2]
    210c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    2110:	b29b      	uxth	r3, r3
    2112:	f04f 0c00 	mov.w	ip, #0
    2116:	ea4c 0303 	orr.w	r3, ip, r3
    211a:	70c3      	strb	r3, [r0, #3]
    211c:	f101 0301 	add.w	r3, r1, #1
    2120:	b299      	uxth	r1, r3
    2122:	f24b 335e 	movw	r3, #45918	; 0xb35e
    2126:	f2c2 0300 	movt	r3, #8192	; 0x2000
    212a:	8019      	strh	r1, [r3, #0]
    212c:	f102 0301 	add.w	r3, r2, #1
    2130:	b29a      	uxth	r2, r3
    2132:	f24b 335e 	movw	r3, #45918	; 0xb35e
    2136:	f2c2 0300 	movt	r3, #8192	; 0x2000
    213a:	801a      	strh	r2, [r3, #0]
	comms_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(COMMS_PKT_LENGTH))));
    213c:	f24c 1348 	movw	r3, #49480	; 0xc148
    2140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2144:	681b      	ldr	r3, [r3, #0]
    2146:	f04f 0200 	mov.w	r2, #0
    214a:	711a      	strb	r2, [r3, #4]
    214c:	f04f 0200 	mov.w	r2, #0
    2150:	f042 0268 	orr.w	r2, r2, #104	; 0x68
    2154:	715a      	strb	r2, [r3, #5]
	comms_pkt->ccsds_s1 = current_time_upper;
    2156:	f24c 1348 	movw	r3, #49480	; 0xc148
    215a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    215e:	681b      	ldr	r3, [r3, #0]
    2160:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    2164:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2168:	e9d2 0100 	ldrd	r0, r1, [r2]
    216c:	4602      	mov	r2, r0
    216e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2172:	f04f 0000 	mov.w	r0, #0
    2176:	ea40 0101 	orr.w	r1, r0, r1
    217a:	7199      	strb	r1, [r3, #6]
    217c:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2180:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2184:	f04f 0000 	mov.w	r0, #0
    2188:	ea40 0101 	orr.w	r1, r0, r1
    218c:	71d9      	strb	r1, [r3, #7]
    218e:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2192:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2196:	f04f 0000 	mov.w	r0, #0
    219a:	ea40 0101 	orr.w	r1, r0, r1
    219e:	7219      	strb	r1, [r3, #8]
    21a0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    21a4:	f04f 0100 	mov.w	r1, #0
    21a8:	ea41 0202 	orr.w	r2, r1, r2
    21ac:	725a      	strb	r2, [r3, #9]

	comms_pkt->ccsds_s2 = current_time_lower;
    21ae:	f24c 1348 	movw	r3, #49480	; 0xc148
    21b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    21b6:	681b      	ldr	r3, [r3, #0]
    21b8:	f24c 32c8 	movw	r2, #50120	; 0xc3c8
    21bc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    21c0:	e9d2 0100 	ldrd	r0, r1, [r2]
    21c4:	4602      	mov	r2, r0
    21c6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    21ca:	f04f 0000 	mov.w	r0, #0
    21ce:	ea40 0101 	orr.w	r1, r0, r1
    21d2:	7299      	strb	r1, [r3, #10]
    21d4:	ea4f 2112 	mov.w	r1, r2, lsr #8
    21d8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    21dc:	f04f 0000 	mov.w	r0, #0
    21e0:	ea40 0101 	orr.w	r1, r0, r1
    21e4:	72d9      	strb	r1, [r3, #11]
    21e6:	ea4f 4112 	mov.w	r1, r2, lsr #16
    21ea:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    21ee:	f04f 0000 	mov.w	r0, #0
    21f2:	ea40 0101 	orr.w	r1, r0, r1
    21f6:	7319      	strb	r1, [r3, #12]
    21f8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    21fc:	f04f 0100 	mov.w	r1, #0
    2200:	ea41 0202 	orr.w	r2, r1, r2
    2204:	735a      	strb	r2, [r3, #13]

	get_time_vector();
    2206:	f001 feab 	bl	3f60 <get_time_vector>
	for(;i<32;i++){
    220a:	e013      	b.n	2234 <get_comms+0x4a4>
		comms_pkt->comms_GTime_SVector[i] = Time_Vector[i];
    220c:	f24c 1348 	movw	r3, #49480	; 0xc148
    2210:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2214:	6819      	ldr	r1, [r3, #0]
    2216:	88f8      	ldrh	r0, [r7, #6]
    2218:	88fa      	ldrh	r2, [r7, #6]
    221a:	f24c 4320 	movw	r3, #50208	; 0xc420
    221e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2222:	5c9a      	ldrb	r2, [r3, r2]
    2224:	eb00 0301 	add.w	r3, r0, r1
    2228:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	comms_pkt->ccsds_s1 = current_time_upper;

	comms_pkt->ccsds_s2 = current_time_lower;

	get_time_vector();
	for(;i<32;i++){
    222c:	88fb      	ldrh	r3, [r7, #6]
    222e:	f103 0301 	add.w	r3, r3, #1
    2232:	80fb      	strh	r3, [r7, #6]
    2234:	88fb      	ldrh	r3, [r7, #6]
    2236:	2b1f      	cmp	r3, #31
    2238:	d9e8      	bls.n	220c <get_comms+0x47c>
		comms_pkt->comms_GTime_SVector[i] = Time_Vector[i];
	}

	if(store_in_sd_card){
    223a:	f24b 3359 	movw	r3, #45913	; 0xb359
    223e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2242:	781b      	ldrb	r3, [r3, #0]
    2244:	2b00      	cmp	r3, #0
    2246:	d03c      	beq.n	22c2 <get_comms+0x532>
		sd_dump_comms = 1;
    2248:	f24b 335b 	movw	r3, #45915	; 0xb35b
    224c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2250:	f04f 0201 	mov.w	r2, #1
    2254:	701a      	strb	r2, [r3, #0]
		comms_pkt->comms_sd_dump = sd_dump_comms;
    2256:	f24c 1348 	movw	r3, #49480	; 0xc148
    225a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    225e:	681a      	ldr	r2, [r3, #0]
    2260:	f24b 335b 	movw	r3, #45915	; 0xb35b
    2264:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2268:	781b      	ldrb	r3, [r3, #0]
    226a:	f882 3045 	strb.w	r3, [r2, #69]	; 0x45
		comms_pkt->Fletcher_Code = make_FLetcher(data, sizeof(comms_pkt_t) - 2);
    226e:	f24c 1348 	movw	r3, #49480	; 0xc148
    2272:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2276:	681c      	ldr	r4, [r3, #0]
    2278:	f24b 6038 	movw	r0, #46648	; 0xb638
    227c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2280:	f04f 0166 	mov.w	r1, #102	; 0x66
    2284:	f7fe fa30 	bl	6e8 <make_FLetcher>
    2288:	4603      	mov	r3, r0
    228a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    228e:	f04f 0100 	mov.w	r1, #0
    2292:	ea41 0202 	orr.w	r2, r1, r2
    2296:	f884 2066 	strb.w	r2, [r4, #102]	; 0x66
    229a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    229e:	b29b      	uxth	r3, r3
    22a0:	f04f 0200 	mov.w	r2, #0
    22a4:	ea42 0303 	orr.w	r3, r2, r3
    22a8:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
		store_data(&comms_partition, data);
    22ac:	f24c 30fc 	movw	r0, #50172	; 0xc3fc
    22b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    22b4:	f24b 6138 	movw	r1, #46648	; 0xb638
    22b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
    22bc:	f003 f98c 	bl	55d8 <store_data>
    22c0:	e03d      	b.n	233e <get_comms+0x5ae>
	}
	else{
		sd_dump_comms = 0;
    22c2:	f24b 335b 	movw	r3, #45915	; 0xb35b
    22c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22ca:	f04f 0200 	mov.w	r2, #0
    22ce:	701a      	strb	r2, [r3, #0]
		comms_pkt->comms_sd_dump = sd_dump_comms;
    22d0:	f24c 1348 	movw	r3, #49480	; 0xc148
    22d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22d8:	681a      	ldr	r2, [r3, #0]
    22da:	f24b 335b 	movw	r3, #45915	; 0xb35b
    22de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22e2:	781b      	ldrb	r3, [r3, #0]
    22e4:	f882 3045 	strb.w	r3, [r2, #69]	; 0x45
		comms_pkt->Fletcher_Code = make_FLetcher(data, sizeof(comms_pkt_t) - 2);
    22e8:	f24c 1348 	movw	r3, #49480	; 0xc148
    22ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22f0:	681c      	ldr	r4, [r3, #0]
    22f2:	f24b 6038 	movw	r0, #46648	; 0xb638
    22f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    22fa:	f04f 0166 	mov.w	r1, #102	; 0x66
    22fe:	f7fe f9f3 	bl	6e8 <make_FLetcher>
    2302:	4603      	mov	r3, r0
    2304:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    2308:	f04f 0100 	mov.w	r1, #0
    230c:	ea41 0202 	orr.w	r2, r1, r2
    2310:	f884 2066 	strb.w	r2, [r4, #102]	; 0x66
    2314:	ea4f 2313 	mov.w	r3, r3, lsr #8
    2318:	b29b      	uxth	r3, r3
    231a:	f04f 0200 	mov.w	r2, #0
    231e:	ea42 0303 	orr.w	r3, r2, r3
    2322:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
		vGetPktStruct(comms, (void*) comms_pkt, sizeof(comms_pkt_t));
    2326:	f24c 1348 	movw	r3, #49480	; 0xc148
    232a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    232e:	681b      	ldr	r3, [r3, #0]
    2330:	f04f 0001 	mov.w	r0, #1
    2334:	4619      	mov	r1, r3
    2336:	f04f 0268 	mov.w	r2, #104	; 0x68
    233a:	f7fe f959 	bl	5f0 <vGetPktStruct>
//		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(comms_pkt_t));
	}

//	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(comms_pkt_t));
//	vGetPktStruct(comms, (void*) data_test, sizeof(data_test));
}
    233e:	f107 070c 	add.w	r7, r7, #12
    2342:	46bd      	mov	sp, r7
    2344:	bd90      	pop	{r4, r7, pc}
    2346:	bf00      	nop

00002348 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    2348:	b480      	push	{r7}
    234a:	b083      	sub	sp, #12
    234c:	af00      	add	r7, sp, #0
    234e:	4603      	mov	r3, r0
    2350:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    2352:	f24e 1300 	movw	r3, #57600	; 0xe100
    2356:	f2ce 0300 	movt	r3, #57344	; 0xe000
    235a:	f997 2007 	ldrsb.w	r2, [r7, #7]
    235e:	ea4f 1252 	mov.w	r2, r2, lsr #5
    2362:	79f9      	ldrb	r1, [r7, #7]
    2364:	f001 011f 	and.w	r1, r1, #31
    2368:	f04f 0001 	mov.w	r0, #1
    236c:	fa00 f101 	lsl.w	r1, r0, r1
    2370:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2374:	f107 070c 	add.w	r7, r7, #12
    2378:	46bd      	mov	sp, r7
    237a:	bc80      	pop	{r7}
    237c:	4770      	bx	lr
    237e:	bf00      	nop

00002380 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    2380:	b480      	push	{r7}
    2382:	b083      	sub	sp, #12
    2384:	af00      	add	r7, sp, #0
    2386:	4603      	mov	r3, r0
    2388:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    238a:	f24e 1300 	movw	r3, #57600	; 0xe100
    238e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2392:	f997 2007 	ldrsb.w	r2, [r7, #7]
    2396:	ea4f 1252 	mov.w	r2, r2, lsr #5
    239a:	79f9      	ldrb	r1, [r7, #7]
    239c:	f001 011f 	and.w	r1, r1, #31
    23a0:	f04f 0001 	mov.w	r0, #1
    23a4:	fa00 f101 	lsl.w	r1, r0, r1
    23a8:	f102 0220 	add.w	r2, r2, #32
    23ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    23b0:	f107 070c 	add.w	r7, r7, #12
    23b4:	46bd      	mov	sp, r7
    23b6:	bc80      	pop	{r7}
    23b8:	4770      	bx	lr
    23ba:	bf00      	nop

000023bc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    23bc:	b480      	push	{r7}
    23be:	b083      	sub	sp, #12
    23c0:	af00      	add	r7, sp, #0
    23c2:	4603      	mov	r3, r0
    23c4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    23c6:	f24e 1300 	movw	r3, #57600	; 0xe100
    23ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
    23ce:	f997 2007 	ldrsb.w	r2, [r7, #7]
    23d2:	ea4f 1252 	mov.w	r2, r2, lsr #5
    23d6:	79f9      	ldrb	r1, [r7, #7]
    23d8:	f001 011f 	and.w	r1, r1, #31
    23dc:	f04f 0001 	mov.w	r0, #1
    23e0:	fa00 f101 	lsl.w	r1, r0, r1
    23e4:	f102 0260 	add.w	r2, r2, #96	; 0x60
    23e8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    23ec:	f107 070c 	add.w	r7, r7, #12
    23f0:	46bd      	mov	sp, r7
    23f2:	bc80      	pop	{r7}
    23f4:	4770      	bx	lr
    23f6:	bf00      	nop

000023f8 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number. 
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    23f8:	b480      	push	{r7}
    23fa:	b083      	sub	sp, #12
    23fc:	af00      	add	r7, sp, #0
    23fe:	4603      	mov	r3, r0
    2400:	6039      	str	r1, [r7, #0]
    2402:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
    2404:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2408:	2b00      	cmp	r3, #0
    240a:	da10      	bge.n	242e <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
    240c:	f64e 5300 	movw	r3, #60672	; 0xed00
    2410:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2414:	79fa      	ldrb	r2, [r7, #7]
    2416:	f002 020f 	and.w	r2, r2, #15
    241a:	f1a2 0104 	sub.w	r1, r2, #4
    241e:	683a      	ldr	r2, [r7, #0]
    2420:	b2d2      	uxtb	r2, r2
    2422:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2426:	b2d2      	uxtb	r2, r2
    2428:	440b      	add	r3, r1
    242a:	761a      	strb	r2, [r3, #24]
    242c:	e00d      	b.n	244a <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
    242e:	f24e 1300 	movw	r3, #57600	; 0xe100
    2432:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2436:	f997 1007 	ldrsb.w	r1, [r7, #7]
    243a:	683a      	ldr	r2, [r7, #0]
    243c:	b2d2      	uxtb	r2, r2
    243e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    2442:	b2d2      	uxtb	r2, r2
    2444:	440b      	add	r3, r1
    2446:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    244a:	f107 070c 	add.w	r7, r7, #12
    244e:	46bd      	mov	sp, r7
    2450:	bc80      	pop	{r7}
    2452:	4770      	bx	lr

00002454 <MSS_TIM64_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE 
 */
static __INLINE void MSS_TIM64_init(mss_timer_mode_t mode)
{
    2454:	b580      	push	{r7, lr}
    2456:	b082      	sub	sp, #8
    2458:	af00      	add	r7, sp, #0
    245a:	4603      	mov	r3, r0
    245c:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ(Timer1_IRQn);         /* disable timer 1 interrupt within NVIC */
    245e:	f04f 000e 	mov.w	r0, #14
    2462:	f7ff ff8d 	bl	2380 <NVIC_DisableIRQ>
    NVIC_DisableIRQ(Timer2_IRQn);         /* disable timer 2 interrupt within NVIC */
    2466:	f04f 000f 	mov.w	r0, #15
    246a:	f7ff ff89 	bl	2380 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
    246e:	f248 0300 	movw	r3, #32768	; 0x8000
    2472:	f2c4 0303 	movt	r3, #16387	; 0x4003
    2476:	f248 0200 	movw	r2, #32768	; 0x8000
    247a:	f2c4 0203 	movt	r2, #16387	; 0x4003
    247e:	6c92      	ldr	r2, [r2, #72]	; 0x48
    2480:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    2484:	649a      	str	r2, [r3, #72]	; 0x48
    
    TIMER->TIM64_MODE = 1u;                     /* switch to 64 bits mode */
    2486:	f244 0300 	movw	r3, #16384	; 0x4000
    248a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    248e:	f04f 0201 	mov.w	r2, #1
    2492:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM64ENABLE = 0u;            /* disable timer */
    2494:	f240 0300 	movw	r3, #0
    2498:	f2c4 2308 	movt	r3, #16904	; 0x4208
    249c:	f04f 0200 	mov.w	r2, #0
    24a0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    TIMER_BITBAND->TIM64INTEN = 0u;             /* disable interrupt */
    24a4:	f240 0300 	movw	r3, #0
    24a8:	f2c4 2308 	movt	r3, #16904	; 0x4208
    24ac:	f04f 0200 	mov.w	r2, #0
    24b0:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    TIMER_BITBAND->TIM64MODE = (uint32_t)mode;  /* set mode (continuous/one-shot) */
    24b4:	f240 0300 	movw	r3, #0
    24b8:	f2c4 2308 	movt	r3, #16904	; 0x4208
    24bc:	79fa      	ldrb	r2, [r7, #7]
    24be:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
    
    TIMER->TIM1_RIS = 1u;                   /* clear timer 1 interrupt */
    24c2:	f244 0300 	movw	r3, #16384	; 0x4000
    24c6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    24ca:	f04f 0201 	mov.w	r2, #1
    24ce:	611a      	str	r2, [r3, #16]
    TIMER->TIM2_RIS = 1u;                   /* clear timer 2 interrupt */
    24d0:	f244 0300 	movw	r3, #16384	; 0x4000
    24d4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    24d8:	f04f 0201 	mov.w	r2, #1
    24dc:	629a      	str	r2, [r3, #40]	; 0x28
    NVIC_ClearPendingIRQ(Timer1_IRQn);    /* clear timer 1 interrupt within NVIC */
    24de:	f04f 000e 	mov.w	r0, #14
    24e2:	f7ff ff6b 	bl	23bc <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ(Timer2_IRQn);    /* clear timer 2 interrupt within NVIC */
    24e6:	f04f 000f 	mov.w	r0, #15
    24ea:	f7ff ff67 	bl	23bc <NVIC_ClearPendingIRQ>
}
    24ee:	f107 0708 	add.w	r7, r7, #8
    24f2:	46bd      	mov	sp, r7
    24f4:	bd80      	pop	{r7, pc}
    24f6:	bf00      	nop

000024f8 <MSS_TIM64_start>:
  the MSS_TIM64_load_immediate() or MSS_TIM64_load_background() functions.
  Note: The MSS_TIM64_start() function is also used to resume the down-counter
        if previously stopped using the MSS_TIM64_stop() function.
 */
static __INLINE void MSS_TIM64_start(void)
{
    24f8:	b480      	push	{r7}
    24fa:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM64ENABLE = 1u;    /* enable timer */
    24fc:	f240 0300 	movw	r3, #0
    2500:	f2c4 2308 	movt	r3, #16904	; 0x4208
    2504:	f04f 0201 	mov.w	r2, #1
    2508:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
    250c:	46bd      	mov	sp, r7
    250e:	bc80      	pop	{r7}
    2510:	4770      	bx	lr
    2512:	bf00      	nop

00002514 <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
    2514:	b480      	push	{r7}
    2516:	b083      	sub	sp, #12
    2518:	af00      	add	r7, sp, #0
    251a:	6078      	str	r0, [r7, #4]
    251c:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
    251e:	f244 0300 	movw	r3, #16384	; 0x4000
    2522:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2526:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    2528:	683b      	ldr	r3, [r7, #0]
    252a:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
    252c:	f244 0300 	movw	r3, #16384	; 0x4000
    2530:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2534:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    2536:	687b      	ldr	r3, [r7, #4]
    2538:	601a      	str	r2, [r3, #0]
}
    253a:	f107 070c 	add.w	r7, r7, #12
    253e:	46bd      	mov	sp, r7
    2540:	bc80      	pop	{r7}
    2542:	4770      	bx	lr

00002544 <MSS_TIM64_load_immediate>:
static __INLINE void MSS_TIM64_load_immediate
(
    uint32_t load_value_u,
    uint32_t load_value_l
)
{
    2544:	b480      	push	{r7}
    2546:	b083      	sub	sp, #12
    2548:	af00      	add	r7, sp, #0
    254a:	6078      	str	r0, [r7, #4]
    254c:	6039      	str	r1, [r7, #0]
    TIMER->TIM64_LOADVAL_U = load_value_u;
    254e:	f244 0300 	movw	r3, #16384	; 0x4000
    2552:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2556:	687a      	ldr	r2, [r7, #4]
    2558:	639a      	str	r2, [r3, #56]	; 0x38
    TIMER->TIM64_LOADVAL_L = load_value_l;
    255a:	f244 0300 	movw	r3, #16384	; 0x4000
    255e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2562:	683a      	ldr	r2, [r7, #0]
    2564:	63da      	str	r2, [r3, #60]	; 0x3c
}
    2566:	f107 070c 	add.w	r7, r7, #12
    256a:	46bd      	mov	sp, r7
    256c:	bc80      	pop	{r7}
    256e:	4770      	bx	lr

00002570 <MSS_WD_init>:
        
  @return
    This function does not return a value.
 */
static __INLINE void MSS_WD_init(void)
{
    2570:	b580      	push	{r7, lr}
    2572:	b082      	sub	sp, #8
    2574:	af00      	add	r7, sp, #0
    uint32_t wdg_value;
    
    /* Disable interrupts. */
    WATCHDOG->WDOGCONTROL &= ~(MSS_WDOG_TIMEOUT_IRQ_ENABLE_BIT_MASK | MSS_WDOG_WAKEUP_IRQ_CLEAR_BIT_MASK);
    2576:	f245 0300 	movw	r3, #20480	; 0x5000
    257a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    257e:	f245 0200 	movw	r2, #20480	; 0x5000
    2582:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2586:	6952      	ldr	r2, [r2, #20]
    2588:	f022 0203 	bic.w	r2, r2, #3
    258c:	615a      	str	r2, [r3, #20]
    
    /* Clear any existing interrupts. */
    WATCHDOG->WDOGRIS = MSS_WDOG_TIMEOUT_IRQ_CLEAR_BIT_MASK | MSS_WDOG_WAKEUP_IRQ_CLEAR_BIT_MASK;
    258e:	f245 0300 	movw	r3, #20480	; 0x5000
    2592:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2596:	f04f 0203 	mov.w	r2, #3
    259a:	61da      	str	r2, [r3, #28]
    
    /* Clear any pending wakeup interrupt from Cortex-M3 NVIC */
    NVIC_ClearPendingIRQ(WdogWakeup_IRQn);
    259c:	f04f 0000 	mov.w	r0, #0
    25a0:	f7ff ff0c 	bl	23bc <NVIC_ClearPendingIRQ>
    
    /* Reload watchdog with new load value if in allowed window. */
    wdg_value = WATCHDOG->WDOGVALUE;
    25a4:	f245 0300 	movw	r3, #20480	; 0x5000
    25a8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    25ac:	681b      	ldr	r3, [r3, #0]
    25ae:	607b      	str	r3, [r7, #4]
    if(wdg_value < WATCHDOG->WDOGMVRP)
    25b0:	f245 0300 	movw	r3, #20480	; 0x5000
    25b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    25b8:	689a      	ldr	r2, [r3, #8]
    25ba:	687b      	ldr	r3, [r7, #4]
    25bc:	429a      	cmp	r2, r3
    25be:	d908      	bls.n	25d2 <MSS_WD_init+0x62>
    {
        WATCHDOG->WDOGREFRESH = MSS_WDOG_REFRESH_KEY;
    25c0:	f245 0300 	movw	r3, #20480	; 0x5000
    25c4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    25c8:	f64d 6242 	movw	r2, #56898	; 0xde42
    25cc:	f6ca 4215 	movt	r2, #44053	; 0xac15
    25d0:	60da      	str	r2, [r3, #12]
    }
}
    25d2:	f107 0708 	add.w	r7, r7, #8
    25d6:	46bd      	mov	sp, r7
    25d8:	bd80      	pop	{r7, pc}
    25da:	bf00      	nop

000025dc <MSS_WD_reload>:
 
  @return
    This function does not return a value.
 */
static __INLINE void MSS_WD_reload(void)
{
    25dc:	b480      	push	{r7}
    25de:	af00      	add	r7, sp, #0
    WATCHDOG->WDOGREFRESH = MSS_WDOG_REFRESH_KEY;
    25e0:	f245 0300 	movw	r3, #20480	; 0x5000
    25e4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    25e8:	f64d 6242 	movw	r2, #56898	; 0xde42
    25ec:	f6ca 4215 	movt	r2, #44053	; 0xac15
    25f0:	60da      	str	r2, [r3, #12]
}
    25f2:	46bd      	mov	sp, r7
    25f4:	bc80      	pop	{r7}
    25f6:	4770      	bx	lr

000025f8 <form_log_packet>:

//Declare variable for status for each packet
uint16_t hk_status,gmc_status,comms_status,therm_status;

//Function to form Log packet
void form_log_packet() {
    25f8:	b598      	push	{r3, r4, r7, lr}
    25fa:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    25fc:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    2600:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2604:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2608:	f2c2 0300 	movt	r3, #8192	; 0x2000
    260c:	4610      	mov	r0, r2
    260e:	4619      	mov	r1, r3
    2610:	f7ff ff80 	bl	2514 <MSS_TIM64_get_current_value>
	log_packet_ptr->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(ccsds_p1(tlm_pkt_type,LOGS_API_ID));
    2614:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2618:	f2c2 0300 	movt	r3, #8192	; 0x2000
    261c:	681b      	ldr	r3, [r3, #0]
    261e:	f04f 0200 	mov.w	r2, #0
    2622:	f042 0208 	orr.w	r2, r2, #8
    2626:	701a      	strb	r2, [r3, #0]
    2628:	f04f 0200 	mov.w	r2, #0
    262c:	f042 0206 	orr.w	r2, r2, #6
    2630:	705a      	strb	r2, [r3, #1]
	log_packet_ptr->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(ccsds_p2((logs_seq_no)));
    2632:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2636:	f2c2 0300 	movt	r3, #8192	; 0x2000
    263a:	681a      	ldr	r2, [r3, #0]
    263c:	f24c 33bc 	movw	r3, #50108	; 0xc3bc
    2640:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2644:	881b      	ldrh	r3, [r3, #0]
    2646:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    264a:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    264e:	b29b      	uxth	r3, r3
    2650:	b29b      	uxth	r3, r3
    2652:	ea4f 2303 	mov.w	r3, r3, lsl #8
    2656:	b299      	uxth	r1, r3
    2658:	f24c 33bc 	movw	r3, #50108	; 0xc3bc
    265c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2660:	881b      	ldrh	r3, [r3, #0]
    2662:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    2666:	ea6f 4393 	mvn.w	r3, r3, lsr #18
    266a:	b29b      	uxth	r3, r3
    266c:	b29b      	uxth	r3, r3
    266e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    2672:	b29b      	uxth	r3, r3
    2674:	ea41 0303 	orr.w	r3, r1, r3
    2678:	b29b      	uxth	r3, r3
    267a:	b29b      	uxth	r3, r3
    267c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    2680:	f04f 0000 	mov.w	r0, #0
    2684:	ea40 0101 	orr.w	r1, r0, r1
    2688:	7091      	strb	r1, [r2, #2]
    268a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    268e:	b29b      	uxth	r3, r3
    2690:	f04f 0100 	mov.w	r1, #0
    2694:	ea41 0303 	orr.w	r3, r1, r3
    2698:	70d3      	strb	r3, [r2, #3]
	log_packet_ptr->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(ccsds_p3(LOGS_PKT_LENGTH));
    269a:	f24c 139c 	movw	r3, #49564	; 0xc19c
    269e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26a2:	681b      	ldr	r3, [r3, #0]
    26a4:	f04f 0200 	mov.w	r2, #0
    26a8:	711a      	strb	r2, [r3, #4]
    26aa:	f04f 0200 	mov.w	r2, #0
    26ae:	f042 027e 	orr.w	r2, r2, #126	; 0x7e
    26b2:	715a      	strb	r2, [r3, #5]
	log_packet_ptr->ccsds_s2 = current_time_lower;
    26b4:	f24c 139c 	movw	r3, #49564	; 0xc19c
    26b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    26bc:	681b      	ldr	r3, [r3, #0]
    26be:	f24c 32c8 	movw	r2, #50120	; 0xc3c8
    26c2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    26c6:	e9d2 0100 	ldrd	r0, r1, [r2]
    26ca:	4602      	mov	r2, r0
    26cc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    26d0:	f04f 0000 	mov.w	r0, #0
    26d4:	ea40 0101 	orr.w	r1, r0, r1
    26d8:	7299      	strb	r1, [r3, #10]
    26da:	ea4f 2112 	mov.w	r1, r2, lsr #8
    26de:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    26e2:	f04f 0000 	mov.w	r0, #0
    26e6:	ea40 0101 	orr.w	r1, r0, r1
    26ea:	72d9      	strb	r1, [r3, #11]
    26ec:	ea4f 4112 	mov.w	r1, r2, lsr #16
    26f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    26f4:	f04f 0000 	mov.w	r0, #0
    26f8:	ea40 0101 	orr.w	r1, r0, r1
    26fc:	7319      	strb	r1, [r3, #12]
    26fe:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2702:	f04f 0100 	mov.w	r1, #0
    2706:	ea41 0202 	orr.w	r2, r1, r2
    270a:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->ccsds_s1 = current_time_upper;
    270c:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2714:	681b      	ldr	r3, [r3, #0]
    2716:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    271a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    271e:	e9d2 0100 	ldrd	r0, r1, [r2]
    2722:	4602      	mov	r2, r0
    2724:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2728:	f04f 0000 	mov.w	r0, #0
    272c:	ea40 0101 	orr.w	r1, r0, r1
    2730:	7199      	strb	r1, [r3, #6]
    2732:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2736:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    273a:	f04f 0000 	mov.w	r0, #0
    273e:	ea40 0101 	orr.w	r1, r0, r1
    2742:	71d9      	strb	r1, [r3, #7]
    2744:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2748:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    274c:	f04f 0000 	mov.w	r0, #0
    2750:	ea40 0101 	orr.w	r1, r0, r1
    2754:	7219      	strb	r1, [r3, #8]
    2756:	ea4f 6212 	mov.w	r2, r2, lsr #24
    275a:	f04f 0100 	mov.w	r1, #0
    275e:	ea41 0202 	orr.w	r2, r1, r2
    2762:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->Fletcher_Code = make_FLetcher(log_data,LOGS_PKT_LENGTH-2);
    2764:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2768:	f2c2 0300 	movt	r3, #8192	; 0x2000
    276c:	681c      	ldr	r4, [r3, #0]
    276e:	f24c 10b8 	movw	r0, #49592	; 0xc1b8
    2772:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2776:	f04f 017c 	mov.w	r1, #124	; 0x7c
    277a:	f7fd ffb5 	bl	6e8 <make_FLetcher>
    277e:	4603      	mov	r3, r0
    2780:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    2784:	f04f 0100 	mov.w	r1, #0
    2788:	ea41 0202 	orr.w	r2, r1, r2
    278c:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    2790:	ea4f 2313 	mov.w	r3, r3, lsr #8
    2794:	b29b      	uxth	r3, r3
    2796:	f04f 0200 	mov.w	r2, #0
    279a:	ea42 0303 	orr.w	r3, r2, r3
    279e:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
	//Need to replace the below l
	// add_to_queue(LOGS_PKT_LENGTH,&log_p,log_data,&logs_miss,LOGS_TASK_ID);
	if(store_in_sd_card){
    27a2:	f24b 3359 	movw	r3, #45913	; 0xb359
    27a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27aa:	781b      	ldrb	r3, [r3, #0]
    27ac:	2b00      	cmp	r3, #0
    27ae:	d00a      	beq.n	27c6 <form_log_packet+0x1ce>
		store_data(&log_partiton, log_data);
    27b0:	f24c 1084 	movw	r0, #49540	; 0xc184
    27b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    27b8:	f24c 11b8 	movw	r1, #49592	; 0xc1b8
    27bc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    27c0:	f002 ff0a 	bl	55d8 <store_data>
    27c4:	e00b      	b.n	27de <form_log_packet+0x1e6>
	}
	else{
		vGetPktStruct(logs, (void*) log_packet_ptr, sizeof(log_packet_t));
    27c6:	f24c 139c 	movw	r3, #49564	; 0xc19c
    27ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27ce:	681b      	ldr	r3, [r3, #0]
    27d0:	f04f 0004 	mov.w	r0, #4
    27d4:	4619      	mov	r1, r3
    27d6:	f04f 027e 	mov.w	r2, #126	; 0x7e
    27da:	f7fd ff09 	bl	5f0 <vGetPktStruct>
//		MSS_UART_polled_tx(&g_mss_uart0, log_data, sizeof(log_packet_t));
	}
	log_counter = 0;
    27de:	f24c 1380 	movw	r3, #49536	; 0xc180
    27e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27e6:	f04f 0200 	mov.w	r2, #0
    27ea:	701a      	strb	r2, [r3, #0]
	logs_seq_no++;
    27ec:	f24c 33bc 	movw	r3, #50108	; 0xc3bc
    27f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27f4:	881b      	ldrh	r3, [r3, #0]
    27f6:	f103 0301 	add.w	r3, r3, #1
    27fa:	b29a      	uxth	r2, r3
    27fc:	f24c 33bc 	movw	r3, #50108	; 0xc3bc
    2800:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2804:	801a      	strh	r2, [r3, #0]
}
    2806:	bd98      	pop	{r3, r4, r7, pc}

00002808 <HK_ISR>:
void HK_ISR(){
    2808:	b580      	push	{r7, lr}
    280a:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    280c:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    2810:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2814:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2818:	f2c2 0300 	movt	r3, #8192	; 0x2000
    281c:	4610      	mov	r0, r2
    281e:	4619      	mov	r1, r3
    2820:	f7ff fe78 	bl	2514 <MSS_TIM64_get_current_value>

	hk_status = get_hk();
    2824:	f7fd fffc 	bl	820 <get_hk>
    2828:	4603      	mov	r3, r0
    282a:	461a      	mov	r2, r3
    282c:	f24c 33d4 	movw	r3, #50132	; 0xc3d4
    2830:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2834:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
    2836:	f24c 1380 	movw	r3, #49536	; 0xc180
    283a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    283e:	781b      	ldrb	r3, [r3, #0]
    2840:	2b09      	cmp	r3, #9
    2842:	d901      	bls.n	2848 <HK_ISR+0x40>
		form_log_packet();
    2844:	f7ff fed8 	bl	25f8 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = HK_TASK_ID;
    2848:	f24c 139c 	movw	r3, #49564	; 0xc19c
    284c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2850:	6819      	ldr	r1, [r3, #0]
    2852:	f24c 1380 	movw	r3, #49536	; 0xc180
    2856:	f2c2 0300 	movt	r3, #8192	; 0x2000
    285a:	781b      	ldrb	r3, [r3, #0]
    285c:	461a      	mov	r2, r3
    285e:	4613      	mov	r3, r2
    2860:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2864:	4413      	add	r3, r2
    2866:	ea4f 0343 	mov.w	r3, r3, lsl #1
    286a:	4413      	add	r3, r2
    286c:	440b      	add	r3, r1
    286e:	f103 0316 	add.w	r3, r3, #22
    2872:	f04f 0202 	mov.w	r2, #2
    2876:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
    2878:	f24c 139c 	movw	r3, #49564	; 0xc19c
    287c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2880:	6818      	ldr	r0, [r3, #0]
    2882:	f24c 1380 	movw	r3, #49536	; 0xc180
    2886:	f2c2 0300 	movt	r3, #8192	; 0x2000
    288a:	781b      	ldrb	r3, [r3, #0]
    288c:	4619      	mov	r1, r3
    288e:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
    2892:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2896:	e9d3 2300 	ldrd	r2, r3, [r3]
    289a:	460b      	mov	r3, r1
    289c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    28a0:	440b      	add	r3, r1
    28a2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    28a6:	440b      	add	r3, r1
    28a8:	4403      	add	r3, r0
    28aa:	f103 0308 	add.w	r3, r3, #8
    28ae:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    28b2:	f04f 0000 	mov.w	r0, #0
    28b6:	ea40 0101 	orr.w	r1, r0, r1
    28ba:	7299      	strb	r1, [r3, #10]
    28bc:	ea4f 2112 	mov.w	r1, r2, lsr #8
    28c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    28c4:	f04f 0000 	mov.w	r0, #0
    28c8:	ea40 0101 	orr.w	r1, r0, r1
    28cc:	72d9      	strb	r1, [r3, #11]
    28ce:	ea4f 4112 	mov.w	r1, r2, lsr #16
    28d2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    28d6:	f04f 0000 	mov.w	r0, #0
    28da:	ea40 0101 	orr.w	r1, r0, r1
    28de:	7319      	strb	r1, [r3, #12]
    28e0:	ea4f 6212 	mov.w	r2, r2, lsr #24
    28e4:	f04f 0100 	mov.w	r1, #0
    28e8:	ea41 0202 	orr.w	r2, r1, r2
    28ec:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
    28ee:	f24c 139c 	movw	r3, #49564	; 0xc19c
    28f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    28f6:	6818      	ldr	r0, [r3, #0]
    28f8:	f24c 1380 	movw	r3, #49536	; 0xc180
    28fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2900:	781b      	ldrb	r3, [r3, #0]
    2902:	4619      	mov	r1, r3
    2904:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2908:	f2c2 0300 	movt	r3, #8192	; 0x2000
    290c:	e9d3 2300 	ldrd	r2, r3, [r3]
    2910:	460b      	mov	r3, r1
    2912:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2916:	440b      	add	r3, r1
    2918:	ea4f 0343 	mov.w	r3, r3, lsl #1
    291c:	440b      	add	r3, r1
    291e:	4403      	add	r3, r0
    2920:	f103 0308 	add.w	r3, r3, #8
    2924:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2928:	f04f 0000 	mov.w	r0, #0
    292c:	ea40 0101 	orr.w	r1, r0, r1
    2930:	7199      	strb	r1, [r3, #6]
    2932:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2936:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    293a:	f04f 0000 	mov.w	r0, #0
    293e:	ea40 0101 	orr.w	r1, r0, r1
    2942:	71d9      	strb	r1, [r3, #7]
    2944:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2948:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    294c:	f04f 0000 	mov.w	r0, #0
    2950:	ea40 0101 	orr.w	r1, r0, r1
    2954:	7219      	strb	r1, [r3, #8]
    2956:	ea4f 6212 	mov.w	r2, r2, lsr #24
    295a:	f04f 0100 	mov.w	r1, #0
    295e:	ea41 0202 	orr.w	r2, r1, r2
    2962:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = hk_status;
    2964:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2968:	f2c2 0300 	movt	r3, #8192	; 0x2000
    296c:	6818      	ldr	r0, [r3, #0]
    296e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2972:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2976:	781b      	ldrb	r3, [r3, #0]
    2978:	461a      	mov	r2, r3
    297a:	f24c 33d4 	movw	r3, #50132	; 0xc3d4
    297e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2982:	8819      	ldrh	r1, [r3, #0]
    2984:	4613      	mov	r3, r2
    2986:	ea4f 0383 	mov.w	r3, r3, lsl #2
    298a:	4413      	add	r3, r2
    298c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2990:	4413      	add	r3, r2
    2992:	4403      	add	r3, r0
    2994:	f103 0310 	add.w	r3, r3, #16
    2998:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    299c:	f04f 0000 	mov.w	r0, #0
    29a0:	ea40 0202 	orr.w	r2, r0, r2
    29a4:	71da      	strb	r2, [r3, #7]
    29a6:	ea4f 2211 	mov.w	r2, r1, lsr #8
    29aa:	b292      	uxth	r2, r2
    29ac:	f04f 0100 	mov.w	r1, #0
    29b0:	ea41 0202 	orr.w	r2, r1, r2
    29b4:	721a      	strb	r2, [r3, #8]
	log_counter++;
    29b6:	f24c 1380 	movw	r3, #49536	; 0xc180
    29ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29be:	781b      	ldrb	r3, [r3, #0]
    29c0:	f103 0301 	add.w	r3, r3, #1
    29c4:	b2da      	uxtb	r2, r3
    29c6:	f24c 1380 	movw	r3, #49536	; 0xc180
    29ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29ce:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&hk_timer);
    29d0:	f24c 401c 	movw	r0, #50204	; 0xc41c
    29d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    29d8:	f006 fcc4 	bl	9364 <TMR_clear_int>
}
    29dc:	bd80      	pop	{r7, pc}
    29de:	bf00      	nop

000029e0 <GMC_ISR>:

void GMC_ISR(){
    29e0:	b580      	push	{r7, lr}
    29e2:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    29e4:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    29e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    29ec:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    29f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    29f4:	4610      	mov	r0, r2
    29f6:	4619      	mov	r1, r3
    29f8:	f7ff fd8c 	bl	2514 <MSS_TIM64_get_current_value>
	gmc_status = get_gmc();
    29fc:	f7fe fee2 	bl	17c4 <get_gmc>
    2a00:	4603      	mov	r3, r0
    2a02:	461a      	mov	r2, r3
    2a04:	f24c 13b2 	movw	r3, #49586	; 0xc1b2
    2a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a0c:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
    2a0e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a16:	781b      	ldrb	r3, [r3, #0]
    2a18:	2b09      	cmp	r3, #9
    2a1a:	d901      	bls.n	2a20 <GMC_ISR+0x40>
		form_log_packet();
    2a1c:	f7ff fdec 	bl	25f8 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = GMC_TASK_ID;
    2a20:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a28:	6819      	ldr	r1, [r3, #0]
    2a2a:	f24c 1380 	movw	r3, #49536	; 0xc180
    2a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a32:	781b      	ldrb	r3, [r3, #0]
    2a34:	461a      	mov	r2, r3
    2a36:	4613      	mov	r3, r2
    2a38:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2a3c:	4413      	add	r3, r2
    2a3e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2a42:	4413      	add	r3, r2
    2a44:	440b      	add	r3, r1
    2a46:	f103 0316 	add.w	r3, r3, #22
    2a4a:	f04f 0206 	mov.w	r2, #6
    2a4e:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
    2a50:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a58:	6818      	ldr	r0, [r3, #0]
    2a5a:	f24c 1380 	movw	r3, #49536	; 0xc180
    2a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a62:	781b      	ldrb	r3, [r3, #0]
    2a64:	4619      	mov	r1, r3
    2a66:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
    2a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a6e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2a72:	460b      	mov	r3, r1
    2a74:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2a78:	440b      	add	r3, r1
    2a7a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2a7e:	440b      	add	r3, r1
    2a80:	4403      	add	r3, r0
    2a82:	f103 0308 	add.w	r3, r3, #8
    2a86:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2a8a:	f04f 0000 	mov.w	r0, #0
    2a8e:	ea40 0101 	orr.w	r1, r0, r1
    2a92:	7299      	strb	r1, [r3, #10]
    2a94:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2a98:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2a9c:	f04f 0000 	mov.w	r0, #0
    2aa0:	ea40 0101 	orr.w	r1, r0, r1
    2aa4:	72d9      	strb	r1, [r3, #11]
    2aa6:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2aaa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2aae:	f04f 0000 	mov.w	r0, #0
    2ab2:	ea40 0101 	orr.w	r1, r0, r1
    2ab6:	7319      	strb	r1, [r3, #12]
    2ab8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2abc:	f04f 0100 	mov.w	r1, #0
    2ac0:	ea41 0202 	orr.w	r2, r1, r2
    2ac4:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
    2ac6:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ace:	6818      	ldr	r0, [r3, #0]
    2ad0:	f24c 1380 	movw	r3, #49536	; 0xc180
    2ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ad8:	781b      	ldrb	r3, [r3, #0]
    2ada:	4619      	mov	r1, r3
    2adc:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2ae0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ae4:	e9d3 2300 	ldrd	r2, r3, [r3]
    2ae8:	460b      	mov	r3, r1
    2aea:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2aee:	440b      	add	r3, r1
    2af0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2af4:	440b      	add	r3, r1
    2af6:	4403      	add	r3, r0
    2af8:	f103 0308 	add.w	r3, r3, #8
    2afc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2b00:	f04f 0000 	mov.w	r0, #0
    2b04:	ea40 0101 	orr.w	r1, r0, r1
    2b08:	7199      	strb	r1, [r3, #6]
    2b0a:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2b0e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2b12:	f04f 0000 	mov.w	r0, #0
    2b16:	ea40 0101 	orr.w	r1, r0, r1
    2b1a:	71d9      	strb	r1, [r3, #7]
    2b1c:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2b20:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2b24:	f04f 0000 	mov.w	r0, #0
    2b28:	ea40 0101 	orr.w	r1, r0, r1
    2b2c:	7219      	strb	r1, [r3, #8]
    2b2e:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2b32:	f04f 0100 	mov.w	r1, #0
    2b36:	ea41 0202 	orr.w	r2, r1, r2
    2b3a:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = gmc_status;
    2b3c:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2b40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b44:	6818      	ldr	r0, [r3, #0]
    2b46:	f24c 1380 	movw	r3, #49536	; 0xc180
    2b4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b4e:	781b      	ldrb	r3, [r3, #0]
    2b50:	461a      	mov	r2, r3
    2b52:	f24c 13b2 	movw	r3, #49586	; 0xc1b2
    2b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b5a:	8819      	ldrh	r1, [r3, #0]
    2b5c:	4613      	mov	r3, r2
    2b5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2b62:	4413      	add	r3, r2
    2b64:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2b68:	4413      	add	r3, r2
    2b6a:	4403      	add	r3, r0
    2b6c:	f103 0310 	add.w	r3, r3, #16
    2b70:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    2b74:	f04f 0000 	mov.w	r0, #0
    2b78:	ea40 0202 	orr.w	r2, r0, r2
    2b7c:	71da      	strb	r2, [r3, #7]
    2b7e:	ea4f 2211 	mov.w	r2, r1, lsr #8
    2b82:	b292      	uxth	r2, r2
    2b84:	f04f 0100 	mov.w	r1, #0
    2b88:	ea41 0202 	orr.w	r2, r1, r2
    2b8c:	721a      	strb	r2, [r3, #8]
	log_counter++;
    2b8e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b96:	781b      	ldrb	r3, [r3, #0]
    2b98:	f103 0301 	add.w	r3, r3, #1
    2b9c:	b2da      	uxtb	r2, r3
    2b9e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ba6:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&gmc_timer);
    2ba8:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    2bac:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2bb0:	f006 fbd8 	bl	9364 <TMR_clear_int>
}
    2bb4:	bd80      	pop	{r7, pc}
    2bb6:	bf00      	nop

00002bb8 <COMMS_ISR>:

void COMMS_ISR(){
    2bb8:	b580      	push	{r7, lr}
    2bba:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    2bbc:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    2bc0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2bc4:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2bc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bcc:	4610      	mov	r0, r2
    2bce:	4619      	mov	r1, r3
    2bd0:	f7ff fca0 	bl	2514 <MSS_TIM64_get_current_value>
	comms_status = get_comms();
    2bd4:	f7ff f8dc 	bl	1d90 <get_comms>
    2bd8:	4603      	mov	r3, r0
    2bda:	461a      	mov	r2, r3
    2bdc:	f24c 4340 	movw	r3, #50240	; 0xc440
    2be0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2be4:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
    2be6:	f24c 1380 	movw	r3, #49536	; 0xc180
    2bea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bee:	781b      	ldrb	r3, [r3, #0]
    2bf0:	2b09      	cmp	r3, #9
    2bf2:	d901      	bls.n	2bf8 <COMMS_ISR+0x40>
		form_log_packet();
    2bf4:	f7ff fd00 	bl	25f8 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = COMMS_TASK_ID;
    2bf8:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2bfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c00:	6819      	ldr	r1, [r3, #0]
    2c02:	f24c 1380 	movw	r3, #49536	; 0xc180
    2c06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c0a:	781b      	ldrb	r3, [r3, #0]
    2c0c:	461a      	mov	r2, r3
    2c0e:	4613      	mov	r3, r2
    2c10:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2c14:	4413      	add	r3, r2
    2c16:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2c1a:	4413      	add	r3, r2
    2c1c:	440b      	add	r3, r1
    2c1e:	f103 0316 	add.w	r3, r3, #22
    2c22:	f04f 0204 	mov.w	r2, #4
    2c26:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
    2c28:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c30:	6818      	ldr	r0, [r3, #0]
    2c32:	f24c 1380 	movw	r3, #49536	; 0xc180
    2c36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c3a:	781b      	ldrb	r3, [r3, #0]
    2c3c:	4619      	mov	r1, r3
    2c3e:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
    2c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2c46:	e9d3 2300 	ldrd	r2, r3, [r3]
    2c4a:	460b      	mov	r3, r1
    2c4c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2c50:	440b      	add	r3, r1
    2c52:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2c56:	440b      	add	r3, r1
    2c58:	4403      	add	r3, r0
    2c5a:	f103 0308 	add.w	r3, r3, #8
    2c5e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2c62:	f04f 0000 	mov.w	r0, #0
    2c66:	ea40 0101 	orr.w	r1, r0, r1
    2c6a:	7299      	strb	r1, [r3, #10]
    2c6c:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2c70:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2c74:	f04f 0000 	mov.w	r0, #0
    2c78:	ea40 0101 	orr.w	r1, r0, r1
    2c7c:	72d9      	strb	r1, [r3, #11]
    2c7e:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2c82:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2c86:	f04f 0000 	mov.w	r0, #0
    2c8a:	ea40 0101 	orr.w	r1, r0, r1
    2c8e:	7319      	strb	r1, [r3, #12]
    2c90:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2c94:	f04f 0100 	mov.w	r1, #0
    2c98:	ea41 0202 	orr.w	r2, r1, r2
    2c9c:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
    2c9e:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ca6:	6818      	ldr	r0, [r3, #0]
    2ca8:	f24c 1380 	movw	r3, #49536	; 0xc180
    2cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2cb0:	781b      	ldrb	r3, [r3, #0]
    2cb2:	4619      	mov	r1, r3
    2cb4:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2cb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2cbc:	e9d3 2300 	ldrd	r2, r3, [r3]
    2cc0:	460b      	mov	r3, r1
    2cc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2cc6:	440b      	add	r3, r1
    2cc8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2ccc:	440b      	add	r3, r1
    2cce:	4403      	add	r3, r0
    2cd0:	f103 0308 	add.w	r3, r3, #8
    2cd4:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2cd8:	f04f 0000 	mov.w	r0, #0
    2cdc:	ea40 0101 	orr.w	r1, r0, r1
    2ce0:	7199      	strb	r1, [r3, #6]
    2ce2:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2ce6:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2cea:	f04f 0000 	mov.w	r0, #0
    2cee:	ea40 0101 	orr.w	r1, r0, r1
    2cf2:	71d9      	strb	r1, [r3, #7]
    2cf4:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2cf8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2cfc:	f04f 0000 	mov.w	r0, #0
    2d00:	ea40 0101 	orr.w	r1, r0, r1
    2d04:	7219      	strb	r1, [r3, #8]
    2d06:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2d0a:	f04f 0100 	mov.w	r1, #0
    2d0e:	ea41 0202 	orr.w	r2, r1, r2
    2d12:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = comms_status;
    2d14:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d1c:	6818      	ldr	r0, [r3, #0]
    2d1e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2d22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d26:	781b      	ldrb	r3, [r3, #0]
    2d28:	461a      	mov	r2, r3
    2d2a:	f24c 4340 	movw	r3, #50240	; 0xc440
    2d2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d32:	8819      	ldrh	r1, [r3, #0]
    2d34:	4613      	mov	r3, r2
    2d36:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2d3a:	4413      	add	r3, r2
    2d3c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2d40:	4413      	add	r3, r2
    2d42:	4403      	add	r3, r0
    2d44:	f103 0310 	add.w	r3, r3, #16
    2d48:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    2d4c:	f04f 0000 	mov.w	r0, #0
    2d50:	ea40 0202 	orr.w	r2, r0, r2
    2d54:	71da      	strb	r2, [r3, #7]
    2d56:	ea4f 2211 	mov.w	r2, r1, lsr #8
    2d5a:	b292      	uxth	r2, r2
    2d5c:	f04f 0100 	mov.w	r1, #0
    2d60:	ea41 0202 	orr.w	r2, r1, r2
    2d64:	721a      	strb	r2, [r3, #8]
	log_counter++;
    2d66:	f24c 1380 	movw	r3, #49536	; 0xc180
    2d6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d6e:	781b      	ldrb	r3, [r3, #0]
    2d70:	f103 0301 	add.w	r3, r3, #1
    2d74:	b2da      	uxtb	r2, r3
    2d76:	f24c 1380 	movw	r3, #49536	; 0xc180
    2d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d7e:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&comms_timer);
    2d80:	f24c 1094 	movw	r0, #49556	; 0xc194
    2d84:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2d88:	f006 faec 	bl	9364 <TMR_clear_int>
}
    2d8c:	bd80      	pop	{r7, pc}
    2d8e:	bf00      	nop

00002d90 <THER_ISR>:

void THER_ISR(){
    2d90:	b580      	push	{r7, lr}
    2d92:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
    2d94:	f24c 32d8 	movw	r2, #50136	; 0xc3d8
    2d98:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2d9c:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2da0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2da4:	4610      	mov	r0, r2
    2da6:	4619      	mov	r1, r3
    2da8:	f7ff fbb4 	bl	2514 <MSS_TIM64_get_current_value>
	therm_status =  get_temp();
    2dac:	f7fe fb2a 	bl	1404 <get_temp>
    2db0:	4603      	mov	r3, r0
    2db2:	461a      	mov	r2, r3
    2db4:	f24c 1398 	movw	r3, #49560	; 0xc198
    2db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dbc:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
    2dbe:	f24c 1380 	movw	r3, #49536	; 0xc180
    2dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dc6:	781b      	ldrb	r3, [r3, #0]
    2dc8:	2b09      	cmp	r3, #9
    2dca:	d901      	bls.n	2dd0 <THER_ISR+0x40>
		form_log_packet();
    2dcc:	f7ff fc14 	bl	25f8 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = THERMISTOR_TASK_ID;
    2dd0:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2dd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2dd8:	6819      	ldr	r1, [r3, #0]
    2dda:	f24c 1380 	movw	r3, #49536	; 0xc180
    2dde:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2de2:	781b      	ldrb	r3, [r3, #0]
    2de4:	461a      	mov	r2, r3
    2de6:	4613      	mov	r3, r2
    2de8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2dec:	4413      	add	r3, r2
    2dee:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2df2:	4413      	add	r3, r2
    2df4:	440b      	add	r3, r1
    2df6:	f103 0316 	add.w	r3, r3, #22
    2dfa:	f04f 0201 	mov.w	r2, #1
    2dfe:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
    2e00:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2e04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e08:	6818      	ldr	r0, [r3, #0]
    2e0a:	f24c 1380 	movw	r3, #49536	; 0xc180
    2e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e12:	781b      	ldrb	r3, [r3, #0]
    2e14:	4619      	mov	r1, r3
    2e16:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
    2e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e1e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2e22:	460b      	mov	r3, r1
    2e24:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2e28:	440b      	add	r3, r1
    2e2a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2e2e:	440b      	add	r3, r1
    2e30:	4403      	add	r3, r0
    2e32:	f103 0308 	add.w	r3, r3, #8
    2e36:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2e3a:	f04f 0000 	mov.w	r0, #0
    2e3e:	ea40 0101 	orr.w	r1, r0, r1
    2e42:	7299      	strb	r1, [r3, #10]
    2e44:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2e48:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2e4c:	f04f 0000 	mov.w	r0, #0
    2e50:	ea40 0101 	orr.w	r1, r0, r1
    2e54:	72d9      	strb	r1, [r3, #11]
    2e56:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2e5a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2e5e:	f04f 0000 	mov.w	r0, #0
    2e62:	ea40 0101 	orr.w	r1, r0, r1
    2e66:	7319      	strb	r1, [r3, #12]
    2e68:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2e6c:	f04f 0100 	mov.w	r1, #0
    2e70:	ea41 0202 	orr.w	r2, r1, r2
    2e74:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
    2e76:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e7e:	6818      	ldr	r0, [r3, #0]
    2e80:	f24c 1380 	movw	r3, #49536	; 0xc180
    2e84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e88:	781b      	ldrb	r3, [r3, #0]
    2e8a:	4619      	mov	r1, r3
    2e8c:	f24c 33c8 	movw	r3, #50120	; 0xc3c8
    2e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2e94:	e9d3 2300 	ldrd	r2, r3, [r3]
    2e98:	460b      	mov	r3, r1
    2e9a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2e9e:	440b      	add	r3, r1
    2ea0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2ea4:	440b      	add	r3, r1
    2ea6:	4403      	add	r3, r0
    2ea8:	f103 0308 	add.w	r3, r3, #8
    2eac:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2eb0:	f04f 0000 	mov.w	r0, #0
    2eb4:	ea40 0101 	orr.w	r1, r0, r1
    2eb8:	7199      	strb	r1, [r3, #6]
    2eba:	ea4f 2112 	mov.w	r1, r2, lsr #8
    2ebe:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2ec2:	f04f 0000 	mov.w	r0, #0
    2ec6:	ea40 0101 	orr.w	r1, r0, r1
    2eca:	71d9      	strb	r1, [r3, #7]
    2ecc:	ea4f 4112 	mov.w	r1, r2, lsr #16
    2ed0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    2ed4:	f04f 0000 	mov.w	r0, #0
    2ed8:	ea40 0101 	orr.w	r1, r0, r1
    2edc:	7219      	strb	r1, [r3, #8]
    2ede:	ea4f 6212 	mov.w	r2, r2, lsr #24
    2ee2:	f04f 0100 	mov.w	r1, #0
    2ee6:	ea41 0202 	orr.w	r2, r1, r2
    2eea:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = therm_status;
    2eec:	f24c 139c 	movw	r3, #49564	; 0xc19c
    2ef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ef4:	6818      	ldr	r0, [r3, #0]
    2ef6:	f24c 1380 	movw	r3, #49536	; 0xc180
    2efa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2efe:	781b      	ldrb	r3, [r3, #0]
    2f00:	461a      	mov	r2, r3
    2f02:	f24c 1398 	movw	r3, #49560	; 0xc198
    2f06:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f0a:	8819      	ldrh	r1, [r3, #0]
    2f0c:	4613      	mov	r3, r2
    2f0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2f12:	4413      	add	r3, r2
    2f14:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2f18:	4413      	add	r3, r2
    2f1a:	4403      	add	r3, r0
    2f1c:	f103 0310 	add.w	r3, r3, #16
    2f20:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    2f24:	f04f 0000 	mov.w	r0, #0
    2f28:	ea40 0202 	orr.w	r2, r0, r2
    2f2c:	71da      	strb	r2, [r3, #7]
    2f2e:	ea4f 2211 	mov.w	r2, r1, lsr #8
    2f32:	b292      	uxth	r2, r2
    2f34:	f04f 0100 	mov.w	r1, #0
    2f38:	ea41 0202 	orr.w	r2, r1, r2
    2f3c:	721a      	strb	r2, [r3, #8]
	log_counter++;
    2f3e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f46:	781b      	ldrb	r3, [r3, #0]
    2f48:	f103 0301 	add.w	r3, r3, #1
    2f4c:	b2da      	uxtb	r2, r3
    2f4e:	f24c 1380 	movw	r3, #49536	; 0xc180
    2f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f56:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&temp_timer);
    2f58:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    2f5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2f60:	f006 fa00 	bl	9364 <TMR_clear_int>
}
    2f64:	bd80      	pop	{r7, pc}
    2f66:	bf00      	nop

00002f68 <SD_ISR>:

void SD_ISR(){
    2f68:	b580      	push	{r7, lr}
    2f6a:	af00      	add	r7, sp, #0
	get_sd_data();
    2f6c:	f7fe fbf8 	bl	1760 <get_sd_data>
	if(hk_partition.read_pointer < hk_partition.write_pointer && store_in_sd_card == 0){
    2f70:	f24c 430c 	movw	r3, #50188	; 0xc40c
    2f74:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f78:	689a      	ldr	r2, [r3, #8]
    2f7a:	f24c 430c 	movw	r3, #50188	; 0xc40c
    2f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f82:	68db      	ldr	r3, [r3, #12]
    2f84:	429a      	cmp	r2, r3
    2f86:	d208      	bcs.n	2f9a <SD_ISR+0x32>
    2f88:	f24b 3359 	movw	r3, #45913	; 0xb359
    2f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2f90:	781b      	ldrb	r3, [r3, #0]
    2f92:	2b00      	cmp	r3, #0
    2f94:	d101      	bne.n	2f9a <SD_ISR+0x32>
		get_sd_data();
    2f96:	f7fe fbe3 	bl	1760 <get_sd_data>
	}

	TMR_clear_int(&sd_timer);
    2f9a:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    2f9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2fa2:	f006 f9df 	bl	9364 <TMR_clear_int>
}
    2fa6:	bd80      	pop	{r7, pc}

00002fa8 <timer_intr_set>:

void timer_intr_set(){
    2fa8:	b580      	push	{r7, lr}
    2faa:	b082      	sub	sp, #8
    2fac:	af02      	add	r7, sp, #8
	TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, HK_PKT_PERIOD);
    2fae:	f643 1338 	movw	r3, #14648	; 0x3938
    2fb2:	9300      	str	r3, [sp, #0]
    2fb4:	f24c 401c 	movw	r0, #50204	; 0xc41c
    2fb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2fbc:	f246 0100 	movw	r1, #24576	; 0x6000
    2fc0:	f2c5 0100 	movt	r1, #20480	; 0x5000
    2fc4:	f04f 0200 	mov.w	r2, #0
    2fc8:	f04f 0309 	mov.w	r3, #9
    2fcc:	f006 f908 	bl	91e0 <TMR_init>
	TMR_enable_int(&hk_timer);
    2fd0:	f24c 401c 	movw	r0, #50204	; 0xc41c
    2fd4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2fd8:	f006 f9a6 	bl	9328 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq4_IRQn);
    2fdc:	f04f 0026 	mov.w	r0, #38	; 0x26
    2fe0:	f7ff f9b2 	bl	2348 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq4_IRQn, 254);
    2fe4:	f04f 0026 	mov.w	r0, #38	; 0x26
    2fe8:	f04f 01fe 	mov.w	r1, #254	; 0xfe
    2fec:	f7ff fa04 	bl	23f8 <NVIC_SetPriority>

	TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, COMMS_PKT_PERIOD);
    2ff0:	f645 338c 	movw	r3, #23436	; 0x5b8c
    2ff4:	9300      	str	r3, [sp, #0]
    2ff6:	f24c 1094 	movw	r0, #49556	; 0xc194
    2ffa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2ffe:	f247 0100 	movw	r1, #28672	; 0x7000
    3002:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3006:	f04f 0200 	mov.w	r2, #0
    300a:	f04f 0309 	mov.w	r3, #9
    300e:	f006 f8e7 	bl	91e0 <TMR_init>
	TMR_enable_int(&comms_timer);
    3012:	f24c 1094 	movw	r0, #49556	; 0xc194
    3016:	f2c2 0000 	movt	r0, #8192	; 0x2000
    301a:	f006 f985 	bl	9328 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq5_IRQn);
    301e:	f04f 0027 	mov.w	r0, #39	; 0x27
    3022:	f7ff f991 	bl	2348 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq5_IRQn, 254);
    3026:	f04f 0027 	mov.w	r0, #39	; 0x27
    302a:	f04f 01fe 	mov.w	r1, #254	; 0xfe
    302e:	f7ff f9e3 	bl	23f8 <NVIC_SetPriority>


	TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, TEMP_PKT_PERIOD);
    3032:	f247 2370 	movw	r3, #29296	; 0x7270
    3036:	9300      	str	r3, [sp, #0]
    3038:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    303c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3040:	f248 0100 	movw	r1, #32768	; 0x8000
    3044:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3048:	f04f 0200 	mov.w	r2, #0
    304c:	f04f 0309 	mov.w	r3, #9
    3050:	f006 f8c6 	bl	91e0 <TMR_init>
	TMR_enable_int(&temp_timer);
    3054:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3058:	f2c2 0000 	movt	r0, #8192	; 0x2000
    305c:	f006 f964 	bl	9328 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq6_IRQn);
    3060:	f04f 0028 	mov.w	r0, #40	; 0x28
    3064:	f7ff f970 	bl	2348 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq6_IRQn, 254);
    3068:	f04f 0028 	mov.w	r0, #40	; 0x28
    306c:	f04f 01fe 	mov.w	r1, #254	; 0xfe
    3070:	f7ff f9c2 	bl	23f8 <NVIC_SetPriority>

	TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, SD_PKT_PERIOD);
    3074:	f647 0360 	movw	r3, #30816	; 0x7860
    3078:	f2c0 0304 	movt	r3, #4
    307c:	9300      	str	r3, [sp, #0]
    307e:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3082:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3086:	f249 0100 	movw	r1, #36864	; 0x9000
    308a:	f2c5 0100 	movt	r1, #20480	; 0x5000
    308e:	f04f 0200 	mov.w	r2, #0
    3092:	f04f 0309 	mov.w	r3, #9
    3096:	f006 f8a3 	bl	91e0 <TMR_init>
	TMR_enable_int(&sd_timer);
    309a:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    309e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    30a2:	f006 f941 	bl	9328 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq7_IRQn);
    30a6:	f04f 0029 	mov.w	r0, #41	; 0x29
    30aa:	f7ff f94d 	bl	2348 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq7_IRQn, 254);
    30ae:	f04f 0029 	mov.w	r0, #41	; 0x29
    30b2:	f04f 01fe 	mov.w	r1, #254	; 0xfe
    30b6:	f7ff f99f 	bl	23f8 <NVIC_SetPriority>

	TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, GMC_PKT_PERIOD);
    30ba:	f643 1338 	movw	r3, #14648	; 0x3938
    30be:	9300      	str	r3, [sp, #0]
    30c0:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    30c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    30c8:	f24a 0100 	movw	r1, #40960	; 0xa000
    30cc:	f2c5 0100 	movt	r1, #20480	; 0x5000
    30d0:	f04f 0200 	mov.w	r2, #0
    30d4:	f04f 0309 	mov.w	r3, #9
    30d8:	f006 f882 	bl	91e0 <TMR_init>
	TMR_enable_int(&gmc_timer);
    30dc:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    30e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    30e4:	f006 f920 	bl	9328 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq8_IRQn);
    30e8:	f04f 002a 	mov.w	r0, #42	; 0x2a
    30ec:	f7ff f92c 	bl	2348 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq8_IRQn, 254);
    30f0:	f04f 002a 	mov.w	r0, #42	; 0x2a
    30f4:	f04f 01fe 	mov.w	r1, #254	; 0xfe
    30f8:	f7ff f97e 	bl	23f8 <NVIC_SetPriority>

	TMR_start(&hk_timer);
    30fc:	f24c 401c 	movw	r0, #50204	; 0xc41c
    3100:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3104:	f006 f8d4 	bl	92b0 <TMR_start>
	TMR_start(&comms_timer);
    3108:	f24c 1094 	movw	r0, #49556	; 0xc194
    310c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3110:	f006 f8ce 	bl	92b0 <TMR_start>
	TMR_start(&temp_timer);
    3114:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3118:	f2c2 0000 	movt	r0, #8192	; 0x2000
    311c:	f006 f8c8 	bl	92b0 <TMR_start>
	TMR_start(&sd_timer);
    3120:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3124:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3128:	f006 f8c2 	bl	92b0 <TMR_start>
	TMR_start(&gmc_timer);
    312c:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    3130:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3134:	f006 f8bc 	bl	92b0 <TMR_start>
}
    3138:	46bd      	mov	sp, r7
    313a:	bd80      	pop	{r7, pc}

0000313c <timer_dis>:

void timer_dis(){
    313c:	b580      	push	{r7, lr}
    313e:	af00      	add	r7, sp, #0
//	NVIC_DisableIRQ(FabricIrq4_IRQn);
	NVIC_DisableIRQ(FabricIrq5_IRQn);
    3140:	f04f 0027 	mov.w	r0, #39	; 0x27
    3144:	f7ff f91c 	bl	2380 <NVIC_DisableIRQ>
}
    3148:	bd80      	pop	{r7, pc}
    314a:	bf00      	nop

0000314c <timer_ena>:

void timer_ena(){
    314c:	b580      	push	{r7, lr}
    314e:	af00      	add	r7, sp, #0
//	NVIC_EnableIRQ(FabricIrq4_IRQn);
	NVIC_EnableIRQ(FabricIrq5_IRQn);
    3150:	f04f 0027 	mov.w	r0, #39	; 0x27
    3154:	f7ff f8f8 	bl	2348 <NVIC_EnableIRQ>
}
    3158:	bd80      	pop	{r7, pc}
    315a:	bf00      	nop

0000315c <get_cmd>:

void get_cmd(uint8_t* cmd, uint8_t src){
    315c:	b580      	push	{r7, lr}
    315e:	b082      	sub	sp, #8
    3160:	af00      	add	r7, sp, #0
    3162:	6078      	str	r0, [r7, #4]
    3164:	460b      	mov	r3, r1
    3166:	70fb      	strb	r3, [r7, #3]

	rx_cmd_pkt = (rx_cmd_t*) cmd;
    3168:	687a      	ldr	r2, [r7, #4]
    316a:	f24c 33e0 	movw	r3, #50144	; 0xc3e0
    316e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3172:	601a      	str	r2, [r3, #0]

	if(cmd_valid(rx_cmd_pkt, src)){
    3174:	f24c 33e0 	movw	r3, #50144	; 0xc3e0
    3178:	f2c2 0300 	movt	r3, #8192	; 0x2000
    317c:	681a      	ldr	r2, [r3, #0]
    317e:	78fb      	ldrb	r3, [r7, #3]
    3180:	4610      	mov	r0, r2
    3182:	4619      	mov	r1, r3
    3184:	f000 fb9a 	bl	38bc <cmd_valid>
    3188:	4603      	mov	r3, r0
    318a:	2b00      	cmp	r3, #0
    318c:	d026      	beq.n	31dc <get_cmd+0x80>
		cmd_engine(rx_cmd_pkt);
    318e:	f24c 33e0 	movw	r3, #50144	; 0xc3e0
    3192:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3196:	681b      	ldr	r3, [r3, #0]
    3198:	4618      	mov	r0, r3
    319a:	f000 fc0b 	bl	39b4 <cmd_engine>
		if(src == 0){
    319e:	78fb      	ldrb	r3, [r7, #3]
    31a0:	2b00      	cmp	r3, #0
    31a2:	d10d      	bne.n	31c0 <get_cmd+0x64>
			cmd_rs485_succ_count++;
    31a4:	f24b 336c 	movw	r3, #45932	; 0xb36c
    31a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31ac:	781b      	ldrb	r3, [r3, #0]
    31ae:	f103 0301 	add.w	r3, r3, #1
    31b2:	b2da      	uxtb	r2, r3
    31b4:	f24b 336c 	movw	r3, #45932	; 0xb36c
    31b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31bc:	701a      	strb	r2, [r3, #0]
		}
		else{
			cmd_succ_count++;
    31be:	e02b      	b.n	3218 <get_cmd+0xbc>
    31c0:	f24b 336a 	movw	r3, #45930	; 0xb36a
    31c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31c8:	781b      	ldrb	r3, [r3, #0]
    31ca:	f103 0301 	add.w	r3, r3, #1
    31ce:	b2da      	uxtb	r2, r3
    31d0:	f24b 336a 	movw	r3, #45930	; 0xb36a
    31d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31d8:	701a      	strb	r2, [r3, #0]
    31da:	e01d      	b.n	3218 <get_cmd+0xbc>
		}


	}
	else{
		if(src == 0){
    31dc:	78fb      	ldrb	r3, [r7, #3]
    31de:	2b00      	cmp	r3, #0
    31e0:	d10d      	bne.n	31fe <get_cmd+0xa2>
			cmd_rs485_fail_count++;
    31e2:	f24b 336d 	movw	r3, #45933	; 0xb36d
    31e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31ea:	781b      	ldrb	r3, [r3, #0]
    31ec:	f103 0301 	add.w	r3, r3, #1
    31f0:	b2da      	uxtb	r2, r3
    31f2:	f24b 336d 	movw	r3, #45933	; 0xb36d
    31f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31fa:	701a      	strb	r2, [r3, #0]
    31fc:	e00c      	b.n	3218 <get_cmd+0xbc>
		}
		else{
			cmd_reject_count++;
    31fe:	f24b 336b 	movw	r3, #45931	; 0xb36b
    3202:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3206:	781b      	ldrb	r3, [r3, #0]
    3208:	f103 0301 	add.w	r3, r3, #1
    320c:	b2da      	uxtb	r2, r3
    320e:	f24b 336b 	movw	r3, #45931	; 0xb36b
    3212:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3216:	701a      	strb	r2, [r3, #0]
		}

	}
}
    3218:	f107 0708 	add.w	r7, r7, #8
    321c:	46bd      	mov	sp, r7
    321e:	bd80      	pop	{r7, pc}

00003220 <init_cmd_engine>:

void init_cmd_engine(){
    3220:	b580      	push	{r7, lr}
    3222:	af00      	add	r7, sp, #0
	add_cmd(0, 2, cmd_noop);
    3224:	f643 2305 	movw	r3, #14853	; 0x3a05
    3228:	f2c0 0300 	movt	r3, #0
    322c:	f04f 0000 	mov.w	r0, #0
    3230:	f04f 0102 	mov.w	r1, #2
    3234:	461a      	mov	r2, r3
    3236:	f000 fb5f 	bl	38f8 <add_cmd>
	add_cmd(1, 3, set_pkt_rate);
    323a:	f643 2319 	movw	r3, #14873	; 0x3a19
    323e:	f2c0 0300 	movt	r3, #0
    3242:	f04f 0001 	mov.w	r0, #1
    3246:	f04f 0103 	mov.w	r1, #3
    324a:	461a      	mov	r2, r3
    324c:	f000 fb54 	bl	38f8 <add_cmd>
	add_cmd(2, 3, exe_iap);
    3250:	f643 43ad 	movw	r3, #15533	; 0x3cad
    3254:	f2c0 0300 	movt	r3, #0
    3258:	f04f 0002 	mov.w	r0, #2
    325c:	f04f 0103 	mov.w	r1, #3
    3260:	461a      	mov	r2, r3
    3262:	f000 fb49 	bl	38f8 <add_cmd>
	add_cmd(3, 6, read_adf_reg);
    3266:	f643 43d5 	movw	r3, #15573	; 0x3cd5
    326a:	f2c0 0300 	movt	r3, #0
    326e:	f04f 0003 	mov.w	r0, #3
    3272:	f04f 0106 	mov.w	r1, #6
    3276:	461a      	mov	r2, r3
    3278:	f000 fb3e 	bl	38f8 <add_cmd>
	add_cmd(4, 16, exe_rtm);
    327c:	f643 53d5 	movw	r3, #15829	; 0x3dd5
    3280:	f2c0 0300 	movt	r3, #0
    3284:	f04f 0004 	mov.w	r0, #4
    3288:	f04f 0110 	mov.w	r1, #16
    328c:	461a      	mov	r2, r3
    328e:	f000 fb33 	bl	38f8 <add_cmd>
}
    3292:	bd80      	pop	{r7, pc}

00003294 <Tim64_init>:

//Function to initialise 64 bit timer
void Tim64_init() {
    3294:	b580      	push	{r7, lr}
    3296:	af00      	add	r7, sp, #0
	MSS_TIM64_init(MSS_TIMER_ONE_SHOT_MODE);
    3298:	f04f 0001 	mov.w	r0, #1
    329c:	f7ff f8da 	bl	2454 <MSS_TIM64_init>
	MSS_TIM64_load_immediate(0xFFFFFFFF,0xFFFFFFFF);
    32a0:	f04f 30ff 	mov.w	r0, #4294967295
    32a4:	f04f 31ff 	mov.w	r1, #4294967295
    32a8:	f7ff f94c 	bl	2544 <MSS_TIM64_load_immediate>
	MSS_TIM64_start();
    32ac:	f7ff f924 	bl	24f8 <MSS_TIM64_start>
}
    32b0:	bd80      	pop	{r7, pc}
    32b2:	bf00      	nop

000032b4 <get_init>:

void get_init(){
    32b4:	b590      	push	{r4, r7, lr}
    32b6:	b083      	sub	sp, #12
    32b8:	af00      	add	r7, sp, #0
	init_pkt = (init_packet_t* )data;
    32ba:	f24b 6238 	movw	r2, #46648	; 0xb638
    32be:	f2c2 0200 	movt	r2, #8192	; 0x2000
    32c2:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    32c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32ca:	601a      	str	r2, [r3, #0]
	init_pkt->Status_1 = stat1;
    32cc:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    32d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32d4:	681a      	ldr	r2, [r3, #0]
    32d6:	f24b 3374 	movw	r3, #45940	; 0xb374
    32da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32de:	781b      	ldrb	r3, [r3, #0]
    32e0:	73d3      	strb	r3, [r2, #15]
	init_pkt->Adf_init_status = adf_status;
    32e2:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    32e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32ea:	681a      	ldr	r2, [r3, #0]
    32ec:	f24b 3377 	movw	r3, #45943	; 0xb377
    32f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    32f4:	781b      	ldrb	r3, [r3, #0]
    32f6:	7413      	strb	r3, [r2, #16]
	init_pkt->status_2 = stat2;
    32f8:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    32fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3300:	681a      	ldr	r2, [r3, #0]
    3302:	f24b 3375 	movw	r3, #45941	; 0xb375
    3306:	f2c2 0300 	movt	r3, #8192	; 0x2000
    330a:	781b      	ldrb	r3, [r3, #0]
    330c:	7453      	strb	r3, [r2, #17]
	init_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, INIT_API_ID))));
    330e:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    3312:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3316:	681b      	ldr	r3, [r3, #0]
    3318:	f04f 0200 	mov.w	r2, #0
    331c:	f042 0208 	orr.w	r2, r2, #8
    3320:	701a      	strb	r2, [r3, #0]
    3322:	f04f 0200 	mov.w	r2, #0
    3326:	f042 0205 	orr.w	r2, r2, #5
    332a:	705a      	strb	r2, [r3, #1]
	init_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((0)))));
    332c:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    3330:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3334:	681a      	ldr	r2, [r3, #0]
    3336:	f04f 0300 	mov.w	r3, #0
    333a:	ea6f 6383 	mvn.w	r3, r3, lsl #26
    333e:	ea6f 6393 	mvn.w	r3, r3, lsr #26
    3342:	7093      	strb	r3, [r2, #2]
    3344:	f04f 0300 	mov.w	r3, #0
    3348:	70d3      	strb	r3, [r2, #3]
	init_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(INIT_PKT_LENGTH))));
    334a:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    334e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3352:	681b      	ldr	r3, [r3, #0]
    3354:	f04f 0200 	mov.w	r2, #0
    3358:	711a      	strb	r2, [r3, #4]
    335a:	f04f 0200 	mov.w	r2, #0
    335e:	f042 0234 	orr.w	r2, r2, #52	; 0x34
    3362:	715a      	strb	r2, [r3, #5]
	init_pkt->ccsds_s1 = 0;
    3364:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    3368:	f2c2 0300 	movt	r3, #8192	; 0x2000
    336c:	681b      	ldr	r3, [r3, #0]
    336e:	f04f 0200 	mov.w	r2, #0
    3372:	719a      	strb	r2, [r3, #6]
    3374:	f04f 0200 	mov.w	r2, #0
    3378:	71da      	strb	r2, [r3, #7]
    337a:	f04f 0200 	mov.w	r2, #0
    337e:	721a      	strb	r2, [r3, #8]
    3380:	f04f 0200 	mov.w	r2, #0
    3384:	725a      	strb	r2, [r3, #9]
	init_pkt->ccsds_s2 = 0;
    3386:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    338a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    338e:	681b      	ldr	r3, [r3, #0]
    3390:	f04f 0200 	mov.w	r2, #0
    3394:	729a      	strb	r2, [r3, #10]
    3396:	f04f 0200 	mov.w	r2, #0
    339a:	72da      	strb	r2, [r3, #11]
    339c:	f04f 0200 	mov.w	r2, #0
    33a0:	731a      	strb	r2, [r3, #12]
    33a2:	f04f 0200 	mov.w	r2, #0
    33a6:	735a      	strb	r2, [r3, #13]

	uint8_t i = 0;
    33a8:	f04f 0300 	mov.w	r3, #0
    33ac:	71fb      	strb	r3, [r7, #7]

	get_time_vector();
    33ae:	f000 fdd7 	bl	3f60 <get_time_vector>
	for(;i<32;i++){
    33b2:	e012      	b.n	33da <get_init+0x126>
		init_pkt->GTime_SVector[i] = Time_Vector[i];
    33b4:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    33b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33bc:	6819      	ldr	r1, [r3, #0]
    33be:	79f8      	ldrb	r0, [r7, #7]
    33c0:	79fa      	ldrb	r2, [r7, #7]
    33c2:	f24c 4320 	movw	r3, #50208	; 0xc420
    33c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33ca:	5c9a      	ldrb	r2, [r3, r2]
    33cc:	eb00 0301 	add.w	r3, r0, r1
    33d0:	749a      	strb	r2, [r3, #18]
	init_pkt->ccsds_s2 = 0;

	uint8_t i = 0;

	get_time_vector();
	for(;i<32;i++){
    33d2:	79fb      	ldrb	r3, [r7, #7]
    33d4:	f103 0301 	add.w	r3, r3, #1
    33d8:	71fb      	strb	r3, [r7, #7]
    33da:	79fb      	ldrb	r3, [r7, #7]
    33dc:	2b1f      	cmp	r3, #31
    33de:	d9e9      	bls.n	33b4 <get_init+0x100>
		init_pkt->GTime_SVector[i] = Time_Vector[i];
	}
	init_pkt->Fletcher_Code = make_FLetcher(data, sizeof(init_packet_t) - 2);
    33e0:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    33e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    33e8:	681c      	ldr	r4, [r3, #0]
    33ea:	f24b 6038 	movw	r0, #46648	; 0xb638
    33ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
    33f2:	f04f 0132 	mov.w	r1, #50	; 0x32
    33f6:	f7fd f977 	bl	6e8 <make_FLetcher>
    33fa:	4603      	mov	r3, r0
    33fc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    3400:	f04f 0100 	mov.w	r1, #0
    3404:	ea41 0202 	orr.w	r2, r1, r2
    3408:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
    340c:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3410:	b29b      	uxth	r3, r3
    3412:	f04f 0200 	mov.w	r2, #0
    3416:	ea42 0303 	orr.w	r3, r2, r3
    341a:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33


	vGetPktStruct(init, (void*) init_pkt, sizeof(init_packet_t));
    341e:	f24c 13b4 	movw	r3, #49588	; 0xc1b4
    3422:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3426:	681b      	ldr	r3, [r3, #0]
    3428:	f04f 0006 	mov.w	r0, #6
    342c:	4619      	mov	r1, r3
    342e:	f04f 0234 	mov.w	r2, #52	; 0x34
    3432:	f7fd f8dd 	bl	5f0 <vGetPktStruct>
//	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(init_packet_t));

}
    3436:	f107 070c 	add.w	r7, r7, #12
    343a:	46bd      	mov	sp, r7
    343c:	bd90      	pop	{r4, r7, pc}
    343e:	bf00      	nop

00003440 <main>:

int main(){
    3440:	b580      	push	{r7, lr}
    3442:	b08c      	sub	sp, #48	; 0x30
    3444:	af02      	add	r7, sp, #8
//adf_init
	//gmc_init
	//sd_init
	//pslv_interface_init
	//interface_init
	MSS_WD_init();
    3446:	f7ff f893 	bl	2570 <MSS_WD_init>
	MSS_WD_reload();
    344a:	f7ff f8c7 	bl	25dc <MSS_WD_reload>
	p1_init();
    344e:	f7fd f8a3 	bl	598 <p1_init>
	MSS_GPIO_init();
    3452:	f005 fdc9 	bl	8fe8 <MSS_GPIO_init>
	MSS_GPIO_config(MSS_GPIO_0, MSS_GPIO_OUTPUT_MODE);
    3456:	f04f 0000 	mov.w	r0, #0
    345a:	f04f 0105 	mov.w	r1, #5
    345e:	f005 fe19 	bl	9094 <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_2, MSS_GPIO_OUTPUT_MODE);
    3462:	f04f 0002 	mov.w	r0, #2
    3466:	f04f 0105 	mov.w	r1, #5
    346a:	f005 fe13 	bl	9094 <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_6, MSS_GPIO_OUTPUT_MODE);
    346e:	f04f 0006 	mov.w	r0, #6
    3472:	f04f 0105 	mov.w	r1, #5
    3476:	f005 fe0d 	bl	9094 <MSS_GPIO_config>

	MSS_GPIO_set_output(MSS_GPIO_0, 1);	//Control_Interface ON
    347a:	f04f 0000 	mov.w	r0, #0
    347e:	f04f 0101 	mov.w	r1, #1
    3482:	f005 fe25 	bl	90d0 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_2, 1);	//COmms_ON
    3486:	f04f 0002 	mov.w	r0, #2
    348a:	f04f 0101 	mov.w	r1, #1
    348e:	f005 fe1f 	bl	90d0 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_6, 1);	//GMC_on
    3492:	f04f 0006 	mov.w	r0, #6
    3496:	f04f 0101 	mov.w	r1, #1
    349a:	f005 fe19 	bl	90d0 <MSS_GPIO_set_output>

	MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
    349e:	f04f 0000 	mov.w	r0, #0
    34a2:	f003 fd13 	bl	6ecc <MSS_SYS_init>
	MSS_SPI_init( &g_mss_spi0 );
    34a6:	f24c 5084 	movw	r0, #50564	; 0xc584
    34aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    34ae:	f003 ffbb 	bl	7428 <MSS_SPI_init>
	MSS_SPI_configure_master_mode(&g_mss_spi0, MSS_SPI_SLAVE_0, MSS_SPI_MODE0, 8u, 8);
    34b2:	f04f 0308 	mov.w	r3, #8
    34b6:	9300      	str	r3, [sp, #0]
    34b8:	f24c 5084 	movw	r0, #50564	; 0xc584
    34bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    34c0:	f04f 0100 	mov.w	r1, #0
    34c4:	f04f 0200 	mov.w	r2, #0
    34c8:	f04f 0308 	mov.w	r3, #8
    34cc:	f004 f8f6 	bl	76bc <MSS_SPI_configure_master_mode>

	MSS_SPI_init(&g_mss_spi1);
    34d0:	f24c 5000 	movw	r0, #50432	; 0xc500
    34d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    34d8:	f003 ffa6 	bl	7428 <MSS_SPI_init>
	MSS_SPI_configure_master_mode(&g_mss_spi1, MSS_SPI_SLAVE_0, MSS_SPI_MODE0, 512, 8);
    34dc:	f04f 0308 	mov.w	r3, #8
    34e0:	9300      	str	r3, [sp, #0]
    34e2:	f24c 5000 	movw	r0, #50432	; 0xc500
    34e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    34ea:	f04f 0100 	mov.w	r1, #0
    34ee:	f04f 0200 	mov.w	r2, #0
    34f2:	f44f 7300 	mov.w	r3, #512	; 0x200
    34f6:	f004 f8e1 	bl	76bc <MSS_SPI_configure_master_mode>

	initialise_partition(&hk_partition, HK_BLOCK_INIT, HK_BLOCK_END);
    34fa:	f24c 400c 	movw	r0, #50188	; 0xc40c
    34fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3502:	f04f 010a 	mov.w	r1, #10
    3506:	f641 220a 	movw	r2, #6666	; 0x1a0a
    350a:	f2c0 024f 	movt	r2, #79	; 0x4f
    350e:	f002 f84b 	bl	55a8 <initialise_partition>
	initialise_partition(&comms_partition, COMMS_BLOCK_INIT, COMMS_BLOCK_END);
    3512:	f24c 30fc 	movw	r0, #50172	; 0xc3fc
    3516:	f2c2 0000 	movt	r0, #8192	; 0x2000
    351a:	f240 31d2 	movw	r1, #978	; 0x3d2
    351e:	f2c0 0157 	movt	r1, #87	; 0x57
    3522:	f64c 6252 	movw	r2, #52818	; 0xce52
    3526:	f2c0 0257 	movt	r2, #87	; 0x57
    352a:	f002 f83d 	bl	55a8 <initialise_partition>
	initialise_partition(&thermistor_partition, THERMISTOR_BLOCK_INIT, THERMISTOR_BLOCK_END);
    352e:	f24c 30e8 	movw	r0, #50152	; 0xc3e8
    3532:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3536:	f246 417e 	movw	r1, #25726	; 0x647e
    353a:	f2c0 0159 	movt	r1, #89	; 0x59
    353e:	f645 12fe 	movw	r2, #23038	; 0x59fe
    3542:	f2c0 027a 	movt	r2, #122	; 0x7a
    3546:	f002 f82f 	bl	55a8 <initialise_partition>
	initialise_partition(&gmc_partition, GMC_BLOCK_INIT, GMC_BLOCK_END);
    354a:	f24c 10a0 	movw	r0, #49568	; 0xc1a0
    354e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3552:	f44f 712f 	mov.w	r1, #700	; 0x2bc
    3556:	f44f 7248 	mov.w	r2, #800	; 0x320
    355a:	f002 f825 	bl	55a8 <initialise_partition>
	initialise_partition(&log_partiton, LOGS_BLOCK_INIT, LOGS_BLOCK_END);
    355e:	f24c 1084 	movw	r0, #49540	; 0xc184
    3562:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3566:	f641 216e 	movw	r1, #6766	; 0x1a6e
    356a:	f2c0 014f 	movt	r1, #79	; 0x4f
    356e:	f240 326e 	movw	r2, #878	; 0x36e
    3572:	f2c0 0257 	movt	r2, #87	; 0x57
    3576:	f002 f817 	bl	55a8 <initialise_partition>

	uint8_t init_envm[3];
	init_envm[0] = 0x00;
    357a:	f04f 0300 	mov.w	r3, #0
    357e:	733b      	strb	r3, [r7, #12]
	init_envm[1] = 0x00;
    3580:	f04f 0300 	mov.w	r3, #0
    3584:	737b      	strb	r3, [r7, #13]
	init_envm[2] = 0x00;
    3586:	f04f 0300 	mov.w	r3, #0
    358a:	73bb      	strb	r3, [r7, #14]
	NVM_write(REPRO_CODE_WORD_ADDR, init_envm, 3, NVM_DO_NOT_LOCK_PAGE);
    358c:	f24b 0308 	movw	r3, #45064	; 0xb008
    3590:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3594:	681a      	ldr	r2, [r3, #0]
    3596:	f107 030c 	add.w	r3, r7, #12
    359a:	4610      	mov	r0, r2
    359c:	4619      	mov	r1, r3
    359e:	f04f 0203 	mov.w	r2, #3
    35a2:	f04f 0300 	mov.w	r3, #0
    35a6:	f004 fdb3 	bl	8110 <NVM_write>

	//Assign log packet pointer to log data buffer
	log_packet_ptr = (log_packet_t*)log_data;
    35aa:	f24c 12b8 	movw	r2, #49592	; 0xc1b8
    35ae:	f2c2 0200 	movt	r2, #8192	; 0x2000
    35b2:	f24c 139c 	movw	r3, #49564	; 0xc19c
    35b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35ba:	601a      	str	r2, [r3, #0]

	//Initialise log counter to zero
	log_counter = 0;
    35bc:	f24c 1380 	movw	r3, #49536	; 0xc180
    35c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35c4:	f04f 0200 	mov.w	r2, #0
    35c8:	701a      	strb	r2, [r3, #0]

	//Initailise the log sequence number
	logs_seq_no = 1;
    35ca:	f24c 33bc 	movw	r3, #50108	; 0xc3bc
    35ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35d2:	f04f 0201 	mov.w	r2, #1
    35d6:	801a      	strh	r2, [r3, #0]

	//Function to initialise 64 bit timer
	Tim64_init();
    35d8:	f7ff fe5c 	bl	3294 <Tim64_init>

	uint8_t mode = 0;
    35dc:	f04f 0300 	mov.w	r3, #0
    35e0:	747b      	strb	r3, [r7, #17]
	counter_init(&counter_i2c);
    35e2:	f24c 004c 	movw	r0, #49228	; 0xc04c
    35e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    35ea:	f002 f851 	bl	5690 <counter_init>

	stat1 |= ADC_Init(TEMP_ADC_CORE_I2C, ADC_ADDR);
    35ee:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    35f2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    35f6:	f04f 0123 	mov.w	r1, #35	; 0x23
    35fa:	f000 ff75 	bl	44e8 <ADC_Init>
    35fe:	4603      	mov	r3, r0
    3600:	461a      	mov	r2, r3
    3602:	f24b 3374 	movw	r3, #45940	; 0xb374
    3606:	f2c2 0300 	movt	r3, #8192	; 0x2000
    360a:	781b      	ldrb	r3, [r3, #0]
    360c:	ea42 0303 	orr.w	r3, r2, r3
    3610:	b2da      	uxtb	r2, r3
    3612:	f24b 3374 	movw	r3, #45940	; 0xb374
    3616:	f2c2 0300 	movt	r3, #8192	; 0x2000
    361a:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 1);
    361c:	f24b 3374 	movw	r3, #45940	; 0xb374
    3620:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3624:	781b      	ldrb	r3, [r3, #0]
    3626:	ea4f 0343 	mov.w	r3, r3, lsl #1
    362a:	b2da      	uxtb	r2, r3
    362c:	f24b 3374 	movw	r3, #45940	; 0xb374
    3630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3634:	701a      	strb	r2, [r3, #0]
	stat1 |= ADC_Init(&counter_i2c, ADC_ADDR);
    3636:	f24c 004c 	movw	r0, #49228	; 0xc04c
    363a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    363e:	f04f 0123 	mov.w	r1, #35	; 0x23
    3642:	f000 ff51 	bl	44e8 <ADC_Init>
    3646:	4603      	mov	r3, r0
    3648:	461a      	mov	r2, r3
    364a:	f24b 3374 	movw	r3, #45940	; 0xb374
    364e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3652:	781b      	ldrb	r3, [r3, #0]
    3654:	ea42 0303 	orr.w	r3, r2, r3
    3658:	b2da      	uxtb	r2, r3
    365a:	f24b 3374 	movw	r3, #45940	; 0xb374
    365e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3662:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 1);
    3664:	f24b 3374 	movw	r3, #45940	; 0xb374
    3668:	f2c2 0300 	movt	r3, #8192	; 0x2000
    366c:	781b      	ldrb	r3, [r3, #0]
    366e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3672:	b2da      	uxtb	r2, r3
    3674:	f24b 3374 	movw	r3, #45940	; 0xb374
    3678:	f2c2 0300 	movt	r3, #8192	; 0x2000
    367c:	701a      	strb	r2, [r3, #0]
	stat1 |= SD_Init();
    367e:	f001 fb59 	bl	4d34 <SD_Init>
    3682:	4603      	mov	r3, r0
    3684:	461a      	mov	r2, r3
    3686:	f24b 3374 	movw	r3, #45940	; 0xb374
    368a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    368e:	781b      	ldrb	r3, [r3, #0]
    3690:	ea42 0303 	orr.w	r3, r2, r3
    3694:	b2da      	uxtb	r2, r3
    3696:	f24b 3374 	movw	r3, #45940	; 0xb374
    369a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    369e:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 5);
    36a0:	f24b 3374 	movw	r3, #45940	; 0xb374
    36a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36a8:	781b      	ldrb	r3, [r3, #0]
    36aa:	ea4f 1343 	mov.w	r3, r3, lsl #5
    36ae:	b2da      	uxtb	r2, r3
    36b0:	f24b 3374 	movw	r3, #45940	; 0xb374
    36b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36b8:	701a      	strb	r2, [r3, #0]
	stat1 |= init_RS485_Controller();
    36ba:	f000 fc71 	bl	3fa0 <init_RS485_Controller>
    36be:	4603      	mov	r3, r0
    36c0:	461a      	mov	r2, r3
    36c2:	f24b 3374 	movw	r3, #45940	; 0xb374
    36c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36ca:	781b      	ldrb	r3, [r3, #0]
    36cc:	ea42 0303 	orr.w	r3, r2, r3
    36d0:	b2da      	uxtb	r2, r3
    36d2:	f24b 3374 	movw	r3, #45940	; 0xb374
    36d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36da:	701a      	strb	r2, [r3, #0]

	adf_status = adf_init();
    36dc:	f002 f8ca 	bl	5874 <adf_init>
    36e0:	4603      	mov	r3, r0
    36e2:	461a      	mov	r2, r3
    36e4:	f24b 3377 	movw	r3, #45943	; 0xb377
    36e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36ec:	701a      	strb	r2, [r3, #0]
	mode = adf_get_state();
    36ee:	f002 fd57 	bl	61a0 <adf_get_state>
    36f2:	4603      	mov	r3, r0
    36f4:	747b      	strb	r3, [r7, #17]

	stat2 |= mode;
    36f6:	f24b 3375 	movw	r3, #45941	; 0xb375
    36fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36fe:	781a      	ldrb	r2, [r3, #0]
    3700:	7c7b      	ldrb	r3, [r7, #17]
    3702:	ea42 0303 	orr.w	r3, r2, r3
    3706:	b2da      	uxtb	r2, r3
    3708:	f24b 3375 	movw	r3, #45941	; 0xb375
    370c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3710:	701a      	strb	r2, [r3, #0]
	stat2 = (stat2 << 1);
    3712:	f24b 3375 	movw	r3, #45941	; 0xb375
    3716:	f2c2 0300 	movt	r3, #8192	; 0x2000
    371a:	781b      	ldrb	r3, [r3, #0]
    371c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3720:	b2da      	uxtb	r2, r3
    3722:	f24b 3375 	movw	r3, #45941	; 0xb375
    3726:	f2c2 0300 	movt	r3, #8192	; 0x2000
    372a:	701a      	strb	r2, [r3, #0]
	stat2 |= vc_init(VC_SENSOR_I2C ,VC1);
    372c:	f24b 4038 	movw	r0, #46136	; 0xb438
    3730:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3734:	f04f 0140 	mov.w	r1, #64	; 0x40
    3738:	f000 fdd6 	bl	42e8 <vc_init>
    373c:	4603      	mov	r3, r0
    373e:	461a      	mov	r2, r3
    3740:	f24b 3375 	movw	r3, #45941	; 0xb375
    3744:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3748:	781b      	ldrb	r3, [r3, #0]
    374a:	ea42 0303 	orr.w	r3, r2, r3
    374e:	b2da      	uxtb	r2, r3
    3750:	f24b 3375 	movw	r3, #45941	; 0xb375
    3754:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3758:	701a      	strb	r2, [r3, #0]
	stat2 = (stat2 << 1);
    375a:	f24b 3375 	movw	r3, #45941	; 0xb375
    375e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3762:	781b      	ldrb	r3, [r3, #0]
    3764:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3768:	b2da      	uxtb	r2, r3
    376a:	f24b 3375 	movw	r3, #45941	; 0xb375
    376e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3772:	701a      	strb	r2, [r3, #0]

	vc_init(TEMP_ADC_CORE_I2C, VC1);
    3774:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    3778:	f2c2 0000 	movt	r0, #8192	; 0x2000
    377c:	f04f 0140 	mov.w	r1, #64	; 0x40
    3780:	f000 fdb2 	bl	42e8 <vc_init>

	uint16_t curr_tpsram_read_addr;
	uint16_t rssi;
	uint8_t cmd[8];
	uint8_t cmd_rx_flag = 0;
    3784:	f04f 0300 	mov.w	r3, #0
    3788:	75fb      	strb	r3, [r7, #23]


	uint32_t wd_reset;

	init_cmd_engine();
    378a:	f7ff fd49 	bl	3220 <init_cmd_engine>

	 MSS_UART_init(&g_mss_uart0,
    378e:	f24c 40c0 	movw	r0, #50368	; 0xc4c0
    3792:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3796:	f44f 5116 	mov.w	r1, #9600	; 0x2580
    379a:	f04f 0203 	mov.w	r2, #3
    379e:	f002 ff1f 	bl	65e0 <MSS_UART_init>
	                   MSS_UART_9600_BAUD,
	                   MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);


	NVIC_ClearPendingIRQ(FabricIrq4_IRQn);
    37a2:	f04f 0026 	mov.w	r0, #38	; 0x26
    37a6:	f7fe fe09 	bl	23bc <NVIC_ClearPendingIRQ>
	NVIC_ClearPendingIRQ(FabricIrq5_IRQn);
    37aa:	f04f 0027 	mov.w	r0, #39	; 0x27
    37ae:	f7fe fe05 	bl	23bc <NVIC_ClearPendingIRQ>

	timer_intr_set();
    37b2:	f7ff fbf9 	bl	2fa8 <timer_intr_set>

	uint32_t timer_count = 0xFFFFFFFF;
    37b6:	f04f 33ff 	mov.w	r3, #4294967295
    37ba:	61fb      	str	r3, [r7, #28]
	uint32_t CMD_CHK_TIMER = 0xFFFFFFFF - (MSS_SYS_M3_CLK_FREQ* (10));
    37bc:	f645 43ff 	movw	r3, #23807	; 0x5cff
    37c0:	f6ce 631e 	movt	r3, #60958	; 0xee1e
    37c4:	623b      	str	r3, [r7, #32]
	uint32_t curr_value = 0x0;
    37c6:	f04f 0300 	mov.w	r3, #0
    37ca:	627b      	str	r3, [r7, #36]	; 0x24

	get_init();
    37cc:	f7ff fd72 	bl	32b4 <get_init>

	while(1){

		adf_send_cmd(CMD_PHY_CCA);
    37d0:	f04f 0086 	mov.w	r0, #134	; 0x86
    37d4:	f002 fb54 	bl	5e80 <adf_send_cmd>

		timer_dis();
    37d8:	f7ff fcb0 	bl	313c <timer_dis>
		get_rssi_cca_data(&rssi_cca);
    37dc:	f24c 30e4 	movw	r0, #50148	; 0xc3e4
    37e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    37e4:	f002 fd74 	bl	62d0 <get_rssi_cca_data>
		timer_ena();
    37e8:	f7ff fcb0 	bl	314c <timer_ena>

		if(store_in_sd_card == 1){
    37ec:	f24b 3359 	movw	r3, #45913	; 0xb359
    37f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37f4:	781b      	ldrb	r3, [r3, #0]
    37f6:	2b01      	cmp	r3, #1
    37f8:	d116      	bne.n	3828 <main+0x3e8>
			curr_tpsram_read_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_RADDR);
    37fa:	f245 000c 	movw	r0, #20492	; 0x500c
    37fe:	f2c5 0000 	movt	r0, #20480	; 0x5000
    3802:	f002 fe41 	bl	6488 <HW_get_16bit_reg>
    3806:	4603      	mov	r3, r0
    3808:	827b      	strh	r3, [r7, #18]
			if(curr_tpsram_read_addr > Read_TPSRAM_addr){
    380a:	f24c 13b0 	movw	r3, #49584	; 0xc1b0
    380e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3812:	881b      	ldrh	r3, [r3, #0]
    3814:	8a7a      	ldrh	r2, [r7, #18]
    3816:	429a      	cmp	r2, r3
    3818:	d906      	bls.n	3828 <main+0x3e8>
				store_in_sd_card = 0;
    381a:	f24b 3359 	movw	r3, #45913	; 0xb359
    381e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3822:	f04f 0200 	mov.w	r2, #0
    3826:	701a      	strb	r2, [r3, #0]
			}
		}

		MSS_WD_reload();
    3828:	f7fe fed8 	bl	25dc <MSS_WD_reload>
	}
    382c:	e7d0      	b.n	37d0 <main+0x390>
    382e:	bf00      	nop

00003830 <FabricIrq0_IRQHandler>:
    return 0;

}

void FabricIrq0_IRQHandler(void)
{
    3830:	b580      	push	{r7, lr}
    3832:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c0);
    3834:	f24b 4038 	movw	r0, #46136	; 0xb438
    3838:	f2c2 0000 	movt	r0, #8192	; 0x2000
    383c:	f006 fb60 	bl	9f00 <I2C_isr>
}
    3840:	bd80      	pop	{r7, pc}
    3842:	bf00      	nop

00003844 <FabricIrq1_IRQHandler>:

void FabricIrq1_IRQHandler(void)
{
    3844:	b580      	push	{r7, lr}
    3846:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c1);
    3848:	f24b 40a4 	movw	r0, #46244	; 0xb4a4
    384c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3850:	f006 fb56 	bl	9f00 <I2C_isr>
}
    3854:	bd80      	pop	{r7, pc}
    3856:	bf00      	nop

00003858 <FabricIrq2_IRQHandler>:

void FabricIrq2_IRQHandler(void)
{
    3858:	b580      	push	{r7, lr}
    385a:	af00      	add	r7, sp, #0
    I2C_isr(&counter_i2c);
    385c:	f24c 004c 	movw	r0, #49228	; 0xc04c
    3860:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3864:	f006 fb4c 	bl	9f00 <I2C_isr>
}
    3868:	bd80      	pop	{r7, pc}
    386a:	bf00      	nop

0000386c <FabricIrq3_IRQHandler>:

void FabricIrq3_IRQHandler(void)
{
    386c:	b580      	push	{r7, lr}
    386e:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c3);
    3870:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    3874:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3878:	f006 fb42 	bl	9f00 <I2C_isr>
}
    387c:	bd80      	pop	{r7, pc}
    387e:	bf00      	nop

00003880 <FabricIrq4_IRQHandler>:

void FabricIrq4_IRQHandler(void)
{
    3880:	b580      	push	{r7, lr}
    3882:	af00      	add	r7, sp, #0
    HK_ISR();
    3884:	f7fe ffc0 	bl	2808 <HK_ISR>

}
    3888:	bd80      	pop	{r7, pc}
    388a:	bf00      	nop

0000388c <FabricIrq5_IRQHandler>:

void FabricIrq5_IRQHandler(void)
{
    388c:	b580      	push	{r7, lr}
    388e:	af00      	add	r7, sp, #0
    COMMS_ISR();
    3890:	f7ff f992 	bl	2bb8 <COMMS_ISR>
}
    3894:	bd80      	pop	{r7, pc}
    3896:	bf00      	nop

00003898 <FabricIrq6_IRQHandler>:

void FabricIrq6_IRQHandler(void)
{
    3898:	b580      	push	{r7, lr}
    389a:	af00      	add	r7, sp, #0
    THER_ISR();
    389c:	f7ff fa78 	bl	2d90 <THER_ISR>
}
    38a0:	bd80      	pop	{r7, pc}
    38a2:	bf00      	nop

000038a4 <FabricIrq7_IRQHandler>:

void FabricIrq7_IRQHandler(void)
{
    38a4:	b580      	push	{r7, lr}
    38a6:	af00      	add	r7, sp, #0
    SD_ISR();
    38a8:	f7ff fb5e 	bl	2f68 <SD_ISR>
}
    38ac:	bd80      	pop	{r7, pc}
    38ae:	bf00      	nop

000038b0 <FabricIrq8_IRQHandler>:

void FabricIrq8_IRQHandler(void)
{
    38b0:	b580      	push	{r7, lr}
    38b2:	af00      	add	r7, sp, #0
    GMC_ISR();
    38b4:	f7ff f894 	bl	29e0 <GMC_ISR>
}
    38b8:	bd80      	pop	{r7, pc}
    38ba:	bf00      	nop

000038bc <cmd_valid>:
extern uint8_t IMG_ID;

uint32_t REPRO_CODE_WORD_ADDR = 0x60033000;
uint8_t* code_word = (uint8_t*) 0x60033000;

uint8_t cmd_valid(rx_cmd_t* rx_cmd, uint8_t src){
    38bc:	b480      	push	{r7}
    38be:	b083      	sub	sp, #12
    38c0:	af00      	add	r7, sp, #0
    38c2:	6078      	str	r0, [r7, #4]
    38c4:	460b      	mov	r3, r1
    38c6:	70fb      	strb	r3, [r7, #3]
	//Logic to check validity of the command ID within limits along with the params limits.

	if(rx_cmd->cmd_id - 1 >= 0x00 && rx_cmd->cmd_id - 1 <= NUM_CMDS){
    38c8:	687b      	ldr	r3, [r7, #4]
    38ca:	781b      	ldrb	r3, [r3, #0]
    38cc:	f103 33ff 	add.w	r3, r3, #4294967295
    38d0:	2b00      	cmp	r3, #0
    38d2:	db08      	blt.n	38e6 <cmd_valid+0x2a>
    38d4:	687b      	ldr	r3, [r7, #4]
    38d6:	781b      	ldrb	r3, [r3, #0]
    38d8:	f103 33ff 	add.w	r3, r3, #4294967295
    38dc:	2b05      	cmp	r3, #5
    38de:	dc02      	bgt.n	38e6 <cmd_valid+0x2a>
		return 1;  //Will be checking the validated of the checksum.
    38e0:	f04f 0301 	mov.w	r3, #1
    38e4:	e001      	b.n	38ea <cmd_valid+0x2e>
	}
	else{
		return 0;
    38e6:	f04f 0300 	mov.w	r3, #0
	}

}
    38ea:	4618      	mov	r0, r3
    38ec:	f107 070c 	add.w	r7, r7, #12
    38f0:	46bd      	mov	sp, r7
    38f2:	bc80      	pop	{r7}
    38f4:	4770      	bx	lr
    38f6:	bf00      	nop

000038f8 <add_cmd>:


void add_cmd(uint8_t id, uint16_t length, void (*ex_func)(uint8_t id, rx_cmd_t* rcv_cmd)){
    38f8:	b480      	push	{r7}
    38fa:	b083      	sub	sp, #12
    38fc:	af00      	add	r7, sp, #0
    38fe:	460b      	mov	r3, r1
    3900:	603a      	str	r2, [r7, #0]
    3902:	4602      	mov	r2, r0
    3904:	71fa      	strb	r2, [r7, #7]
    3906:	80bb      	strh	r3, [r7, #4]

	cmd_list[id].id = id;
    3908:	79f9      	ldrb	r1, [r7, #7]
    390a:	f24c 4244 	movw	r2, #50244	; 0xc444
    390e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    3912:	460b      	mov	r3, r1
    3914:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3918:	ebc1 0303 	rsb	r3, r1, r3
    391c:	4413      	add	r3, r2
    391e:	79fa      	ldrb	r2, [r7, #7]
    3920:	701a      	strb	r2, [r3, #0]
	cmd_list[id].length = length;
    3922:	79f9      	ldrb	r1, [r7, #7]
    3924:	f24c 4244 	movw	r2, #50244	; 0xc444
    3928:	f2c2 0200 	movt	r2, #8192	; 0x2000
    392c:	460b      	mov	r3, r1
    392e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3932:	ebc1 0303 	rsb	r3, r1, r3
    3936:	4413      	add	r3, r2
    3938:	793a      	ldrb	r2, [r7, #4]
    393a:	f04f 0100 	mov.w	r1, #0
    393e:	ea41 0202 	orr.w	r2, r1, r2
    3942:	705a      	strb	r2, [r3, #1]
    3944:	797a      	ldrb	r2, [r7, #5]
    3946:	f04f 0100 	mov.w	r1, #0
    394a:	ea41 0202 	orr.w	r2, r1, r2
    394e:	709a      	strb	r2, [r3, #2]
	cmd_list[id].ex_func = ex_func;
    3950:	79f8      	ldrb	r0, [r7, #7]
    3952:	683a      	ldr	r2, [r7, #0]
    3954:	f24c 4144 	movw	r1, #50244	; 0xc444
    3958:	f2c2 0100 	movt	r1, #8192	; 0x2000
    395c:	4603      	mov	r3, r0
    395e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3962:	ebc0 0303 	rsb	r3, r0, r3
    3966:	440b      	add	r3, r1
    3968:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    396c:	f04f 0000 	mov.w	r0, #0
    3970:	ea40 0101 	orr.w	r1, r0, r1
    3974:	70d9      	strb	r1, [r3, #3]
    3976:	ea4f 2112 	mov.w	r1, r2, lsr #8
    397a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    397e:	f04f 0000 	mov.w	r0, #0
    3982:	ea40 0101 	orr.w	r1, r0, r1
    3986:	7119      	strb	r1, [r3, #4]
    3988:	ea4f 4112 	mov.w	r1, r2, lsr #16
    398c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    3990:	f04f 0000 	mov.w	r0, #0
    3994:	ea40 0101 	orr.w	r1, r0, r1
    3998:	7159      	strb	r1, [r3, #5]
    399a:	ea4f 6212 	mov.w	r2, r2, lsr #24
    399e:	f04f 0100 	mov.w	r1, #0
    39a2:	ea41 0202 	orr.w	r2, r1, r2
    39a6:	719a      	strb	r2, [r3, #6]

}
    39a8:	f107 070c 	add.w	r7, r7, #12
    39ac:	46bd      	mov	sp, r7
    39ae:	bc80      	pop	{r7}
    39b0:	4770      	bx	lr
    39b2:	bf00      	nop

000039b4 <cmd_engine>:

void cmd_engine(rx_cmd_t* rx_cmd){
    39b4:	b580      	push	{r7, lr}
    39b6:	b082      	sub	sp, #8
    39b8:	af00      	add	r7, sp, #0
    39ba:	6078      	str	r0, [r7, #4]

	   //the actual command apid's is one greater than this.
//	add_cmd(2, 2, cmd_sc_reset);

	cmd_list[rx_cmd->cmd_id - 1].ex_func(rx_cmd);
    39bc:	687b      	ldr	r3, [r7, #4]
    39be:	781b      	ldrb	r3, [r3, #0]
    39c0:	f103 31ff 	add.w	r1, r3, #4294967295
    39c4:	f24c 4244 	movw	r2, #50244	; 0xc444
    39c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    39cc:	460b      	mov	r3, r1
    39ce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    39d2:	ebc1 0303 	rsb	r3, r1, r3
    39d6:	4413      	add	r3, r2
    39d8:	78da      	ldrb	r2, [r3, #3]
    39da:	7919      	ldrb	r1, [r3, #4]
    39dc:	ea4f 2101 	mov.w	r1, r1, lsl #8
    39e0:	ea41 0202 	orr.w	r2, r1, r2
    39e4:	7959      	ldrb	r1, [r3, #5]
    39e6:	ea4f 4101 	mov.w	r1, r1, lsl #16
    39ea:	ea41 0202 	orr.w	r2, r1, r2
    39ee:	799b      	ldrb	r3, [r3, #6]
    39f0:	ea4f 6303 	mov.w	r3, r3, lsl #24
    39f4:	ea43 0302 	orr.w	r3, r3, r2
    39f8:	6878      	ldr	r0, [r7, #4]
    39fa:	4798      	blx	r3

}
    39fc:	f107 0708 	add.w	r7, r7, #8
    3a00:	46bd      	mov	sp, r7
    3a02:	bd80      	pop	{r7, pc}

00003a04 <cmd_noop>:

// Commands Definition

void cmd_noop(rx_cmd_t* rcv_cmd){
    3a04:	b480      	push	{r7}
    3a06:	b085      	sub	sp, #20
    3a08:	af00      	add	r7, sp, #0
    3a0a:	6078      	str	r0, [r7, #4]

	uint8_t a;

}
    3a0c:	f107 0714 	add.w	r7, r7, #20
    3a10:	46bd      	mov	sp, r7
    3a12:	bc80      	pop	{r7}
    3a14:	4770      	bx	lr
    3a16:	bf00      	nop

00003a18 <set_pkt_rate>:

void set_pkt_rate(rx_cmd_t* rcv_cmd){
    3a18:	b580      	push	{r7, lr}
    3a1a:	b086      	sub	sp, #24
    3a1c:	af02      	add	r7, sp, #8
    3a1e:	6078      	str	r0, [r7, #4]

	uint32_t new_time_period = MSS_SYS_M3_CLK_FREQ/1024 * (rcv_cmd->parameters[1] / 10);
    3a20:	687b      	ldr	r3, [r7, #4]
    3a22:	789a      	ldrb	r2, [r3, #2]
    3a24:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    3a28:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
    3a2c:	fba3 1302 	umull	r1, r3, r3, r2
    3a30:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    3a34:	b2db      	uxtb	r3, r3
    3a36:	f247 2270 	movw	r2, #29296	; 0x7270
    3a3a:	fb02 f303 	mul.w	r3, r2, r3
    3a3e:	60fb      	str	r3, [r7, #12]

	if(rcv_cmd->parameters[1] != 0){
    3a40:	687b      	ldr	r3, [r7, #4]
    3a42:	789b      	ldrb	r3, [r3, #2]
    3a44:	2b00      	cmp	r3, #0
    3a46:	f000 80a5 	beq.w	3b94 <set_pkt_rate+0x17c>
		if(rcv_cmd->parameters[0] == hk){
    3a4a:	687b      	ldr	r3, [r7, #4]
    3a4c:	785b      	ldrb	r3, [r3, #1]
    3a4e:	2b00      	cmp	r3, #0
    3a50:	d11c      	bne.n	3a8c <set_pkt_rate+0x74>
			TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
    3a52:	68fb      	ldr	r3, [r7, #12]
    3a54:	9300      	str	r3, [sp, #0]
    3a56:	f24c 401c 	movw	r0, #50204	; 0xc41c
    3a5a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3a5e:	f246 0100 	movw	r1, #24576	; 0x6000
    3a62:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3a66:	f04f 0200 	mov.w	r2, #0
    3a6a:	f04f 0309 	mov.w	r3, #9
    3a6e:	f005 fbb7 	bl	91e0 <TMR_init>
			TMR_enable_int(&hk_timer);
    3a72:	f24c 401c 	movw	r0, #50204	; 0xc41c
    3a76:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3a7a:	f005 fc55 	bl	9328 <TMR_enable_int>
			TMR_start(&hk_timer);
    3a7e:	f24c 401c 	movw	r0, #50204	; 0xc41c
    3a82:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3a86:	f005 fc13 	bl	92b0 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
    3a8a:	e0bb      	b.n	3c04 <set_pkt_rate+0x1ec>
		if(rcv_cmd->parameters[0] == hk){
			TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&hk_timer);
			TMR_start(&hk_timer);
		}
		else if(rcv_cmd->parameters[0] == comms){
    3a8c:	687b      	ldr	r3, [r7, #4]
    3a8e:	785b      	ldrb	r3, [r3, #1]
    3a90:	2b01      	cmp	r3, #1
    3a92:	d11c      	bne.n	3ace <set_pkt_rate+0xb6>
			TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
    3a94:	68fb      	ldr	r3, [r7, #12]
    3a96:	9300      	str	r3, [sp, #0]
    3a98:	f24c 1094 	movw	r0, #49556	; 0xc194
    3a9c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3aa0:	f247 0100 	movw	r1, #28672	; 0x7000
    3aa4:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3aa8:	f04f 0200 	mov.w	r2, #0
    3aac:	f04f 0309 	mov.w	r3, #9
    3ab0:	f005 fb96 	bl	91e0 <TMR_init>
			TMR_enable_int(&comms_timer);
    3ab4:	f24c 1094 	movw	r0, #49556	; 0xc194
    3ab8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3abc:	f005 fc34 	bl	9328 <TMR_enable_int>
			TMR_start(&comms_timer);
    3ac0:	f24c 1094 	movw	r0, #49556	; 0xc194
    3ac4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3ac8:	f005 fbf2 	bl	92b0 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
    3acc:	e09a      	b.n	3c04 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == comms){
			TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&comms_timer);
			TMR_start(&comms_timer);
		}
		else if(rcv_cmd->parameters[0] == thermistor){
    3ace:	687b      	ldr	r3, [r7, #4]
    3ad0:	785b      	ldrb	r3, [r3, #1]
    3ad2:	2b02      	cmp	r3, #2
    3ad4:	d11c      	bne.n	3b10 <set_pkt_rate+0xf8>
			TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
    3ad6:	68fb      	ldr	r3, [r7, #12]
    3ad8:	9300      	str	r3, [sp, #0]
    3ada:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3ade:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3ae2:	f248 0100 	movw	r1, #32768	; 0x8000
    3ae6:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3aea:	f04f 0200 	mov.w	r2, #0
    3aee:	f04f 0309 	mov.w	r3, #9
    3af2:	f005 fb75 	bl	91e0 <TMR_init>
			TMR_enable_int(&temp_timer);
    3af6:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3afa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3afe:	f005 fc13 	bl	9328 <TMR_enable_int>
			TMR_start(&temp_timer);
    3b02:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3b06:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b0a:	f005 fbd1 	bl	92b0 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
    3b0e:	e079      	b.n	3c04 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == thermistor){
			TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&temp_timer);
			TMR_start(&temp_timer);
		}
		else if(rcv_cmd->parameters[0] == sd){
    3b10:	687b      	ldr	r3, [r7, #4]
    3b12:	785b      	ldrb	r3, [r3, #1]
    3b14:	2b05      	cmp	r3, #5
    3b16:	d11c      	bne.n	3b52 <set_pkt_rate+0x13a>
			TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
    3b18:	68fb      	ldr	r3, [r7, #12]
    3b1a:	9300      	str	r3, [sp, #0]
    3b1c:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3b20:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b24:	f249 0100 	movw	r1, #36864	; 0x9000
    3b28:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3b2c:	f04f 0200 	mov.w	r2, #0
    3b30:	f04f 0309 	mov.w	r3, #9
    3b34:	f005 fb54 	bl	91e0 <TMR_init>
			TMR_enable_int(&sd_timer);
    3b38:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3b3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b40:	f005 fbf2 	bl	9328 <TMR_enable_int>
			TMR_start(&sd_timer);
    3b44:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3b48:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b4c:	f005 fbb0 	bl	92b0 <TMR_start>
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
    3b50:	e058      	b.n	3c04 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == sd){
			TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&sd_timer);
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
    3b52:	687b      	ldr	r3, [r7, #4]
    3b54:	785b      	ldrb	r3, [r3, #1]
    3b56:	2b03      	cmp	r3, #3
    3b58:	d153      	bne.n	3c02 <set_pkt_rate+0x1ea>
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
    3b5a:	68fb      	ldr	r3, [r7, #12]
    3b5c:	9300      	str	r3, [sp, #0]
    3b5e:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    3b62:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b66:	f24a 0100 	movw	r1, #40960	; 0xa000
    3b6a:	f2c5 0100 	movt	r1, #20480	; 0x5000
    3b6e:	f04f 0200 	mov.w	r2, #0
    3b72:	f04f 0309 	mov.w	r3, #9
    3b76:	f005 fb33 	bl	91e0 <TMR_init>
			TMR_enable_int(&gmc_timer);
    3b7a:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    3b7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b82:	f005 fbd1 	bl	9328 <TMR_enable_int>
			TMR_start(&gmc_timer);
    3b86:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    3b8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3b8e:	f005 fb8f 	bl	92b0 <TMR_start>
    3b92:	e037      	b.n	3c04 <set_pkt_rate+0x1ec>
		}
	}
	else{
		//Here, instead of disabling the NVIC interrupts, we can stop the timer, so that the packetisation can again be restarted with another command
		if(rcv_cmd->parameters[0] == hk){
    3b94:	687b      	ldr	r3, [r7, #4]
    3b96:	785b      	ldrb	r3, [r3, #1]
    3b98:	2b00      	cmp	r3, #0
    3b9a:	d106      	bne.n	3baa <set_pkt_rate+0x192>
			TMR_stop(&hk_timer);
    3b9c:	f24c 401c 	movw	r0, #50204	; 0xc41c
    3ba0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3ba4:	f005 fba2 	bl	92ec <TMR_stop>
    3ba8:	e02c      	b.n	3c04 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq4_IRQn);
		}
		else if(rcv_cmd->parameters[0] == comms){
    3baa:	687b      	ldr	r3, [r7, #4]
    3bac:	785b      	ldrb	r3, [r3, #1]
    3bae:	2b01      	cmp	r3, #1
    3bb0:	d106      	bne.n	3bc0 <set_pkt_rate+0x1a8>
			TMR_stop(&comms_timer);
    3bb2:	f24c 1094 	movw	r0, #49556	; 0xc194
    3bb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3bba:	f005 fb97 	bl	92ec <TMR_stop>
    3bbe:	e021      	b.n	3c04 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq5_IRQn);
		}
		else if(rcv_cmd->parameters[0] == thermistor){
    3bc0:	687b      	ldr	r3, [r7, #4]
    3bc2:	785b      	ldrb	r3, [r3, #1]
    3bc4:	2b02      	cmp	r3, #2
    3bc6:	d106      	bne.n	3bd6 <set_pkt_rate+0x1be>
			TMR_stop(&temp_timer);
    3bc8:	f24c 30c0 	movw	r0, #50112	; 0xc3c0
    3bcc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3bd0:	f005 fb8c 	bl	92ec <TMR_stop>
    3bd4:	e016      	b.n	3c04 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq6_IRQn);
		}
		else if(rcv_cmd->parameters[0] == sd){
    3bd6:	687b      	ldr	r3, [r7, #4]
    3bd8:	785b      	ldrb	r3, [r3, #1]
    3bda:	2b05      	cmp	r3, #5
    3bdc:	d106      	bne.n	3bec <set_pkt_rate+0x1d4>
			TMR_stop(&sd_timer);
    3bde:	f24c 30d0 	movw	r0, #50128	; 0xc3d0
    3be2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3be6:	f005 fb81 	bl	92ec <TMR_stop>
    3bea:	e00b      	b.n	3c04 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq7_IRQn);
		}
		else if(rcv_cmd->parameters[0] == gmc){
    3bec:	687b      	ldr	r3, [r7, #4]
    3bee:	785b      	ldrb	r3, [r3, #1]
    3bf0:	2b03      	cmp	r3, #3
    3bf2:	d107      	bne.n	3c04 <set_pkt_rate+0x1ec>
			TMR_stop(&gmc_timer);
    3bf4:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
    3bf8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3bfc:	f005 fb76 	bl	92ec <TMR_stop>
    3c00:	e000      	b.n	3c04 <set_pkt_rate+0x1ec>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
    3c02:	bf00      	nop
			TMR_stop(&gmc_timer);
//			NVIC_DisableIRQ(FabricIrq8_IRQn);
		}
	}

}
    3c04:	f107 0710 	add.w	r7, r7, #16
    3c08:	46bd      	mov	sp, r7
    3c0a:	bd80      	pop	{r7, pc}

00003c0c <copy_esram_image>:
		n--;
	}
}

void copy_esram_image()
{
    3c0c:	b480      	push	{r7}
    3c0e:	b085      	sub	sp, #20
    3c10:	af00      	add	r7, sp, #0
    unsigned int ii=0;
    3c12:	f04f 0300 	mov.w	r3, #0
    3c16:	607b      	str	r3, [r7, #4]
    unsigned long *exeDestAddr, *exeSrcAddr;

    exeDestAddr = (unsigned long *)0x20008000;
    3c18:	f248 0300 	movw	r3, #32768	; 0x8000
    3c1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c20:	60bb      	str	r3, [r7, #8]
    exeSrcAddr = (unsigned long *)0x6000D000;
    3c22:	f24d 0300 	movw	r3, #53248	; 0xd000
    3c26:	f2c6 0300 	movt	r3, #24576	; 0x6000
    3c2a:	60fb      	str	r3, [r7, #12]
    /* 60 K B = 61440/4 ptr increments by 4bytes*/
    for (ii=0; ii<2764; ii++ )
    3c2c:	f04f 0300 	mov.w	r3, #0
    3c30:	607b      	str	r3, [r7, #4]
    3c32:	e00f      	b.n	3c54 <copy_esram_image+0x48>
    {
    	*exeDestAddr++ = *exeSrcAddr++;
    3c34:	68fb      	ldr	r3, [r7, #12]
    3c36:	681a      	ldr	r2, [r3, #0]
    3c38:	68bb      	ldr	r3, [r7, #8]
    3c3a:	601a      	str	r2, [r3, #0]
    3c3c:	68bb      	ldr	r3, [r7, #8]
    3c3e:	f103 0304 	add.w	r3, r3, #4
    3c42:	60bb      	str	r3, [r7, #8]
    3c44:	68fb      	ldr	r3, [r7, #12]
    3c46:	f103 0304 	add.w	r3, r3, #4
    3c4a:	60fb      	str	r3, [r7, #12]
    unsigned long *exeDestAddr, *exeSrcAddr;

    exeDestAddr = (unsigned long *)0x20008000;
    exeSrcAddr = (unsigned long *)0x6000D000;
    /* 60 K B = 61440/4 ptr increments by 4bytes*/
    for (ii=0; ii<2764; ii++ )
    3c4c:	687b      	ldr	r3, [r7, #4]
    3c4e:	f103 0301 	add.w	r3, r3, #1
    3c52:	607b      	str	r3, [r7, #4]
    3c54:	687a      	ldr	r2, [r7, #4]
    3c56:	f640 23cb 	movw	r3, #2763	; 0xacb
    3c5a:	429a      	cmp	r2, r3
    3c5c:	d9ea      	bls.n	3c34 <copy_esram_image+0x28>
    {
    	*exeDestAddr++ = *exeSrcAddr++;
    }

}
    3c5e:	f107 0714 	add.w	r7, r7, #20
    3c62:	46bd      	mov	sp, r7
    3c64:	bc80      	pop	{r7}
    3c66:	4770      	bx	lr

00003c68 <remap_user_code_eSRAM_0>:

void __attribute__((optimize("O0"))) remap_user_code_eSRAM_0(void)
{
    3c68:	b580      	push	{r7, lr}
    3c6a:	b082      	sub	sp, #8
    3c6c:	af00      	add	r7, sp, #0
//	 while(1){ };            //This instruction never executed
//	}



	int * address = (int *)0x20008004;
    3c6e:	f248 0304 	movw	r3, #32772	; 0x8004
    3c72:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c76:	603b      	str	r3, [r7, #0]
	__set_MSP(*(int*)0x20008000);
    3c78:	f248 0300 	movw	r3, #32768	; 0x8000
    3c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c80:	681b      	ldr	r3, [r3, #0]
    3c82:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
    3c84:	687b      	ldr	r3, [r7, #4]
    3c86:	f383 8808 	msr	MSP, r3
	SYSREG->ESRAM_CR |= 0x3;
    3c8a:	f248 0300 	movw	r3, #32768	; 0x8000
    3c8e:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3c92:	f248 0200 	movw	r2, #32768	; 0x8000
    3c96:	f2c4 0203 	movt	r2, #16387	; 0x4003
    3c9a:	6812      	ldr	r2, [r2, #0]
    3c9c:	f042 0203 	orr.w	r2, r2, #3
    3ca0:	601a      	str	r2, [r3, #0]
	((void (*)())(*address))();
    3ca2:	683b      	ldr	r3, [r7, #0]
    3ca4:	681b      	ldr	r3, [r3, #0]
    3ca6:	4798      	blx	r3
	while(1){ };
    3ca8:	e7fe      	b.n	3ca8 <remap_user_code_eSRAM_0+0x40>
    3caa:	bf00      	nop

00003cac <exe_iap>:
}

void exe_iap(rx_cmd_t* rcv_cmd){
    3cac:	b580      	push	{r7, lr}
    3cae:	b084      	sub	sp, #16
    3cb0:	af00      	add	r7, sp, #0
    3cb2:	6078      	str	r0, [r7, #4]
//			else{
//				prog_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_PROGRAM, 0x001000);
//			}
//		}

	SYSREG->WDOG_CR = 0x00000000;
    3cb4:	f248 0300 	movw	r3, #32768	; 0x8000
    3cb8:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3cbc:	f04f 0200 	mov.w	r2, #0
    3cc0:	66da      	str	r2, [r3, #108]	; 0x6c

	copy_esram_image();
    3cc2:	f7ff ffa3 	bl	3c0c <copy_esram_image>

	remap_user_code_eSRAM_0();
    3cc6:	f7ff ffcf 	bl	3c68 <remap_user_code_eSRAM_0>
//	}

}
    3cca:	f107 0710 	add.w	r7, r7, #16
    3cce:	46bd      	mov	sp, r7
    3cd0:	bd80      	pop	{r7, pc}
    3cd2:	bf00      	nop

00003cd4 <read_adf_reg>:

void read_adf_reg(rx_cmd_t* rcv_cmd){
    3cd4:	b580      	push	{r7, lr}
    3cd6:	b084      	sub	sp, #16
    3cd8:	af00      	add	r7, sp, #0
    3cda:	6078      	str	r0, [r7, #4]

	uint8_t data_read[6];
	uint8_t j;

	cmd_adf_read_addr = (rcv_cmd->parameters[1] << 24) | (rcv_cmd->parameters[2] << 16) | (rcv_cmd->parameters[3] << 8) | rcv_cmd->parameters[4];
    3cdc:	687b      	ldr	r3, [r7, #4]
    3cde:	789b      	ldrb	r3, [r3, #2]
    3ce0:	ea4f 6203 	mov.w	r2, r3, lsl #24
    3ce4:	687b      	ldr	r3, [r7, #4]
    3ce6:	78db      	ldrb	r3, [r3, #3]
    3ce8:	ea4f 4303 	mov.w	r3, r3, lsl #16
    3cec:	ea42 0203 	orr.w	r2, r2, r3
    3cf0:	687b      	ldr	r3, [r7, #4]
    3cf2:	791b      	ldrb	r3, [r3, #4]
    3cf4:	ea4f 2303 	mov.w	r3, r3, lsl #8
    3cf8:	ea42 0203 	orr.w	r2, r2, r3
    3cfc:	687b      	ldr	r3, [r7, #4]
    3cfe:	795b      	ldrb	r3, [r3, #5]
    3d00:	ea42 0303 	orr.w	r3, r2, r3
    3d04:	461a      	mov	r2, r3
    3d06:	f24b 3364 	movw	r3, #45924	; 0xb364
    3d0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d0e:	601a      	str	r2, [r3, #0]
	cmd_adf_read_No_double_words = rcv_cmd->parameters[0];
    3d10:	687b      	ldr	r3, [r7, #4]
    3d12:	785a      	ldrb	r2, [r3, #1]
    3d14:	f24b 3368 	movw	r3, #45928	; 0xb368
    3d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d1c:	701a      	strb	r2, [r3, #0]

	adf_read_from_memory(RMODE_1, cmd_adf_read_addr, data_read, 6);
    3d1e:	f24b 3364 	movw	r3, #45924	; 0xb364
    3d22:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d26:	681a      	ldr	r2, [r3, #0]
    3d28:	f107 0308 	add.w	r3, r7, #8
    3d2c:	f04f 0078 	mov.w	r0, #120	; 0x78
    3d30:	4611      	mov	r1, r2
    3d32:	461a      	mov	r2, r3
    3d34:	f04f 0306 	mov.w	r3, #6
    3d38:	f002 f856 	bl	5de8 <adf_read_from_memory>

	cmd_adf_data[0] = (data_read[2] << 24) | (data_read[3] << 16) | (data_read[4] << 8) | (data_read[5]);
    3d3c:	7abb      	ldrb	r3, [r7, #10]
    3d3e:	ea4f 6203 	mov.w	r2, r3, lsl #24
    3d42:	7afb      	ldrb	r3, [r7, #11]
    3d44:	ea4f 4303 	mov.w	r3, r3, lsl #16
    3d48:	ea42 0203 	orr.w	r2, r2, r3
    3d4c:	7b3b      	ldrb	r3, [r7, #12]
    3d4e:	ea4f 2303 	mov.w	r3, r3, lsl #8
    3d52:	ea42 0203 	orr.w	r2, r2, r3
    3d56:	7b7b      	ldrb	r3, [r7, #13]
    3d58:	ea42 0303 	orr.w	r3, r2, r3
    3d5c:	461a      	mov	r2, r3
    3d5e:	f24c 1358 	movw	r3, #49496	; 0xc158
    3d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d66:	601a      	str	r2, [r3, #0]

	cmd_adf_read_addr += 4;
    3d68:	f24b 3364 	movw	r3, #45924	; 0xb364
    3d6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d70:	681b      	ldr	r3, [r3, #0]
    3d72:	f103 0204 	add.w	r2, r3, #4
    3d76:	f24b 3364 	movw	r3, #45924	; 0xb364
    3d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d7e:	601a      	str	r2, [r3, #0]

	adf_read_from_memory(RMODE_1, cmd_adf_read_addr, data_read, 6);
    3d80:	f24b 3364 	movw	r3, #45924	; 0xb364
    3d84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d88:	681a      	ldr	r2, [r3, #0]
    3d8a:	f107 0308 	add.w	r3, r7, #8
    3d8e:	f04f 0078 	mov.w	r0, #120	; 0x78
    3d92:	4611      	mov	r1, r2
    3d94:	461a      	mov	r2, r3
    3d96:	f04f 0306 	mov.w	r3, #6
    3d9a:	f002 f825 	bl	5de8 <adf_read_from_memory>

	cmd_adf_data[1] = (data_read[2] << 24) | (data_read[3] << 16) | (data_read[4] << 8) | (data_read[5]);
    3d9e:	7abb      	ldrb	r3, [r7, #10]
    3da0:	ea4f 6203 	mov.w	r2, r3, lsl #24
    3da4:	7afb      	ldrb	r3, [r7, #11]
    3da6:	ea4f 4303 	mov.w	r3, r3, lsl #16
    3daa:	ea42 0203 	orr.w	r2, r2, r3
    3dae:	7b3b      	ldrb	r3, [r7, #12]
    3db0:	ea4f 2303 	mov.w	r3, r3, lsl #8
    3db4:	ea42 0203 	orr.w	r2, r2, r3
    3db8:	7b7b      	ldrb	r3, [r7, #13]
    3dba:	ea42 0303 	orr.w	r3, r2, r3
    3dbe:	461a      	mov	r2, r3
    3dc0:	f24c 1358 	movw	r3, #49496	; 0xc158
    3dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3dc8:	605a      	str	r2, [r3, #4]


}
    3dca:	f107 0710 	add.w	r7, r7, #16
    3dce:	46bd      	mov	sp, r7
    3dd0:	bd80      	pop	{r7, pc}
    3dd2:	bf00      	nop

00003dd4 <exe_rtm>:

void exe_rtm(rx_cmd_t* rcv_cmd){
    3dd4:	b480      	push	{r7}
    3dd6:	b085      	sub	sp, #20
    3dd8:	af00      	add	r7, sp, #0
    3dda:	6078      	str	r0, [r7, #4]
	uint8_t i = 0;
    3ddc:	f04f 0300 	mov.w	r3, #0
    3de0:	73fb      	strb	r3, [r7, #15]

	for(;i<16;i++){
    3de2:	e00d      	b.n	3e00 <exe_rtm+0x2c>
		RTM[i] = rcv_cmd->parameters[i];
    3de4:	7bfa      	ldrb	r2, [r7, #15]
    3de6:	7bf9      	ldrb	r1, [r7, #15]
    3de8:	687b      	ldr	r3, [r7, #4]
    3dea:	440b      	add	r3, r1
    3dec:	7859      	ldrb	r1, [r3, #1]
    3dee:	f24c 03b8 	movw	r3, #49336	; 0xc0b8
    3df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3df6:	5499      	strb	r1, [r3, r2]
}

void exe_rtm(rx_cmd_t* rcv_cmd){
	uint8_t i = 0;

	for(;i<16;i++){
    3df8:	7bfb      	ldrb	r3, [r7, #15]
    3dfa:	f103 0301 	add.w	r3, r3, #1
    3dfe:	73fb      	strb	r3, [r7, #15]
    3e00:	7bfb      	ldrb	r3, [r7, #15]
    3e02:	2b0f      	cmp	r3, #15
    3e04:	d9ee      	bls.n	3de4 <exe_rtm+0x10>
		RTM[i] = rcv_cmd->parameters[i];
	}

}
    3e06:	f107 0714 	add.w	r7, r7, #20
    3e0a:	46bd      	mov	sp, r7
    3e0c:	bc80      	pop	{r7}
    3e0e:	4770      	bx	lr

00003e10 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    3e10:	b480      	push	{r7}
    3e12:	b083      	sub	sp, #12
    3e14:	af00      	add	r7, sp, #0
    3e16:	4603      	mov	r3, r0
    3e18:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    3e1a:	f24e 1300 	movw	r3, #57600	; 0xe100
    3e1e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    3e22:	f997 2007 	ldrsb.w	r2, [r7, #7]
    3e26:	ea4f 1252 	mov.w	r2, r2, lsr #5
    3e2a:	79f9      	ldrb	r1, [r7, #7]
    3e2c:	f001 011f 	and.w	r1, r1, #31
    3e30:	f04f 0001 	mov.w	r0, #1
    3e34:	fa00 f101 	lsl.w	r1, r0, r1
    3e38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    3e3c:	f107 070c 	add.w	r7, r7, #12
    3e40:	46bd      	mov	sp, r7
    3e42:	bc80      	pop	{r7}
    3e44:	4770      	bx	lr
    3e46:	bf00      	nop

00003e48 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number. 
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    3e48:	b480      	push	{r7}
    3e4a:	b083      	sub	sp, #12
    3e4c:	af00      	add	r7, sp, #0
    3e4e:	4603      	mov	r3, r0
    3e50:	6039      	str	r1, [r7, #0]
    3e52:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
    3e54:	f997 3007 	ldrsb.w	r3, [r7, #7]
    3e58:	2b00      	cmp	r3, #0
    3e5a:	da10      	bge.n	3e7e <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
    3e5c:	f64e 5300 	movw	r3, #60672	; 0xed00
    3e60:	f2ce 0300 	movt	r3, #57344	; 0xe000
    3e64:	79fa      	ldrb	r2, [r7, #7]
    3e66:	f002 020f 	and.w	r2, r2, #15
    3e6a:	f1a2 0104 	sub.w	r1, r2, #4
    3e6e:	683a      	ldr	r2, [r7, #0]
    3e70:	b2d2      	uxtb	r2, r2
    3e72:	ea4f 1202 	mov.w	r2, r2, lsl #4
    3e76:	b2d2      	uxtb	r2, r2
    3e78:	440b      	add	r3, r1
    3e7a:	761a      	strb	r2, [r3, #24]
    3e7c:	e00d      	b.n	3e9a <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
    3e7e:	f24e 1300 	movw	r3, #57600	; 0xe100
    3e82:	f2ce 0300 	movt	r3, #57344	; 0xe000
    3e86:	f997 1007 	ldrsb.w	r1, [r7, #7]
    3e8a:	683a      	ldr	r2, [r7, #0]
    3e8c:	b2d2      	uxtb	r2, r2
    3e8e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    3e92:	b2d2      	uxtb	r2, r2
    3e94:	440b      	add	r3, r1
    3e96:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    3e9a:	f107 070c 	add.w	r7, r7, #12
    3e9e:	46bd      	mov	sp, r7
    3ea0:	bc80      	pop	{r7}
    3ea2:	4770      	bx	lr

00003ea4 <GPIO1_IRQHandler>:
extern timer_instance_t sd_timer;
extern uint8_t Time_Vector[32];

uint8_t no_of_TTPU_cmds = 0;

void GPIO1_IRQHandler( void ){
    3ea4:	b580      	push	{r7, lr}
    3ea6:	b084      	sub	sp, #16
    3ea8:	af00      	add	r7, sp, #0
    uint16_t a, i = 0;
    3eaa:	f04f 0300 	mov.w	r3, #0
    3eae:	817b      	strh	r3, [r7, #10]
    a  = 1;
    3eb0:	f04f 0301 	mov.w	r3, #1
    3eb4:	813b      	strh	r3, [r7, #8]
    uint16_t buf[1];
    uint16_t r_addr, w_addr;
    buf[0] = 0xFF;
    3eb6:	f04f 03ff 	mov.w	r3, #255	; 0xff
    3eba:	80bb      	strh	r3, [r7, #4]
//
		r_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_RADDR);
    3ebc:	f245 000c 	movw	r0, #20492	; 0x500c
    3ec0:	f2c5 0000 	movt	r0, #20480	; 0x5000
    3ec4:	f002 fae0 	bl	6488 <HW_get_16bit_reg>
    3ec8:	4603      	mov	r3, r0
    3eca:	81bb      	strh	r3, [r7, #12]
		w_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_WADDR);
    3ecc:	f245 0010 	movw	r0, #20496	; 0x5010
    3ed0:	f2c5 0000 	movt	r0, #20480	; 0x5000
    3ed4:	f002 fad8 	bl	6488 <HW_get_16bit_reg>
    3ed8:	4603      	mov	r3, r0
    3eda:	81fb      	strh	r3, [r7, #14]

		//Start storing the packets in sd card

		store_in_sd_card = 1;
    3edc:	f24b 3359 	movw	r3, #45913	; 0xb359
    3ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ee4:	f04f 0201 	mov.w	r2, #1
    3ee8:	701a      	strb	r2, [r3, #0]


		MSS_GPIO_clear_irq(MSS_GPIO_1);
    3eea:	f04f 0001 	mov.w	r0, #1
    3eee:	f005 f957 	bl	91a0 <MSS_GPIO_clear_irq>
		return ;


    //Start storing in SD_CARD
    //Clear the interrupt after reading a 256 block packet
}
    3ef2:	f107 0710 	add.w	r7, r7, #16
    3ef6:	46bd      	mov	sp, r7
    3ef8:	bd80      	pop	{r7, pc}
    3efa:	bf00      	nop

00003efc <GPIO3_IRQHandler>:

void GPIO3_IRQHandler(void){
    3efc:	b580      	push	{r7, lr}
    3efe:	b08a      	sub	sp, #40	; 0x28
    3f00:	af00      	add	r7, sp, #0

//	uint8_t cmd[32];
//	for(;i<32;i++){
//		cmd[i] = HAL_get_8bit_reg(RS_485_Controller_0, READ_SRAM_CMD);
//	}
	uint8_t i = 0;
    3f02:	f04f 0300 	mov.w	r3, #0
    3f06:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	uint8_t cmd[32];
	no_of_TTPU_cmds++;
    3f0a:	f24b 3378 	movw	r3, #45944	; 0xb378
    3f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f12:	781b      	ldrb	r3, [r3, #0]
    3f14:	f103 0301 	add.w	r3, r3, #1
    3f18:	b2da      	uxtb	r2, r3
    3f1a:	f24b 3378 	movw	r3, #45944	; 0xb378
    3f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f22:	701a      	strb	r2, [r3, #0]

	if(no_of_TTPU_cmds == NUMBER_OF_REPRO_CMDS){
    3f24:	f24b 3378 	movw	r3, #45944	; 0xb378
    3f28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f2c:	781b      	ldrb	r3, [r3, #0]
    3f2e:	2b05      	cmp	r3, #5
    3f30:	d103      	bne.n	3f3a <GPIO3_IRQHandler+0x3e>
		cmd[0] = 0x03;
    3f32:	f04f 0303 	mov.w	r3, #3
    3f36:	713b      	strb	r3, [r7, #4]
    3f38:	e002      	b.n	3f40 <GPIO3_IRQHandler+0x44>
	}
	else{
		cmd[0] = 0x01;
    3f3a:	f04f 0301 	mov.w	r3, #1
    3f3e:	713b      	strb	r3, [r7, #4]
//
//	for(;i<32;i++){
//		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
//	}

	get_cmd(cmd, 0);
    3f40:	f107 0304 	add.w	r3, r7, #4
    3f44:	4618      	mov	r0, r3
    3f46:	f04f 0100 	mov.w	r1, #0
    3f4a:	f7ff f907 	bl	315c <get_cmd>
//	else{
//		cmd_rs485_fail_count++;
//	}


	MSS_GPIO_clear_irq( MSS_GPIO_3);
    3f4e:	f04f 0003 	mov.w	r0, #3
    3f52:	f005 f925 	bl	91a0 <MSS_GPIO_clear_irq>

}
    3f56:	f107 0728 	add.w	r7, r7, #40	; 0x28
    3f5a:	46bd      	mov	sp, r7
    3f5c:	bd80      	pop	{r7, pc}
    3f5e:	bf00      	nop

00003f60 <get_time_vector>:

void get_time_vector(){
    3f60:	b590      	push	{r4, r7, lr}
    3f62:	b083      	sub	sp, #12
    3f64:	af00      	add	r7, sp, #0

	uint8_t i = 0;
    3f66:	f04f 0300 	mov.w	r3, #0
    3f6a:	71fb      	strb	r3, [r7, #7]


	for(;i<32;i++){
    3f6c:	e011      	b.n	3f92 <get_time_vector+0x32>
		Time_Vector[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_SRAM_CMD);
    3f6e:	79fc      	ldrb	r4, [r7, #7]
    3f70:	f24c 000c 	movw	r0, #49164	; 0xc00c
    3f74:	f2c5 0000 	movt	r0, #20480	; 0x5000
    3f78:	f002 fa9e 	bl	64b8 <HW_get_8bit_reg>
    3f7c:	4603      	mov	r3, r0
    3f7e:	461a      	mov	r2, r3
    3f80:	f24c 4320 	movw	r3, #50208	; 0xc420
    3f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f88:	551a      	strb	r2, [r3, r4]
void get_time_vector(){

	uint8_t i = 0;


	for(;i<32;i++){
    3f8a:	79fb      	ldrb	r3, [r7, #7]
    3f8c:	f103 0301 	add.w	r3, r3, #1
    3f90:	71fb      	strb	r3, [r7, #7]
    3f92:	79fb      	ldrb	r3, [r7, #7]
    3f94:	2b1f      	cmp	r3, #31
    3f96:	d9ea      	bls.n	3f6e <get_time_vector+0xe>
		Time_Vector[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_SRAM_CMD);
	 }

}
    3f98:	f107 070c 	add.w	r7, r7, #12
    3f9c:	46bd      	mov	sp, r7
    3f9e:	bd90      	pop	{r4, r7, pc}

00003fa0 <init_RS485_Controller>:


uint8_t init_RS485_Controller(){
    3fa0:	b580      	push	{r7, lr}
    3fa2:	b084      	sub	sp, #16
    3fa4:	af00      	add	r7, sp, #0

    MSS_GPIO_config(MSS_GPIO_1, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);		//SRAM Full INTR
    3fa6:	f04f 0001 	mov.w	r0, #1
    3faa:	f04f 0142 	mov.w	r1, #66	; 0x42
    3fae:	f005 f871 	bl	9094 <MSS_GPIO_config>
    MSS_GPIO_enable_irq(MSS_GPIO_1);
    3fb2:	f04f 0001 	mov.w	r0, #1
    3fb6:	f005 f8c3 	bl	9140 <MSS_GPIO_enable_irq>
    NVIC_EnableIRQ(GPIO1_IRQn);
    3fba:	f04f 0033 	mov.w	r0, #51	; 0x33
    3fbe:	f7ff ff27 	bl	3e10 <NVIC_EnableIRQ>
    NVIC_SetPriority(GPIO1_IRQn, 255);
    3fc2:	f04f 0033 	mov.w	r0, #51	; 0x33
    3fc6:	f04f 01ff 	mov.w	r1, #255	; 0xff
    3fca:	f7ff ff3d 	bl	3e48 <NVIC_SetPriority>

    MSS_GPIO_config(MSS_GPIO_3, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_NEGATIVE);		//RS485_cmd_INTR
    3fce:	f04f 0003 	mov.w	r0, #3
    3fd2:	f04f 0162 	mov.w	r1, #98	; 0x62
    3fd6:	f005 f85d 	bl	9094 <MSS_GPIO_config>
	MSS_GPIO_enable_irq(MSS_GPIO_3);
    3fda:	f04f 0003 	mov.w	r0, #3
    3fde:	f005 f8af 	bl	9140 <MSS_GPIO_enable_irq>
	NVIC_EnableIRQ(GPIO3_IRQn);
    3fe2:	f04f 0035 	mov.w	r0, #53	; 0x35
    3fe6:	f7ff ff13 	bl	3e10 <NVIC_EnableIRQ>
	NVIC_SetPriority(GPIO3_IRQn, 253);
    3fea:	f04f 0035 	mov.w	r0, #53	; 0x35
    3fee:	f04f 01fd 	mov.w	r1, #253	; 0xfd
    3ff2:	f7ff ff29 	bl	3e48 <NVIC_SetPriority>
    uint16_t buf[1];
    uint16_t waddr, i, raddr;
    buf[0] = 0;
    3ff6:	f04f 0300 	mov.w	r3, #0
    3ffa:	80bb      	strh	r3, [r7, #4]
    i = 0;
    3ffc:	f04f 0300 	mov.w	r3, #0
    4000:	817b      	strh	r3, [r7, #10]
    uint8_t cont;
    uint8_t status;

    HAL_set_8bit_reg(RS_485_Controller_0, WRITE_SLAVE_ADDR, (uint_fast8_t) SLAVE_ADDR);
    4002:	f245 0014 	movw	r0, #20500	; 0x5014
    4006:	f2c5 0000 	movt	r0, #20480	; 0x5000
    400a:	f04f 0126 	mov.w	r1, #38	; 0x26
    400e:	f002 fa51 	bl	64b4 <HW_set_8bit_reg>

    HAL_set_8bit_reg(RS_485_Controller_0, WRITE_CLKS_PER_BIT, (uint_fast8_t) CLKS_PER_BIT);
    4012:	f245 0018 	movw	r0, #20504	; 0x5018
    4016:	f2c5 0000 	movt	r0, #20480	; 0x5000
    401a:	f04f 010f 	mov.w	r1, #15
    401e:	f002 fa49 	bl	64b4 <HW_set_8bit_reg>

    HAL_set_8bit_reg(APB_READ_CMD_0, WRITE_PAY_ID, (uint_fast8_t) PAY_ID);
    4022:	f24b 0010 	movw	r0, #45072	; 0xb010
    4026:	f2c5 0000 	movt	r0, #20480	; 0x5000
    402a:	f04f 0107 	mov.w	r1, #7
    402e:	f002 fa41 	bl	64b4 <HW_set_8bit_reg>

    cont = HAL_get_8bit_reg(RS_485_Controller_0, READ_CONST);
    4032:	f245 0008 	movw	r0, #20488	; 0x5008
    4036:	f2c5 0000 	movt	r0, #20480	; 0x5000
    403a:	f002 fa3d 	bl	64b8 <HW_get_8bit_reg>
    403e:	4603      	mov	r3, r0
    4040:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
    4042:	7bbb      	ldrb	r3, [r7, #14]
    4044:	2bab      	cmp	r3, #171	; 0xab
    4046:	d007      	beq.n	4058 <init_RS485_Controller+0xb8>
    	status |= 0x01;
    4048:	7bfb      	ldrb	r3, [r7, #15]
    404a:	f043 0301 	orr.w	r3, r3, #1
    404e:	73fb      	strb	r3, [r7, #15]
    	status  = status << 1;
    4050:	7bfb      	ldrb	r3, [r7, #15]
    4052:	ea4f 0343 	mov.w	r3, r3, lsl #1
    4056:	73fb      	strb	r3, [r7, #15]
    }
    status  = status << 1;
    4058:	7bfb      	ldrb	r3, [r7, #15]
    405a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    405e:	73fb      	strb	r3, [r7, #15]
    cont = HAL_get_8bit_reg(APB_READ_CMD_0, READ_CONST);
    4060:	f24b 0008 	movw	r0, #45064	; 0xb008
    4064:	f2c5 0000 	movt	r0, #20480	; 0x5000
    4068:	f002 fa26 	bl	64b8 <HW_get_8bit_reg>
    406c:	4603      	mov	r3, r0
    406e:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
    4070:	7bbb      	ldrb	r3, [r7, #14]
    4072:	2bab      	cmp	r3, #171	; 0xab
    4074:	d007      	beq.n	4086 <init_RS485_Controller+0xe6>
		status |= 0x01;
    4076:	7bfb      	ldrb	r3, [r7, #15]
    4078:	f043 0301 	orr.w	r3, r3, #1
    407c:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
    407e:	7bfb      	ldrb	r3, [r7, #15]
    4080:	ea4f 0343 	mov.w	r3, r3, lsl #1
    4084:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
    4086:	7bfb      	ldrb	r3, [r7, #15]
    4088:	ea4f 0343 	mov.w	r3, r3, lsl #1
    408c:	73fb      	strb	r3, [r7, #15]
    cont = HAL_get_8bit_reg(APB_READ_TLM_0, READ_CONST);
    408e:	f24c 0008 	movw	r0, #49160	; 0xc008
    4092:	f2c5 0000 	movt	r0, #20480	; 0x5000
    4096:	f002 fa0f 	bl	64b8 <HW_get_8bit_reg>
    409a:	4603      	mov	r3, r0
    409c:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
    409e:	7bbb      	ldrb	r3, [r7, #14]
    40a0:	2bab      	cmp	r3, #171	; 0xab
    40a2:	d007      	beq.n	40b4 <init_RS485_Controller+0x114>
		status |= 0x01;
    40a4:	7bfb      	ldrb	r3, [r7, #15]
    40a6:	f043 0301 	orr.w	r3, r3, #1
    40aa:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
    40ac:	7bfb      	ldrb	r3, [r7, #15]
    40ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
    40b2:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
    40b4:	7bfb      	ldrb	r3, [r7, #15]
    40b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
    40ba:	73fb      	strb	r3, [r7, #15]

	raddr = HAL_get_16bit_reg(RS_485_CONTROLLER_0, READ_RADDR);
    40bc:	f245 000c 	movw	r0, #20492	; 0x500c
    40c0:	f2c5 0000 	movt	r0, #20480	; 0x5000
    40c4:	f002 f9e0 	bl	6488 <HW_get_16bit_reg>
    40c8:	4603      	mov	r3, r0
    40ca:	81bb      	strh	r3, [r7, #12]

	if(raddr != 0){
    40cc:	89bb      	ldrh	r3, [r7, #12]
    40ce:	2b00      	cmp	r3, #0
    40d0:	d007      	beq.n	40e2 <init_RS485_Controller+0x142>
		status |= 0x01;
    40d2:	7bfb      	ldrb	r3, [r7, #15]
    40d4:	f043 0301 	orr.w	r3, r3, #1
    40d8:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
    40da:	7bfb      	ldrb	r3, [r7, #15]
    40dc:	ea4f 0343 	mov.w	r3, r3, lsl #1
    40e0:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
    40e2:	7bfb      	ldrb	r3, [r7, #15]
    40e4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    40e8:	73fb      	strb	r3, [r7, #15]

	waddr = HAL_get_16bit_reg(RS_485_Controller_0, READ_WADDR);
    40ea:	f245 0010 	movw	r0, #20496	; 0x5010
    40ee:	f2c5 0000 	movt	r0, #20480	; 0x5000
    40f2:	f002 f9c9 	bl	6488 <HW_get_16bit_reg>
    40f6:	4603      	mov	r3, r0
    40f8:	813b      	strh	r3, [r7, #8]
	if(waddr != 2){
    40fa:	893b      	ldrh	r3, [r7, #8]
    40fc:	2b02      	cmp	r3, #2
    40fe:	d007      	beq.n	4110 <init_RS485_Controller+0x170>
		status |= 0x01;
    4100:	7bfb      	ldrb	r3, [r7, #15]
    4102:	f043 0301 	orr.w	r3, r3, #1
    4106:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
    4108:	7bfb      	ldrb	r3, [r7, #15]
    410a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    410e:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
    4110:	7bfb      	ldrb	r3, [r7, #15]
    4112:	ea4f 0343 	mov.w	r3, r3, lsl #1
    4116:	73fb      	strb	r3, [r7, #15]


    buf[0] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_RADDR);
    4118:	f24b 000c 	movw	r0, #45068	; 0xb00c
    411c:	f2c5 0000 	movt	r0, #20480	; 0x5000
    4120:	f002 f9ca 	bl	64b8 <HW_get_8bit_reg>
    4124:	4603      	mov	r3, r0
    4126:	80bb      	strh	r3, [r7, #4]
	buf[0] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
    4128:	f24c 000c 	movw	r0, #49164	; 0xc00c
    412c:	f2c5 0000 	movt	r0, #20480	; 0x5000
    4130:	f002 f9c2 	bl	64b8 <HW_get_8bit_reg>
    4134:	4603      	mov	r3, r0
    4136:	80bb      	strh	r3, [r7, #4]
//    for(;i<1025;i++){
//
//        HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) buf[0]);
//    }

    return status;
    4138:	7bfb      	ldrb	r3, [r7, #15]
}
    413a:	4618      	mov	r0, r3
    413c:	f107 0710 	add.w	r7, r7, #16
    4140:	46bd      	mov	sp, r7
    4142:	bd80      	pop	{r7, pc}

00004144 <vc_write>:
uint8_t config_reg;
i2c_status_t status;
uint8_t read[2];
uint16_t bvol;

uint8_t vc_write(i2c_instance_t* I2C, uint8_t addr, uint8_t *tx, uint8_t tx_size) {
    4144:	b580      	push	{r7, lr}
    4146:	b086      	sub	sp, #24
    4148:	af02      	add	r7, sp, #8
    414a:	60f8      	str	r0, [r7, #12]
    414c:	607a      	str	r2, [r7, #4]
    414e:	460a      	mov	r2, r1
    4150:	72fa      	strb	r2, [r7, #11]
    4152:	70fb      	strb	r3, [r7, #3]
     count = 0;
    4154:	f24c 4374 	movw	r3, #50292	; 0xc474
    4158:	f2c2 0300 	movt	r3, #8192	; 0x2000
    415c:	f04f 0200 	mov.w	r2, #0
    4160:	701a      	strb	r2, [r3, #0]
    while(count < 10) {
    4162:	e02f      	b.n	41c4 <vc_write+0x80>
        I2C_write(I2C,addr,tx,tx_size,I2C_RELEASE_BUS);
    4164:	78fb      	ldrb	r3, [r7, #3]
    4166:	7afa      	ldrb	r2, [r7, #11]
    4168:	f04f 0100 	mov.w	r1, #0
    416c:	9100      	str	r1, [sp, #0]
    416e:	68f8      	ldr	r0, [r7, #12]
    4170:	4611      	mov	r1, r2
    4172:	687a      	ldr	r2, [r7, #4]
    4174:	f005 fd14 	bl	9ba0 <I2C_write>
        status = I2C_wait_complete(VC_SENSOR_I2C,I2C_NO_TIMEOUT);
    4178:	f24b 4038 	movw	r0, #46136	; 0xb438
    417c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4180:	f04f 0100 	mov.w	r1, #0
    4184:	f005 fe88 	bl	9e98 <I2C_wait_complete>
    4188:	4603      	mov	r3, r0
    418a:	461a      	mov	r2, r3
    418c:	f24c 137c 	movw	r3, #49532	; 0xc17c
    4190:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4194:	701a      	strb	r2, [r3, #0]
        if(status == I2C_SUCCESS) {
    4196:	f24c 137c 	movw	r3, #49532	; 0xc17c
    419a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    419e:	781b      	ldrb	r3, [r3, #0]
    41a0:	2b00      	cmp	r3, #0
    41a2:	d102      	bne.n	41aa <vc_write+0x66>
            return 0;
    41a4:	f04f 0300 	mov.w	r3, #0
    41a8:	e018      	b.n	41dc <vc_write+0x98>
        }
        count++;
    41aa:	f24c 4374 	movw	r3, #50292	; 0xc474
    41ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41b2:	781b      	ldrb	r3, [r3, #0]
    41b4:	f103 0301 	add.w	r3, r3, #1
    41b8:	b2da      	uxtb	r2, r3
    41ba:	f24c 4374 	movw	r3, #50292	; 0xc474
    41be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41c2:	701a      	strb	r2, [r3, #0]
uint8_t read[2];
uint16_t bvol;

uint8_t vc_write(i2c_instance_t* I2C, uint8_t addr, uint8_t *tx, uint8_t tx_size) {
     count = 0;
    while(count < 10) {
    41c4:	f24c 4374 	movw	r3, #50292	; 0xc474
    41c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41cc:	781b      	ldrb	r3, [r3, #0]
    41ce:	2b09      	cmp	r3, #9
    41d0:	d9c8      	bls.n	4164 <vc_write+0x20>
        if(status == I2C_SUCCESS) {
            return 0;
        }
        count++;
    }
    return count;
    41d2:	f24c 4374 	movw	r3, #50292	; 0xc474
    41d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    41da:	781b      	ldrb	r3, [r3, #0]

}
    41dc:	4618      	mov	r0, r3
    41de:	f107 0710 	add.w	r7, r7, #16
    41e2:	46bd      	mov	sp, r7
    41e4:	bd80      	pop	{r7, pc}
    41e6:	bf00      	nop

000041e8 <vc_read>:

uint8_t vc_read(i2c_instance_t* I2C, uint8_t addr, uint8_t *rx, uint8_t rx_size) {
    41e8:	b580      	push	{r7, lr}
    41ea:	b086      	sub	sp, #24
    41ec:	af02      	add	r7, sp, #8
    41ee:	60f8      	str	r0, [r7, #12]
    41f0:	607a      	str	r2, [r7, #4]
    41f2:	460a      	mov	r2, r1
    41f4:	72fa      	strb	r2, [r7, #11]
    41f6:	70fb      	strb	r3, [r7, #3]
    count = 0;
    41f8:	f24c 4374 	movw	r3, #50292	; 0xc474
    41fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4200:	f04f 0200 	mov.w	r2, #0
    4204:	701a      	strb	r2, [r3, #0]
    while(count < 10) {
    4206:	e02f      	b.n	4268 <vc_read+0x80>
        I2C_read(I2C,addr,rx,rx_size,I2C_RELEASE_BUS);
    4208:	78fb      	ldrb	r3, [r7, #3]
    420a:	7afa      	ldrb	r2, [r7, #11]
    420c:	f04f 0100 	mov.w	r1, #0
    4210:	9100      	str	r1, [sp, #0]
    4212:	68f8      	ldr	r0, [r7, #12]
    4214:	4611      	mov	r1, r2
    4216:	687a      	ldr	r2, [r7, #4]
    4218:	f005 fd34 	bl	9c84 <I2C_read>
        status = I2C_wait_complete(VC_SENSOR_I2C,I2C_NO_TIMEOUT);
    421c:	f24b 4038 	movw	r0, #46136	; 0xb438
    4220:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4224:	f04f 0100 	mov.w	r1, #0
    4228:	f005 fe36 	bl	9e98 <I2C_wait_complete>
    422c:	4603      	mov	r3, r0
    422e:	461a      	mov	r2, r3
    4230:	f24c 137c 	movw	r3, #49532	; 0xc17c
    4234:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4238:	701a      	strb	r2, [r3, #0]
        if(status == I2C_SUCCESS) {
    423a:	f24c 137c 	movw	r3, #49532	; 0xc17c
    423e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4242:	781b      	ldrb	r3, [r3, #0]
    4244:	2b00      	cmp	r3, #0
    4246:	d102      	bne.n	424e <vc_read+0x66>
            return 0;
    4248:	f04f 0300 	mov.w	r3, #0
    424c:	e018      	b.n	4280 <vc_read+0x98>
        }
        count++;
    424e:	f24c 4374 	movw	r3, #50292	; 0xc474
    4252:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4256:	781b      	ldrb	r3, [r3, #0]
    4258:	f103 0301 	add.w	r3, r3, #1
    425c:	b2da      	uxtb	r2, r3
    425e:	f24c 4374 	movw	r3, #50292	; 0xc474
    4262:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4266:	701a      	strb	r2, [r3, #0]

}

uint8_t vc_read(i2c_instance_t* I2C, uint8_t addr, uint8_t *rx, uint8_t rx_size) {
    count = 0;
    while(count < 10) {
    4268:	f24c 4374 	movw	r3, #50292	; 0xc474
    426c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4270:	781b      	ldrb	r3, [r3, #0]
    4272:	2b09      	cmp	r3, #9
    4274:	d9c8      	bls.n	4208 <vc_read+0x20>
        if(status == I2C_SUCCESS) {
            return 0;
        }
        count++;
    }
    return count;
    4276:	f24c 4374 	movw	r3, #50292	; 0xc474
    427a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    427e:	781b      	ldrb	r3, [r3, #0]

}
    4280:	4618      	mov	r0, r3
    4282:	f107 0710 	add.w	r7, r7, #16
    4286:	46bd      	mov	sp, r7
    4288:	bd80      	pop	{r7, pc}
    428a:	bf00      	nop

0000428c <vc_read_reg>:

uint8_t vc_read_reg(i2c_instance_t* I2C, uint8_t vc_addr, uint8_t reg_addr,uint8_t *rx) {
    428c:	b580      	push	{r7, lr}
    428e:	b084      	sub	sp, #16
    4290:	af00      	add	r7, sp, #0
    4292:	60f8      	str	r0, [r7, #12]
    4294:	607b      	str	r3, [r7, #4]
    4296:	460b      	mov	r3, r1
    4298:	72fb      	strb	r3, [r7, #11]
    429a:	4613      	mov	r3, r2
    429c:	72bb      	strb	r3, [r7, #10]
    if((vc_write(I2C, vc_addr,&reg_addr,sizeof(reg_addr))) >= 10) {
    429e:	7afa      	ldrb	r2, [r7, #11]
    42a0:	f107 030a 	add.w	r3, r7, #10
    42a4:	68f8      	ldr	r0, [r7, #12]
    42a6:	4611      	mov	r1, r2
    42a8:	461a      	mov	r2, r3
    42aa:	f04f 0301 	mov.w	r3, #1
    42ae:	f7ff ff49 	bl	4144 <vc_write>
    42b2:	4603      	mov	r3, r0
    42b4:	2b09      	cmp	r3, #9
    42b6:	d902      	bls.n	42be <vc_read_reg+0x32>
        return 1;
    42b8:	f04f 0301 	mov.w	r3, #1
    42bc:	e00f      	b.n	42de <vc_read_reg+0x52>
    }
    if((vc_read(I2C, vc_addr,(uint8_t*)rx,2)) >= 10) {
    42be:	7afb      	ldrb	r3, [r7, #11]
    42c0:	68f8      	ldr	r0, [r7, #12]
    42c2:	4619      	mov	r1, r3
    42c4:	687a      	ldr	r2, [r7, #4]
    42c6:	f04f 0302 	mov.w	r3, #2
    42ca:	f7ff ff8d 	bl	41e8 <vc_read>
    42ce:	4603      	mov	r3, r0
    42d0:	2b09      	cmp	r3, #9
    42d2:	d902      	bls.n	42da <vc_read_reg+0x4e>
        return 1;
    42d4:	f04f 0301 	mov.w	r3, #1
    42d8:	e001      	b.n	42de <vc_read_reg+0x52>
    }

    return 0;
    42da:	f04f 0300 	mov.w	r3, #0
}
    42de:	4618      	mov	r0, r3
    42e0:	f107 0710 	add.w	r7, r7, #16
    42e4:	46bd      	mov	sp, r7
    42e6:	bd80      	pop	{r7, pc}

000042e8 <vc_init>:
    }

    return 0;
}

uint8_t vc_init(i2c_instance_t* I2C, uint8_t addr) {
    42e8:	b580      	push	{r7, lr}
    42ea:	b082      	sub	sp, #8
    42ec:	af00      	add	r7, sp, #0
    42ee:	6078      	str	r0, [r7, #4]
    42f0:	460b      	mov	r3, r1
    42f2:	70fb      	strb	r3, [r7, #3]

    init_command = VC_INIT_CMD;
    42f4:	f24c 436c 	movw	r3, #50284	; 0xc46c
    42f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    42fc:	f247 0207 	movw	r2, #28679	; 0x7007
    4300:	801a      	strh	r2, [r3, #0]
    config_reg = VC_CONFIG_REG;
    4302:	f24c 4375 	movw	r3, #50293	; 0xc475
    4306:	f2c2 0300 	movt	r3, #8192	; 0x2000
    430a:	f04f 0200 	mov.w	r2, #0
    430e:	701a      	strb	r2, [r3, #0]
    if(vc_write(I2C, addr,&config_reg,sizeof(config_reg)) >= 10) {
    4310:	78fb      	ldrb	r3, [r7, #3]
    4312:	6878      	ldr	r0, [r7, #4]
    4314:	4619      	mov	r1, r3
    4316:	f24c 4275 	movw	r2, #50293	; 0xc475
    431a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    431e:	f04f 0301 	mov.w	r3, #1
    4322:	f7ff ff0f 	bl	4144 <vc_write>
    4326:	4603      	mov	r3, r0
    4328:	2b09      	cmp	r3, #9
    432a:	d902      	bls.n	4332 <vc_init+0x4a>
        return 1;
    432c:	f04f 0301 	mov.w	r3, #1
    4330:	e013      	b.n	435a <vc_init+0x72>
    }
    if(vc_write(I2C, addr,(uint8_t*)(&init_command),sizeof(init_command)) >= 10) {
    4332:	f24c 436c 	movw	r3, #50284	; 0xc46c
    4336:	f2c2 0300 	movt	r3, #8192	; 0x2000
    433a:	78fa      	ldrb	r2, [r7, #3]
    433c:	6878      	ldr	r0, [r7, #4]
    433e:	4611      	mov	r1, r2
    4340:	461a      	mov	r2, r3
    4342:	f04f 0302 	mov.w	r3, #2
    4346:	f7ff fefd 	bl	4144 <vc_write>
    434a:	4603      	mov	r3, r0
    434c:	2b09      	cmp	r3, #9
    434e:	d902      	bls.n	4356 <vc_init+0x6e>
        return 1;
    4350:	f04f 0301 	mov.w	r3, #1
    4354:	e001      	b.n	435a <vc_init+0x72>
    }

    return 0;
    4356:	f04f 0300 	mov.w	r3, #0
}
    435a:	4618      	mov	r0, r3
    435c:	f107 0708 	add.w	r7, r7, #8
    4360:	46bd      	mov	sp, r7
    4362:	bd80      	pop	{r7, pc}

00004364 <read_bus_voltage>:

uint16_t read_bus_voltage(i2c_instance_t* I2C, uint8_t addr, uint8_t chx,uint8_t *flag) {
    4364:	b580      	push	{r7, lr}
    4366:	b084      	sub	sp, #16
    4368:	af00      	add	r7, sp, #0
    436a:	60f8      	str	r0, [r7, #12]
    436c:	607b      	str	r3, [r7, #4]
    436e:	460b      	mov	r3, r1
    4370:	72fb      	strb	r3, [r7, #11]
    4372:	4613      	mov	r3, r2
    4374:	72bb      	strb	r3, [r7, #10]
    read[0] = 0;
    4376:	f24c 4370 	movw	r3, #50288	; 0xc470
    437a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    437e:	f04f 0200 	mov.w	r2, #0
    4382:	701a      	strb	r2, [r3, #0]
    read[1] = 0;
    4384:	f24c 4370 	movw	r3, #50288	; 0xc470
    4388:	f2c2 0300 	movt	r3, #8192	; 0x2000
    438c:	f04f 0200 	mov.w	r2, #0
    4390:	705a      	strb	r2, [r3, #1]
    bvol = 0;
    4392:	f24c 4372 	movw	r3, #50290	; 0xc472
    4396:	f2c2 0300 	movt	r3, #8192	; 0x2000
    439a:	f04f 0200 	mov.w	r2, #0
    439e:	801a      	strh	r2, [r3, #0]
    if(vc_read_reg(I2C, addr,VC_BUSV_CHx(chx),read) == 0) {
    43a0:	7abb      	ldrb	r3, [r7, #10]
    43a2:	ea4f 0343 	mov.w	r3, r3, lsl #1
    43a6:	b2db      	uxtb	r3, r3
    43a8:	7afa      	ldrb	r2, [r7, #11]
    43aa:	68f8      	ldr	r0, [r7, #12]
    43ac:	4611      	mov	r1, r2
    43ae:	461a      	mov	r2, r3
    43b0:	f24c 4370 	movw	r3, #50288	; 0xc470
    43b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43b8:	f7ff ff68 	bl	428c <vc_read_reg>
    43bc:	4603      	mov	r3, r0
    43be:	2b00      	cmp	r3, #0
    43c0:	d11a      	bne.n	43f8 <read_bus_voltage+0x94>
        bvol = read[0]<<8 | read[1];
    43c2:	f24c 4370 	movw	r3, #50288	; 0xc470
    43c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43ca:	781b      	ldrb	r3, [r3, #0]
    43cc:	ea4f 2303 	mov.w	r3, r3, lsl #8
    43d0:	b29a      	uxth	r2, r3
    43d2:	f24c 4370 	movw	r3, #50288	; 0xc470
    43d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43da:	785b      	ldrb	r3, [r3, #1]
    43dc:	ea42 0303 	orr.w	r3, r2, r3
    43e0:	b29b      	uxth	r3, r3
    43e2:	b29a      	uxth	r2, r3
    43e4:	f24c 4372 	movw	r3, #50290	; 0xc472
    43e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    43ec:	801a      	strh	r2, [r3, #0]
        *flag = 0;
    43ee:	687b      	ldr	r3, [r7, #4]
    43f0:	f04f 0200 	mov.w	r2, #0
    43f4:	701a      	strb	r2, [r3, #0]
    43f6:	e00a      	b.n	440e <read_bus_voltage+0xaa>

    } else {
        *flag = 1;
    43f8:	687b      	ldr	r3, [r7, #4]
    43fa:	f04f 0201 	mov.w	r2, #1
    43fe:	701a      	strb	r2, [r3, #0]
        bvol = 0;
    4400:	f24c 4372 	movw	r3, #50290	; 0xc472
    4404:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4408:	f04f 0200 	mov.w	r2, #0
    440c:	801a      	strh	r2, [r3, #0]
    }
    return bvol;
    440e:	f24c 4372 	movw	r3, #50290	; 0xc472
    4412:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4416:	881b      	ldrh	r3, [r3, #0]
}
    4418:	4618      	mov	r0, r3
    441a:	f107 0710 	add.w	r7, r7, #16
    441e:	46bd      	mov	sp, r7
    4420:	bd80      	pop	{r7, pc}
    4422:	bf00      	nop

00004424 <read_shunt_voltage>:

uint16_t read_shunt_voltage(i2c_instance_t* I2C, uint8_t addr, uint8_t chx,uint8_t *flag) {
    4424:	b580      	push	{r7, lr}
    4426:	b084      	sub	sp, #16
    4428:	af00      	add	r7, sp, #0
    442a:	60f8      	str	r0, [r7, #12]
    442c:	607b      	str	r3, [r7, #4]
    442e:	460b      	mov	r3, r1
    4430:	72fb      	strb	r3, [r7, #11]
    4432:	4613      	mov	r3, r2
    4434:	72bb      	strb	r3, [r7, #10]
    read[0] = 0;
    4436:	f24c 4370 	movw	r3, #50288	; 0xc470
    443a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    443e:	f04f 0200 	mov.w	r2, #0
    4442:	701a      	strb	r2, [r3, #0]
    read[1] = 0;
    4444:	f24c 4370 	movw	r3, #50288	; 0xc470
    4448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    444c:	f04f 0200 	mov.w	r2, #0
    4450:	705a      	strb	r2, [r3, #1]
    bvol = 0;
    4452:	f24c 4372 	movw	r3, #50290	; 0xc472
    4456:	f2c2 0300 	movt	r3, #8192	; 0x2000
    445a:	f04f 0200 	mov.w	r2, #0
    445e:	801a      	strh	r2, [r3, #0]
    if(vc_read_reg(I2C, addr,VC_SHUNTV_CHx(chx),read) == 0) {
    4460:	7abb      	ldrb	r3, [r7, #10]
    4462:	ea4f 0343 	mov.w	r3, r3, lsl #1
    4466:	b2db      	uxtb	r3, r3
    4468:	f103 33ff 	add.w	r3, r3, #4294967295
    446c:	b2db      	uxtb	r3, r3
    446e:	7afa      	ldrb	r2, [r7, #11]
    4470:	68f8      	ldr	r0, [r7, #12]
    4472:	4611      	mov	r1, r2
    4474:	461a      	mov	r2, r3
    4476:	f24c 4370 	movw	r3, #50288	; 0xc470
    447a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    447e:	f7ff ff05 	bl	428c <vc_read_reg>
    4482:	4603      	mov	r3, r0
    4484:	2b00      	cmp	r3, #0
    4486:	d11a      	bne.n	44be <read_shunt_voltage+0x9a>
        bvol = read[0]<<8 | read[1];
    4488:	f24c 4370 	movw	r3, #50288	; 0xc470
    448c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4490:	781b      	ldrb	r3, [r3, #0]
    4492:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4496:	b29a      	uxth	r2, r3
    4498:	f24c 4370 	movw	r3, #50288	; 0xc470
    449c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44a0:	785b      	ldrb	r3, [r3, #1]
    44a2:	ea42 0303 	orr.w	r3, r2, r3
    44a6:	b29b      	uxth	r3, r3
    44a8:	b29a      	uxth	r2, r3
    44aa:	f24c 4372 	movw	r3, #50290	; 0xc472
    44ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44b2:	801a      	strh	r2, [r3, #0]
        *flag = 0;
    44b4:	687b      	ldr	r3, [r7, #4]
    44b6:	f04f 0200 	mov.w	r2, #0
    44ba:	701a      	strb	r2, [r3, #0]
    44bc:	e00a      	b.n	44d4 <read_shunt_voltage+0xb0>
    } else {
        *flag = 1;
    44be:	687b      	ldr	r3, [r7, #4]
    44c0:	f04f 0201 	mov.w	r2, #1
    44c4:	701a      	strb	r2, [r3, #0]
        bvol = 0;
    44c6:	f24c 4372 	movw	r3, #50290	; 0xc472
    44ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44ce:	f04f 0200 	mov.w	r2, #0
    44d2:	801a      	strh	r2, [r3, #0]
    }
    return bvol;
    44d4:	f24c 4372 	movw	r3, #50290	; 0xc472
    44d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44dc:	881b      	ldrh	r3, [r3, #0]
}
    44de:	4618      	mov	r0, r3
    44e0:	f107 0710 	add.w	r7, r7, #16
    44e4:	46bd      	mov	sp, r7
    44e6:	bd80      	pop	{r7, pc}

000044e8 <ADC_Init>:
 *      Author: S-SPACE
 */

#include "ADC.h"

uint8_t ADC_Init(i2c_instance_t *i2c_chx,uint8_t address){
    44e8:	b580      	push	{r7, lr}
    44ea:	b088      	sub	sp, #32
    44ec:	af02      	add	r7, sp, #8
    44ee:	6078      	str	r0, [r7, #4]
    44f0:	460b      	mov	r3, r1
    44f2:	70fb      	strb	r3, [r7, #3]
    i2c_status_t status;
    uint8_t channel = 0;
    44f4:	f04f 0300 	mov.w	r3, #0
    44f8:	75bb      	strb	r3, [r7, #22]
    uint8_t return_value = 0;
    44fa:	f04f 0300 	mov.w	r3, #0
    44fe:	75fb      	strb	r3, [r7, #23]
    //Write max and min values to DATA HIGH and DATA LOW registers respectively for all channels
    uint8_t DATA_HIGH[] = {DATA_HIGH_REG(0),DATAHIGH_MAX_H,DATAHIGH_MAX_L};
    4500:	f64b 02b4 	movw	r2, #47284	; 0xb8b4
    4504:	f2c0 0200 	movt	r2, #0
    4508:	f107 0310 	add.w	r3, r7, #16
    450c:	6812      	ldr	r2, [r2, #0]
    450e:	4611      	mov	r1, r2
    4510:	8019      	strh	r1, [r3, #0]
    4512:	f103 0302 	add.w	r3, r3, #2
    4516:	ea4f 4212 	mov.w	r2, r2, lsr #16
    451a:	701a      	strb	r2, [r3, #0]
    uint8_t DATA_LOW[] = {DATA_LOW_REG(0),DATA_LOW_MIN_H,DATA_LOW_MIN_L};
    451c:	f04f 0304 	mov.w	r3, #4
    4520:	733b      	strb	r3, [r7, #12]
    4522:	f04f 0300 	mov.w	r3, #0
    4526:	737b      	strb	r3, [r7, #13]
    4528:	f04f 0300 	mov.w	r3, #0
    452c:	73bb      	strb	r3, [r7, #14]
    for(;channel <= 3;channel++) {
    452e:	e049      	b.n	45c4 <ADC_Init+0xdc>
        DATA_HIGH[0] = DATA_HIGH_REG(channel);
    4530:	7dbb      	ldrb	r3, [r7, #22]
    4532:	461a      	mov	r2, r3
    4534:	ea4f 0242 	mov.w	r2, r2, lsl #1
    4538:	4413      	add	r3, r2
    453a:	b2db      	uxtb	r3, r3
    453c:	f103 0305 	add.w	r3, r3, #5
    4540:	b2db      	uxtb	r3, r3
    4542:	743b      	strb	r3, [r7, #16]
        DATA_LOW[0] = DATA_LOW_REG(channel);
    4544:	7dbb      	ldrb	r3, [r7, #22]
    4546:	461a      	mov	r2, r3
    4548:	ea4f 0242 	mov.w	r2, r2, lsl #1
    454c:	4413      	add	r3, r2
    454e:	b2db      	uxtb	r3, r3
    4550:	f103 0304 	add.w	r3, r3, #4
    4554:	b2db      	uxtb	r3, r3
    4556:	733b      	strb	r3, [r7, #12]
        I2C_write(i2c_chx,address,DATA_HIGH,3,I2C_RELEASE_BUS);
    4558:	78fa      	ldrb	r2, [r7, #3]
    455a:	f107 0310 	add.w	r3, r7, #16
    455e:	f04f 0100 	mov.w	r1, #0
    4562:	9100      	str	r1, [sp, #0]
    4564:	6878      	ldr	r0, [r7, #4]
    4566:	4611      	mov	r1, r2
    4568:	461a      	mov	r2, r3
    456a:	f04f 0303 	mov.w	r3, #3
    456e:	f005 fb17 	bl	9ba0 <I2C_write>
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
    4572:	6878      	ldr	r0, [r7, #4]
    4574:	f04f 0100 	mov.w	r1, #0
    4578:	f005 fc8e 	bl	9e98 <I2C_wait_complete>
    457c:	4603      	mov	r3, r0
    457e:	757b      	strb	r3, [r7, #21]
        I2C_write(i2c_chx,address,DATA_LOW,3,I2C_RELEASE_BUS);
    4580:	78fa      	ldrb	r2, [r7, #3]
    4582:	f107 030c 	add.w	r3, r7, #12
    4586:	f04f 0100 	mov.w	r1, #0
    458a:	9100      	str	r1, [sp, #0]
    458c:	6878      	ldr	r0, [r7, #4]
    458e:	4611      	mov	r1, r2
    4590:	461a      	mov	r2, r3
    4592:	f04f 0303 	mov.w	r3, #3
    4596:	f005 fb03 	bl	9ba0 <I2C_write>
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
    459a:	6878      	ldr	r0, [r7, #4]
    459c:	f04f 0100 	mov.w	r1, #0
    45a0:	f005 fc7a 	bl	9e98 <I2C_wait_complete>
    45a4:	4603      	mov	r3, r0
    45a6:	757b      	strb	r3, [r7, #21]
        return_value |= (status << channel);
    45a8:	7d7a      	ldrb	r2, [r7, #21]
    45aa:	7dbb      	ldrb	r3, [r7, #22]
    45ac:	fa02 f303 	lsl.w	r3, r2, r3
    45b0:	b2da      	uxtb	r2, r3
    45b2:	7dfb      	ldrb	r3, [r7, #23]
    45b4:	ea42 0303 	orr.w	r3, r2, r3
    45b8:	b2db      	uxtb	r3, r3
    45ba:	75fb      	strb	r3, [r7, #23]
    uint8_t channel = 0;
    uint8_t return_value = 0;
    //Write max and min values to DATA HIGH and DATA LOW registers respectively for all channels
    uint8_t DATA_HIGH[] = {DATA_HIGH_REG(0),DATAHIGH_MAX_H,DATAHIGH_MAX_L};
    uint8_t DATA_LOW[] = {DATA_LOW_REG(0),DATA_LOW_MIN_H,DATA_LOW_MIN_L};
    for(;channel <= 3;channel++) {
    45bc:	7dbb      	ldrb	r3, [r7, #22]
    45be:	f103 0301 	add.w	r3, r3, #1
    45c2:	75bb      	strb	r3, [r7, #22]
    45c4:	7dbb      	ldrb	r3, [r7, #22]
    45c6:	2b03      	cmp	r3, #3
    45c8:	d9b2      	bls.n	4530 <ADC_Init+0x48>
        I2C_write(i2c_chx,address,DATA_LOW,3,I2C_RELEASE_BUS);
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
        return_value |= (status << channel);
    }

    return return_value;
    45ca:	7dfb      	ldrb	r3, [r7, #23]
}
    45cc:	4618      	mov	r0, r3
    45ce:	f107 0718 	add.w	r7, r7, #24
    45d2:	46bd      	mov	sp, r7
    45d4:	bd80      	pop	{r7, pc}
    45d6:	bf00      	nop

000045d8 <get_ADC_value>:

uint16_t get_ADC_value(i2c_instance_t *i2c_chx,uint8_t address,uint8_t chx,uint8_t *flag) {
    45d8:	b580      	push	{r7, lr}
    45da:	b08c      	sub	sp, #48	; 0x30
    45dc:	af04      	add	r7, sp, #16
    45de:	60f8      	str	r0, [r7, #12]
    45e0:	607b      	str	r3, [r7, #4]
    45e2:	460b      	mov	r3, r1
    45e4:	72fb      	strb	r3, [r7, #11]
    45e6:	4613      	mov	r3, r2
    45e8:	72bb      	strb	r3, [r7, #10]
    uint8_t adc_read_value[2];
    uint8_t ch_read[] = {chx};
    45ea:	7abb      	ldrb	r3, [r7, #10]
    45ec:	753b      	strb	r3, [r7, #20]
    ch_read[0] |= 0x8;
    45ee:	7d3b      	ldrb	r3, [r7, #20]
    45f0:	f043 0308 	orr.w	r3, r3, #8
    45f4:	b2db      	uxtb	r3, r3
    45f6:	753b      	strb	r3, [r7, #20]
    ch_read[0] = ch_read[0] << 4;
    45f8:	7d3b      	ldrb	r3, [r7, #20]
    45fa:	ea4f 1303 	mov.w	r3, r3, lsl #4
    45fe:	b2db      	uxtb	r3, r3
    4600:	753b      	strb	r3, [r7, #20]
    uint8_t status;
    uint16_t voltage;
    I2C_write_read(i2c_chx,address,ch_read,1,adc_read_value,2,I2C_RELEASE_BUS);
    4602:	7afa      	ldrb	r2, [r7, #11]
    4604:	f107 0314 	add.w	r3, r7, #20
    4608:	f107 0118 	add.w	r1, r7, #24
    460c:	9100      	str	r1, [sp, #0]
    460e:	f04f 0102 	mov.w	r1, #2
    4612:	9101      	str	r1, [sp, #4]
    4614:	f04f 0100 	mov.w	r1, #0
    4618:	9102      	str	r1, [sp, #8]
    461a:	68f8      	ldr	r0, [r7, #12]
    461c:	4611      	mov	r1, r2
    461e:	461a      	mov	r2, r3
    4620:	f04f 0301 	mov.w	r3, #1
    4624:	f005 fba0 	bl	9d68 <I2C_write_read>
    status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
    4628:	68f8      	ldr	r0, [r7, #12]
    462a:	f04f 0100 	mov.w	r1, #0
    462e:	f005 fc33 	bl	9e98 <I2C_wait_complete>
    4632:	4603      	mov	r3, r0
    4634:	777b      	strb	r3, [r7, #29]
    if(status != 0) {
    4636:	7f7b      	ldrb	r3, [r7, #29]
    4638:	2b00      	cmp	r3, #0
    463a:	d004      	beq.n	4646 <get_ADC_value+0x6e>
        *flag = 1;
    463c:	687b      	ldr	r3, [r7, #4]
    463e:	f04f 0201 	mov.w	r2, #1
    4642:	701a      	strb	r2, [r3, #0]
    4644:	e012      	b.n	466c <get_ADC_value+0x94>
    } else {
        voltage = (adc_read_value[0] << 8 ) | adc_read_value[1];
    4646:	7e3b      	ldrb	r3, [r7, #24]
    4648:	ea4f 2303 	mov.w	r3, r3, lsl #8
    464c:	b29a      	uxth	r2, r3
    464e:	7e7b      	ldrb	r3, [r7, #25]
    4650:	ea42 0303 	orr.w	r3, r2, r3
    4654:	b29b      	uxth	r3, r3
    4656:	83fb      	strh	r3, [r7, #30]
        voltage &= 0x0FFF;
    4658:	8bfb      	ldrh	r3, [r7, #30]
    465a:	ea4f 5303 	mov.w	r3, r3, lsl #20
    465e:	ea4f 5313 	mov.w	r3, r3, lsr #20
    4662:	83fb      	strh	r3, [r7, #30]
        *flag = 0;
    4664:	687b      	ldr	r3, [r7, #4]
    4666:	f04f 0200 	mov.w	r2, #0
    466a:	701a      	strb	r2, [r3, #0]
    }
    return voltage;
    466c:	8bfb      	ldrh	r3, [r7, #30]
}
    466e:	4618      	mov	r0, r3
    4670:	f107 0720 	add.w	r7, r7, #32
    4674:	46bd      	mov	sp, r7
    4676:	bd80      	pop	{r7, pc}

00004678 <get_IMU_acc>:
#include <stdio.h>

#include <core_i2c.h>
#include "IMU.h"

uint8_t get_IMU_acc(uint16_t *a_x,uint16_t *a_y,uint16_t *a_z) {
    4678:	b580      	push	{r7, lr}
    467a:	b092      	sub	sp, #72	; 0x48
    467c:	af04      	add	r7, sp, #16
    467e:	60f8      	str	r0, [r7, #12]
    4680:	60b9      	str	r1, [r7, #8]
    4682:	607a      	str	r2, [r7, #4]
    uint8_t write_CTRL_REG6_XL[2] = {0x20,0x60};
    4684:	f64b 03bc 	movw	r3, #47292	; 0xb8bc
    4688:	f2c0 0300 	movt	r3, #0
    468c:	881b      	ldrh	r3, [r3, #0]
    468e:	86bb      	strh	r3, [r7, #52]	; 0x34
    uint8_t read_ACC_out_X_L[] = {0x28};
    4690:	f04f 0328 	mov.w	r3, #40	; 0x28
    4694:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    uint8_t read_ACC_out_Y_L[] = {0x2A};
    4698:	f04f 032a 	mov.w	r3, #42	; 0x2a
    469c:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    uint8_t read_ACC_out_Z_L[] = {0x2C};
    46a0:	f04f 032c 	mov.w	r3, #44	; 0x2c
    46a4:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    uint8_t read_ACC_out_X_H[] = {0x29};
    46a8:	f04f 0329 	mov.w	r3, #41	; 0x29
    46ac:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    uint8_t read_ACC_out_Y_H[] = {0x2B};
    46b0:	f04f 032b 	mov.w	r3, #43	; 0x2b
    46b4:	f887 3020 	strb.w	r3, [r7, #32]
    uint8_t read_ACC_out_Z_H[] = {0x2D};
    46b8:	f04f 032d 	mov.w	r3, #45	; 0x2d
    46bc:	773b      	strb	r3, [r7, #28]
    uint8_t rx_buffer[1],rx_buffer_2[1];
    uint8_t result = 0,status;
    46be:	f04f 0300 	mov.w	r3, #0
    46c2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36


    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,write_CTRL_REG6_XL,2,rx_buffer,
    46c6:	f107 0334 	add.w	r3, r7, #52	; 0x34
    46ca:	f107 0218 	add.w	r2, r7, #24
    46ce:	9200      	str	r2, [sp, #0]
    46d0:	f04f 0201 	mov.w	r2, #1
    46d4:	9201      	str	r2, [sp, #4]
    46d6:	f04f 0200 	mov.w	r2, #0
    46da:	9202      	str	r2, [sp, #8]
    46dc:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    46e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    46e4:	f04f 016a 	mov.w	r1, #106	; 0x6a
    46e8:	461a      	mov	r2, r3
    46ea:	f04f 0302 	mov.w	r3, #2
    46ee:	f005 fb3b 	bl	9d68 <I2C_write_read>
                    1,I2C_RELEASE_BUS);
    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    46f2:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    46f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    46fa:	f04f 0100 	mov.w	r1, #0
    46fe:	f005 fbcb 	bl	9e98 <I2C_wait_complete>
    4702:	4603      	mov	r3, r0
    4704:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    4708:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    470c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4710:	4413      	add	r3, r2
    4712:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Z_L,1,rx_buffer,
    4716:	f107 0328 	add.w	r3, r7, #40	; 0x28
    471a:	f107 0218 	add.w	r2, r7, #24
    471e:	9200      	str	r2, [sp, #0]
    4720:	f04f 0201 	mov.w	r2, #1
    4724:	9201      	str	r2, [sp, #4]
    4726:	f04f 0200 	mov.w	r2, #0
    472a:	9202      	str	r2, [sp, #8]
    472c:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4730:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4734:	f04f 016a 	mov.w	r1, #106	; 0x6a
    4738:	461a      	mov	r2, r3
    473a:	f04f 0301 	mov.w	r3, #1
    473e:	f005 fb13 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4742:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4746:	f2c2 0000 	movt	r0, #8192	; 0x2000
    474a:	f04f 0100 	mov.w	r1, #0
    474e:	f005 fba3 	bl	9e98 <I2C_wait_complete>
    4752:	4603      	mov	r3, r0
    4754:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    4758:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    475c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4760:	4413      	add	r3, r2
    4762:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Z_H,1,rx_buffer_2,
    4766:	f107 031c 	add.w	r3, r7, #28
    476a:	f107 0214 	add.w	r2, r7, #20
    476e:	9200      	str	r2, [sp, #0]
    4770:	f04f 0201 	mov.w	r2, #1
    4774:	9201      	str	r2, [sp, #4]
    4776:	f04f 0200 	mov.w	r2, #0
    477a:	9202      	str	r2, [sp, #8]
    477c:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4780:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4784:	f04f 016a 	mov.w	r1, #106	; 0x6a
    4788:	461a      	mov	r2, r3
    478a:	f04f 0301 	mov.w	r3, #1
    478e:	f005 faeb 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4792:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4796:	f2c2 0000 	movt	r0, #8192	; 0x2000
    479a:	f04f 0100 	mov.w	r1, #0
    479e:	f005 fb7b 	bl	9e98 <I2C_wait_complete>
    47a2:	4603      	mov	r3, r0
    47a4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    47a8:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    47ac:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    47b0:	4413      	add	r3, r2
    47b2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_z = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    47b6:	7d3b      	ldrb	r3, [r7, #20]
    47b8:	ea4f 2303 	mov.w	r3, r3, lsl #8
    47bc:	b29a      	uxth	r2, r3
    47be:	7e3b      	ldrb	r3, [r7, #24]
    47c0:	ea42 0303 	orr.w	r3, r2, r3
    47c4:	b29b      	uxth	r3, r3
    47c6:	b29a      	uxth	r2, r3
    47c8:	687b      	ldr	r3, [r7, #4]
    47ca:	801a      	strh	r2, [r3, #0]
    if((*a_z) > 32768) {
    47cc:	687b      	ldr	r3, [r7, #4]
    47ce:	881b      	ldrh	r3, [r3, #0]
    47d0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    47d4:	d906      	bls.n	47e4 <get_IMU_acc+0x16c>
        *a_z = 65535-*a_z;
    47d6:	687b      	ldr	r3, [r7, #4]
    47d8:	881b      	ldrh	r3, [r3, #0]
    47da:	ea6f 0303 	mvn.w	r3, r3
    47de:	b29a      	uxth	r2, r3
    47e0:	687b      	ldr	r3, [r7, #4]
    47e2:	801a      	strh	r2, [r3, #0]
    }

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Y_L,1,rx_buffer,
    47e4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    47e8:	f107 0218 	add.w	r2, r7, #24
    47ec:	9200      	str	r2, [sp, #0]
    47ee:	f04f 0201 	mov.w	r2, #1
    47f2:	9201      	str	r2, [sp, #4]
    47f4:	f04f 0200 	mov.w	r2, #0
    47f8:	9202      	str	r2, [sp, #8]
    47fa:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    47fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4802:	f04f 016a 	mov.w	r1, #106	; 0x6a
    4806:	461a      	mov	r2, r3
    4808:	f04f 0301 	mov.w	r3, #1
    480c:	f005 faac 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4810:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4814:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4818:	f04f 0100 	mov.w	r1, #0
    481c:	f005 fb3c 	bl	9e98 <I2C_wait_complete>
    4820:	4603      	mov	r3, r0
    4822:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    4826:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    482a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    482e:	4413      	add	r3, r2
    4830:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Y_H,1,rx_buffer_2,
    4834:	f107 0320 	add.w	r3, r7, #32
    4838:	f107 0214 	add.w	r2, r7, #20
    483c:	9200      	str	r2, [sp, #0]
    483e:	f04f 0201 	mov.w	r2, #1
    4842:	9201      	str	r2, [sp, #4]
    4844:	f04f 0200 	mov.w	r2, #0
    4848:	9202      	str	r2, [sp, #8]
    484a:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    484e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4852:	f04f 016a 	mov.w	r1, #106	; 0x6a
    4856:	461a      	mov	r2, r3
    4858:	f04f 0301 	mov.w	r3, #1
    485c:	f005 fa84 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4860:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4864:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4868:	f04f 0100 	mov.w	r1, #0
    486c:	f005 fb14 	bl	9e98 <I2C_wait_complete>
    4870:	4603      	mov	r3, r0
    4872:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    4876:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    487a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    487e:	4413      	add	r3, r2
    4880:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_y = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    4884:	7d3b      	ldrb	r3, [r7, #20]
    4886:	ea4f 2303 	mov.w	r3, r3, lsl #8
    488a:	b29a      	uxth	r2, r3
    488c:	7e3b      	ldrb	r3, [r7, #24]
    488e:	ea42 0303 	orr.w	r3, r2, r3
    4892:	b29b      	uxth	r3, r3
    4894:	b29a      	uxth	r2, r3
    4896:	68bb      	ldr	r3, [r7, #8]
    4898:	801a      	strh	r2, [r3, #0]
    if((*a_y) > 32768) {
    489a:	68bb      	ldr	r3, [r7, #8]
    489c:	881b      	ldrh	r3, [r3, #0]
    489e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    48a2:	d906      	bls.n	48b2 <get_IMU_acc+0x23a>
        *a_y = 65535-*a_y;
    48a4:	68bb      	ldr	r3, [r7, #8]
    48a6:	881b      	ldrh	r3, [r3, #0]
    48a8:	ea6f 0303 	mvn.w	r3, r3
    48ac:	b29a      	uxth	r2, r3
    48ae:	68bb      	ldr	r3, [r7, #8]
    48b0:	801a      	strh	r2, [r3, #0]
    }

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_X_L,1,rx_buffer,
    48b2:	f107 0330 	add.w	r3, r7, #48	; 0x30
    48b6:	f107 0218 	add.w	r2, r7, #24
    48ba:	9200      	str	r2, [sp, #0]
    48bc:	f04f 0201 	mov.w	r2, #1
    48c0:	9201      	str	r2, [sp, #4]
    48c2:	f04f 0200 	mov.w	r2, #0
    48c6:	9202      	str	r2, [sp, #8]
    48c8:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    48cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    48d0:	f04f 016a 	mov.w	r1, #106	; 0x6a
    48d4:	461a      	mov	r2, r3
    48d6:	f04f 0301 	mov.w	r3, #1
    48da:	f005 fa45 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    48de:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    48e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    48e6:	f04f 0100 	mov.w	r1, #0
    48ea:	f005 fad5 	bl	9e98 <I2C_wait_complete>
    48ee:	4603      	mov	r3, r0
    48f0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    48f4:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    48f8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    48fc:	4413      	add	r3, r2
    48fe:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_X_H,1,rx_buffer_2,
    4902:	f107 0324 	add.w	r3, r7, #36	; 0x24
    4906:	f107 0214 	add.w	r2, r7, #20
    490a:	9200      	str	r2, [sp, #0]
    490c:	f04f 0201 	mov.w	r2, #1
    4910:	9201      	str	r2, [sp, #4]
    4912:	f04f 0200 	mov.w	r2, #0
    4916:	9202      	str	r2, [sp, #8]
    4918:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    491c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4920:	f04f 016a 	mov.w	r1, #106	; 0x6a
    4924:	461a      	mov	r2, r3
    4926:	f04f 0301 	mov.w	r3, #1
    492a:	f005 fa1d 	bl	9d68 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    492e:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4932:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4936:	f04f 0100 	mov.w	r1, #0
    493a:	f005 faad 	bl	9e98 <I2C_wait_complete>
    493e:	4603      	mov	r3, r0
    4940:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
    4944:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4948:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    494c:	4413      	add	r3, r2
    494e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_x = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    4952:	7d3b      	ldrb	r3, [r7, #20]
    4954:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4958:	b29a      	uxth	r2, r3
    495a:	7e3b      	ldrb	r3, [r7, #24]
    495c:	ea42 0303 	orr.w	r3, r2, r3
    4960:	b29b      	uxth	r3, r3
    4962:	b29a      	uxth	r2, r3
    4964:	68fb      	ldr	r3, [r7, #12]
    4966:	801a      	strh	r2, [r3, #0]
    if((*a_x) > 32768) {
    4968:	68fb      	ldr	r3, [r7, #12]
    496a:	881b      	ldrh	r3, [r3, #0]
    496c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    4970:	d906      	bls.n	4980 <get_IMU_acc+0x308>
        *a_x = 65535-*a_x;
    4972:	68fb      	ldr	r3, [r7, #12]
    4974:	881b      	ldrh	r3, [r3, #0]
    4976:	ea6f 0303 	mvn.w	r3, r3
    497a:	b29a      	uxth	r2, r3
    497c:	68fb      	ldr	r3, [r7, #12]
    497e:	801a      	strh	r2, [r3, #0]
    }

    return status;
    4980:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37

}
    4984:	4618      	mov	r0, r3
    4986:	f107 0738 	add.w	r7, r7, #56	; 0x38
    498a:	46bd      	mov	sp, r7
    498c:	bd80      	pop	{r7, pc}
    498e:	bf00      	nop

00004990 <get_IMU_gyro>:

uint8_t get_IMU_gyro(uint16_t *roll_rate, uint16_t *pitch_rate,uint16_t *yaw_rate) {
    4990:	b580      	push	{r7, lr}
    4992:	b092      	sub	sp, #72	; 0x48
    4994:	af04      	add	r7, sp, #16
    4996:	60f8      	str	r0, [r7, #12]
    4998:	60b9      	str	r1, [r7, #8]
    499a:	607a      	str	r2, [r7, #4]

    uint8_t write_CTRL_REG1_G[2] = {0x10,0x6A};
    499c:	f64b 03b8 	movw	r3, #47288	; 0xb8b8
    49a0:	f2c0 0300 	movt	r3, #0
    49a4:	881b      	ldrh	r3, [r3, #0]
    49a6:	863b      	strh	r3, [r7, #48]	; 0x30
        uint8_t read_ACC_out_X_L[] = {0x18};
    49a8:	f04f 0318 	mov.w	r3, #24
    49ac:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        uint8_t read_ACC_out_Y_L[] = {0x1A};
    49b0:	f04f 031a 	mov.w	r3, #26
    49b4:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
        uint8_t read_ACC_out_Z_L[] = {0x1C};
    49b8:	f04f 031c 	mov.w	r3, #28
    49bc:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        uint8_t read_ACC_out_X_H[] = {0x19};
    49c0:	f04f 0319 	mov.w	r3, #25
    49c4:	f887 3020 	strb.w	r3, [r7, #32]
        uint8_t read_ACC_out_Y_H[] = {0x1B};
    49c8:	f04f 031b 	mov.w	r3, #27
    49cc:	773b      	strb	r3, [r7, #28]
        uint8_t read_ACC_out_Z_H[] = {0x1D};
    49ce:	f04f 031d 	mov.w	r3, #29
    49d2:	763b      	strb	r3, [r7, #24]
        uint8_t IMU_slave_addr = 0x6a;
    49d4:	f04f 036a 	mov.w	r3, #106	; 0x6a
    49d8:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
        uint8_t rx_buffer[1],rx_buffer_2[1];
        uint8_t result = 0,status;
    49dc:	f04f 0300 	mov.w	r3, #0
    49e0:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36


        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,write_CTRL_REG1_G,2,rx_buffer,
    49e4:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    49e8:	f107 0330 	add.w	r3, r7, #48	; 0x30
    49ec:	f107 0114 	add.w	r1, r7, #20
    49f0:	9100      	str	r1, [sp, #0]
    49f2:	f04f 0101 	mov.w	r1, #1
    49f6:	9101      	str	r1, [sp, #4]
    49f8:	f04f 0100 	mov.w	r1, #0
    49fc:	9102      	str	r1, [sp, #8]
    49fe:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4a02:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4a06:	4611      	mov	r1, r2
    4a08:	461a      	mov	r2, r3
    4a0a:	f04f 0302 	mov.w	r3, #2
    4a0e:	f005 f9ab 	bl	9d68 <I2C_write_read>
                        1,I2C_RELEASE_BUS);
        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4a12:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4a16:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4a1a:	f04f 0100 	mov.w	r1, #0
    4a1e:	f005 fa3b 	bl	9e98 <I2C_wait_complete>
    4a22:	4603      	mov	r3, r0
    4a24:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4a28:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4a2c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4a30:	4413      	add	r3, r2
    4a32:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Z_L,1,rx_buffer,
    4a36:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4a3a:	f107 0324 	add.w	r3, r7, #36	; 0x24
    4a3e:	f107 0114 	add.w	r1, r7, #20
    4a42:	9100      	str	r1, [sp, #0]
    4a44:	f04f 0101 	mov.w	r1, #1
    4a48:	9101      	str	r1, [sp, #4]
    4a4a:	f04f 0100 	mov.w	r1, #0
    4a4e:	9102      	str	r1, [sp, #8]
    4a50:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4a54:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4a58:	4611      	mov	r1, r2
    4a5a:	461a      	mov	r2, r3
    4a5c:	f04f 0301 	mov.w	r3, #1
    4a60:	f005 f982 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4a64:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4a68:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4a6c:	f04f 0100 	mov.w	r1, #0
    4a70:	f005 fa12 	bl	9e98 <I2C_wait_complete>
    4a74:	4603      	mov	r3, r0
    4a76:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4a7a:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4a7e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4a82:	4413      	add	r3, r2
    4a84:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Z_H,1,rx_buffer_2,
    4a88:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4a8c:	f107 0318 	add.w	r3, r7, #24
    4a90:	f107 0110 	add.w	r1, r7, #16
    4a94:	9100      	str	r1, [sp, #0]
    4a96:	f04f 0101 	mov.w	r1, #1
    4a9a:	9101      	str	r1, [sp, #4]
    4a9c:	f04f 0100 	mov.w	r1, #0
    4aa0:	9102      	str	r1, [sp, #8]
    4aa2:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4aa6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4aaa:	4611      	mov	r1, r2
    4aac:	461a      	mov	r2, r3
    4aae:	f04f 0301 	mov.w	r3, #1
    4ab2:	f005 f959 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4ab6:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4aba:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4abe:	f04f 0100 	mov.w	r1, #0
    4ac2:	f005 f9e9 	bl	9e98 <I2C_wait_complete>
    4ac6:	4603      	mov	r3, r0
    4ac8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4acc:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4ad0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4ad4:	4413      	add	r3, r2
    4ad6:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *roll_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    4ada:	7c3b      	ldrb	r3, [r7, #16]
    4adc:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4ae0:	b29a      	uxth	r2, r3
    4ae2:	7d3b      	ldrb	r3, [r7, #20]
    4ae4:	ea42 0303 	orr.w	r3, r2, r3
    4ae8:	b29b      	uxth	r3, r3
    4aea:	b29a      	uxth	r2, r3
    4aec:	68fb      	ldr	r3, [r7, #12]
    4aee:	801a      	strh	r2, [r3, #0]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Y_L,1,rx_buffer,
    4af0:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4af4:	f107 0328 	add.w	r3, r7, #40	; 0x28
    4af8:	f107 0114 	add.w	r1, r7, #20
    4afc:	9100      	str	r1, [sp, #0]
    4afe:	f04f 0101 	mov.w	r1, #1
    4b02:	9101      	str	r1, [sp, #4]
    4b04:	f04f 0100 	mov.w	r1, #0
    4b08:	9102      	str	r1, [sp, #8]
    4b0a:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4b0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4b12:	4611      	mov	r1, r2
    4b14:	461a      	mov	r2, r3
    4b16:	f04f 0301 	mov.w	r3, #1
    4b1a:	f005 f925 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4b1e:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4b22:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4b26:	f04f 0100 	mov.w	r1, #0
    4b2a:	f005 f9b5 	bl	9e98 <I2C_wait_complete>
    4b2e:	4603      	mov	r3, r0
    4b30:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4b34:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4b38:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4b3c:	4413      	add	r3, r2
    4b3e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Y_H,1,rx_buffer_2,
    4b42:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4b46:	f107 031c 	add.w	r3, r7, #28
    4b4a:	f107 0110 	add.w	r1, r7, #16
    4b4e:	9100      	str	r1, [sp, #0]
    4b50:	f04f 0101 	mov.w	r1, #1
    4b54:	9101      	str	r1, [sp, #4]
    4b56:	f04f 0100 	mov.w	r1, #0
    4b5a:	9102      	str	r1, [sp, #8]
    4b5c:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4b60:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4b64:	4611      	mov	r1, r2
    4b66:	461a      	mov	r2, r3
    4b68:	f04f 0301 	mov.w	r3, #1
    4b6c:	f005 f8fc 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4b70:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4b74:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4b78:	f04f 0100 	mov.w	r1, #0
    4b7c:	f005 f98c 	bl	9e98 <I2C_wait_complete>
    4b80:	4603      	mov	r3, r0
    4b82:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4b86:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4b8a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4b8e:	4413      	add	r3, r2
    4b90:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *pitch_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    4b94:	7c3b      	ldrb	r3, [r7, #16]
    4b96:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4b9a:	b29a      	uxth	r2, r3
    4b9c:	7d3b      	ldrb	r3, [r7, #20]
    4b9e:	ea42 0303 	orr.w	r3, r2, r3
    4ba2:	b29b      	uxth	r3, r3
    4ba4:	b29a      	uxth	r2, r3
    4ba6:	68bb      	ldr	r3, [r7, #8]
    4ba8:	801a      	strh	r2, [r3, #0]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_X_L,1,rx_buffer,
    4baa:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4bae:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    4bb2:	f107 0114 	add.w	r1, r7, #20
    4bb6:	9100      	str	r1, [sp, #0]
    4bb8:	f04f 0101 	mov.w	r1, #1
    4bbc:	9101      	str	r1, [sp, #4]
    4bbe:	f04f 0100 	mov.w	r1, #0
    4bc2:	9102      	str	r1, [sp, #8]
    4bc4:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4bc8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4bcc:	4611      	mov	r1, r2
    4bce:	461a      	mov	r2, r3
    4bd0:	f04f 0301 	mov.w	r3, #1
    4bd4:	f005 f8c8 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4bd8:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4bdc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4be0:	f04f 0100 	mov.w	r1, #0
    4be4:	f005 f958 	bl	9e98 <I2C_wait_complete>
    4be8:	4603      	mov	r3, r0
    4bea:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4bee:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4bf2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4bf6:	4413      	add	r3, r2
    4bf8:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_X_H,1,rx_buffer_2,
    4bfc:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
    4c00:	f107 0320 	add.w	r3, r7, #32
    4c04:	f107 0110 	add.w	r1, r7, #16
    4c08:	9100      	str	r1, [sp, #0]
    4c0a:	f04f 0101 	mov.w	r1, #1
    4c0e:	9101      	str	r1, [sp, #4]
    4c10:	f04f 0100 	mov.w	r1, #0
    4c14:	9102      	str	r1, [sp, #8]
    4c16:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4c1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4c1e:	4611      	mov	r1, r2
    4c20:	461a      	mov	r2, r3
    4c22:	f04f 0301 	mov.w	r3, #1
    4c26:	f005 f89f 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4c2a:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4c2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4c32:	f04f 0100 	mov.w	r1, #0
    4c36:	f005 f92f 	bl	9e98 <I2C_wait_complete>
    4c3a:	4603      	mov	r3, r0
    4c3c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
    4c40:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
    4c44:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4c48:	4413      	add	r3, r2
    4c4a:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *yaw_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
    4c4e:	7c3b      	ldrb	r3, [r7, #16]
    4c50:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4c54:	b29a      	uxth	r2, r3
    4c56:	7d3b      	ldrb	r3, [r7, #20]
    4c58:	ea42 0303 	orr.w	r3, r2, r3
    4c5c:	b29b      	uxth	r3, r3
    4c5e:	b29a      	uxth	r2, r3
    4c60:	687b      	ldr	r3, [r7, #4]
    4c62:	801a      	strh	r2, [r3, #0]

        return status;
    4c64:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
    4c68:	4618      	mov	r0, r3
    4c6a:	f107 0738 	add.w	r7, r7, #56	; 0x38
    4c6e:	46bd      	mov	sp, r7
    4c70:	bd80      	pop	{r7, pc}
    4c72:	bf00      	nop

00004c74 <get_IMU_temp>:

uint8_t get_IMU_temp(uint16_t *temp) {
    4c74:	b580      	push	{r7, lr}
    4c76:	b08a      	sub	sp, #40	; 0x28
    4c78:	af04      	add	r7, sp, #16
    4c7a:	6078      	str	r0, [r7, #4]

        uint8_t read_temp_L[] = {0x15};
    4c7c:	f04f 0315 	mov.w	r3, #21
    4c80:	753b      	strb	r3, [r7, #20]
        uint8_t read_temp_H[] = {0x16};
    4c82:	f04f 0316 	mov.w	r3, #22
    4c86:	743b      	strb	r3, [r7, #16]
        uint8_t IMU_slave_addr = 0x6a;
    4c88:	f04f 036a 	mov.w	r3, #106	; 0x6a
    4c8c:	75bb      	strb	r3, [r7, #22]
        uint8_t rx_buffer[1],rx_buffer_2[1];
        i2c_status_t status;

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_temp_L,1,rx_buffer,
    4c8e:	7dba      	ldrb	r2, [r7, #22]
    4c90:	f107 0314 	add.w	r3, r7, #20
    4c94:	f107 010c 	add.w	r1, r7, #12
    4c98:	9100      	str	r1, [sp, #0]
    4c9a:	f04f 0101 	mov.w	r1, #1
    4c9e:	9101      	str	r1, [sp, #4]
    4ca0:	f04f 0100 	mov.w	r1, #0
    4ca4:	9102      	str	r1, [sp, #8]
    4ca6:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4caa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4cae:	4611      	mov	r1, r2
    4cb0:	461a      	mov	r2, r3
    4cb2:	f04f 0301 	mov.w	r3, #1
    4cb6:	f005 f857 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4cba:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4cbe:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4cc2:	f04f 0100 	mov.w	r1, #0
    4cc6:	f005 f8e7 	bl	9e98 <I2C_wait_complete>
    4cca:	4603      	mov	r3, r0
    4ccc:	75fb      	strb	r3, [r7, #23]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_temp_H,1,rx_buffer_2,
    4cce:	7dba      	ldrb	r2, [r7, #22]
    4cd0:	f107 0310 	add.w	r3, r7, #16
    4cd4:	f107 0108 	add.w	r1, r7, #8
    4cd8:	9100      	str	r1, [sp, #0]
    4cda:	f04f 0101 	mov.w	r1, #1
    4cde:	9101      	str	r1, [sp, #4]
    4ce0:	f04f 0100 	mov.w	r1, #0
    4ce4:	9102      	str	r1, [sp, #8]
    4ce6:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4cea:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4cee:	4611      	mov	r1, r2
    4cf0:	461a      	mov	r2, r3
    4cf2:	f04f 0301 	mov.w	r3, #1
    4cf6:	f005 f837 	bl	9d68 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
    4cfa:	f24b 50c8 	movw	r0, #46536	; 0xb5c8
    4cfe:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4d02:	f04f 0100 	mov.w	r1, #0
    4d06:	f005 f8c7 	bl	9e98 <I2C_wait_complete>
    4d0a:	4603      	mov	r3, r0
    4d0c:	75fb      	strb	r3, [r7, #23]

        *temp = (rx_buffer[0]) | (rx_buffer_2[0] << 8);
    4d0e:	7b3b      	ldrb	r3, [r7, #12]
    4d10:	461a      	mov	r2, r3
    4d12:	7a3b      	ldrb	r3, [r7, #8]
    4d14:	ea4f 2303 	mov.w	r3, r3, lsl #8
    4d18:	b29b      	uxth	r3, r3
    4d1a:	ea42 0303 	orr.w	r3, r2, r3
    4d1e:	b29b      	uxth	r3, r3
    4d20:	b29a      	uxth	r2, r3
    4d22:	687b      	ldr	r3, [r7, #4]
    4d24:	801a      	strh	r2, [r3, #0]

        return 0;
    4d26:	f04f 0300 	mov.w	r3, #0

}
    4d2a:	4618      	mov	r0, r3
    4d2c:	f107 0718 	add.w	r7, r7, #24
    4d30:	46bd      	mov	sp, r7
    4d32:	bd80      	pop	{r7, pc}

00004d34 <SD_Init>:
uint8_t CMD8[] = {0x48, 0x00, 0x00, 0x01, 0xAA, 0x87,0xff};
uint8_t CMD58[] = {0x7A,0x00,0x00,0x00,0x00,0xFD,0xFF};
uint8_t CMD55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65,0xff};	// last 0xff is use to give sd card buffer clock
uint8_t ACMD41[] = {0x69, 0x40, 0x00, 0x00, 0x00, 0xE5,0xff};
uint8_t CMD1[] = {0x41,0x00,0x00,0x00,0x00,0xF9,0xff};
uint8_t SD_Init() {
    4d34:	b580      	push	{r7, lr}
    4d36:	b086      	sub	sp, #24
    4d38:	af02      	add	r7, sp, #8
	flag = 0;
    4d3a:	f24c 4376 	movw	r3, #50294	; 0xc476
    4d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d42:	f04f 0200 	mov.w	r2, #0
    4d46:	701a      	strb	r2, [r3, #0]
	MSS_GPIO_set_output( SD_CARD_GPIO,1);
    4d48:	f04f 000a 	mov.w	r0, #10
    4d4c:	f04f 0101 	mov.w	r1, #1
    4d50:	f004 f9be 	bl	90d0 <MSS_GPIO_set_output>
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
    4d54:	f04f 0300 	mov.w	r3, #0
    4d58:	713b      	strb	r3, [r7, #4]
    4d5a:	f04f 0300 	mov.w	r3, #0
    4d5e:	717b      	strb	r3, [r7, #5]
    4d60:	f04f 0300 	mov.w	r3, #0
    4d64:	71bb      	strb	r3, [r7, #6]
    4d66:	f04f 0300 	mov.w	r3, #0
    4d6a:	71fb      	strb	r3, [r7, #7]
    4d6c:	f04f 0300 	mov.w	r3, #0
    4d70:	723b      	strb	r3, [r7, #8]

	uint32_t i = 0;
    4d72:	f04f 0300 	mov.w	r3, #0
    4d76:	60fb      	str	r3, [r7, #12]

	for(i =0; i<10; i++){
    4d78:	f04f 0300 	mov.w	r3, #0
    4d7c:	60fb      	str	r3, [r7, #12]
    4d7e:	e00b      	b.n	4d98 <SD_Init+0x64>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4d80:	f24c 5000 	movw	r0, #50432	; 0xc500
    4d84:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4d88:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4d8c:	f002 fe0a 	bl	79a4 <MSS_SPI_transfer_frame>
	MSS_GPIO_set_output( SD_CARD_GPIO,1);
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};

	uint32_t i = 0;

	for(i =0; i<10; i++){
    4d90:	68fb      	ldr	r3, [r7, #12]
    4d92:	f103 0301 	add.w	r3, r3, #1
    4d96:	60fb      	str	r3, [r7, #12]
    4d98:	68fb      	ldr	r3, [r7, #12]
    4d9a:	2b09      	cmp	r3, #9
    4d9c:	d9f0      	bls.n	4d80 <SD_Init+0x4c>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
	}

	MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    4d9e:	f24c 5000 	movw	r0, #50432	; 0xc500
    4da2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4da6:	f04f 0100 	mov.w	r1, #0
    4daa:	f002 fd2f 	bl	780c <MSS_SPI_set_slave_select>
	do {
		MSS_SPI_transfer_block(&g_mss_spi1, CMD0, 7, rx_buffer, 1);
    4dae:	f107 0304 	add.w	r3, r7, #4
    4db2:	f04f 0201 	mov.w	r2, #1
    4db6:	9200      	str	r2, [sp, #0]
    4db8:	f24c 5000 	movw	r0, #50432	; 0xc500
    4dbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4dc0:	f24b 010c 	movw	r1, #45068	; 0xb00c
    4dc4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4dc8:	f04f 0207 	mov.w	r2, #7
    4dcc:	f002 fe4a 	bl	7a64 <MSS_SPI_transfer_block>
		i++;
    4dd0:	68fb      	ldr	r3, [r7, #12]
    4dd2:	f103 0301 	add.w	r3, r3, #1
    4dd6:	60fb      	str	r3, [r7, #12]
		if(rx_buffer[0] == 1) {
    4dd8:	793b      	ldrb	r3, [r7, #4]
    4dda:	2b01      	cmp	r3, #1
    4ddc:	d006      	beq.n	4dec <SD_Init+0xb8>
			break;
		}
	} while(rx_buffer[0] != 1 && i < 255);
    4dde:	793b      	ldrb	r3, [r7, #4]
    4de0:	2b01      	cmp	r3, #1
    4de2:	d004      	beq.n	4dee <SD_Init+0xba>
    4de4:	68fb      	ldr	r3, [r7, #12]
    4de6:	2bfe      	cmp	r3, #254	; 0xfe
    4de8:	d9e1      	bls.n	4dae <SD_Init+0x7a>
    4dea:	e000      	b.n	4dee <SD_Init+0xba>
	MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
	do {
		MSS_SPI_transfer_block(&g_mss_spi1, CMD0, 7, rx_buffer, 1);
		i++;
		if(rx_buffer[0] == 1) {
			break;
    4dec:	bf00      	nop
		}
	} while(rx_buffer[0] != 1 && i < 255);


	i = 0;
    4dee:	f04f 0300 	mov.w	r3, #0
    4df2:	60fb      	str	r3, [r7, #12]


	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4df4:	f24c 5000 	movw	r0, #50432	; 0xc500
    4df8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4dfc:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4e00:	f002 fdd0 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4e04:	f24c 5000 	movw	r0, #50432	; 0xc500
    4e08:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4e0c:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4e10:	f002 fdc8 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD8, 7, rx_buffer, 5);
    4e14:	f107 0304 	add.w	r3, r7, #4
    4e18:	f04f 0205 	mov.w	r2, #5
    4e1c:	9200      	str	r2, [sp, #0]
    4e1e:	f24c 5000 	movw	r0, #50432	; 0xc500
    4e22:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4e26:	f24b 0114 	movw	r1, #45076	; 0xb014
    4e2a:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4e2e:	f04f 0207 	mov.w	r2, #7
    4e32:	f002 fe17 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4e36:	f24c 5000 	movw	r0, #50432	; 0xc500
    4e3a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4e3e:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4e42:	f002 fdaf 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4e46:	f24c 5000 	movw	r0, #50432	; 0xc500
    4e4a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4e4e:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4e52:	f002 fda7 	bl	79a4 <MSS_SPI_transfer_frame>

		i++;
    4e56:	68fb      	ldr	r3, [r7, #12]
    4e58:	f103 0301 	add.w	r3, r3, #1
    4e5c:	60fb      	str	r3, [r7, #12]
		if(rx_buffer[4] == 0xaa && rx_buffer[3] == 0x01 && rx_buffer[2] == 0x00 && rx_buffer[1] == 0x00) {
    4e5e:	7a3b      	ldrb	r3, [r7, #8]
    4e60:	2baa      	cmp	r3, #170	; 0xaa
    4e62:	d110      	bne.n	4e86 <SD_Init+0x152>
    4e64:	79fb      	ldrb	r3, [r7, #7]
    4e66:	2b01      	cmp	r3, #1
    4e68:	d10d      	bne.n	4e86 <SD_Init+0x152>
    4e6a:	79bb      	ldrb	r3, [r7, #6]
    4e6c:	2b00      	cmp	r3, #0
    4e6e:	d10a      	bne.n	4e86 <SD_Init+0x152>
    4e70:	797b      	ldrb	r3, [r7, #5]
    4e72:	2b00      	cmp	r3, #0
    4e74:	d107      	bne.n	4e86 <SD_Init+0x152>
			flag =  1;
    4e76:	f24c 4376 	movw	r3, #50294	; 0xc476
    4e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e7e:	f04f 0201 	mov.w	r2, #1
    4e82:	701a      	strb	r2, [r3, #0]
			break;
    4e84:	e002      	b.n	4e8c <SD_Init+0x158>
		}

	} while( i < 255);
    4e86:	68fb      	ldr	r3, [r7, #12]
    4e88:	2bfe      	cmp	r3, #254	; 0xfe
    4e8a:	d9b3      	bls.n	4df4 <SD_Init+0xc0>
	if(i >= 255) {
    4e8c:	68fb      	ldr	r3, [r7, #12]
    4e8e:	2bfe      	cmp	r3, #254	; 0xfe
    4e90:	d90a      	bls.n	4ea8 <SD_Init+0x174>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    4e92:	f24c 5000 	movw	r0, #50432	; 0xc500
    4e96:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4e9a:	f04f 0100 	mov.w	r1, #0
    4e9e:	f002 fd39 	bl	7914 <MSS_SPI_clear_slave_select>
		return 1;
    4ea2:	f04f 0301 	mov.w	r3, #1
    4ea6:	e17e      	b.n	51a6 <SD_Init+0x472>
	}


	rx_buffer[0] = 0x00;
    4ea8:	f04f 0300 	mov.w	r3, #0
    4eac:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
    4eae:	f04f 0300 	mov.w	r3, #0
    4eb2:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
    4eb4:	f04f 0300 	mov.w	r3, #0
    4eb8:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
    4eba:	f04f 0300 	mov.w	r3, #0
    4ebe:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
    4ec0:	f04f 0300 	mov.w	r3, #0
    4ec4:	723b      	strb	r3, [r7, #8]
	i = 0;
    4ec6:	f04f 0300 	mov.w	r3, #0
    4eca:	60fb      	str	r3, [r7, #12]
	flag = 0;
    4ecc:	f24c 4376 	movw	r3, #50294	; 0xc476
    4ed0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4ed4:	f04f 0200 	mov.w	r2, #0
    4ed8:	701a      	strb	r2, [r3, #0]
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4eda:	f24c 5000 	movw	r0, #50432	; 0xc500
    4ede:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4ee2:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4ee6:	f002 fd5d 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4eea:	f24c 5000 	movw	r0, #50432	; 0xc500
    4eee:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4ef2:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4ef6:	f002 fd55 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD58, 7, rx_buffer, 5);
    4efa:	f107 0304 	add.w	r3, r7, #4
    4efe:	f04f 0205 	mov.w	r2, #5
    4f02:	9200      	str	r2, [sp, #0]
    4f04:	f24c 5000 	movw	r0, #50432	; 0xc500
    4f08:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4f0c:	f24b 011c 	movw	r1, #45084	; 0xb01c
    4f10:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4f14:	f04f 0207 	mov.w	r2, #7
    4f18:	f002 fda4 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4f1c:	f24c 5000 	movw	r0, #50432	; 0xc500
    4f20:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4f24:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4f28:	f002 fd3c 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4f2c:	f24c 5000 	movw	r0, #50432	; 0xc500
    4f30:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4f34:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4f38:	f002 fd34 	bl	79a4 <MSS_SPI_transfer_frame>

		i++;
    4f3c:	68fb      	ldr	r3, [r7, #12]
    4f3e:	f103 0301 	add.w	r3, r3, #1
    4f42:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[3] == 0x80 && rx_buffer[2] == 0xFF) {
    4f44:	79fb      	ldrb	r3, [r7, #7]
    4f46:	2b80      	cmp	r3, #128	; 0x80
    4f48:	d10a      	bne.n	4f60 <SD_Init+0x22c>
    4f4a:	79bb      	ldrb	r3, [r7, #6]
    4f4c:	2bff      	cmp	r3, #255	; 0xff
    4f4e:	d107      	bne.n	4f60 <SD_Init+0x22c>
			flag = 1;
    4f50:	f24c 4376 	movw	r3, #50294	; 0xc476
    4f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f58:	f04f 0201 	mov.w	r2, #1
    4f5c:	701a      	strb	r2, [r3, #0]
			break;
    4f5e:	e002      	b.n	4f66 <SD_Init+0x232>
		}

	} while( i < 255);
    4f60:	68fb      	ldr	r3, [r7, #12]
    4f62:	2bfe      	cmp	r3, #254	; 0xfe
    4f64:	d9b9      	bls.n	4eda <SD_Init+0x1a6>
	if(i >= 255) {
    4f66:	68fb      	ldr	r3, [r7, #12]
    4f68:	2bfe      	cmp	r3, #254	; 0xfe
    4f6a:	d90a      	bls.n	4f82 <SD_Init+0x24e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    4f6c:	f24c 5000 	movw	r0, #50432	; 0xc500
    4f70:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4f74:	f04f 0100 	mov.w	r1, #0
    4f78:	f002 fccc 	bl	7914 <MSS_SPI_clear_slave_select>
		return 1;
    4f7c:	f04f 0301 	mov.w	r3, #1
    4f80:	e111      	b.n	51a6 <SD_Init+0x472>
	}



	rx_buffer[0] = 0x00;
    4f82:	f04f 0300 	mov.w	r3, #0
    4f86:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
    4f88:	f04f 0300 	mov.w	r3, #0
    4f8c:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
    4f8e:	f04f 0300 	mov.w	r3, #0
    4f92:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
    4f94:	f04f 0300 	mov.w	r3, #0
    4f98:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
    4f9a:	f04f 0300 	mov.w	r3, #0
    4f9e:	723b      	strb	r3, [r7, #8]
	i = 0;
    4fa0:	f04f 0300 	mov.w	r3, #0
    4fa4:	60fb      	str	r3, [r7, #12]
	flag = 0;
    4fa6:	f24c 4376 	movw	r3, #50294	; 0xc476
    4faa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fae:	f04f 0200 	mov.w	r2, #0
    4fb2:	701a      	strb	r2, [r3, #0]


	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4fb4:	f24c 5000 	movw	r0, #50432	; 0xc500
    4fb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4fbc:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4fc0:	f002 fcf0 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4fc4:	f24c 5000 	movw	r0, #50432	; 0xc500
    4fc8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4fcc:	f04f 01ff 	mov.w	r1, #255	; 0xff
    4fd0:	f002 fce8 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD55, 7, rx_buffer, 1);
    4fd4:	f107 0304 	add.w	r3, r7, #4
    4fd8:	f04f 0201 	mov.w	r2, #1
    4fdc:	9200      	str	r2, [sp, #0]
    4fde:	f24c 5000 	movw	r0, #50432	; 0xc500
    4fe2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4fe6:	f24b 0124 	movw	r1, #45092	; 0xb024
    4fea:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4fee:	f04f 0207 	mov.w	r2, #7
    4ff2:	f002 fd37 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    4ff6:	f24c 5000 	movw	r0, #50432	; 0xc500
    4ffa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4ffe:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5002:	f002 fccf 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, ACMD41, 7, rx_buffer, 1);
    5006:	f107 0304 	add.w	r3, r7, #4
    500a:	f04f 0201 	mov.w	r2, #1
    500e:	9200      	str	r2, [sp, #0]
    5010:	f24c 5000 	movw	r0, #50432	; 0xc500
    5014:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5018:	f24b 012c 	movw	r1, #45100	; 0xb02c
    501c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5020:	f04f 0207 	mov.w	r2, #7
    5024:	f002 fd1e 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5028:	f24c 5000 	movw	r0, #50432	; 0xc500
    502c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5030:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5034:	f002 fcb6 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5038:	f24c 5000 	movw	r0, #50432	; 0xc500
    503c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5040:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5044:	f002 fcae 	bl	79a4 <MSS_SPI_transfer_frame>

		i++;
    5048:	68fb      	ldr	r3, [r7, #12]
    504a:	f103 0301 	add.w	r3, r3, #1
    504e:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[0] == 0x00) {
    5050:	793b      	ldrb	r3, [r7, #4]
    5052:	2b00      	cmp	r3, #0
    5054:	d107      	bne.n	5066 <SD_Init+0x332>
			flag = 1;
    5056:	f24c 4376 	movw	r3, #50294	; 0xc476
    505a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    505e:	f04f 0201 	mov.w	r2, #1
    5062:	701a      	strb	r2, [r3, #0]
			break;
    5064:	e004      	b.n	5070 <SD_Init+0x33c>
		}


	} while( i <2550);
    5066:	68fa      	ldr	r2, [r7, #12]
    5068:	f640 13f5 	movw	r3, #2549	; 0x9f5
    506c:	429a      	cmp	r2, r3
    506e:	d9a1      	bls.n	4fb4 <SD_Init+0x280>
	if(flag == 0) {
    5070:	f24c 4376 	movw	r3, #50294	; 0xc476
    5074:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5078:	781b      	ldrb	r3, [r3, #0]
    507a:	2b00      	cmp	r3, #0
    507c:	d10a      	bne.n	5094 <SD_Init+0x360>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    507e:	f24c 5000 	movw	r0, #50432	; 0xc500
    5082:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5086:	f04f 0100 	mov.w	r1, #0
    508a:	f002 fc43 	bl	7914 <MSS_SPI_clear_slave_select>
		return 1;
    508e:	f04f 0301 	mov.w	r3, #1
    5092:	e088      	b.n	51a6 <SD_Init+0x472>
	}

	rx_buffer[0] = 0x00;
    5094:	f04f 0300 	mov.w	r3, #0
    5098:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
    509a:	f04f 0300 	mov.w	r3, #0
    509e:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
    50a0:	f04f 0300 	mov.w	r3, #0
    50a4:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
    50a6:	f04f 0300 	mov.w	r3, #0
    50aa:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
    50ac:	f04f 0300 	mov.w	r3, #0
    50b0:	723b      	strb	r3, [r7, #8]
	i = 0;
    50b2:	f04f 0300 	mov.w	r3, #0
    50b6:	60fb      	str	r3, [r7, #12]
	flag = 0;
    50b8:	f24c 4376 	movw	r3, #50294	; 0xc476
    50bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    50c0:	f04f 0200 	mov.w	r2, #0
    50c4:	701a      	strb	r2, [r3, #0]
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    50c6:	f24c 5000 	movw	r0, #50432	; 0xc500
    50ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
    50ce:	f04f 01ff 	mov.w	r1, #255	; 0xff
    50d2:	f002 fc67 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    50d6:	f24c 5000 	movw	r0, #50432	; 0xc500
    50da:	f2c2 0000 	movt	r0, #8192	; 0x2000
    50de:	f04f 01ff 	mov.w	r1, #255	; 0xff
    50e2:	f002 fc5f 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD58, 7, rx_buffer, 5);
    50e6:	f107 0304 	add.w	r3, r7, #4
    50ea:	f04f 0205 	mov.w	r2, #5
    50ee:	9200      	str	r2, [sp, #0]
    50f0:	f24c 5000 	movw	r0, #50432	; 0xc500
    50f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    50f8:	f24b 011c 	movw	r1, #45084	; 0xb01c
    50fc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5100:	f04f 0207 	mov.w	r2, #7
    5104:	f002 fcae 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5108:	f24c 5000 	movw	r0, #50432	; 0xc500
    510c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5110:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5114:	f002 fc46 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5118:	f24c 5000 	movw	r0, #50432	; 0xc500
    511c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5120:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5124:	f002 fc3e 	bl	79a4 <MSS_SPI_transfer_frame>

		i++;
    5128:	68fb      	ldr	r3, [r7, #12]
    512a:	f103 0301 	add.w	r3, r3, #1
    512e:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[3] == 0x80 && rx_buffer[2] == 0xFF) {
    5130:	79fb      	ldrb	r3, [r7, #7]
    5132:	2b80      	cmp	r3, #128	; 0x80
    5134:	d10a      	bne.n	514c <SD_Init+0x418>
    5136:	79bb      	ldrb	r3, [r7, #6]
    5138:	2bff      	cmp	r3, #255	; 0xff
    513a:	d107      	bne.n	514c <SD_Init+0x418>
			flag = 1;
    513c:	f24c 4376 	movw	r3, #50294	; 0xc476
    5140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5144:	f04f 0201 	mov.w	r2, #1
    5148:	701a      	strb	r2, [r3, #0]
			break;
    514a:	e002      	b.n	5152 <SD_Init+0x41e>
		}

	} while( i < 255);
    514c:	68fb      	ldr	r3, [r7, #12]
    514e:	2bfe      	cmp	r3, #254	; 0xfe
    5150:	d9b9      	bls.n	50c6 <SD_Init+0x392>

	if(i >= 255) {
    5152:	68fb      	ldr	r3, [r7, #12]
    5154:	2bfe      	cmp	r3, #254	; 0xfe
    5156:	d90a      	bls.n	516e <SD_Init+0x43a>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5158:	f24c 5000 	movw	r0, #50432	; 0xc500
    515c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5160:	f04f 0100 	mov.w	r1, #0
    5164:	f002 fbd6 	bl	7914 <MSS_SPI_clear_slave_select>
		return 1;
    5168:	f04f 0301 	mov.w	r3, #1
    516c:	e01b      	b.n	51a6 <SD_Init+0x472>
	}

	if(flag == 1) {
    516e:	f24c 4376 	movw	r3, #50294	; 0xc476
    5172:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5176:	781b      	ldrb	r3, [r3, #0]
    5178:	2b01      	cmp	r3, #1
    517a:	d10a      	bne.n	5192 <SD_Init+0x45e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    517c:	f24c 5000 	movw	r0, #50432	; 0xc500
    5180:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5184:	f04f 0100 	mov.w	r1, #0
    5188:	f002 fbc4 	bl	7914 <MSS_SPI_clear_slave_select>
		return 0;
    518c:	f04f 0300 	mov.w	r3, #0
    5190:	e009      	b.n	51a6 <SD_Init+0x472>
	}
	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5192:	f24c 5000 	movw	r0, #50432	; 0xc500
    5196:	f2c2 0000 	movt	r0, #8192	; 0x2000
    519a:	f04f 0100 	mov.w	r1, #0
    519e:	f002 fbb9 	bl	7914 <MSS_SPI_clear_slave_select>
	return 1;
    51a2:	f04f 0301 	mov.w	r3, #1
}
    51a6:	4618      	mov	r0, r3
    51a8:	f107 0710 	add.w	r7, r7, #16
    51ac:	46bd      	mov	sp, r7
    51ae:	bd80      	pop	{r7, pc}

000051b0 <SD_Write>:

uint8_t SD_Write(uint32_t addr,uint8_t *buff) {
    51b0:	b580      	push	{r7, lr}
    51b2:	b08c      	sub	sp, #48	; 0x30
    51b4:	af02      	add	r7, sp, #8
    51b6:	6078      	str	r0, [r7, #4]
    51b8:	6039      	str	r1, [r7, #0]
	uint8_t CMD24[] = {0x58,((addr >> 24) & 0xff ),((addr >> 16) & 0xff ),((addr >> 8) & 0xff ),(addr & 0xff ),0xFF,0xff};
    51ba:	687b      	ldr	r3, [r7, #4]
    51bc:	ea4f 6313 	mov.w	r3, r3, lsr #24
    51c0:	b2d8      	uxtb	r0, r3
    51c2:	687b      	ldr	r3, [r7, #4]
    51c4:	ea4f 4313 	mov.w	r3, r3, lsr #16
    51c8:	b2d9      	uxtb	r1, r3
    51ca:	687b      	ldr	r3, [r7, #4]
    51cc:	ea4f 2313 	mov.w	r3, r3, lsr #8
    51d0:	b2da      	uxtb	r2, r3
    51d2:	687b      	ldr	r3, [r7, #4]
    51d4:	b2db      	uxtb	r3, r3
    51d6:	f04f 0c58 	mov.w	ip, #88	; 0x58
    51da:	f887 c018 	strb.w	ip, [r7, #24]
    51de:	7678      	strb	r0, [r7, #25]
    51e0:	76b9      	strb	r1, [r7, #26]
    51e2:	76fa      	strb	r2, [r7, #27]
    51e4:	773b      	strb	r3, [r7, #28]
    51e6:	f04f 33ff 	mov.w	r3, #4294967295
    51ea:	777b      	strb	r3, [r7, #29]
    51ec:	f04f 33ff 	mov.w	r3, #4294967295
    51f0:	77bb      	strb	r3, [r7, #30]
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
    51f2:	f04f 0300 	mov.w	r3, #0
    51f6:	743b      	strb	r3, [r7, #16]
    51f8:	f04f 0300 	mov.w	r3, #0
    51fc:	747b      	strb	r3, [r7, #17]
    51fe:	f04f 0300 	mov.w	r3, #0
    5202:	74bb      	strb	r3, [r7, #18]
    5204:	f04f 0300 	mov.w	r3, #0
    5208:	74fb      	strb	r3, [r7, #19]
    520a:	f04f 0300 	mov.w	r3, #0
    520e:	753b      	strb	r3, [r7, #20]
	uint8_t flag = 0;
    5210:	f04f 0300 	mov.w	r3, #0
    5214:	77fb      	strb	r3, [r7, #31]
	uint8_t start_flag = 0xFE;
    5216:	f06f 0301 	mvn.w	r3, #1
    521a:	73fb      	strb	r3, [r7, #15]
	uint32_t i = 0,j = 0;
    521c:	f04f 0300 	mov.w	r3, #0
    5220:	623b      	str	r3, [r7, #32]
    5222:	f04f 0300 	mov.w	r3, #0
    5226:	627b      	str	r3, [r7, #36]	; 0x24

	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5228:	f24c 5000 	movw	r0, #50432	; 0xc500
    522c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5230:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5234:	f002 fbb6 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5238:	f24c 5000 	movw	r0, #50432	; 0xc500
    523c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5240:	f04f 0100 	mov.w	r1, #0
    5244:	f002 fae2 	bl	780c <MSS_SPI_set_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5248:	f24c 5000 	movw	r0, #50432	; 0xc500
    524c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5250:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5254:	f002 fba6 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD24, 7, rx_buffer, 1);
    5258:	f107 0218 	add.w	r2, r7, #24
    525c:	f107 0310 	add.w	r3, r7, #16
    5260:	f04f 0101 	mov.w	r1, #1
    5264:	9100      	str	r1, [sp, #0]
    5266:	f24c 5000 	movw	r0, #50432	; 0xc500
    526a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    526e:	4611      	mov	r1, r2
    5270:	f04f 0207 	mov.w	r2, #7
    5274:	f002 fbf6 	bl	7a64 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5278:	f24c 5000 	movw	r0, #50432	; 0xc500
    527c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5280:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5284:	f002 fb8e 	bl	79a4 <MSS_SPI_transfer_frame>

		i++;
    5288:	6a3b      	ldr	r3, [r7, #32]
    528a:	f103 0301 	add.w	r3, r3, #1
    528e:	623b      	str	r3, [r7, #32]

		if(rx_buffer[0] == 0x00) {
    5290:	7c3b      	ldrb	r3, [r7, #16]
    5292:	2b00      	cmp	r3, #0
    5294:	d177      	bne.n	5386 <SD_Write+0x1d6>
			MSS_SPI_transfer_block(&g_mss_spi1, &start_flag, 1, rx_buffer, 1);
    5296:	f107 020f 	add.w	r2, r7, #15
    529a:	f107 0310 	add.w	r3, r7, #16
    529e:	f04f 0101 	mov.w	r1, #1
    52a2:	9100      	str	r1, [sp, #0]
    52a4:	f24c 5000 	movw	r0, #50432	; 0xc500
    52a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    52ac:	4611      	mov	r1, r2
    52ae:	f04f 0201 	mov.w	r2, #1
    52b2:	f002 fbd7 	bl	7a64 <MSS_SPI_transfer_block>
			MSS_SPI_transfer_block(&g_mss_spi1, buff, 512, rx_buffer, 0);
    52b6:	f107 0310 	add.w	r3, r7, #16
    52ba:	f04f 0200 	mov.w	r2, #0
    52be:	9200      	str	r2, [sp, #0]
    52c0:	f24c 5000 	movw	r0, #50432	; 0xc500
    52c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    52c8:	6839      	ldr	r1, [r7, #0]
    52ca:	f44f 7200 	mov.w	r2, #512	; 0x200
    52ce:	f002 fbc9 	bl	7a64 <MSS_SPI_transfer_block>
			while(j<100){
    52d2:	e017      	b.n	5304 <SD_Write+0x154>
				rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    52d4:	f24c 5000 	movw	r0, #50432	; 0xc500
    52d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    52dc:	f04f 01ff 	mov.w	r1, #255	; 0xff
    52e0:	f002 fb60 	bl	79a4 <MSS_SPI_transfer_frame>
    52e4:	4603      	mov	r3, r0
    52e6:	b2db      	uxtb	r3, r3
    52e8:	743b      	strb	r3, [r7, #16]
				if((rx_buffer[0]&0x1F) == 0x05) {
    52ea:	7c3b      	ldrb	r3, [r7, #16]
    52ec:	f003 031f 	and.w	r3, r3, #31
    52f0:	2b05      	cmp	r3, #5
    52f2:	d103      	bne.n	52fc <SD_Write+0x14c>
					flag = 1;
    52f4:	f04f 0301 	mov.w	r3, #1
    52f8:	77fb      	strb	r3, [r7, #31]
					break;
    52fa:	e006      	b.n	530a <SD_Write+0x15a>
				}
				j++;
    52fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    52fe:	f103 0301 	add.w	r3, r3, #1
    5302:	627b      	str	r3, [r7, #36]	; 0x24
		i++;

		if(rx_buffer[0] == 0x00) {
			MSS_SPI_transfer_block(&g_mss_spi1, &start_flag, 1, rx_buffer, 1);
			MSS_SPI_transfer_block(&g_mss_spi1, buff, 512, rx_buffer, 0);
			while(j<100){
    5304:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5306:	2b63      	cmp	r3, #99	; 0x63
    5308:	d9e4      	bls.n	52d4 <SD_Write+0x124>
					flag = 1;
					break;
				}
				j++;
			}
			if(flag == 1) {
    530a:	7ffb      	ldrb	r3, [r7, #31]
    530c:	2b01      	cmp	r3, #1
    530e:	d13f      	bne.n	5390 <SD_Write+0x1e0>
				flag = 0;
    5310:	f04f 0300 	mov.w	r3, #0
    5314:	77fb      	strb	r3, [r7, #31]
				j = 0;
    5316:	f04f 0300 	mov.w	r3, #0
    531a:	627b      	str	r3, [r7, #36]	; 0x24
				while(j<100) {
    531c:	e02f      	b.n	537e <SD_Write+0x1ce>
					rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    531e:	f24c 5000 	movw	r0, #50432	; 0xc500
    5322:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5326:	f04f 01ff 	mov.w	r1, #255	; 0xff
    532a:	f002 fb3b 	bl	79a4 <MSS_SPI_transfer_frame>
    532e:	4603      	mov	r3, r0
    5330:	b2db      	uxtb	r3, r3
    5332:	743b      	strb	r3, [r7, #16]
					if(rx_buffer[0]!=0x00) {
    5334:	7c3b      	ldrb	r3, [r7, #16]
    5336:	2b00      	cmp	r3, #0
    5338:	d01d      	beq.n	5376 <SD_Write+0x1c6>
						flag = 1;
    533a:	f04f 0301 	mov.w	r3, #1
    533e:	77fb      	strb	r3, [r7, #31]
						MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5340:	f24c 5000 	movw	r0, #50432	; 0xc500
    5344:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5348:	f04f 01ff 	mov.w	r1, #255	; 0xff
    534c:	f002 fb2a 	bl	79a4 <MSS_SPI_transfer_frame>
						MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5350:	f24c 5000 	movw	r0, #50432	; 0xc500
    5354:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5358:	f04f 0100 	mov.w	r1, #0
    535c:	f002 fada 	bl	7914 <MSS_SPI_clear_slave_select>
						MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5360:	f24c 5000 	movw	r0, #50432	; 0xc500
    5364:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5368:	f04f 01ff 	mov.w	r1, #255	; 0xff
    536c:	f002 fb1a 	bl	79a4 <MSS_SPI_transfer_frame>
						return 0;
    5370:	f04f 0300 	mov.w	r3, #0
    5374:	e035      	b.n	53e2 <SD_Write+0x232>
					}
					j++;
    5376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5378:	f103 0301 	add.w	r3, r3, #1
    537c:	627b      	str	r3, [r7, #36]	; 0x24
				j++;
			}
			if(flag == 1) {
				flag = 0;
				j = 0;
				while(j<100) {
    537e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5380:	2b63      	cmp	r3, #99	; 0x63
    5382:	d9cc      	bls.n	531e <SD_Write+0x16e>
						return 0;
					}
					j++;
				}
			}
			break;
    5384:	e005      	b.n	5392 <SD_Write+0x1e2>
		}

	} while( i < 255);
    5386:	6a3b      	ldr	r3, [r7, #32]
    5388:	2bfe      	cmp	r3, #254	; 0xfe
    538a:	f67f af4d 	bls.w	5228 <SD_Write+0x78>
    538e:	e000      	b.n	5392 <SD_Write+0x1e2>
						return 0;
					}
					j++;
				}
			}
			break;
    5390:	bf00      	nop
		}

	} while( i < 255);

	if(i >= 255) {
    5392:	6a3b      	ldr	r3, [r7, #32]
    5394:	2bfe      	cmp	r3, #254	; 0xfe
    5396:	d912      	bls.n	53be <SD_Write+0x20e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5398:	f24c 5000 	movw	r0, #50432	; 0xc500
    539c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    53a0:	f04f 0100 	mov.w	r1, #0
    53a4:	f002 fab6 	bl	7914 <MSS_SPI_clear_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    53a8:	f24c 5000 	movw	r0, #50432	; 0xc500
    53ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
    53b0:	f04f 01ff 	mov.w	r1, #255	; 0xff
    53b4:	f002 faf6 	bl	79a4 <MSS_SPI_transfer_frame>
		return 1;
    53b8:	f04f 0301 	mov.w	r3, #1
    53bc:	e011      	b.n	53e2 <SD_Write+0x232>
	}
	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    53be:	f24c 5000 	movw	r0, #50432	; 0xc500
    53c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    53c6:	f04f 0100 	mov.w	r1, #0
    53ca:	f002 faa3 	bl	7914 <MSS_SPI_clear_slave_select>
	MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    53ce:	f24c 5000 	movw	r0, #50432	; 0xc500
    53d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
    53d6:	f04f 01ff 	mov.w	r1, #255	; 0xff
    53da:	f002 fae3 	bl	79a4 <MSS_SPI_transfer_frame>
	return 1;
    53de:	f04f 0301 	mov.w	r3, #1
}
    53e2:	4618      	mov	r0, r3
    53e4:	f107 0728 	add.w	r7, r7, #40	; 0x28
    53e8:	46bd      	mov	sp, r7
    53ea:	bd80      	pop	{r7, pc}

000053ec <SD_Read>:

uint8_t SD_Read(const uint32_t addr,uint8_t *buff) {
    53ec:	b580      	push	{r7, lr}
    53ee:	b08c      	sub	sp, #48	; 0x30
    53f0:	af02      	add	r7, sp, #8
    53f2:	6078      	str	r0, [r7, #4]
    53f4:	6039      	str	r1, [r7, #0]
	uint8_t CMD17[] = {0x51,((addr >> 24) & 0xff ),((addr >> 16) & 0xff ),((addr >> 8) & 0xff ),(addr & 0xff ),0xFF,0xff};
    53f6:	687b      	ldr	r3, [r7, #4]
    53f8:	ea4f 6313 	mov.w	r3, r3, lsr #24
    53fc:	b2d8      	uxtb	r0, r3
    53fe:	687b      	ldr	r3, [r7, #4]
    5400:	ea4f 4313 	mov.w	r3, r3, lsr #16
    5404:	b2d9      	uxtb	r1, r3
    5406:	687b      	ldr	r3, [r7, #4]
    5408:	ea4f 2313 	mov.w	r3, r3, lsr #8
    540c:	b2da      	uxtb	r2, r3
    540e:	687b      	ldr	r3, [r7, #4]
    5410:	b2db      	uxtb	r3, r3
    5412:	f04f 0c51 	mov.w	ip, #81	; 0x51
    5416:	f887 c018 	strb.w	ip, [r7, #24]
    541a:	7678      	strb	r0, [r7, #25]
    541c:	76b9      	strb	r1, [r7, #26]
    541e:	76fa      	strb	r2, [r7, #27]
    5420:	773b      	strb	r3, [r7, #28]
    5422:	f04f 33ff 	mov.w	r3, #4294967295
    5426:	777b      	strb	r3, [r7, #29]
    5428:	f04f 33ff 	mov.w	r3, #4294967295
    542c:	77bb      	strb	r3, [r7, #30]
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
    542e:	f04f 0300 	mov.w	r3, #0
    5432:	743b      	strb	r3, [r7, #16]
    5434:	f04f 0300 	mov.w	r3, #0
    5438:	747b      	strb	r3, [r7, #17]
    543a:	f04f 0300 	mov.w	r3, #0
    543e:	74bb      	strb	r3, [r7, #18]
    5440:	f04f 0300 	mov.w	r3, #0
    5444:	74fb      	strb	r3, [r7, #19]
    5446:	f04f 0300 	mov.w	r3, #0
    544a:	753b      	strb	r3, [r7, #20]
	uint8_t flag = 0;
    544c:	f04f 0300 	mov.w	r3, #0
    5450:	77fb      	strb	r3, [r7, #31]
	uint8_t dummy_data = 0xff;
    5452:	f04f 33ff 	mov.w	r3, #4294967295
    5456:	73fb      	strb	r3, [r7, #15]
	uint32_t i = 0;
    5458:	f04f 0300 	mov.w	r3, #0
    545c:	623b      	str	r3, [r7, #32]
	uint16_t c = 0;
    545e:	f04f 0300 	mov.w	r3, #0
    5462:	84fb      	strh	r3, [r7, #38]	; 0x26

	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5464:	f24c 5000 	movw	r0, #50432	; 0xc500
    5468:	f2c2 0000 	movt	r0, #8192	; 0x2000
    546c:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5470:	f002 fa98 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    5474:	f24c 5000 	movw	r0, #50432	; 0xc500
    5478:	f2c2 0000 	movt	r0, #8192	; 0x2000
    547c:	f04f 0100 	mov.w	r1, #0
    5480:	f002 f9c4 	bl	780c <MSS_SPI_set_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5484:	f24c 5000 	movw	r0, #50432	; 0xc500
    5488:	f2c2 0000 	movt	r0, #8192	; 0x2000
    548c:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5490:	f002 fa88 	bl	79a4 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD17, 7, rx_buffer, 1);
    5494:	f107 0218 	add.w	r2, r7, #24
    5498:	f107 0310 	add.w	r3, r7, #16
    549c:	f04f 0101 	mov.w	r1, #1
    54a0:	9100      	str	r1, [sp, #0]
    54a2:	f24c 5000 	movw	r0, #50432	; 0xc500
    54a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
    54aa:	4611      	mov	r1, r2
    54ac:	f04f 0207 	mov.w	r2, #7
    54b0:	f002 fad8 	bl	7a64 <MSS_SPI_transfer_block>
		while(c<250) {
    54b4:	e056      	b.n	5564 <SD_Read+0x178>
			rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    54b6:	f24c 5000 	movw	r0, #50432	; 0xc500
    54ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
    54be:	f04f 01ff 	mov.w	r1, #255	; 0xff
    54c2:	f002 fa6f 	bl	79a4 <MSS_SPI_transfer_frame>
    54c6:	4603      	mov	r3, r0
    54c8:	b2db      	uxtb	r3, r3
    54ca:	743b      	strb	r3, [r7, #16]
			c++;
    54cc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    54ce:	f103 0301 	add.w	r3, r3, #1
    54d2:	84fb      	strh	r3, [r7, #38]	; 0x26
			if(rx_buffer[0] == 0xFE) {
    54d4:	7c3b      	ldrb	r3, [r7, #16]
    54d6:	2bfe      	cmp	r3, #254	; 0xfe
    54d8:	d144      	bne.n	5564 <SD_Read+0x178>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    54da:	f24c 5000 	movw	r0, #50432	; 0xc500
    54de:	f2c2 0000 	movt	r0, #8192	; 0x2000
    54e2:	f04f 01ff 	mov.w	r1, #255	; 0xff
    54e6:	f002 fa5d 	bl	79a4 <MSS_SPI_transfer_frame>
				MSS_SPI_transfer_block(&g_mss_spi1,&dummy_data,0,buff,512);
    54ea:	f107 030f 	add.w	r3, r7, #15
    54ee:	f44f 7200 	mov.w	r2, #512	; 0x200
    54f2:	9200      	str	r2, [sp, #0]
    54f4:	f24c 5000 	movw	r0, #50432	; 0xc500
    54f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    54fc:	4619      	mov	r1, r3
    54fe:	f04f 0200 	mov.w	r2, #0
    5502:	683b      	ldr	r3, [r7, #0]
    5504:	f002 faae 	bl	7a64 <MSS_SPI_transfer_block>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5508:	f24c 5000 	movw	r0, #50432	; 0xc500
    550c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5510:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5514:	f002 fa46 	bl	79a4 <MSS_SPI_transfer_frame>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    5518:	f24c 5000 	movw	r0, #50432	; 0xc500
    551c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5520:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5524:	f002 fa3e 	bl	79a4 <MSS_SPI_transfer_frame>
				flag = 1;
    5528:	f04f 0301 	mov.w	r3, #1
    552c:	77fb      	strb	r3, [r7, #31]
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    552e:	f24c 5000 	movw	r0, #50432	; 0xc500
    5532:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5536:	f04f 01ff 	mov.w	r1, #255	; 0xff
    553a:	f002 fa33 	bl	79a4 <MSS_SPI_transfer_frame>
				MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    553e:	f24c 5000 	movw	r0, #50432	; 0xc500
    5542:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5546:	f04f 0100 	mov.w	r1, #0
    554a:	f002 f9e3 	bl	7914 <MSS_SPI_clear_slave_select>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    554e:	f24c 5000 	movw	r0, #50432	; 0xc500
    5552:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5556:	f04f 01ff 	mov.w	r1, #255	; 0xff
    555a:	f002 fa23 	bl	79a4 <MSS_SPI_transfer_frame>
				return 0;
    555e:	f04f 0300 	mov.w	r3, #0
    5562:	e01c      	b.n	559e <SD_Read+0x1b2>
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
		MSS_SPI_transfer_block(&g_mss_spi1, CMD17, 7, rx_buffer, 1);
		while(c<250) {
    5564:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    5566:	2bf9      	cmp	r3, #249	; 0xf9
    5568:	d9a5      	bls.n	54b6 <SD_Read+0xca>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
				return 0;
				break;
			}
		}
		i++;
    556a:	6a3b      	ldr	r3, [r7, #32]
    556c:	f103 0301 	add.w	r3, r3, #1
    5570:	623b      	str	r3, [r7, #32]
	}while(i<100);
    5572:	6a3b      	ldr	r3, [r7, #32]
    5574:	2b63      	cmp	r3, #99	; 0x63
    5576:	f67f af75 	bls.w	5464 <SD_Read+0x78>

	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
    557a:	f24c 5000 	movw	r0, #50432	; 0xc500
    557e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5582:	f04f 0100 	mov.w	r1, #0
    5586:	f002 f9c5 	bl	7914 <MSS_SPI_clear_slave_select>
	MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
    558a:	f24c 5000 	movw	r0, #50432	; 0xc500
    558e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5592:	f04f 01ff 	mov.w	r1, #255	; 0xff
    5596:	f002 fa05 	bl	79a4 <MSS_SPI_transfer_frame>
	return 1;
    559a:	f04f 0301 	mov.w	r3, #1
}
    559e:	4618      	mov	r0, r3
    55a0:	f107 0728 	add.w	r7, r7, #40	; 0x28
    55a4:	46bd      	mov	sp, r7
    55a6:	bd80      	pop	{r7, pc}

000055a8 <initialise_partition>:
 * 
 */

#include "memory.h"

void initialise_partition(partition_t *partition, uint32_t start_b,uint32_t end_b) {
    55a8:	b480      	push	{r7}
    55aa:	b085      	sub	sp, #20
    55ac:	af00      	add	r7, sp, #0
    55ae:	60f8      	str	r0, [r7, #12]
    55b0:	60b9      	str	r1, [r7, #8]
    55b2:	607a      	str	r2, [r7, #4]
	partition->start_block = start_b;
    55b4:	68fb      	ldr	r3, [r7, #12]
    55b6:	68ba      	ldr	r2, [r7, #8]
    55b8:	601a      	str	r2, [r3, #0]
	partition->end_block = end_b;
    55ba:	68fb      	ldr	r3, [r7, #12]
    55bc:	687a      	ldr	r2, [r7, #4]
    55be:	605a      	str	r2, [r3, #4]
	partition->read_pointer = start_b;
    55c0:	68fb      	ldr	r3, [r7, #12]
    55c2:	68ba      	ldr	r2, [r7, #8]
    55c4:	609a      	str	r2, [r3, #8]
	partition->write_pointer = start_b;
    55c6:	68fb      	ldr	r3, [r7, #12]
    55c8:	68ba      	ldr	r2, [r7, #8]
    55ca:	60da      	str	r2, [r3, #12]
}
    55cc:	f107 0714 	add.w	r7, r7, #20
    55d0:	46bd      	mov	sp, r7
    55d2:	bc80      	pop	{r7}
    55d4:	4770      	bx	lr
    55d6:	bf00      	nop

000055d8 <store_data>:

uint8_t store_data(partition_t *partition,uint8_t *data) {
    55d8:	b580      	push	{r7, lr}
    55da:	b082      	sub	sp, #8
    55dc:	af00      	add	r7, sp, #0
    55de:	6078      	str	r0, [r7, #4]
    55e0:	6039      	str	r1, [r7, #0]
	if((partition->write_pointer >= partition->end_block) || (partition->write_pointer < partition->start_block)) {
    55e2:	687b      	ldr	r3, [r7, #4]
    55e4:	68da      	ldr	r2, [r3, #12]
    55e6:	687b      	ldr	r3, [r7, #4]
    55e8:	685b      	ldr	r3, [r3, #4]
    55ea:	429a      	cmp	r2, r3
    55ec:	d205      	bcs.n	55fa <store_data+0x22>
    55ee:	687b      	ldr	r3, [r7, #4]
    55f0:	68da      	ldr	r2, [r3, #12]
    55f2:	687b      	ldr	r3, [r7, #4]
    55f4:	681b      	ldr	r3, [r3, #0]
    55f6:	429a      	cmp	r2, r3
    55f8:	d202      	bcs.n	5600 <store_data+0x28>
		return 2;
    55fa:	f04f 0302 	mov.w	r3, #2
    55fe:	e013      	b.n	5628 <store_data+0x50>
	}

	if(SD_Write(partition->write_pointer,data) == 0) {
    5600:	687b      	ldr	r3, [r7, #4]
    5602:	68db      	ldr	r3, [r3, #12]
    5604:	4618      	mov	r0, r3
    5606:	6839      	ldr	r1, [r7, #0]
    5608:	f7ff fdd2 	bl	51b0 <SD_Write>
    560c:	4603      	mov	r3, r0
    560e:	2b00      	cmp	r3, #0
    5610:	d108      	bne.n	5624 <store_data+0x4c>
		partition->write_pointer++;
    5612:	687b      	ldr	r3, [r7, #4]
    5614:	68db      	ldr	r3, [r3, #12]
    5616:	f103 0201 	add.w	r2, r3, #1
    561a:	687b      	ldr	r3, [r7, #4]
    561c:	60da      	str	r2, [r3, #12]
		return 0;
    561e:	f04f 0300 	mov.w	r3, #0
    5622:	e001      	b.n	5628 <store_data+0x50>
	}

	return 1;
    5624:	f04f 0301 	mov.w	r3, #1
}
    5628:	4618      	mov	r0, r3
    562a:	f107 0708 	add.w	r7, r7, #8
    562e:	46bd      	mov	sp, r7
    5630:	bd80      	pop	{r7, pc}
    5632:	bf00      	nop

00005634 <read_data>:

uint8_t read_data(partition_t *partition,uint8_t *data) {
    5634:	b580      	push	{r7, lr}
    5636:	b082      	sub	sp, #8
    5638:	af00      	add	r7, sp, #0
    563a:	6078      	str	r0, [r7, #4]
    563c:	6039      	str	r1, [r7, #0]
	if((partition->read_pointer >= partition->write_pointer) || (partition->read_pointer < partition->start_block)) {
    563e:	687b      	ldr	r3, [r7, #4]
    5640:	689a      	ldr	r2, [r3, #8]
    5642:	687b      	ldr	r3, [r7, #4]
    5644:	68db      	ldr	r3, [r3, #12]
    5646:	429a      	cmp	r2, r3
    5648:	d205      	bcs.n	5656 <read_data+0x22>
    564a:	687b      	ldr	r3, [r7, #4]
    564c:	689a      	ldr	r2, [r3, #8]
    564e:	687b      	ldr	r3, [r7, #4]
    5650:	681b      	ldr	r3, [r3, #0]
    5652:	429a      	cmp	r2, r3
    5654:	d202      	bcs.n	565c <read_data+0x28>
		return 2;
    5656:	f04f 0302 	mov.w	r3, #2
    565a:	e013      	b.n	5684 <read_data+0x50>
	}

	if(SD_Read(partition->read_pointer,data) == 0) {
    565c:	687b      	ldr	r3, [r7, #4]
    565e:	689b      	ldr	r3, [r3, #8]
    5660:	4618      	mov	r0, r3
    5662:	6839      	ldr	r1, [r7, #0]
    5664:	f7ff fec2 	bl	53ec <SD_Read>
    5668:	4603      	mov	r3, r0
    566a:	2b00      	cmp	r3, #0
    566c:	d108      	bne.n	5680 <read_data+0x4c>
		partition->read_pointer++;
    566e:	687b      	ldr	r3, [r7, #4]
    5670:	689b      	ldr	r3, [r3, #8]
    5672:	f103 0201 	add.w	r2, r3, #1
    5676:	687b      	ldr	r3, [r7, #4]
    5678:	609a      	str	r2, [r3, #8]
		return 0;
    567a:	f04f 0300 	mov.w	r3, #0
    567e:	e001      	b.n	5684 <read_data+0x50>
	}

	return 1;
    5680:	f04f 0301 	mov.w	r3, #1
}
    5684:	4618      	mov	r0, r3
    5686:	f107 0708 	add.w	r7, r7, #8
    568a:	46bd      	mov	sp, r7
    568c:	bd80      	pop	{r7, pc}
    568e:	bf00      	nop

00005690 <counter_init>:
uint8_t rx_size = 3u;
i2c_status_t status;
uint8_t flag;
uint8_t gmc_voltage_flags;

i2c_status_t counter_init(i2c_instance_t *i2c_GMC_counter){
    5690:	b580      	push	{r7, lr}
    5692:	b082      	sub	sp, #8
    5694:	af00      	add	r7, sp, #0
    5696:	6078      	str	r0, [r7, #4]
    MSS_GPIO_config(RESET_GMC_GPIO, MSS_GPIO_OUTPUT_MODE);
    5698:	f04f 0006 	mov.w	r0, #6
    569c:	f04f 0105 	mov.w	r1, #5
    56a0:	f003 fcf8 	bl	9094 <MSS_GPIO_config>
    MSS_GPIO_set_output(RESET_GMC_GPIO, 1);
    56a4:	f04f 0006 	mov.w	r0, #6
    56a8:	f04f 0101 	mov.w	r1, #1
    56ac:	f003 fd10 	bl	90d0 <MSS_GPIO_set_output>
	I2C_init(
    56b0:	6878      	ldr	r0, [r7, #4]
    56b2:	f242 0100 	movw	r1, #8192	; 0x2000
    56b6:	f2c5 0100 	movt	r1, #20480	; 0x5000
    56ba:	f04f 0210 	mov.w	r2, #16
    56be:	f04f 0300 	mov.w	r3, #0
    56c2:	f004 f9f7 	bl	9ab4 <I2C_init>
				i2c_GMC_counter,
				base_addr,
				DUMMY_SLAVE_ADDRESS,
				I2C_PCLK_DIV_256
				);
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    56c6:	6878      	ldr	r0, [r7, #4]
    56c8:	f04f 0100 	mov.w	r1, #0
    56cc:	f004 fbe4 	bl	9e98 <I2C_wait_complete>
    56d0:	4603      	mov	r3, r0
    56d2:	461a      	mov	r2, r3
    56d4:	f24c 137c 	movw	r3, #49532	; 0xc17c
    56d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    56dc:	701a      	strb	r2, [r3, #0]
	return status;
    56de:	f24c 137c 	movw	r3, #49532	; 0xc17c
    56e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    56e6:	781b      	ldrb	r3, [r3, #0]
}
    56e8:	4618      	mov	r0, r3
    56ea:	f107 0708 	add.w	r7, r7, #8
    56ee:	46bd      	mov	sp, r7
    56f0:	bd80      	pop	{r7, pc}
    56f2:	bf00      	nop

000056f4 <get_count>:
	I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_RELEASE_BUS);
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
	return status;
}

i2c_status_t get_count(i2c_instance_t *i2c_GMC_counter, uint8_t* count){
    56f4:	b580      	push	{r7, lr}
    56f6:	b084      	sub	sp, #16
    56f8:	af02      	add	r7, sp, #8
    56fa:	6078      	str	r0, [r7, #4]
    56fc:	6039      	str	r1, [r7, #0]
	I2C_read(i2c_GMC_counter, counter_addr, count, rx_size, I2C_RELEASE_BUS);
    56fe:	f24b 0334 	movw	r3, #45108	; 0xb034
    5702:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5706:	781b      	ldrb	r3, [r3, #0]
    5708:	f04f 0200 	mov.w	r2, #0
    570c:	9200      	str	r2, [sp, #0]
    570e:	6878      	ldr	r0, [r7, #4]
    5710:	f04f 0132 	mov.w	r1, #50	; 0x32
    5714:	683a      	ldr	r2, [r7, #0]
    5716:	f004 fab5 	bl	9c84 <I2C_read>
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    571a:	6878      	ldr	r0, [r7, #4]
    571c:	f04f 0100 	mov.w	r1, #0
    5720:	f004 fbba 	bl	9e98 <I2C_wait_complete>
    5724:	4603      	mov	r3, r0
    5726:	461a      	mov	r2, r3
    5728:	f24c 137c 	movw	r3, #49532	; 0xc17c
    572c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5730:	701a      	strb	r2, [r3, #0]
	return status;
    5732:	f24c 137c 	movw	r3, #49532	; 0xc17c
    5736:	f2c2 0300 	movt	r3, #8192	; 0x2000
    573a:	781b      	ldrb	r3, [r3, #0]
}
    573c:	4618      	mov	r0, r3
    573e:	f107 0708 	add.w	r7, r7, #8
    5742:	46bd      	mov	sp, r7
    5744:	bd80      	pop	{r7, pc}
    5746:	bf00      	nop

00005748 <get_free_res>:
    I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_RELEASE_BUS);
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    return status;
}

i2c_status_t get_free_res(i2c_instance_t *i2c_GMC_counter, uint8_t* free_res){
    5748:	b580      	push	{r7, lr}
    574a:	b086      	sub	sp, #24
    574c:	af02      	add	r7, sp, #8
    574e:	6078      	str	r0, [r7, #4]
    5750:	6039      	str	r1, [r7, #0]
    uint8_t tx_size = 1;
    5752:	f04f 0301 	mov.w	r3, #1
    5756:	73fb      	strb	r3, [r7, #15]
    uint8_t tx_buffer[1];
    tx_buffer[0] = 0x01;  //1xxxxxx1 address pointer and test bit(why sending this byte after slave address?)
    5758:	f04f 0301 	mov.w	r3, #1
    575c:	733b      	strb	r3, [r7, #12]

    I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_HOLD_BUS);
    575e:	7bfb      	ldrb	r3, [r7, #15]
    5760:	f107 020c 	add.w	r2, r7, #12
    5764:	f04f 0101 	mov.w	r1, #1
    5768:	9100      	str	r1, [sp, #0]
    576a:	6878      	ldr	r0, [r7, #4]
    576c:	f04f 0132 	mov.w	r1, #50	; 0x32
    5770:	f004 fa16 	bl	9ba0 <I2C_write>
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    5774:	6878      	ldr	r0, [r7, #4]
    5776:	f04f 0100 	mov.w	r1, #0
    577a:	f004 fb8d 	bl	9e98 <I2C_wait_complete>
    577e:	4603      	mov	r3, r0
    5780:	461a      	mov	r2, r3
    5782:	f24c 137c 	movw	r3, #49532	; 0xc17c
    5786:	f2c2 0300 	movt	r3, #8192	; 0x2000
    578a:	701a      	strb	r2, [r3, #0]


    I2C_read(i2c_GMC_counter, counter_addr, free_res, rx_size, I2C_RELEASE_BUS);
    578c:	f24b 0334 	movw	r3, #45108	; 0xb034
    5790:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5794:	781b      	ldrb	r3, [r3, #0]
    5796:	f04f 0200 	mov.w	r2, #0
    579a:	9200      	str	r2, [sp, #0]
    579c:	6878      	ldr	r0, [r7, #4]
    579e:	f04f 0132 	mov.w	r1, #50	; 0x32
    57a2:	683a      	ldr	r2, [r7, #0]
    57a4:	f004 fa6e 	bl	9c84 <I2C_read>
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    57a8:	6878      	ldr	r0, [r7, #4]
    57aa:	f04f 0100 	mov.w	r1, #0
    57ae:	f004 fb73 	bl	9e98 <I2C_wait_complete>
    57b2:	4603      	mov	r3, r0
    57b4:	461a      	mov	r2, r3
    57b6:	f24c 137c 	movw	r3, #49532	; 0xc17c
    57ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57be:	701a      	strb	r2, [r3, #0]
    return status;
    57c0:	f24c 137c 	movw	r3, #49532	; 0xc17c
    57c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57c8:	781b      	ldrb	r3, [r3, #0]
}
    57ca:	4618      	mov	r0, r3
    57cc:	f107 0710 	add.w	r7, r7, #16
    57d0:	46bd      	mov	sp, r7
    57d2:	bd80      	pop	{r7, pc}

000057d4 <get_gmc_voltages>:

i2c_status_t get_gmc_voltages(i2c_instance_t *i2c_GMC_ADC, uint8_t* ADC_voltages){
    57d4:	b590      	push	{r4, r7, lr}
    57d6:	b085      	sub	sp, #20
    57d8:	af00      	add	r7, sp, #0
    57da:	6078      	str	r0, [r7, #4]
    57dc:	6039      	str	r1, [r7, #0]
	uint8_t channel;
	for (channel=0; channel<8; channel++){
    57de:	f04f 0300 	mov.w	r3, #0
    57e2:	73fb      	strb	r3, [r7, #15]
    57e4:	e02e      	b.n	5844 <get_gmc_voltages+0x70>
		ADC_voltages[channel] = get_ADC_value(&counter_i2c, GMC_ADC_address, channel, &flag);
    57e6:	7bfa      	ldrb	r2, [r7, #15]
    57e8:	683b      	ldr	r3, [r7, #0]
    57ea:	eb02 0403 	add.w	r4, r2, r3
    57ee:	7bfb      	ldrb	r3, [r7, #15]
    57f0:	f24c 004c 	movw	r0, #49228	; 0xc04c
    57f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
    57f8:	f04f 0123 	mov.w	r1, #35	; 0x23
    57fc:	461a      	mov	r2, r3
    57fe:	f24c 4376 	movw	r3, #50294	; 0xc476
    5802:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5806:	f7fe fee7 	bl	45d8 <get_ADC_value>
    580a:	4603      	mov	r3, r0
    580c:	b2db      	uxtb	r3, r3
    580e:	7023      	strb	r3, [r4, #0]
		gmc_voltage_flags = gmc_voltage_flags << 1 | flag;
    5810:	f24c 4377 	movw	r3, #50295	; 0xc477
    5814:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5818:	781b      	ldrb	r3, [r3, #0]
    581a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    581e:	b2da      	uxtb	r2, r3
    5820:	f24c 4376 	movw	r3, #50294	; 0xc476
    5824:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5828:	781b      	ldrb	r3, [r3, #0]
    582a:	ea42 0303 	orr.w	r3, r2, r3
    582e:	b2db      	uxtb	r3, r3
    5830:	b2da      	uxtb	r2, r3
    5832:	f24c 4377 	movw	r3, #50295	; 0xc477
    5836:	f2c2 0300 	movt	r3, #8192	; 0x2000
    583a:	701a      	strb	r2, [r3, #0]
    return status;
}

i2c_status_t get_gmc_voltages(i2c_instance_t *i2c_GMC_ADC, uint8_t* ADC_voltages){
	uint8_t channel;
	for (channel=0; channel<8; channel++){
    583c:	7bfb      	ldrb	r3, [r7, #15]
    583e:	f103 0301 	add.w	r3, r3, #1
    5842:	73fb      	strb	r3, [r7, #15]
    5844:	7bfb      	ldrb	r3, [r7, #15]
    5846:	2b07      	cmp	r3, #7
    5848:	d9cd      	bls.n	57e6 <get_gmc_voltages+0x12>
		ADC_voltages[channel] = get_ADC_value(&counter_i2c, GMC_ADC_address, channel, &flag);
		gmc_voltage_flags = gmc_voltage_flags << 1 | flag;
	}
}
    584a:	f107 0714 	add.w	r7, r7, #20
    584e:	46bd      	mov	sp, r7
    5850:	bd90      	pop	{r4, r7, pc}
    5852:	bf00      	nop

00005854 <set_adf_spi_instance>:
#include "adf7030.h"

ADF_SPI_INSTANCE_t *adf_spi;
extern cmd_t cmd_list[NUM_CMDS];

void set_adf_spi_instance(ADF_SPI_INSTANCE_t *instance) {
    5854:	b480      	push	{r7}
    5856:	b083      	sub	sp, #12
    5858:	af00      	add	r7, sp, #0
    585a:	6078      	str	r0, [r7, #4]
    adf_spi = instance;
    585c:	f24c 4378 	movw	r3, #50296	; 0xc478
    5860:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5864:	687a      	ldr	r2, [r7, #4]
    5866:	601a      	str	r2, [r3, #0]
}
    5868:	f107 070c 	add.w	r7, r7, #12
    586c:	46bd      	mov	sp, r7
    586e:	bc80      	pop	{r7}
    5870:	4770      	bx	lr
    5872:	bf00      	nop

00005874 <adf_init>:
static uint32_t config_length_header;

//Pointer to store the beginning of the SPI commands in radio_memory_configuration
uint8_t *radio_memory_configuration_start_spi_command;

uint8_t adf_init(){
    5874:	b580      	push	{r7, lr}
    5876:	b08c      	sub	sp, #48	; 0x30
    5878:	af02      	add	r7, sp, #8
	uint32_t before = 0xFFFFFFFF,current,limit;
    587a:	f04f 33ff 	mov.w	r3, #4294967295
    587e:	617b      	str	r3, [r7, #20]
	uint8_t buf=0xFF, count=0;
    5880:	f04f 33ff 	mov.w	r3, #4294967295
    5884:	74fb      	strb	r3, [r7, #19]
    5886:	f04f 0300 	mov.w	r3, #0
    588a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	uint8_t flag = 1,rx_data =0;
    588e:	f04f 0301 	mov.w	r3, #1
    5892:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    5896:	f04f 0300 	mov.w	r3, #0
    589a:	74bb      	strb	r3, [r7, #18]
	uint8_t enable_intr[4];
	enable_intr[0] = 0x00;
    589c:	f04f 0300 	mov.w	r3, #0
    58a0:	733b      	strb	r3, [r7, #12]
	enable_intr[1] = 0xFF;
    58a2:	f04f 33ff 	mov.w	r3, #4294967295
    58a6:	737b      	strb	r3, [r7, #13]
	enable_intr[2] = 0x10;
    58a8:	f04f 0310 	mov.w	r3, #16
    58ac:	73bb      	strb	r3, [r7, #14]
	enable_intr[3] = 0x17;
    58ae:	f04f 0317 	mov.w	r3, #23
    58b2:	73fb      	strb	r3, [r7, #15]
	uint8_t rssi_cca[6];
	rssi_cca[0] = 0x00;
    58b4:	f04f 0300 	mov.w	r3, #0
    58b8:	713b      	strb	r3, [r7, #4]
	rssi_cca[1] = 0x00;
    58ba:	f04f 0300 	mov.w	r3, #0
    58be:	717b      	strb	r3, [r7, #5]
	rssi_cca[2] = 0x00;
    58c0:	f04f 0300 	mov.w	r3, #0
    58c4:	71bb      	strb	r3, [r7, #6]
	rssi_cca[3] = 0x00;
    58c6:	f04f 0300 	mov.w	r3, #0
    58ca:	71fb      	strb	r3, [r7, #7]
	//Timer to check if MISO is reacting on time. Typical delay bw #CS Low and MISO high is 92us from datasheet. Here
//	TMR_init(&timer,CORETIMER_0_0,TMR_ONE_SHOT_MODE,PRESCALER_DIV_2,before);

	//Set the adf spi as g_core_spi0

	SPI_init(&g_core_spi0, CORESPI_C0_0, 8);
    58cc:	f24b 5014 	movw	r0, #46356	; 0xb514
    58d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
    58d4:	f244 0100 	movw	r1, #16384	; 0x4000
    58d8:	f2c5 0100 	movt	r1, #20480	; 0x5000
    58dc:	f04f 0208 	mov.w	r2, #8
    58e0:	f003 fd5a 	bl	9398 <SPI_init>
	SPI_configure_master_mode(&g_core_spi0);
    58e4:	f24b 5014 	movw	r0, #46356	; 0xb514
    58e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    58ec:	f003 fdc6 	bl	947c <SPI_configure_master_mode>

	MSS_GPIO_config(MSS_GPIO_5, MSS_GPIO_OUTPUT_MODE);
    58f0:	f04f 0005 	mov.w	r0, #5
    58f4:	f04f 0105 	mov.w	r1, #5
    58f8:	f003 fbcc 	bl	9094 <MSS_GPIO_config>

	set_adf_spi_instance(&g_core_spi0);
    58fc:	f24b 5014 	movw	r0, #46356	; 0xb514
    5900:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5904:	f7ff ffa6 	bl	5854 <set_adf_spi_instance>

	//Doing ADF_RESET

	MSS_GPIO_set_output(ADF_RST,0);
    5908:	f04f 0005 	mov.w	r0, #5
    590c:	f04f 0100 	mov.w	r1, #0
    5910:	f003 fbde 	bl	90d0 <MSS_GPIO_set_output>
	uint16_t i = 0;
    5914:	f04f 0300 	mov.w	r3, #0
    5918:	84bb      	strh	r3, [r7, #36]	; 0x24
	for(i=0;i<1000;i++){
    591a:	f04f 0300 	mov.w	r3, #0
    591e:	84bb      	strh	r3, [r7, #36]	; 0x24
    5920:	e003      	b.n	592a <adf_init+0xb6>
    5922:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    5924:	f103 0301 	add.w	r3, r3, #1
    5928:	84bb      	strh	r3, [r7, #36]	; 0x24
    592a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    592c:	f240 33e7 	movw	r3, #999	; 0x3e7
    5930:	429a      	cmp	r2, r3
    5932:	d9f6      	bls.n	5922 <adf_init+0xae>

	}
	MSS_GPIO_set_output(ADF_RST,1);
    5934:	f04f 0005 	mov.w	r0, #5
    5938:	f04f 0101 	mov.w	r1, #1
    593c:	f003 fbc8 	bl	90d0 <MSS_GPIO_set_output>
	//Start timer
//	TMR_start(&timer);

	//Bring #CS Low by selecting the slave
//	ADF_SPI_SLAVE_SELECT(adf_spi, ADF_SPI_SLAVE);
	i = 0;
    5940:	f04f 0300 	mov.w	r3, #0
    5944:	84bb      	strh	r3, [r7, #36]	; 0x24

//		ADF_SPI_BLOCK_READ(adf_spi, &rx_data ,1, &rx_data, 1);
		//Older version
		//MSS_GPIO_set_output(MSS_GPIO_3, 0);
		//New Version
		ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    5946:	f24c 4378 	movw	r3, #50296	; 0xc478
    594a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    594e:	681b      	ldr	r3, [r3, #0]
    5950:	4618      	mov	r0, r3
    5952:	f04f 0100 	mov.w	r1, #0
    5956:	f003 fdd3 	bl	9500 <SPI_set_slave_select>
		for(i=0;i<350;i++){
    595a:	f04f 0300 	mov.w	r3, #0
    595e:	84bb      	strh	r3, [r7, #36]	; 0x24
    5960:	e003      	b.n	596a <adf_init+0xf6>
    5962:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    5964:	f103 0301 	add.w	r3, r3, #1
    5968:	84bb      	strh	r3, [r7, #36]	; 0x24
    596a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    596c:	f240 135d 	movw	r3, #349	; 0x15d
    5970:	429a      	cmp	r2, r3
    5972:	d9f6      	bls.n	5962 <adf_init+0xee>

		}
		ADF_SPI_BLOCK_READ(adf_spi, &buf ,1, &rx_data, 1);
    5974:	f24c 4378 	movw	r3, #50296	; 0xc478
    5978:	f2c2 0300 	movt	r3, #8192	; 0x2000
    597c:	6819      	ldr	r1, [r3, #0]
    597e:	f107 0213 	add.w	r2, r7, #19
    5982:	f107 0312 	add.w	r3, r7, #18
    5986:	f04f 0001 	mov.w	r0, #1
    598a:	9000      	str	r0, [sp, #0]
    598c:	4608      	mov	r0, r1
    598e:	4611      	mov	r1, r2
    5990:	f04f 0201 	mov.w	r2, #1
    5994:	f000 fb56 	bl	6044 <adf_spi_trans_read>

//		for(i=0;i<350;i++){
//
//		}

		if(rx_data) {
    5998:	7cbb      	ldrb	r3, [r7, #18]
    599a:	2b00      	cmp	r3, #0
    599c:	d01b      	beq.n	59d6 <adf_init+0x162>
			flag = 0;
    599e:	f04f 0300 	mov.w	r3, #0
    59a2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
			//Older version
//			MSS_GPIO_set_output(MSS_GPIO_3, 1);
			//New version
			ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
    59a6:	f24c 4378 	movw	r3, #50296	; 0xc478
    59aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59ae:	681b      	ldr	r3, [r3, #0]
    59b0:	4618      	mov	r0, r3
    59b2:	f04f 0100 	mov.w	r1, #0
    59b6:	f003 fdf7 	bl	95a8 <SPI_clear_slave_select>
			for(i=0;i<1000;i++){
    59ba:	f04f 0300 	mov.w	r3, #0
    59be:	84bb      	strh	r3, [r7, #36]	; 0x24
    59c0:	e003      	b.n	59ca <adf_init+0x156>
    59c2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    59c4:	f103 0301 	add.w	r3, r3, #1
    59c8:	84bb      	strh	r3, [r7, #36]	; 0x24
    59ca:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    59cc:	f240 33e7 	movw	r3, #999	; 0x3e7
    59d0:	429a      	cmp	r2, r3
    59d2:	d9f6      	bls.n	59c2 <adf_init+0x14e>

			}
			break;
    59d4:	e009      	b.n	59ea <adf_init+0x176>
		}
		// current = TMR_current_value(&timer);
		// if((before - current) > limit) {
		// 	flag = 1;
		// 	break;
		count++;
    59d6:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    59da:	f103 0301 	add.w	r3, r3, #1
    59de:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
		// }
	}while(count<10);
    59e2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    59e6:	2b09      	cmp	r3, #9
    59e8:	d9ad      	bls.n	5946 <adf_init+0xd2>


	ADF_SPI_SLAVE_SELECT(adf_spi, ADF_SPI_SLAVE);
    59ea:	f24c 4378 	movw	r3, #50296	; 0xc478
    59ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    59f2:	681b      	ldr	r3, [r3, #0]
    59f4:	4618      	mov	r0, r3
    59f6:	f04f 0100 	mov.w	r1, #0
    59fa:	f003 fd81 	bl	9500 <SPI_set_slave_select>
	ADF_SPI_BLOCK_READ(adf_spi, &buf ,1, &rx_data, 1);
    59fe:	f24c 4378 	movw	r3, #50296	; 0xc478
    5a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a06:	6819      	ldr	r1, [r3, #0]
    5a08:	f107 0213 	add.w	r2, r7, #19
    5a0c:	f107 0312 	add.w	r3, r7, #18
    5a10:	f04f 0001 	mov.w	r0, #1
    5a14:	9000      	str	r0, [sp, #0]
    5a16:	4608      	mov	r0, r1
    5a18:	4611      	mov	r1, r2
    5a1a:	f04f 0201 	mov.w	r2, #1
    5a1e:	f000 fb11 	bl	6044 <adf_spi_trans_read>
	uint8_t check_val = 0,nop = ADF_NOP;
    5a22:	f04f 0300 	mov.w	r3, #0
    5a26:	70fb      	strb	r3, [r7, #3]
    5a28:	f04f 33ff 	mov.w	r3, #4294967295
    5a2c:	70bb      	strb	r3, [r7, #2]
	uint8_t tries = 0;
    5a2e:	f04f 0300 	mov.w	r3, #0
    5a32:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	//Send NOP command(0xFF) until adf is ready to receive command and also adf is in idle state
	do {
		ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
    5a36:	f24c 4378 	movw	r3, #50296	; 0xc478
    5a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a3e:	6819      	ldr	r1, [r3, #0]
    5a40:	f107 0202 	add.w	r2, r7, #2
    5a44:	f107 0303 	add.w	r3, r7, #3
    5a48:	f04f 0001 	mov.w	r0, #1
    5a4c:	9000      	str	r0, [sp, #0]
    5a4e:	4608      	mov	r0, r1
    5a50:	4611      	mov	r1, r2
    5a52:	f04f 0201 	mov.w	r2, #1
    5a56:	f000 faf5 	bl	6044 <adf_spi_trans_read>
		if(((check_val & CMD_READY) != 0) && ((check_val & 0x04) != 0)) {
    5a5a:	78fb      	ldrb	r3, [r7, #3]
    5a5c:	f003 0320 	and.w	r3, r3, #32
    5a60:	2b00      	cmp	r3, #0
    5a62:	d004      	beq.n	5a6e <adf_init+0x1fa>
    5a64:	78fb      	ldrb	r3, [r7, #3]
    5a66:	f003 0304 	and.w	r3, r3, #4
    5a6a:	2b00      	cmp	r3, #0
    5a6c:	d10f      	bne.n	5a8e <adf_init+0x21a>
			break;
		}
	}while(tries++ < 100);
    5a6e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    5a72:	2b63      	cmp	r3, #99	; 0x63
    5a74:	bf8c      	ite	hi
    5a76:	2300      	movhi	r3, #0
    5a78:	2301      	movls	r3, #1
    5a7a:	b2db      	uxtb	r3, r3
    5a7c:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
    5a80:	f102 0201 	add.w	r2, r2, #1
    5a84:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
    5a88:	2b00      	cmp	r3, #0
    5a8a:	d1d4      	bne.n	5a36 <adf_init+0x1c2>
    5a8c:	e000      	b.n	5a90 <adf_init+0x21c>
	uint8_t tries = 0;
	//Send NOP command(0xFF) until adf is ready to receive command and also adf is in idle state
	do {
		ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
		if(((check_val & CMD_READY) != 0) && ((check_val & 0x04) != 0)) {
			break;
    5a8e:	bf00      	nop

	//Pull #CS high again
	//Old version
//	ADF_SPI_SLAVE_SELECT(adf_spi, 0);
	//New version
	ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
    5a90:	f24c 4378 	movw	r3, #50296	; 0xc478
    5a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5a98:	681b      	ldr	r3, [r3, #0]
    5a9a:	4618      	mov	r0, r3
    5a9c:	f04f 0100 	mov.w	r1, #0
    5aa0:	f003 fd82 	bl	95a8 <SPI_clear_slave_select>
//	TMR_stop(&timer);

	uint8_t ret_val;
	tries = 0;
    5aa4:	f04f 0300 	mov.w	r3, #0
    5aa8:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	//Call adf_config to configure the ADF
	while(tries++ < 100) {
    5aac:	e008      	b.n	5ac0 <adf_init+0x24c>
	   ret_val = adf_get_state();
    5aae:	f000 fb77 	bl	61a0 <adf_get_state>
    5ab2:	4603      	mov	r3, r0
    5ab4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	   if(ret_val == PHY_OFF) {
    5ab8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    5abc:	2b01      	cmp	r3, #1
    5abe:	d00f      	beq.n	5ae0 <adf_init+0x26c>
//	TMR_stop(&timer);

	uint8_t ret_val;
	tries = 0;
	//Call adf_config to configure the ADF
	while(tries++ < 100) {
    5ac0:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    5ac4:	2b63      	cmp	r3, #99	; 0x63
    5ac6:	bf8c      	ite	hi
    5ac8:	2300      	movhi	r3, #0
    5aca:	2301      	movls	r3, #1
    5acc:	b2db      	uxtb	r3, r3
    5ace:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
    5ad2:	f102 0201 	add.w	r2, r2, #1
    5ad6:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
    5ada:	2b00      	cmp	r3, #0
    5adc:	d1e7      	bne.n	5aae <adf_init+0x23a>
    5ade:	e000      	b.n	5ae2 <adf_init+0x26e>
	   ret_val = adf_get_state();
	   if(ret_val == PHY_OFF) {
		   break;
    5ae0:	bf00      	nop

	if(tries >= 100) {
//		return ERR_FAIL_TO_SET_PHY_OFF;
	}

	count = config_adf7030();
    5ae2:	f000 f8b7 	bl	5c54 <config_adf7030>
    5ae6:	4603      	mov	r3, r0
    5ae8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

	adf_read_from_memory(RMODE_1, PROFILE_CCA_READBACK, rssi_cca, 6);
    5aec:	f107 0304 	add.w	r3, r7, #4
    5af0:	f04f 0078 	mov.w	r0, #120	; 0x78
    5af4:	f240 317c 	movw	r1, #892	; 0x37c
    5af8:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5afc:	461a      	mov	r2, r3
    5afe:	f04f 0306 	mov.w	r3, #6
    5b02:	f000 f971 	bl	5de8 <adf_read_from_memory>

	rssi_cca[3] = rssi_cca[3] && 0x00;
    5b06:	f04f 0300 	mov.w	r3, #0
    5b0a:	71fb      	strb	r3, [r7, #7]

	adf_write_to_memory(WMODE_1, PROFILE_CCA_READBACK, rssi_cca, 4);
    5b0c:	f107 0304 	add.w	r3, r7, #4
    5b10:	f04f 0038 	mov.w	r0, #56	; 0x38
    5b14:	f240 317c 	movw	r1, #892	; 0x37c
    5b18:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5b1c:	461a      	mov	r2, r3
    5b1e:	f04f 0304 	mov.w	r3, #4
    5b22:	f000 f917 	bl	5d54 <adf_write_to_memory>

	if(count == 0){
    5b26:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    5b2a:	2b00      	cmp	r3, #0
    5b2c:	d109      	bne.n	5b42 <adf_init+0x2ce>
		count = cmd_ready_set();
    5b2e:	f000 fa0d 	bl	5f4c <cmd_ready_set>
    5b32:	4603      	mov	r3, r0
    5b34:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	} else {
		return ERR_CONFIG_FILE_FAILED;
	}

	if(count == 0){
    5b38:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    5b3c:	2b00      	cmp	r3, #0
    5b3e:	d003      	beq.n	5b48 <adf_init+0x2d4>
    5b40:	e00c      	b.n	5b5c <adf_init+0x2e8>
	adf_write_to_memory(WMODE_1, PROFILE_CCA_READBACK, rssi_cca, 4);

	if(count == 0){
		count = cmd_ready_set();
	} else {
		return ERR_CONFIG_FILE_FAILED;
    5b42:	f04f 0303 	mov.w	r3, #3
    5b46:	e01a      	b.n	5b7e <adf_init+0x30a>
	}

	if(count == 0){
		count = adf_in_idle();
    5b48:	f000 fa3e 	bl	5fc8 <adf_in_idle>
    5b4c:	4603      	mov	r3, r0
    5b4e:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	} else {
		return ERR_CMD_FAILED;
	}

	if(count == 0){
    5b52:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    5b56:	2b00      	cmp	r3, #0
    5b58:	d003      	beq.n	5b62 <adf_init+0x2ee>
    5b5a:	e00f      	b.n	5b7c <adf_init+0x308>
	}

	if(count == 0){
		count = adf_in_idle();
	} else {
		return ERR_CMD_FAILED;
    5b5c:	f04f 0302 	mov.w	r3, #2
    5b60:	e00d      	b.n	5b7e <adf_init+0x30a>
	}

	if(count == 0){
		adf_write_to_memory(WMODE_1, GENERIC_PKT_FRAME_CFG1, enable_intr, 4);
    5b62:	f107 030c 	add.w	r3, r7, #12
    5b66:	f04f 0038 	mov.w	r0, #56	; 0x38
    5b6a:	f240 5100 	movw	r1, #1280	; 0x500
    5b6e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5b72:	461a      	mov	r2, r3
    5b74:	f04f 0304 	mov.w	r3, #4
    5b78:	f000 f8ec 	bl	5d54 <adf_write_to_memory>
    5b7c:	e7ff      	b.n	5b7e <adf_init+0x30a>
	} else {
//		return ERR_IN_IDLE_FAILED;
	}

}
    5b7e:	4618      	mov	r0, r3
    5b80:	f107 0728 	add.w	r7, r7, #40	; 0x28
    5b84:	46bd      	mov	sp, r7
    5b86:	bd80      	pop	{r7, pc}

00005b88 <apply_file>:

uint8_t apply_file(uint8_t *file, uint16_t size) {
    5b88:	b580      	push	{r7, lr}
    5b8a:	b088      	sub	sp, #32
    5b8c:	af02      	add	r7, sp, #8
    5b8e:	6078      	str	r0, [r7, #4]
    5b90:	460b      	mov	r3, r1
    5b92:	807b      	strh	r3, [r7, #2]
//    uint32_t size = sizeof(file);
	//uint32_t size = 728;
    uint32_t array_position = 0;
    5b94:	f04f 0300 	mov.w	r3, #0
    5b98:	60fb      	str	r3, [r7, #12]
    uint8_t *pSeqData;
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    5b9a:	f24c 4378 	movw	r3, #50296	; 0xc478
    5b9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5ba2:	681b      	ldr	r3, [r3, #0]
    5ba4:	4618      	mov	r0, r3
    5ba6:	f04f 0100 	mov.w	r1, #0
    5baa:	f003 fca9 	bl	9500 <SPI_set_slave_select>
    do 
    { 
      // Calculate the number of bytes to write
      uint32_t length =  (*(file + array_position ) << 16) | 
    5bae:	687a      	ldr	r2, [r7, #4]
    5bb0:	68fb      	ldr	r3, [r7, #12]
    5bb2:	4413      	add	r3, r2
    5bb4:	781b      	ldrb	r3, [r3, #0]
    5bb6:	ea4f 4203 	mov.w	r2, r3, lsl #16
                         (*(file + array_position + 1) << 8) |
    5bba:	68fb      	ldr	r3, [r7, #12]
    5bbc:	f103 0101 	add.w	r1, r3, #1
    5bc0:	687b      	ldr	r3, [r7, #4]
    5bc2:	440b      	add	r3, r1
    5bc4:	781b      	ldrb	r3, [r3, #0]
    5bc6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    5bca:	ea42 0203 	orr.w	r2, r2, r3
                         (*(file + array_position + 2));
    5bce:	68fb      	ldr	r3, [r7, #12]
    5bd0:	f103 0102 	add.w	r1, r3, #2
    5bd4:	687b      	ldr	r3, [r7, #4]
    5bd6:	440b      	add	r3, r1
    5bd8:	781b      	ldrb	r3, [r3, #0]
    uint8_t *pSeqData;
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    do 
    { 
      // Calculate the number of bytes to write
      uint32_t length =  (*(file + array_position ) << 16) | 
    5bda:	ea42 0303 	orr.w	r3, r2, r3
                         (*(file + array_position + 1) << 8) |
                         (*(file + array_position + 2));
    5bde:	617b      	str	r3, [r7, #20]
      
      if(length > 0xFFFF)
    5be0:	697a      	ldr	r2, [r7, #20]
    5be2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5be6:	429a      	cmp	r2, r3
    5be8:	d902      	bls.n	5bf0 <apply_file+0x68>
      {
         return ERR_LENGTH_OVERFLOW;
    5bea:	f04f 0301 	mov.w	r3, #1
    5bee:	e02b      	b.n	5c48 <apply_file+0xc0>
      } 
      
      // Write the SPI data pointed to location (MEMORY_FILE + array_position) with specified length (length)
      pSeqData = (file + array_position + 3);
    5bf0:	68fb      	ldr	r3, [r7, #12]
    5bf2:	f103 0303 	add.w	r3, r3, #3
    5bf6:	687a      	ldr	r2, [r7, #4]
    5bf8:	4413      	add	r3, r2
    5bfa:	613b      	str	r3, [r7, #16]
      
      // Transfer the Configuration sequence
      ADF_SPI_BLOCK_WRITE(adf_spi,pSeqData,1,(pSeqData+1),(length-4));
    5bfc:	f24c 4378 	movw	r3, #50296	; 0xc478
    5c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c04:	681a      	ldr	r2, [r3, #0]
    5c06:	693b      	ldr	r3, [r7, #16]
    5c08:	f103 0301 	add.w	r3, r3, #1
    5c0c:	6979      	ldr	r1, [r7, #20]
    5c0e:	f1a1 0104 	sub.w	r1, r1, #4
    5c12:	9100      	str	r1, [sp, #0]
    5c14:	4610      	mov	r0, r2
    5c16:	6939      	ldr	r1, [r7, #16]
    5c18:	f04f 0201 	mov.w	r2, #1
    5c1c:	f000 fa46 	bl	60ac <adf_spi_trans_write>

      // Update the array position to point to the next block
      array_position += length;
    5c20:	68fa      	ldr	r2, [r7, #12]
    5c22:	697b      	ldr	r3, [r7, #20]
    5c24:	4413      	add	r3, r2
    5c26:	60fb      	str	r3, [r7, #12]
    
    }while(array_position < size); // Continue operation until full data file has been written
    5c28:	887a      	ldrh	r2, [r7, #2]
    5c2a:	68fb      	ldr	r3, [r7, #12]
    5c2c:	429a      	cmp	r2, r3
    5c2e:	d8be      	bhi.n	5bae <apply_file+0x26>
    //ADF_SPI_SLAVE_SELECT(adf_spi,0);
    //using new drivers
    ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
    5c30:	f24c 4378 	movw	r3, #50296	; 0xc478
    5c34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5c38:	681b      	ldr	r3, [r3, #0]
    5c3a:	4618      	mov	r0, r3
    5c3c:	f04f 0100 	mov.w	r1, #0
    5c40:	f003 fcb2 	bl	95a8 <SPI_clear_slave_select>

    return 0;
    5c44:	f04f 0300 	mov.w	r3, #0

}
    5c48:	4618      	mov	r0, r3
    5c4a:	f107 0718 	add.w	r7, r7, #24
    5c4e:	46bd      	mov	sp, r7
    5c50:	bd80      	pop	{r7, pc}
    5c52:	bf00      	nop

00005c54 <config_adf7030>:

uint8_t config_adf7030() {
    5c54:	b580      	push	{r7, lr}
    5c56:	b088      	sub	sp, #32
    5c58:	af00      	add	r7, sp, #0
    //   array_position += length;
    
    // }while(array_position < size); // Continue operation until full data file has been written

    uint8_t ret_val;
    uint8_t en_calib_array[] = {EN_CALIB >> 24,(EN_CALIB >> 16) & 0xFF, (EN_CALIB >> 8) & 0xFF, EN_CALIB & 0xFF};
    5c5a:	f64b 03c0 	movw	r3, #47296	; 0xb8c0
    5c5e:	f2c0 0300 	movt	r3, #0
    5c62:	681b      	ldr	r3, [r3, #0]
    5c64:	61bb      	str	r3, [r7, #24]
    uint8_t en_calib_ar[] = {EN_CALIB & 0xFF, (EN_CALIB >> 8) & 0xFF, (EN_CALIB >> 16) & 0xFF, EN_CALIB >> 24 };
    5c66:	f64b 03c4 	movw	r3, #47300	; 0xb8c4
    5c6a:	f2c0 0300 	movt	r3, #0
    5c6e:	681b      	ldr	r3, [r3, #0]
    5c70:	617b      	str	r3, [r7, #20]
    uint8_t dis_calib_array[] = {DIS_CALIB >> 24,(DIS_CALIB >> 16) & 0xFF, (DIS_CALIB >> 8) & 0xFF, DIS_CALIB & 0xFF};
    5c72:	f64b 03c8 	movw	r3, #47304	; 0xb8c8
    5c76:	f2c0 0300 	movt	r3, #0
    5c7a:	681b      	ldr	r3, [r3, #0]
    5c7c:	613b      	str	r3, [r7, #16]
    uint8_t dis_calib_ar[] = {DIS_CALIB & 0xFF, (DIS_CALIB >> 8) & 0xFF, (DIS_CALIB >> 16) & 0xFF, DIS_CALIB >> 24};
    5c7e:	f64b 03cc 	movw	r3, #47308	; 0xb8cc
    5c82:	f2c0 0300 	movt	r3, #0
    5c86:	681b      	ldr	r3, [r3, #0]
    5c88:	60fb      	str	r3, [r7, #12]
    uint8_t read_reg[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
    5c8a:	f04f 0300 	mov.w	r3, #0
    5c8e:	713b      	strb	r3, [r7, #4]
    5c90:	f04f 0300 	mov.w	r3, #0
    5c94:	717b      	strb	r3, [r7, #5]
    5c96:	f04f 0300 	mov.w	r3, #0
    5c9a:	71bb      	strb	r3, [r7, #6]
    5c9c:	f04f 0300 	mov.w	r3, #0
    5ca0:	71fb      	strb	r3, [r7, #7]
    5ca2:	f04f 0300 	mov.w	r3, #0
    5ca6:	723b      	strb	r3, [r7, #8]
    5ca8:	f04f 0300 	mov.w	r3, #0
    5cac:	727b      	strb	r3, [r7, #9]
	uint8_t tries = 0;
    5cae:	f04f 0300 	mov.w	r3, #0
    5cb2:	77fb      	strb	r3, [r7, #31]

    //Apply the configuration file
    ret_val = apply_file(radio_memory_configuration, SIZEOFCONFIG);
    5cb4:	f24b 0038 	movw	r0, #45112	; 0xb038
    5cb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5cbc:	f44f 7136 	mov.w	r1, #728	; 0x2d8
    5cc0:	f7ff ff62 	bl	5b88 <apply_file>
    5cc4:	4603      	mov	r3, r0
    5cc6:	77bb      	strb	r3, [r7, #30]
    if(ret_val) {
    5cc8:	7fbb      	ldrb	r3, [r7, #30]
    5cca:	2b00      	cmp	r3, #0
    5ccc:	d002      	beq.n	5cd4 <config_adf7030+0x80>
        return ERR_CONFIG_FILE_FAILED;
    5cce:	f04f 0303 	mov.w	r3, #3
    5cd2:	e03a      	b.n	5d4a <config_adf7030+0xf6>
    //Enable calibration
//    adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,en_calib_ar,4);

//    Issue CMD_CONFIG_DEV command
//    return 0;
    ret_val = adf_send_cmd(CMD_CFG_DEV);
    5cd4:	f04f 0085 	mov.w	r0, #133	; 0x85
    5cd8:	f000 f8d2 	bl	5e80 <adf_send_cmd>
    5cdc:	4603      	mov	r3, r0
    5cde:	77bb      	strb	r3, [r7, #30]

	if(ret_val != 0) {
    5ce0:	7fbb      	ldrb	r3, [r7, #30]
    5ce2:	2b00      	cmp	r3, #0
    5ce4:	d002      	beq.n	5cec <config_adf7030+0x98>
		return 1;
    5ce6:	f04f 0301 	mov.w	r3, #1
    5cea:	e02e      	b.n	5d4a <config_adf7030+0xf6>
//	   }
//   }

//    adf_in_idle();
    //Issue CMD_PHY_ON
    ret_val = adf_send_cmd(CMD_PHY_ON);
    5cec:	f04f 0082 	mov.w	r0, #130	; 0x82
    5cf0:	f000 f8c6 	bl	5e80 <adf_send_cmd>
    5cf4:	4603      	mov	r3, r0
    5cf6:	77bb      	strb	r3, [r7, #30]
    if(ret_val) {
    5cf8:	7fbb      	ldrb	r3, [r7, #30]
    5cfa:	2b00      	cmp	r3, #0
    5cfc:	d00e      	beq.n	5d1c <config_adf7030+0xc8>
//        adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);
        return (ret_val | 0xC0);
    5cfe:	7fbb      	ldrb	r3, [r7, #30]
    5d00:	ea6f 6383 	mvn.w	r3, r3, lsl #26
    5d04:	ea6f 6393 	mvn.w	r3, r3, lsr #26
    5d08:	b2db      	uxtb	r3, r3
    5d0a:	e01e      	b.n	5d4a <config_adf7030+0xf6>
    }
    while(tries++ < 100) {
    	ret_val = adf_get_state();
    5d0c:	f000 fa48 	bl	61a0 <adf_get_state>
    5d10:	4603      	mov	r3, r0
    5d12:	77bb      	strb	r3, [r7, #30]
	   if(ret_val == PHY_ON) {
    5d14:	7fbb      	ldrb	r3, [r7, #30]
    5d16:	2b02      	cmp	r3, #2
    5d18:	d00e      	beq.n	5d38 <config_adf7030+0xe4>
    5d1a:	e000      	b.n	5d1e <config_adf7030+0xca>
    ret_val = adf_send_cmd(CMD_PHY_ON);
    if(ret_val) {
//        adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);
        return (ret_val | 0xC0);
    }
    while(tries++ < 100) {
    5d1c:	bf00      	nop
    5d1e:	7ffb      	ldrb	r3, [r7, #31]
    5d20:	2b63      	cmp	r3, #99	; 0x63
    5d22:	bf8c      	ite	hi
    5d24:	2300      	movhi	r3, #0
    5d26:	2301      	movls	r3, #1
    5d28:	b2db      	uxtb	r3, r3
    5d2a:	7ffa      	ldrb	r2, [r7, #31]
    5d2c:	f102 0201 	add.w	r2, r2, #1
    5d30:	77fa      	strb	r2, [r7, #31]
    5d32:	2b00      	cmp	r3, #0
    5d34:	d1ea      	bne.n	5d0c <config_adf7030+0xb8>
    5d36:	e000      	b.n	5d3a <config_adf7030+0xe6>
    	ret_val = adf_get_state();
	   if(ret_val == PHY_ON) {
		   break;
    5d38:	bf00      	nop
	   }
   }

	if(tries >= 100) {
    5d3a:	7ffb      	ldrb	r3, [r7, #31]
    5d3c:	2b63      	cmp	r3, #99	; 0x63
    5d3e:	d902      	bls.n	5d46 <config_adf7030+0xf2>
		return 1;
    5d40:	f04f 0301 	mov.w	r3, #1
    5d44:	e001      	b.n	5d4a <config_adf7030+0xf6>
//    }

    //Disable calibration
//    adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);

    return 0;
    5d46:	f04f 0300 	mov.w	r3, #0

#else

#endif
}
    5d4a:	4618      	mov	r0, r3
    5d4c:	f107 0720 	add.w	r7, r7, #32
    5d50:	46bd      	mov	sp, r7
    5d52:	bd80      	pop	{r7, pc}

00005d54 <adf_write_to_memory>:


uint8_t adf_write_to_memory(uint8_t mode,uint32_t addr,uint8_t *data,uint32_t size) {
    5d54:	b580      	push	{r7, lr}
    5d56:	b088      	sub	sp, #32
    5d58:	af02      	add	r7, sp, #8
    5d5a:	60b9      	str	r1, [r7, #8]
    5d5c:	607a      	str	r2, [r7, #4]
    5d5e:	603b      	str	r3, [r7, #0]
    5d60:	4603      	mov	r3, r0
    5d62:	73fb      	strb	r3, [r7, #15]
    //Currently implementing mode1 for testing. Need to implement other modes
    if((mode & WMODE_1) == WMODE_1){
        uint8_t cmd_data[] = {mode,(addr >> 24),((addr >> 16) & 0xFF),((addr >> 8) & 0xFF),(addr & 0xFF )};
    5d64:	68bb      	ldr	r3, [r7, #8]
    5d66:	ea4f 6313 	mov.w	r3, r3, lsr #24
    5d6a:	b2d8      	uxtb	r0, r3
    5d6c:	68bb      	ldr	r3, [r7, #8]
    5d6e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    5d72:	b2d9      	uxtb	r1, r3
    5d74:	68bb      	ldr	r3, [r7, #8]
    5d76:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5d7a:	b2da      	uxtb	r2, r3
    5d7c:	68bb      	ldr	r3, [r7, #8]
    5d7e:	b2db      	uxtb	r3, r3
    5d80:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5d84:	f887 c010 	strb.w	ip, [r7, #16]
    5d88:	7478      	strb	r0, [r7, #17]
    5d8a:	74b9      	strb	r1, [r7, #18]
    5d8c:	74fa      	strb	r2, [r7, #19]
    5d8e:	753b      	strb	r3, [r7, #20]
        ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    5d90:	f24c 4378 	movw	r3, #50296	; 0xc478
    5d94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5d98:	681b      	ldr	r3, [r3, #0]
    5d9a:	4618      	mov	r0, r3
    5d9c:	f04f 0100 	mov.w	r1, #0
    5da0:	f003 fbae 	bl	9500 <SPI_set_slave_select>
        ADF_SPI_BLOCK_WRITE(adf_spi,cmd_data,5,data,size);
    5da4:	f24c 4378 	movw	r3, #50296	; 0xc478
    5da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5dac:	681a      	ldr	r2, [r3, #0]
    5dae:	f107 0310 	add.w	r3, r7, #16
    5db2:	6839      	ldr	r1, [r7, #0]
    5db4:	9100      	str	r1, [sp, #0]
    5db6:	4610      	mov	r0, r2
    5db8:	4619      	mov	r1, r3
    5dba:	f04f 0205 	mov.w	r2, #5
    5dbe:	687b      	ldr	r3, [r7, #4]
    5dc0:	f000 f974 	bl	60ac <adf_spi_trans_write>
        ADF_SPI_SLAVE_CLEAR(adf_spi, ADF_SPI_SLAVE);
    5dc4:	f24c 4378 	movw	r3, #50296	; 0xc478
    5dc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5dcc:	681b      	ldr	r3, [r3, #0]
    5dce:	4618      	mov	r0, r3
    5dd0:	f04f 0100 	mov.w	r1, #0
    5dd4:	f003 fbe8 	bl	95a8 <SPI_clear_slave_select>
    }

    return 0;
    5dd8:	f04f 0300 	mov.w	r3, #0
    

}
    5ddc:	4618      	mov	r0, r3
    5dde:	f107 0718 	add.w	r7, r7, #24
    5de2:	46bd      	mov	sp, r7
    5de4:	bd80      	pop	{r7, pc}
    5de6:	bf00      	nop

00005de8 <adf_read_from_memory>:

uint8_t* adf_read_from_memory(uint8_t mode,uint32_t addr,uint8_t *data,uint32_t size) {
    5de8:	b580      	push	{r7, lr}
    5dea:	b088      	sub	sp, #32
    5dec:	af02      	add	r7, sp, #8
    5dee:	60b9      	str	r1, [r7, #8]
    5df0:	607a      	str	r2, [r7, #4]
    5df2:	603b      	str	r3, [r7, #0]
    5df4:	4603      	mov	r3, r0
    5df6:	73fb      	strb	r3, [r7, #15]
    if((mode & RMODE_1) == RMODE_1){
        uint8_t cmd_data[] = {mode,(addr >> 24),((addr >> 16) & 0xFF),((addr >> 8) & 0xFF),(addr & 0xFF )};
    5df8:	68bb      	ldr	r3, [r7, #8]
    5dfa:	ea4f 6313 	mov.w	r3, r3, lsr #24
    5dfe:	b2d8      	uxtb	r0, r3
    5e00:	68bb      	ldr	r3, [r7, #8]
    5e02:	ea4f 4313 	mov.w	r3, r3, lsr #16
    5e06:	b2d9      	uxtb	r1, r3
    5e08:	68bb      	ldr	r3, [r7, #8]
    5e0a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5e0e:	b2da      	uxtb	r2, r3
    5e10:	68bb      	ldr	r3, [r7, #8]
    5e12:	b2db      	uxtb	r3, r3
    5e14:	f897 c00f 	ldrb.w	ip, [r7, #15]
    5e18:	f887 c010 	strb.w	ip, [r7, #16]
    5e1c:	7478      	strb	r0, [r7, #17]
    5e1e:	74b9      	strb	r1, [r7, #18]
    5e20:	74fa      	strb	r2, [r7, #19]
    5e22:	753b      	strb	r3, [r7, #20]
        ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    5e24:	f24c 4378 	movw	r3, #50296	; 0xc478
    5e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e2c:	681b      	ldr	r3, [r3, #0]
    5e2e:	4618      	mov	r0, r3
    5e30:	f04f 0100 	mov.w	r1, #0
    5e34:	f003 fb64 	bl	9500 <SPI_set_slave_select>
        ADF_SPI_BLOCK_READ(adf_spi,cmd_data,5,data,size+RMODE1_OFFSET);
    5e38:	f24c 4378 	movw	r3, #50296	; 0xc478
    5e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e40:	681a      	ldr	r2, [r3, #0]
    5e42:	683b      	ldr	r3, [r7, #0]
    5e44:	f103 0102 	add.w	r1, r3, #2
    5e48:	f107 0310 	add.w	r3, r7, #16
    5e4c:	9100      	str	r1, [sp, #0]
    5e4e:	4610      	mov	r0, r2
    5e50:	4619      	mov	r1, r3
    5e52:	f04f 0205 	mov.w	r2, #5
    5e56:	687b      	ldr	r3, [r7, #4]
    5e58:	f000 f8f4 	bl	6044 <adf_spi_trans_read>
        ADF_SPI_SLAVE_CLEAR(adf_spi, ADF_SPI_SLAVE);
    5e5c:	f24c 4378 	movw	r3, #50296	; 0xc478
    5e60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e64:	681b      	ldr	r3, [r3, #0]
    5e66:	4618      	mov	r0, r3
    5e68:	f04f 0100 	mov.w	r1, #0
    5e6c:	f003 fb9c 	bl	95a8 <SPI_clear_slave_select>
    }
    return (data+RMODE1_OFFSET);
    5e70:	687b      	ldr	r3, [r7, #4]
    5e72:	f103 0302 	add.w	r3, r3, #2
}
    5e76:	4618      	mov	r0, r3
    5e78:	f107 0718 	add.w	r7, r7, #24
    5e7c:	46bd      	mov	sp, r7
    5e7e:	bd80      	pop	{r7, pc}

00005e80 <adf_send_cmd>:

uint8_t adf_send_cmd(uint8_t command) {
    5e80:	b580      	push	{r7, lr}
    5e82:	b086      	sub	sp, #24
    5e84:	af02      	add	r7, sp, #8
    5e86:	4603      	mov	r3, r0
    5e88:	71fb      	strb	r3, [r7, #7]
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    5e8a:	f24c 4378 	movw	r3, #50296	; 0xc478
    5e8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5e92:	681b      	ldr	r3, [r3, #0]
    5e94:	4618      	mov	r0, r3
    5e96:	f04f 0100 	mov.w	r1, #0
    5e9a:	f003 fb31 	bl	9500 <SPI_set_slave_select>
    uint8_t check_val = 0,nop = ADF_NOP;
    5e9e:	f04f 0300 	mov.w	r3, #0
    5ea2:	73bb      	strb	r3, [r7, #14]
    5ea4:	f04f 33ff 	mov.w	r3, #4294967295
    5ea8:	737b      	strb	r3, [r7, #13]
    uint8_t tries = 0;
    5eaa:	f04f 0300 	mov.w	r3, #0
    5eae:	73fb      	strb	r3, [r7, #15]
    //Send NOP command(0xFF) until adf is ready to receive command
   do {
       ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
    5eb0:	f24c 4378 	movw	r3, #50296	; 0xc478
    5eb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5eb8:	6819      	ldr	r1, [r3, #0]
    5eba:	f107 020d 	add.w	r2, r7, #13
    5ebe:	f107 030e 	add.w	r3, r7, #14
    5ec2:	f04f 0001 	mov.w	r0, #1
    5ec6:	9000      	str	r0, [sp, #0]
    5ec8:	4608      	mov	r0, r1
    5eca:	4611      	mov	r1, r2
    5ecc:	f04f 0201 	mov.w	r2, #1
    5ed0:	f000 f8b8 	bl	6044 <adf_spi_trans_read>
       if((check_val & CMD_READY) != 0) {
    5ed4:	7bbb      	ldrb	r3, [r7, #14]
    5ed6:	f003 0320 	and.w	r3, r3, #32
    5eda:	2b00      	cmp	r3, #0
    5edc:	d10c      	bne.n	5ef8 <adf_send_cmd+0x78>
           break;
       }
   }while(tries++ < 100);
    5ede:	7bfb      	ldrb	r3, [r7, #15]
    5ee0:	2b63      	cmp	r3, #99	; 0x63
    5ee2:	bf8c      	ite	hi
    5ee4:	2300      	movhi	r3, #0
    5ee6:	2301      	movls	r3, #1
    5ee8:	b2db      	uxtb	r3, r3
    5eea:	7bfa      	ldrb	r2, [r7, #15]
    5eec:	f102 0201 	add.w	r2, r2, #1
    5ef0:	73fa      	strb	r2, [r7, #15]
    5ef2:	2b00      	cmp	r3, #0
    5ef4:	d1dc      	bne.n	5eb0 <adf_send_cmd+0x30>
    5ef6:	e000      	b.n	5efa <adf_send_cmd+0x7a>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
   do {
       ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
       if((check_val & CMD_READY) != 0) {
           break;
    5ef8:	bf00      	nop
       }
   }while(tries++ < 100);
   if(tries >= 100) {
    5efa:	7bfb      	ldrb	r3, [r7, #15]
    5efc:	2b63      	cmp	r3, #99	; 0x63
    5efe:	d902      	bls.n	5f06 <adf_send_cmd+0x86>
       return ERR_CMD_FAILED;
    5f00:	f04f 0302 	mov.w	r3, #2
    5f04:	e01d      	b.n	5f42 <adf_send_cmd+0xc2>
   }

    //Send the command
    ADF_SPI_BLOCK_WRITE(adf_spi,&command, 1, &check_val, 1);
    5f06:	f24c 4378 	movw	r3, #50296	; 0xc478
    5f0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f0e:	6819      	ldr	r1, [r3, #0]
    5f10:	f107 0207 	add.w	r2, r7, #7
    5f14:	f107 030e 	add.w	r3, r7, #14
    5f18:	f04f 0001 	mov.w	r0, #1
    5f1c:	9000      	str	r0, [sp, #0]
    5f1e:	4608      	mov	r0, r1
    5f20:	4611      	mov	r1, r2
    5f22:	f04f 0201 	mov.w	r2, #1
    5f26:	f000 f8c1 	bl	60ac <adf_spi_trans_write>
    //Using old drivers
    //ADF_SPI_SLAVE_SELECT(adf_spi,0);
    //Using new drivers
    ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
    5f2a:	f24c 4378 	movw	r3, #50296	; 0xc478
    5f2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f32:	681b      	ldr	r3, [r3, #0]
    5f34:	4618      	mov	r0, r3
    5f36:	f04f 0100 	mov.w	r1, #0
    5f3a:	f003 fb35 	bl	95a8 <SPI_clear_slave_select>

    return 0;
    5f3e:	f04f 0300 	mov.w	r3, #0

}
    5f42:	4618      	mov	r0, r3
    5f44:	f107 0710 	add.w	r7, r7, #16
    5f48:	46bd      	mov	sp, r7
    5f4a:	bd80      	pop	{r7, pc}

00005f4c <cmd_ready_set>:

    return 0;

}

uint8_t cmd_ready_set() {
    5f4c:	b580      	push	{r7, lr}
    5f4e:	b084      	sub	sp, #16
    5f50:	af02      	add	r7, sp, #8
    uint8_t check_val = 0,nop = ADF_NOP;
    5f52:	f04f 0300 	mov.w	r3, #0
    5f56:	71bb      	strb	r3, [r7, #6]
    5f58:	f04f 33ff 	mov.w	r3, #4294967295
    5f5c:	717b      	strb	r3, [r7, #5]
    uint8_t tries = 0;
    5f5e:	f04f 0300 	mov.w	r3, #0
    5f62:	71fb      	strb	r3, [r7, #7]
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
    5f64:	f24c 4378 	movw	r3, #50296	; 0xc478
    5f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5f6c:	6819      	ldr	r1, [r3, #0]
    5f6e:	f107 0205 	add.w	r2, r7, #5
    5f72:	f107 0306 	add.w	r3, r7, #6
    5f76:	f04f 0001 	mov.w	r0, #1
    5f7a:	9000      	str	r0, [sp, #0]
    5f7c:	4608      	mov	r0, r1
    5f7e:	4611      	mov	r1, r2
    5f80:	f04f 0201 	mov.w	r2, #1
    5f84:	f000 f85e 	bl	6044 <adf_spi_trans_read>
        if((check_val & CMD_READY) != 0) {
    5f88:	79bb      	ldrb	r3, [r7, #6]
    5f8a:	f003 0320 	and.w	r3, r3, #32
    5f8e:	2b00      	cmp	r3, #0
    5f90:	d10c      	bne.n	5fac <cmd_ready_set+0x60>
            break;
        }
    }while(tries++ < 100);
    5f92:	79fb      	ldrb	r3, [r7, #7]
    5f94:	2b63      	cmp	r3, #99	; 0x63
    5f96:	bf8c      	ite	hi
    5f98:	2300      	movhi	r3, #0
    5f9a:	2301      	movls	r3, #1
    5f9c:	b2db      	uxtb	r3, r3
    5f9e:	79fa      	ldrb	r2, [r7, #7]
    5fa0:	f102 0201 	add.w	r2, r2, #1
    5fa4:	71fa      	strb	r2, [r7, #7]
    5fa6:	2b00      	cmp	r3, #0
    5fa8:	d1dc      	bne.n	5f64 <cmd_ready_set+0x18>
    5faa:	e000      	b.n	5fae <cmd_ready_set+0x62>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
        if((check_val & CMD_READY) != 0) {
            break;
    5fac:	bf00      	nop
        }
    }while(tries++ < 100);
    if(tries >= 100) {
    5fae:	79fb      	ldrb	r3, [r7, #7]
    5fb0:	2b63      	cmp	r3, #99	; 0x63
    5fb2:	d902      	bls.n	5fba <cmd_ready_set+0x6e>
        return 1;
    5fb4:	f04f 0301 	mov.w	r3, #1
    5fb8:	e001      	b.n	5fbe <cmd_ready_set+0x72>
    }
    return 0;
    5fba:	f04f 0300 	mov.w	r3, #0
}
    5fbe:	4618      	mov	r0, r3
    5fc0:	f107 0708 	add.w	r7, r7, #8
    5fc4:	46bd      	mov	sp, r7
    5fc6:	bd80      	pop	{r7, pc}

00005fc8 <adf_in_idle>:

uint8_t adf_in_idle() {
    5fc8:	b580      	push	{r7, lr}
    5fca:	b084      	sub	sp, #16
    5fcc:	af02      	add	r7, sp, #8
    uint8_t check_val = 0,nop = ADF_NOP;
    5fce:	f04f 0300 	mov.w	r3, #0
    5fd2:	71bb      	strb	r3, [r7, #6]
    5fd4:	f04f 33ff 	mov.w	r3, #4294967295
    5fd8:	717b      	strb	r3, [r7, #5]
    uint8_t tries = 0;
    5fda:	f04f 0300 	mov.w	r3, #0
    5fde:	71fb      	strb	r3, [r7, #7]
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
    5fe0:	f24c 4378 	movw	r3, #50296	; 0xc478
    5fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5fe8:	6819      	ldr	r1, [r3, #0]
    5fea:	f107 0205 	add.w	r2, r7, #5
    5fee:	f107 0306 	add.w	r3, r7, #6
    5ff2:	f04f 0001 	mov.w	r0, #1
    5ff6:	9000      	str	r0, [sp, #0]
    5ff8:	4608      	mov	r0, r1
    5ffa:	4611      	mov	r1, r2
    5ffc:	f04f 0201 	mov.w	r2, #1
    6000:	f000 f820 	bl	6044 <adf_spi_trans_read>
        if((check_val & 0x04) != 0) {
    6004:	79bb      	ldrb	r3, [r7, #6]
    6006:	f003 0304 	and.w	r3, r3, #4
    600a:	2b00      	cmp	r3, #0
    600c:	d10c      	bne.n	6028 <adf_in_idle+0x60>
            break;
        }
    }while(tries++ < 100);
    600e:	79fb      	ldrb	r3, [r7, #7]
    6010:	2b63      	cmp	r3, #99	; 0x63
    6012:	bf8c      	ite	hi
    6014:	2300      	movhi	r3, #0
    6016:	2301      	movls	r3, #1
    6018:	b2db      	uxtb	r3, r3
    601a:	79fa      	ldrb	r2, [r7, #7]
    601c:	f102 0201 	add.w	r2, r2, #1
    6020:	71fa      	strb	r2, [r7, #7]
    6022:	2b00      	cmp	r3, #0
    6024:	d1dc      	bne.n	5fe0 <adf_in_idle+0x18>
    6026:	e000      	b.n	602a <adf_in_idle+0x62>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
        if((check_val & 0x04) != 0) {
            break;
    6028:	bf00      	nop
        }
    }while(tries++ < 100);
    if(tries >= 100) {
    602a:	79fb      	ldrb	r3, [r7, #7]
    602c:	2b63      	cmp	r3, #99	; 0x63
    602e:	d902      	bls.n	6036 <adf_in_idle+0x6e>
        return 1;
    6030:	f04f 0301 	mov.w	r3, #1
    6034:	e001      	b.n	603a <adf_in_idle+0x72>
    }
    return 0;
    6036:	f04f 0300 	mov.w	r3, #0
}
    603a:	4618      	mov	r0, r3
    603c:	f107 0708 	add.w	r7, r7, #8
    6040:	46bd      	mov	sp, r7
    6042:	bd80      	pop	{r7, pc}

00006044 <adf_spi_trans_read>:

void adf_spi_trans_read( spi_instance_t * this_spi,
    uint8_t * cmd_buffer,
    size_t cmd_byte_size,
    uint8_t * rd_buffer,
    size_t rd_byte_size){
    6044:	b580      	push	{r7, lr}
    6046:	b088      	sub	sp, #32
    6048:	af02      	add	r7, sp, #8
    604a:	60f8      	str	r0, [r7, #12]
    604c:	60b9      	str	r1, [r7, #8]
    604e:	607a      	str	r2, [r7, #4]
    6050:	603b      	str	r3, [r7, #0]

	uint16_t i;
	uint8_t r_buf[6];
	r_buf[0] = 0x00;
    6052:	f04f 0300 	mov.w	r3, #0
    6056:	743b      	strb	r3, [r7, #16]
//	MSS_GPIO_set_output(MSS_GPIO_3, 1);
	//Using new drivers
//	SPI_set_slave_select(this_spi,ADF_SPI_SLAVE);


		SPI_transfer_block(this_spi,cmd_buffer,cmd_byte_size,r_buf,rd_byte_size);
    6058:	687b      	ldr	r3, [r7, #4]
    605a:	b29a      	uxth	r2, r3
    605c:	6a3b      	ldr	r3, [r7, #32]
    605e:	b299      	uxth	r1, r3
    6060:	f107 0310 	add.w	r3, r7, #16
    6064:	9100      	str	r1, [sp, #0]
    6066:	68f8      	ldr	r0, [r7, #12]
    6068:	68b9      	ldr	r1, [r7, #8]
    606a:	f003 faf3 	bl	9654 <SPI_transfer_block>

//	SPI_transfer_block(this_spi,0,0,rd_buffer,rd_byte_size);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
    606e:	f04f 0300 	mov.w	r3, #0
    6072:	82fb      	strh	r3, [r7, #22]
    6074:	e011      	b.n	609a <adf_spi_trans_read+0x56>
		if(i<rd_byte_size){
    6076:	8afa      	ldrh	r2, [r7, #22]
    6078:	6a3b      	ldr	r3, [r7, #32]
    607a:	429a      	cmp	r2, r3
    607c:	d209      	bcs.n	6092 <adf_spi_trans_read+0x4e>
			rd_buffer[i] = r_buf[i];
    607e:	8afa      	ldrh	r2, [r7, #22]
    6080:	683b      	ldr	r3, [r7, #0]
    6082:	4413      	add	r3, r2
    6084:	8afa      	ldrh	r2, [r7, #22]
    6086:	f107 0118 	add.w	r1, r7, #24
    608a:	440a      	add	r2, r1
    608c:	f812 2c08 	ldrb.w	r2, [r2, #-8]
    6090:	701a      	strb	r2, [r3, #0]

		SPI_transfer_block(this_spi,cmd_buffer,cmd_byte_size,r_buf,rd_byte_size);

//	SPI_transfer_block(this_spi,0,0,rd_buffer,rd_byte_size);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
    6092:	8afb      	ldrh	r3, [r7, #22]
    6094:	f103 0301 	add.w	r3, r3, #1
    6098:	82fb      	strh	r3, [r7, #22]
    609a:	8afa      	ldrh	r2, [r7, #22]
    609c:	f240 33e7 	movw	r3, #999	; 0x3e7
    60a0:	429a      	cmp	r2, r3
    60a2:	d9e8      	bls.n	6076 <adf_spi_trans_read+0x32>
		if(i<rd_byte_size){
			rd_buffer[i] = r_buf[i];
		}
	}
}
    60a4:	f107 0718 	add.w	r7, r7, #24
    60a8:	46bd      	mov	sp, r7
    60aa:	bd80      	pop	{r7, pc}

000060ac <adf_spi_trans_write>:

void adf_spi_trans_write( spi_instance_t * this_spi,
    uint8_t * cmd_buffer,
    size_t cmd_byte_size,
    uint8_t * wr_buffer,
    size_t wr_byte_size){
    60ac:	b580      	push	{r7, lr}
    60ae:	b0d2      	sub	sp, #328	; 0x148
    60b0:	af02      	add	r7, sp, #8
    60b2:	f107 0c0c 	add.w	ip, r7, #12
    60b6:	f8cc 0000 	str.w	r0, [ip]
    60ba:	f107 0008 	add.w	r0, r7, #8
    60be:	6001      	str	r1, [r0, #0]
    60c0:	f107 0104 	add.w	r1, r7, #4
    60c4:	600a      	str	r2, [r1, #0]
    60c6:	463a      	mov	r2, r7
    60c8:	6013      	str	r3, [r2, #0]

	uint8_t data[300];
	uint16_t i = 0;
    60ca:	f04f 0300 	mov.w	r3, #0
    60ce:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e

	for(;i<cmd_byte_size;i++){
    60d2:	e011      	b.n	60f8 <adf_spi_trans_write+0x4c>
		data[i] = cmd_buffer[i];
    60d4:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
    60d8:	f8b7 113e 	ldrh.w	r1, [r7, #318]	; 0x13e
    60dc:	f107 0208 	add.w	r2, r7, #8
    60e0:	6812      	ldr	r2, [r2, #0]
    60e2:	440a      	add	r2, r1
    60e4:	7811      	ldrb	r1, [r2, #0]
    60e6:	f107 0210 	add.w	r2, r7, #16
    60ea:	54d1      	strb	r1, [r2, r3]
    size_t wr_byte_size){

	uint8_t data[300];
	uint16_t i = 0;

	for(;i<cmd_byte_size;i++){
    60ec:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
    60f0:	f103 0301 	add.w	r3, r3, #1
    60f4:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
    60f8:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
    60fc:	f107 0304 	add.w	r3, r7, #4
    6100:	681b      	ldr	r3, [r3, #0]
    6102:	429a      	cmp	r2, r3
    6104:	d3e6      	bcc.n	60d4 <adf_spi_trans_write+0x28>
		data[i] = cmd_buffer[i];
	}
	for(;i<cmd_byte_size + wr_byte_size;i++){
    6106:	e015      	b.n	6134 <adf_spi_trans_write+0x88>
		data[i] = wr_buffer[i-cmd_byte_size];
    6108:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
    610c:	f8b7 113e 	ldrh.w	r1, [r7, #318]	; 0x13e
    6110:	f107 0204 	add.w	r2, r7, #4
    6114:	6812      	ldr	r2, [r2, #0]
    6116:	ebc2 0101 	rsb	r1, r2, r1
    611a:	463a      	mov	r2, r7
    611c:	6812      	ldr	r2, [r2, #0]
    611e:	440a      	add	r2, r1
    6120:	7811      	ldrb	r1, [r2, #0]
    6122:	f107 0210 	add.w	r2, r7, #16
    6126:	54d1      	strb	r1, [r2, r3]
	uint16_t i = 0;

	for(;i<cmd_byte_size;i++){
		data[i] = cmd_buffer[i];
	}
	for(;i<cmd_byte_size + wr_byte_size;i++){
    6128:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
    612c:	f103 0301 	add.w	r3, r3, #1
    6130:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
    6134:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
    6138:	f107 0304 	add.w	r3, r7, #4
    613c:	6819      	ldr	r1, [r3, #0]
    613e:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
    6142:	440b      	add	r3, r1
    6144:	429a      	cmp	r2, r3
    6146:	d3df      	bcc.n	6108 <adf_spi_trans_write+0x5c>
//	MSS_GPIO_set_output(MSS_GPIO_3, 0);
//	SPI_block_write(this_spi, cmd_buffer, cmd_byte_size, wr_buffer, wr_byte_size);
//	MSS_GPIO_set_output(MSS_GPIO_3, 1);
	//Using new drivers
//	SPI_set_slave_select(this_spi,ADF_SPI_SLAVE);
	SPI_transfer_block(this_spi,data,cmd_byte_size + wr_byte_size,0,0);
    6148:	f107 0304 	add.w	r3, r7, #4
    614c:	681b      	ldr	r3, [r3, #0]
    614e:	b29a      	uxth	r2, r3
    6150:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
    6154:	b29b      	uxth	r3, r3
    6156:	4413      	add	r3, r2
    6158:	b29b      	uxth	r3, r3
    615a:	f107 010c 	add.w	r1, r7, #12
    615e:	f107 0210 	add.w	r2, r7, #16
    6162:	f04f 0000 	mov.w	r0, #0
    6166:	9000      	str	r0, [sp, #0]
    6168:	6808      	ldr	r0, [r1, #0]
    616a:	4611      	mov	r1, r2
    616c:	461a      	mov	r2, r3
    616e:	f04f 0300 	mov.w	r3, #0
    6172:	f003 fa6f 	bl	9654 <SPI_transfer_block>
//	SPI_transfer_block(this_spi,wr_buffer,wr_byte_size,0,0);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
    6176:	f04f 0300 	mov.w	r3, #0
    617a:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
    617e:	e005      	b.n	618c <adf_spi_trans_write+0xe0>
    6180:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
    6184:	f103 0301 	add.w	r3, r3, #1
    6188:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
    618c:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
    6190:	f240 33e7 	movw	r3, #999	; 0x3e7
    6194:	429a      	cmp	r2, r3
    6196:	d9f3      	bls.n	6180 <adf_spi_trans_write+0xd4>

	}
}
    6198:	f507 77a0 	add.w	r7, r7, #320	; 0x140
    619c:	46bd      	mov	sp, r7
    619e:	bd80      	pop	{r7, pc}

000061a0 <adf_get_state>:

uint8_t adf_get_state() {
    61a0:	b580      	push	{r7, lr}
    61a2:	b082      	sub	sp, #8
    61a4:	af00      	add	r7, sp, #0
    uint8_t misc_fw[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
    61a6:	f04f 0300 	mov.w	r3, #0
    61aa:	703b      	strb	r3, [r7, #0]
    61ac:	f04f 0300 	mov.w	r3, #0
    61b0:	707b      	strb	r3, [r7, #1]
    61b2:	f04f 0300 	mov.w	r3, #0
    61b6:	70bb      	strb	r3, [r7, #2]
    61b8:	f04f 0300 	mov.w	r3, #0
    61bc:	70fb      	strb	r3, [r7, #3]
    61be:	f04f 0300 	mov.w	r3, #0
    61c2:	713b      	strb	r3, [r7, #4]
    61c4:	f04f 0300 	mov.w	r3, #0
    61c8:	717b      	strb	r3, [r7, #5]
    uint8_t curr_mode = 0;
    61ca:	f04f 0300 	mov.w	r3, #0
    61ce:	71bb      	strb	r3, [r7, #6]
	uint8_t tries = 0;
    61d0:	f04f 0300 	mov.w	r3, #0
    61d4:	71fb      	strb	r3, [r7, #7]
    while((!(misc_fw[0] == 0xe4 || misc_fw[0] == 0xA4)) && tries++ < 100){
    61d6:	e014      	b.n	6202 <adf_get_state+0x62>
    	adf_read_from_memory(RMODE_1,MISC_FW,misc_fw,4);
    61d8:	463b      	mov	r3, r7
    61da:	f04f 0078 	mov.w	r0, #120	; 0x78
    61de:	f244 21b4 	movw	r1, #17076	; 0x42b4
    61e2:	f2c4 0100 	movt	r1, #16384	; 0x4000
    61e6:	461a      	mov	r2, r3
    61e8:	f04f 0304 	mov.w	r3, #4
    61ec:	f7ff fdfc 	bl	5de8 <adf_read_from_memory>
    	if( misc_fw[0] == 0xe2 || misc_fw[0] == 0xA2 || misc_fw[0] == 0x00){
    61f0:	783b      	ldrb	r3, [r7, #0]
    61f2:	2be2      	cmp	r3, #226	; 0xe2
    61f4:	d017      	beq.n	6226 <adf_get_state+0x86>
    61f6:	783b      	ldrb	r3, [r7, #0]
    61f8:	2ba2      	cmp	r3, #162	; 0xa2
    61fa:	d014      	beq.n	6226 <adf_get_state+0x86>
    61fc:	783b      	ldrb	r3, [r7, #0]
    61fe:	2b00      	cmp	r3, #0
    6200:	d011      	beq.n	6226 <adf_get_state+0x86>

uint8_t adf_get_state() {
    uint8_t misc_fw[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t curr_mode = 0;
	uint8_t tries = 0;
    while((!(misc_fw[0] == 0xe4 || misc_fw[0] == 0xA4)) && tries++ < 100){
    6202:	783b      	ldrb	r3, [r7, #0]
    6204:	2be4      	cmp	r3, #228	; 0xe4
    6206:	d00e      	beq.n	6226 <adf_get_state+0x86>
    6208:	783b      	ldrb	r3, [r7, #0]
    620a:	2ba4      	cmp	r3, #164	; 0xa4
    620c:	d00b      	beq.n	6226 <adf_get_state+0x86>
    620e:	79fb      	ldrb	r3, [r7, #7]
    6210:	2b63      	cmp	r3, #99	; 0x63
    6212:	bf8c      	ite	hi
    6214:	2300      	movhi	r3, #0
    6216:	2301      	movls	r3, #1
    6218:	b2db      	uxtb	r3, r3
    621a:	79fa      	ldrb	r2, [r7, #7]
    621c:	f102 0201 	add.w	r2, r2, #1
    6220:	71fa      	strb	r2, [r7, #7]
    6222:	2b00      	cmp	r3, #0
    6224:	d1d8      	bne.n	61d8 <adf_get_state+0x38>
    	if( misc_fw[0] == 0xe2 || misc_fw[0] == 0xA2 || misc_fw[0] == 0x00){
    		break;
    	}
    }
	//PHY SLEEP is zero. Need to discuss what to return when tries goes out of limits
    curr_mode = misc_fw[4] & 0x3F;
    6226:	793b      	ldrb	r3, [r7, #4]
    6228:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    622c:	71bb      	strb	r3, [r7, #6]
    return curr_mode;
    622e:	79bb      	ldrb	r3, [r7, #6]
}
    6230:	4618      	mov	r0, r3
    6232:	f107 0708 	add.w	r7, r7, #8
    6236:	46bd      	mov	sp, r7
    6238:	bd80      	pop	{r7, pc}
    623a:	bf00      	nop

0000623c <get_rssi_data>:
	while(cmd_buff[0] == 0x00){
		adf_read_from_memory(RMODE_1, RX_BUFFER, cmd_buff, 4);
	}
}

void get_rssi_data(uint16_t* rssi){
    623c:	b580      	push	{r7, lr}
    623e:	b084      	sub	sp, #16
    6240:	af00      	add	r7, sp, #0
    6242:	6078      	str	r0, [r7, #4]

	uint8_t rx_buf[6];
	rx_buf[0] = 0x00;
    6244:	f04f 0300 	mov.w	r3, #0
    6248:	723b      	strb	r3, [r7, #8]

	while(rx_buf[0] == 0x00){
    624a:	e00c      	b.n	6266 <get_rssi_data+0x2a>
		adf_read_from_memory(RMODE_1, RSSI_ADDR, rx_buf, 4);
    624c:	f107 0308 	add.w	r3, r7, #8
    6250:	f04f 0078 	mov.w	r0, #120	; 0x78
    6254:	f240 5138 	movw	r1, #1336	; 0x538
    6258:	f2c2 0100 	movt	r1, #8192	; 0x2000
    625c:	461a      	mov	r2, r3
    625e:	f04f 0304 	mov.w	r3, #4
    6262:	f7ff fdc1 	bl	5de8 <adf_read_from_memory>
void get_rssi_data(uint16_t* rssi){

	uint8_t rx_buf[6];
	rx_buf[0] = 0x00;

	while(rx_buf[0] == 0x00){
    6266:	7a3b      	ldrb	r3, [r7, #8]
    6268:	2b00      	cmp	r3, #0
    626a:	d0ef      	beq.n	624c <get_rssi_data+0x10>
		adf_read_from_memory(RMODE_1, RSSI_ADDR, rx_buf, 4);
	}

	*rssi = (uint16_t)((rx_buf[2] & 0x07) << 8) + rx_buf[3];
    626c:	7abb      	ldrb	r3, [r7, #10]
    626e:	f003 0307 	and.w	r3, r3, #7
    6272:	ea4f 2303 	mov.w	r3, r3, lsl #8
    6276:	b29a      	uxth	r2, r3
    6278:	7afb      	ldrb	r3, [r7, #11]
    627a:	4413      	add	r3, r2
    627c:	b29a      	uxth	r2, r3
    627e:	687b      	ldr	r3, [r7, #4]
    6280:	801a      	strh	r2, [r3, #0]
	*rssi = ~(*rssi) + 1;
    6282:	687b      	ldr	r3, [r7, #4]
    6284:	881b      	ldrh	r3, [r3, #0]
    6286:	f1c3 0300 	rsb	r3, r3, #0
    628a:	b29b      	uxth	r3, r3
    628c:	b29a      	uxth	r2, r3
    628e:	687b      	ldr	r3, [r7, #4]
    6290:	801a      	strh	r2, [r3, #0]
	*rssi = *rssi & 0x0FFF;
    6292:	687b      	ldr	r3, [r7, #4]
    6294:	881b      	ldrh	r3, [r3, #0]
    6296:	ea4f 5303 	mov.w	r3, r3, lsl #20
    629a:	ea4f 5313 	mov.w	r3, r3, lsr #20
    629e:	687a      	ldr	r2, [r7, #4]
    62a0:	8013      	strh	r3, [r2, #0]
	if(*rssi > 2048){
    62a2:	687b      	ldr	r3, [r7, #4]
    62a4:	881b      	ldrh	r3, [r3, #0]
    62a6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    62aa:	d906      	bls.n	62ba <get_rssi_data+0x7e>
		*rssi = *rssi - 2048;
    62ac:	687b      	ldr	r3, [r7, #4]
    62ae:	881b      	ldrh	r3, [r3, #0]
    62b0:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
    62b4:	b29a      	uxth	r2, r3
    62b6:	687b      	ldr	r3, [r7, #4]
    62b8:	801a      	strh	r2, [r3, #0]
	}
	*rssi = *rssi/4;
    62ba:	687b      	ldr	r3, [r7, #4]
    62bc:	881b      	ldrh	r3, [r3, #0]
    62be:	ea4f 0393 	mov.w	r3, r3, lsr #2
    62c2:	b29a      	uxth	r2, r3
    62c4:	687b      	ldr	r3, [r7, #4]
    62c6:	801a      	strh	r2, [r3, #0]

}
    62c8:	f107 0710 	add.w	r7, r7, #16
    62cc:	46bd      	mov	sp, r7
    62ce:	bd80      	pop	{r7, pc}

000062d0 <get_rssi_cca_data>:
	temp[0] = rx_buf[5];
	temp[1] = rx_buf[4] & 0x0F;

}

void get_rssi_cca_data(uint16_t* rssi){
    62d0:	b580      	push	{r7, lr}
    62d2:	b084      	sub	sp, #16
    62d4:	af00      	add	r7, sp, #0
    62d6:	6078      	str	r0, [r7, #4]
	uint8_t rx_buf[6];
	//uint16_t rssi;
	rx_buf[0] = 0x00;
    62d8:	f04f 0300 	mov.w	r3, #0
    62dc:	723b      	strb	r3, [r7, #8]
	uint8_t state;

	adf_send_cmd(CMD_PHY_CCA);
    62de:	f04f 0086 	mov.w	r0, #134	; 0x86
    62e2:	f7ff fdcd 	bl	5e80 <adf_send_cmd>

	state = adf_get_state();
    62e6:	f7ff ff5b 	bl	61a0 <adf_get_state>
    62ea:	4603      	mov	r3, r0
    62ec:	73fb      	strb	r3, [r7, #15]

	while(state != 2){
    62ee:	e003      	b.n	62f8 <get_rssi_cca_data+0x28>
		state = adf_get_state();
    62f0:	f7ff ff56 	bl	61a0 <adf_get_state>
    62f4:	4603      	mov	r3, r0
    62f6:	73fb      	strb	r3, [r7, #15]

	adf_send_cmd(CMD_PHY_CCA);

	state = adf_get_state();

	while(state != 2){
    62f8:	7bfb      	ldrb	r3, [r7, #15]
    62fa:	2b02      	cmp	r3, #2
    62fc:	d1f8      	bne.n	62f0 <get_rssi_cca_data+0x20>
		state = adf_get_state();
	}

	while(rx_buf[0] == 0x00){
    62fe:	e00c      	b.n	631a <get_rssi_cca_data+0x4a>
		adf_read_from_memory(RMODE_1, PROFILE_CCA_READBACK, rx_buf, 4);
    6300:	f107 0308 	add.w	r3, r7, #8
    6304:	f04f 0078 	mov.w	r0, #120	; 0x78
    6308:	f240 317c 	movw	r1, #892	; 0x37c
    630c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    6310:	461a      	mov	r2, r3
    6312:	f04f 0304 	mov.w	r3, #4
    6316:	f7ff fd67 	bl	5de8 <adf_read_from_memory>

	while(state != 2){
		state = adf_get_state();
	}

	while(rx_buf[0] == 0x00){
    631a:	7a3b      	ldrb	r3, [r7, #8]
    631c:	2b00      	cmp	r3, #0
    631e:	d0ef      	beq.n	6300 <get_rssi_cca_data+0x30>
		adf_read_from_memory(RMODE_1, PROFILE_CCA_READBACK, rx_buf, 4);
	}

	*rssi = (uint16_t)((rx_buf[4] & 0x07) << 8) + rx_buf[5];
    6320:	7b3b      	ldrb	r3, [r7, #12]
    6322:	f003 0307 	and.w	r3, r3, #7
    6326:	ea4f 2303 	mov.w	r3, r3, lsl #8
    632a:	b29a      	uxth	r2, r3
    632c:	7b7b      	ldrb	r3, [r7, #13]
    632e:	4413      	add	r3, r2
    6330:	b29a      	uxth	r2, r3
    6332:	687b      	ldr	r3, [r7, #4]
    6334:	801a      	strh	r2, [r3, #0]
	*rssi = ~(*rssi) + 1;
    6336:	687b      	ldr	r3, [r7, #4]
    6338:	881b      	ldrh	r3, [r3, #0]
    633a:	f1c3 0300 	rsb	r3, r3, #0
    633e:	b29b      	uxth	r3, r3
    6340:	b29a      	uxth	r2, r3
    6342:	687b      	ldr	r3, [r7, #4]
    6344:	801a      	strh	r2, [r3, #0]
	*rssi = *rssi & 0x0FFF;
    6346:	687b      	ldr	r3, [r7, #4]
    6348:	881b      	ldrh	r3, [r3, #0]
    634a:	ea4f 5303 	mov.w	r3, r3, lsl #20
    634e:	ea4f 5313 	mov.w	r3, r3, lsr #20
    6352:	687a      	ldr	r2, [r7, #4]
    6354:	8013      	strh	r3, [r2, #0]
	if(*rssi > 2048){
    6356:	687b      	ldr	r3, [r7, #4]
    6358:	881b      	ldrh	r3, [r3, #0]
    635a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    635e:	d906      	bls.n	636e <get_rssi_cca_data+0x9e>
		*rssi = *rssi - 2048;
    6360:	687b      	ldr	r3, [r7, #4]
    6362:	881b      	ldrh	r3, [r3, #0]
    6364:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
    6368:	b29a      	uxth	r2, r3
    636a:	687b      	ldr	r3, [r7, #4]
    636c:	801a      	strh	r2, [r3, #0]
	}
	*rssi = *rssi/4;
    636e:	687b      	ldr	r3, [r7, #4]
    6370:	881b      	ldrh	r3, [r3, #0]
    6372:	ea4f 0393 	mov.w	r3, r3, lsr #2
    6376:	b29a      	uxth	r2, r3
    6378:	687b      	ldr	r3, [r7, #4]
    637a:	801a      	strh	r2, [r3, #0]

}
    637c:	f107 0710 	add.w	r7, r7, #16
    6380:	46bd      	mov	sp, r7
    6382:	bd80      	pop	{r7, pc}

00006384 <get_preamble_pkt>:


	return 0;
}

uint8_t get_preamble_pkt(){
    6384:	b580      	push	{r7, lr}
    6386:	b082      	sub	sp, #8
    6388:	af00      	add	r7, sp, #0
	uint8_t pre[6];
	uint8_t preamble;

	adf_read_from_memory(RMODE_1, PREAMBLE_READ_REG, pre, 4);
    638a:	463b      	mov	r3, r7
    638c:	f04f 0078 	mov.w	r0, #120	; 0x78
    6390:	f240 5104 	movw	r1, #1284	; 0x504
    6394:	f2c2 0100 	movt	r1, #8192	; 0x2000
    6398:	461a      	mov	r2, r3
    639a:	f04f 0304 	mov.w	r3, #4
    639e:	f7ff fd23 	bl	5de8 <adf_read_from_memory>
	preamble = pre[3];
    63a2:	78fb      	ldrb	r3, [r7, #3]
    63a4:	71fb      	strb	r3, [r7, #7]

	return preamble;
    63a6:	79fb      	ldrb	r3, [r7, #7]
}
    63a8:	4618      	mov	r0, r3
    63aa:	f107 0708 	add.w	r7, r7, #8
    63ae:	46bd      	mov	sp, r7
    63b0:	bd80      	pop	{r7, pc}
    63b2:	bf00      	nop

000063b4 <get_sync_word>:

uint32_t get_sync_word(){
    63b4:	b580      	push	{r7, lr}
    63b6:	b084      	sub	sp, #16
    63b8:	af00      	add	r7, sp, #0
	uint8_t sw[6];
	uint32_t sync_word;

	adf_read_from_memory(RMODE_1, SYNC_WORD_READ_REG, sw, 4);
    63ba:	f107 0304 	add.w	r3, r7, #4
    63be:	f04f 0078 	mov.w	r0, #120	; 0x78
    63c2:	f240 5114 	movw	r1, #1300	; 0x514
    63c6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    63ca:	461a      	mov	r2, r3
    63cc:	f04f 0304 	mov.w	r3, #4
    63d0:	f7ff fd0a 	bl	5de8 <adf_read_from_memory>
	sync_word = (sw[2] << 24) | (sw[3] << 16) | (sw[4] << 8) | (sw[5]);
    63d4:	79bb      	ldrb	r3, [r7, #6]
    63d6:	ea4f 6203 	mov.w	r2, r3, lsl #24
    63da:	79fb      	ldrb	r3, [r7, #7]
    63dc:	ea4f 4303 	mov.w	r3, r3, lsl #16
    63e0:	ea42 0203 	orr.w	r2, r2, r3
    63e4:	7a3b      	ldrb	r3, [r7, #8]
    63e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
    63ea:	ea42 0203 	orr.w	r2, r2, r3
    63ee:	7a7b      	ldrb	r3, [r7, #9]
    63f0:	ea42 0303 	orr.w	r3, r2, r3
    63f4:	60fb      	str	r3, [r7, #12]

	return sync_word;
    63f6:	68fb      	ldr	r3, [r7, #12]
}
    63f8:	4618      	mov	r0, r3
    63fa:	f107 0710 	add.w	r7, r7, #16
    63fe:	46bd      	mov	sp, r7
    6400:	bd80      	pop	{r7, pc}
    6402:	bf00      	nop

00006404 <get_freq>:

uint32_t get_freq(){
    6404:	b580      	push	{r7, lr}
    6406:	b084      	sub	sp, #16
    6408:	af00      	add	r7, sp, #0
	uint8_t fre[6];
	uint32_t frequency;

	adf_read_from_memory(RMODE_1, PROFILE_CH_FREQ, fre, 4);
    640a:	f107 0304 	add.w	r3, r7, #4
    640e:	f04f 0078 	mov.w	r0, #120	; 0x78
    6412:	f240 21ec 	movw	r1, #748	; 0x2ec
    6416:	f2c2 0100 	movt	r1, #8192	; 0x2000
    641a:	461a      	mov	r2, r3
    641c:	f04f 0304 	mov.w	r3, #4
    6420:	f7ff fce2 	bl	5de8 <adf_read_from_memory>
	frequency = (fre[2] << 24) | (fre[3] << 16) | (fre[4] << 8) | (fre[5]);
    6424:	79bb      	ldrb	r3, [r7, #6]
    6426:	ea4f 6203 	mov.w	r2, r3, lsl #24
    642a:	79fb      	ldrb	r3, [r7, #7]
    642c:	ea4f 4303 	mov.w	r3, r3, lsl #16
    6430:	ea42 0203 	orr.w	r2, r2, r3
    6434:	7a3b      	ldrb	r3, [r7, #8]
    6436:	ea4f 2303 	mov.w	r3, r3, lsl #8
    643a:	ea42 0203 	orr.w	r2, r2, r3
    643e:	7a7b      	ldrb	r3, [r7, #9]
    6440:	ea42 0303 	orr.w	r3, r2, r3
    6444:	60fb      	str	r3, [r7, #12]

	return frequency;
    6446:	68fb      	ldr	r3, [r7, #12]
}
    6448:	4618      	mov	r0, r3
    644a:	f107 0710 	add.w	r7, r7, #16
    644e:	46bd      	mov	sp, r7
    6450:	bd80      	pop	{r7, pc}
    6452:	bf00      	nop

00006454 <HW_set_32bit_reg>:
    6454:	6001      	str	r1, [r0, #0]
    6456:	4770      	bx	lr

00006458 <HW_get_32bit_reg>:
    6458:	6800      	ldr	r0, [r0, #0]
    645a:	4770      	bx	lr

0000645c <HW_set_32bit_reg_field>:
    645c:	b50e      	push	{r1, r2, r3, lr}
    645e:	fa03 f301 	lsl.w	r3, r3, r1
    6462:	ea03 0302 	and.w	r3, r3, r2
    6466:	6801      	ldr	r1, [r0, #0]
    6468:	ea6f 0202 	mvn.w	r2, r2
    646c:	ea01 0102 	and.w	r1, r1, r2
    6470:	ea41 0103 	orr.w	r1, r1, r3
    6474:	6001      	str	r1, [r0, #0]
    6476:	bd0e      	pop	{r1, r2, r3, pc}

00006478 <HW_get_32bit_reg_field>:
    6478:	6800      	ldr	r0, [r0, #0]
    647a:	ea00 0002 	and.w	r0, r0, r2
    647e:	fa20 f001 	lsr.w	r0, r0, r1
    6482:	4770      	bx	lr

00006484 <HW_set_16bit_reg>:
    6484:	8001      	strh	r1, [r0, #0]
    6486:	4770      	bx	lr

00006488 <HW_get_16bit_reg>:
    6488:	8800      	ldrh	r0, [r0, #0]
    648a:	4770      	bx	lr

0000648c <HW_set_16bit_reg_field>:
    648c:	b50e      	push	{r1, r2, r3, lr}
    648e:	fa03 f301 	lsl.w	r3, r3, r1
    6492:	ea03 0302 	and.w	r3, r3, r2
    6496:	8801      	ldrh	r1, [r0, #0]
    6498:	ea6f 0202 	mvn.w	r2, r2
    649c:	ea01 0102 	and.w	r1, r1, r2
    64a0:	ea41 0103 	orr.w	r1, r1, r3
    64a4:	8001      	strh	r1, [r0, #0]
    64a6:	bd0e      	pop	{r1, r2, r3, pc}

000064a8 <HW_get_16bit_reg_field>:
    64a8:	8800      	ldrh	r0, [r0, #0]
    64aa:	ea00 0002 	and.w	r0, r0, r2
    64ae:	fa20 f001 	lsr.w	r0, r0, r1
    64b2:	4770      	bx	lr

000064b4 <HW_set_8bit_reg>:
    64b4:	7001      	strb	r1, [r0, #0]
    64b6:	4770      	bx	lr

000064b8 <HW_get_8bit_reg>:
    64b8:	7800      	ldrb	r0, [r0, #0]
    64ba:	4770      	bx	lr

000064bc <HW_set_8bit_reg_field>:
    64bc:	b50e      	push	{r1, r2, r3, lr}
    64be:	fa03 f301 	lsl.w	r3, r3, r1
    64c2:	ea03 0302 	and.w	r3, r3, r2
    64c6:	7801      	ldrb	r1, [r0, #0]
    64c8:	ea6f 0202 	mvn.w	r2, r2
    64cc:	ea01 0102 	and.w	r1, r1, r2
    64d0:	ea41 0103 	orr.w	r1, r1, r3
    64d4:	7001      	strb	r1, [r0, #0]
    64d6:	bd0e      	pop	{r1, r2, r3, pc}

000064d8 <HW_get_8bit_reg_field>:
    64d8:	7800      	ldrb	r0, [r0, #0]
    64da:	ea00 0002 	and.w	r0, r0, r2
    64de:	fa20 f001 	lsr.w	r0, r0, r1
    64e2:	4770      	bx	lr

000064e4 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    64e4:	b480      	push	{r7}
    64e6:	b083      	sub	sp, #12
    64e8:	af00      	add	r7, sp, #0
    64ea:	4603      	mov	r3, r0
    64ec:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    64ee:	f24e 1300 	movw	r3, #57600	; 0xe100
    64f2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    64f6:	f997 2007 	ldrsb.w	r2, [r7, #7]
    64fa:	ea4f 1252 	mov.w	r2, r2, lsr #5
    64fe:	79f9      	ldrb	r1, [r7, #7]
    6500:	f001 011f 	and.w	r1, r1, #31
    6504:	f04f 0001 	mov.w	r0, #1
    6508:	fa00 f101 	lsl.w	r1, r0, r1
    650c:	f102 0260 	add.w	r2, r2, #96	; 0x60
    6510:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    6514:	f107 070c 	add.w	r7, r7, #12
    6518:	46bd      	mov	sp, r7
    651a:	bc80      	pop	{r7}
    651c:	4770      	bx	lr
    651e:	bf00      	nop

00006520 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    6520:	b480      	push	{r7}
    6522:	b083      	sub	sp, #12
    6524:	af00      	add	r7, sp, #0
    6526:	6078      	str	r0, [r7, #4]
    6528:	460b      	mov	r3, r1
    652a:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
    652c:	687b      	ldr	r3, [r7, #4]
    652e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    6532:	687b      	ldr	r3, [r7, #4]
    6534:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    6538:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    653c:	ea4f 1343 	mov.w	r3, r3, lsl #5
    6540:	441a      	add	r2, r3
    6542:	78fb      	ldrb	r3, [r7, #3]
    6544:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6548:	4413      	add	r3, r2
    654a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    654e:	f04f 0201 	mov.w	r2, #1
    6552:	601a      	str	r2, [r3, #0]
}
    6554:	f107 070c 	add.w	r7, r7, #12
    6558:	46bd      	mov	sp, r7
    655a:	bc80      	pop	{r7}
    655c:	4770      	bx	lr
    655e:	bf00      	nop

00006560 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    6560:	b480      	push	{r7}
    6562:	b083      	sub	sp, #12
    6564:	af00      	add	r7, sp, #0
    6566:	6078      	str	r0, [r7, #4]
    6568:	460b      	mov	r3, r1
    656a:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
    656c:	687b      	ldr	r3, [r7, #4]
    656e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    6572:	687b      	ldr	r3, [r7, #4]
    6574:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    6578:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    657c:	ea4f 1343 	mov.w	r3, r3, lsl #5
    6580:	441a      	add	r2, r3
    6582:	78fb      	ldrb	r3, [r7, #3]
    6584:	ea4f 0383 	mov.w	r3, r3, lsl #2
    6588:	4413      	add	r3, r2
    658a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    658e:	f04f 0200 	mov.w	r2, #0
    6592:	601a      	str	r2, [r3, #0]
}
    6594:	f107 070c 	add.w	r7, r7, #12
    6598:	46bd      	mov	sp, r7
    659a:	bc80      	pop	{r7}
    659c:	4770      	bx	lr
    659e:	bf00      	nop

000065a0 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    65a0:	b480      	push	{r7}
    65a2:	b083      	sub	sp, #12
    65a4:	af00      	add	r7, sp, #0
    65a6:	6078      	str	r0, [r7, #4]
    65a8:	460b      	mov	r3, r1
    65aa:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
    65ac:	687b      	ldr	r3, [r7, #4]
    65ae:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    65b2:	687b      	ldr	r3, [r7, #4]
    65b4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    65b8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    65bc:	ea4f 1343 	mov.w	r3, r3, lsl #5
    65c0:	441a      	add	r2, r3
    65c2:	78fb      	ldrb	r3, [r7, #3]
    65c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
    65c8:	4413      	add	r3, r2
    65ca:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    65ce:	681b      	ldr	r3, [r3, #0]
    65d0:	b2db      	uxtb	r3, r3
}
    65d2:	4618      	mov	r0, r3
    65d4:	f107 070c 	add.w	r7, r7, #12
    65d8:	46bd      	mov	sp, r7
    65da:	bc80      	pop	{r7}
    65dc:	4770      	bx	lr
    65de:	bf00      	nop

000065e0 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
    65e0:	b580      	push	{r7, lr}
    65e2:	b084      	sub	sp, #16
    65e4:	af00      	add	r7, sp, #0
    65e6:	60f8      	str	r0, [r7, #12]
    65e8:	60b9      	str	r1, [r7, #8]
    65ea:	4613      	mov	r3, r2
    65ec:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    65ee:	68fa      	ldr	r2, [r7, #12]
    65f0:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    65f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    65f8:	429a      	cmp	r2, r3
    65fa:	d007      	beq.n	660c <MSS_UART_init+0x2c>
    65fc:	68fa      	ldr	r2, [r7, #12]
    65fe:	f24c 4380 	movw	r3, #50304	; 0xc480
    6602:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6606:	429a      	cmp	r2, r3
    6608:	d000      	beq.n	660c <MSS_UART_init+0x2c>
    660a:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    660c:	79fb      	ldrb	r3, [r7, #7]
    660e:	68f8      	ldr	r0, [r7, #12]
    6610:	68b9      	ldr	r1, [r7, #8]
    6612:	461a      	mov	r2, r3
    6614:	f000 f988 	bl	6928 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    6618:	68fb      	ldr	r3, [r7, #12]
    661a:	681b      	ldr	r3, [r3, #0]
    661c:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6620:	4618      	mov	r0, r3
    6622:	f04f 0103 	mov.w	r1, #3
    6626:	f7ff ff9b 	bl	6560 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
    662a:	68fb      	ldr	r3, [r7, #12]
    662c:	681b      	ldr	r3, [r3, #0]
    662e:	f103 0334 	add.w	r3, r3, #52	; 0x34
    6632:	4618      	mov	r0, r3
    6634:	f04f 0102 	mov.w	r1, #2
    6638:	f7ff ff92 	bl	6560 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
    663c:	68fb      	ldr	r3, [r7, #12]
    663e:	681b      	ldr	r3, [r3, #0]
    6640:	f103 0338 	add.w	r3, r3, #56	; 0x38
    6644:	4618      	mov	r0, r3
    6646:	f04f 0100 	mov.w	r1, #0
    664a:	f7ff ff89 	bl	6560 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
    664e:	68fa      	ldr	r2, [r7, #12]
    6650:	f646 53c1 	movw	r3, #28097	; 0x6dc1
    6654:	f2c0 0300 	movt	r3, #0
    6658:	6253      	str	r3, [r2, #36]	; 0x24
}
    665a:	f107 0710 	add.w	r7, r7, #16
    665e:	46bd      	mov	sp, r7
    6660:	bd80      	pop	{r7, pc}
    6662:	bf00      	nop

00006664 <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    6664:	b480      	push	{r7}
    6666:	b089      	sub	sp, #36	; 0x24
    6668:	af00      	add	r7, sp, #0
    666a:	60f8      	str	r0, [r7, #12]
    666c:	60b9      	str	r1, [r7, #8]
    666e:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
    6670:	f04f 0300 	mov.w	r3, #0
    6674:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    6676:	68fa      	ldr	r2, [r7, #12]
    6678:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    667c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6680:	429a      	cmp	r2, r3
    6682:	d007      	beq.n	6694 <MSS_UART_polled_tx+0x30>
    6684:	68fa      	ldr	r2, [r7, #12]
    6686:	f24c 4380 	movw	r3, #50304	; 0xc480
    668a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    668e:	429a      	cmp	r2, r3
    6690:	d000      	beq.n	6694 <MSS_UART_polled_tx+0x30>
    6692:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
    6694:	68bb      	ldr	r3, [r7, #8]
    6696:	2b00      	cmp	r3, #0
    6698:	d100      	bne.n	669c <MSS_UART_polled_tx+0x38>
    669a:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
    669c:	687b      	ldr	r3, [r7, #4]
    669e:	2b00      	cmp	r3, #0
    66a0:	d100      	bne.n	66a4 <MSS_UART_polled_tx+0x40>
    66a2:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    66a4:	68fa      	ldr	r2, [r7, #12]
    66a6:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    66aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    66ae:	429a      	cmp	r2, r3
    66b0:	d006      	beq.n	66c0 <MSS_UART_polled_tx+0x5c>
    66b2:	68fa      	ldr	r2, [r7, #12]
    66b4:	f24c 4380 	movw	r3, #50304	; 0xc480
    66b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    66bc:	429a      	cmp	r2, r3
    66be:	d13d      	bne.n	673c <MSS_UART_polled_tx+0xd8>
    66c0:	68bb      	ldr	r3, [r7, #8]
    66c2:	2b00      	cmp	r3, #0
    66c4:	d03a      	beq.n	673c <MSS_UART_polled_tx+0xd8>
    66c6:	687b      	ldr	r3, [r7, #4]
    66c8:	2b00      	cmp	r3, #0
    66ca:	d037      	beq.n	673c <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
    66cc:	68fb      	ldr	r3, [r7, #12]
    66ce:	681b      	ldr	r3, [r3, #0]
    66d0:	7d1b      	ldrb	r3, [r3, #20]
    66d2:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
    66d4:	68fb      	ldr	r3, [r7, #12]
    66d6:	7b5a      	ldrb	r2, [r3, #13]
    66d8:	7efb      	ldrb	r3, [r7, #27]
    66da:	ea42 0303 	orr.w	r3, r2, r3
    66de:	b2da      	uxtb	r2, r3
    66e0:	68fb      	ldr	r3, [r7, #12]
    66e2:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
    66e4:	7efb      	ldrb	r3, [r7, #27]
    66e6:	f003 0320 	and.w	r3, r3, #32
    66ea:	2b00      	cmp	r3, #0
    66ec:	d023      	beq.n	6736 <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
    66ee:	f04f 0310 	mov.w	r3, #16
    66f2:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
    66f4:	687b      	ldr	r3, [r7, #4]
    66f6:	2b0f      	cmp	r3, #15
    66f8:	d801      	bhi.n	66fe <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
    66fa:	687b      	ldr	r3, [r7, #4]
    66fc:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    66fe:	f04f 0300 	mov.w	r3, #0
    6702:	617b      	str	r3, [r7, #20]
    6704:	e00e      	b.n	6724 <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    6706:	68fb      	ldr	r3, [r7, #12]
    6708:	681b      	ldr	r3, [r3, #0]
    670a:	68b9      	ldr	r1, [r7, #8]
    670c:	693a      	ldr	r2, [r7, #16]
    670e:	440a      	add	r2, r1
    6710:	7812      	ldrb	r2, [r2, #0]
    6712:	701a      	strb	r2, [r3, #0]
                    char_idx++;
    6714:	693b      	ldr	r3, [r7, #16]
    6716:	f103 0301 	add.w	r3, r3, #1
    671a:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    671c:	697b      	ldr	r3, [r7, #20]
    671e:	f103 0301 	add.w	r3, r3, #1
    6722:	617b      	str	r3, [r7, #20]
    6724:	697a      	ldr	r2, [r7, #20]
    6726:	69fb      	ldr	r3, [r7, #28]
    6728:	429a      	cmp	r2, r3
    672a:	d3ec      	bcc.n	6706 <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
    672c:	687a      	ldr	r2, [r7, #4]
    672e:	697b      	ldr	r3, [r7, #20]
    6730:	ebc3 0302 	rsb	r3, r3, r2
    6734:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
    6736:	687b      	ldr	r3, [r7, #4]
    6738:	2b00      	cmp	r3, #0
    673a:	d1c7      	bne.n	66cc <MSS_UART_polled_tx+0x68>
    }
}
    673c:	f107 0724 	add.w	r7, r7, #36	; 0x24
    6740:	46bd      	mov	sp, r7
    6742:	bc80      	pop	{r7}
    6744:	4770      	bx	lr
    6746:	bf00      	nop

00006748 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
    6748:	4668      	mov	r0, sp
    674a:	f020 0107 	bic.w	r1, r0, #7
    674e:	468d      	mov	sp, r1
    6750:	b589      	push	{r0, r3, r7, lr}
    6752:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
    6754:	f24c 40c0 	movw	r0, #50368	; 0xc4c0
    6758:	f2c2 0000 	movt	r0, #8192	; 0x2000
    675c:	f000 fa1a 	bl	6b94 <MSS_UART_isr>
}
    6760:	46bd      	mov	sp, r7
    6762:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    6766:	4685      	mov	sp, r0
    6768:	4770      	bx	lr
    676a:	bf00      	nop

0000676c <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
    676c:	4668      	mov	r0, sp
    676e:	f020 0107 	bic.w	r1, r0, #7
    6772:	468d      	mov	sp, r1
    6774:	b589      	push	{r0, r3, r7, lr}
    6776:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
    6778:	f24c 4080 	movw	r0, #50304	; 0xc480
    677c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    6780:	f000 fa08 	bl	6b94 <MSS_UART_isr>
}
    6784:	46bd      	mov	sp, r7
    6786:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    678a:	4685      	mov	sp, r0
    678c:	4770      	bx	lr
    678e:	bf00      	nop

00006790 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
    6790:	b580      	push	{r7, lr}
    6792:	b088      	sub	sp, #32
    6794:	af00      	add	r7, sp, #0
    6796:	6078      	str	r0, [r7, #4]
    6798:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    679a:	687a      	ldr	r2, [r7, #4]
    679c:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    67a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67a4:	429a      	cmp	r2, r3
    67a6:	d007      	beq.n	67b8 <config_baud_divisors+0x28>
    67a8:	687a      	ldr	r2, [r7, #4]
    67aa:	f24c 4380 	movw	r3, #50304	; 0xc480
    67ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67b2:	429a      	cmp	r2, r3
    67b4:	d000      	beq.n	67b8 <config_baud_divisors+0x28>
    67b6:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    67b8:	687a      	ldr	r2, [r7, #4]
    67ba:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    67be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67c2:	429a      	cmp	r2, r3
    67c4:	d007      	beq.n	67d6 <config_baud_divisors+0x46>
    67c6:	687a      	ldr	r2, [r7, #4]
    67c8:	f24c 4380 	movw	r3, #50304	; 0xc480
    67cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67d0:	429a      	cmp	r2, r3
    67d2:	f040 80a4 	bne.w	691e <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
    67d6:	687b      	ldr	r3, [r7, #4]
    67d8:	683a      	ldr	r2, [r7, #0]
    67da:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
    67dc:	f004 f9bc 	bl	ab58 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
    67e0:	687a      	ldr	r2, [r7, #4]
    67e2:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    67e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67ea:	429a      	cmp	r2, r3
    67ec:	d106      	bne.n	67fc <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
    67ee:	f24b 3330 	movw	r3, #45872	; 0xb330
    67f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67f6:	681b      	ldr	r3, [r3, #0]
    67f8:	61fb      	str	r3, [r7, #28]
    67fa:	e005      	b.n	6808 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
    67fc:	f24b 3334 	movw	r3, #45876	; 0xb334
    6800:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6804:	681b      	ldr	r3, [r3, #0]
    6806:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
    6808:	69fb      	ldr	r3, [r7, #28]
    680a:	ea4f 02c3 	mov.w	r2, r3, lsl #3
    680e:	683b      	ldr	r3, [r7, #0]
    6810:	fbb2 f3f3 	udiv	r3, r2, r3
    6814:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
    6816:	697b      	ldr	r3, [r7, #20]
    6818:	ea4f 0353 	mov.w	r3, r3, lsr #1
    681c:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
    681e:	693b      	ldr	r3, [r7, #16]
    6820:	ea4f 1393 	mov.w	r3, r3, lsr #6
    6824:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
    6826:	68fb      	ldr	r3, [r7, #12]
    6828:	ea4f 1383 	mov.w	r3, r3, lsl #6
    682c:	693a      	ldr	r2, [r7, #16]
    682e:	ebc3 0302 	rsb	r3, r3, r2
    6832:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
    6834:	68fb      	ldr	r3, [r7, #12]
    6836:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    683a:	697a      	ldr	r2, [r7, #20]
    683c:	ebc3 0202 	rsb	r2, r3, r2
    6840:	69bb      	ldr	r3, [r7, #24]
    6842:	ea4f 0343 	mov.w	r3, r3, lsl #1
    6846:	ebc3 0302 	rsb	r3, r3, r2
    684a:	69ba      	ldr	r2, [r7, #24]
    684c:	4413      	add	r3, r2
    684e:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
    6850:	68fa      	ldr	r2, [r7, #12]
    6852:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6856:	429a      	cmp	r2, r3
    6858:	d900      	bls.n	685c <config_baud_divisors+0xcc>
    685a:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
    685c:	68fa      	ldr	r2, [r7, #12]
    685e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6862:	429a      	cmp	r2, r3
    6864:	d85b      	bhi.n	691e <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
    6866:	68fb      	ldr	r3, [r7, #12]
    6868:	2b01      	cmp	r3, #1
    686a:	d931      	bls.n	68d0 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    686c:	687b      	ldr	r3, [r7, #4]
    686e:	681b      	ldr	r3, [r3, #0]
    6870:	f103 030c 	add.w	r3, r3, #12
    6874:	4618      	mov	r0, r3
    6876:	f04f 0107 	mov.w	r1, #7
    687a:	f7ff fe51 	bl	6520 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
    687e:	687b      	ldr	r3, [r7, #4]
    6880:	681b      	ldr	r3, [r3, #0]
    6882:	68fa      	ldr	r2, [r7, #12]
    6884:	ea4f 2212 	mov.w	r2, r2, lsr #8
    6888:	b2d2      	uxtb	r2, r2
    688a:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    688c:	687b      	ldr	r3, [r7, #4]
    688e:	681b      	ldr	r3, [r3, #0]
    6890:	68fa      	ldr	r2, [r7, #12]
    6892:	b2d2      	uxtb	r2, r2
    6894:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    6896:	687b      	ldr	r3, [r7, #4]
    6898:	681b      	ldr	r3, [r3, #0]
    689a:	f103 030c 	add.w	r3, r3, #12
    689e:	4618      	mov	r0, r3
    68a0:	f04f 0107 	mov.w	r1, #7
    68a4:	f7ff fe5c 	bl	6560 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
    68a8:	687b      	ldr	r3, [r7, #4]
    68aa:	681b      	ldr	r3, [r3, #0]
    68ac:	f103 0330 	add.w	r3, r3, #48	; 0x30
    68b0:	4618      	mov	r0, r3
    68b2:	f04f 0107 	mov.w	r1, #7
    68b6:	f7ff fe33 	bl	6520 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
    68ba:	69bb      	ldr	r3, [r7, #24]
    68bc:	2bff      	cmp	r3, #255	; 0xff
    68be:	d900      	bls.n	68c2 <config_baud_divisors+0x132>
    68c0:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
    68c2:	687b      	ldr	r3, [r7, #4]
    68c4:	681b      	ldr	r3, [r3, #0]
    68c6:	69ba      	ldr	r2, [r7, #24]
    68c8:	b2d2      	uxtb	r2, r2
    68ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    68ce:	e026      	b.n	691e <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    68d0:	687b      	ldr	r3, [r7, #4]
    68d2:	681b      	ldr	r3, [r3, #0]
    68d4:	f103 030c 	add.w	r3, r3, #12
    68d8:	4618      	mov	r0, r3
    68da:	f04f 0107 	mov.w	r1, #7
    68de:	f7ff fe1f 	bl	6520 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
    68e2:	687b      	ldr	r3, [r7, #4]
    68e4:	681b      	ldr	r3, [r3, #0]
    68e6:	68fa      	ldr	r2, [r7, #12]
    68e8:	ea4f 2212 	mov.w	r2, r2, lsr #8
    68ec:	b2d2      	uxtb	r2, r2
    68ee:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    68f0:	687b      	ldr	r3, [r7, #4]
    68f2:	681b      	ldr	r3, [r3, #0]
    68f4:	68fa      	ldr	r2, [r7, #12]
    68f6:	b2d2      	uxtb	r2, r2
    68f8:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    68fa:	687b      	ldr	r3, [r7, #4]
    68fc:	681b      	ldr	r3, [r3, #0]
    68fe:	f103 030c 	add.w	r3, r3, #12
    6902:	4618      	mov	r0, r3
    6904:	f04f 0107 	mov.w	r1, #7
    6908:	f7ff fe2a 	bl	6560 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
    690c:	687b      	ldr	r3, [r7, #4]
    690e:	681b      	ldr	r3, [r3, #0]
    6910:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6914:	4618      	mov	r0, r3
    6916:	f04f 0107 	mov.w	r1, #7
    691a:	f7ff fe21 	bl	6560 <clear_bit_reg8>
            }
        }
    }
}
    691e:	f107 0720 	add.w	r7, r7, #32
    6922:	46bd      	mov	sp, r7
    6924:	bd80      	pop	{r7, pc}
    6926:	bf00      	nop

00006928 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    6928:	b580      	push	{r7, lr}
    692a:	b084      	sub	sp, #16
    692c:	af00      	add	r7, sp, #0
    692e:	60f8      	str	r0, [r7, #12]
    6930:	60b9      	str	r1, [r7, #8]
    6932:	4613      	mov	r3, r2
    6934:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    6936:	68fa      	ldr	r2, [r7, #12]
    6938:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    693c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6940:	429a      	cmp	r2, r3
    6942:	d007      	beq.n	6954 <global_init+0x2c>
    6944:	68fa      	ldr	r2, [r7, #12]
    6946:	f24c 4380 	movw	r3, #50304	; 0xc480
    694a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    694e:	429a      	cmp	r2, r3
    6950:	d000      	beq.n	6954 <global_init+0x2c>
    6952:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
    6954:	68fa      	ldr	r2, [r7, #12]
    6956:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    695a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    695e:	429a      	cmp	r2, r3
    6960:	d124      	bne.n	69ac <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
    6962:	68fb      	ldr	r3, [r7, #12]
    6964:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    6968:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
    696a:	68fb      	ldr	r3, [r7, #12]
    696c:	f04f 020a 	mov.w	r2, #10
    6970:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
    6972:	f248 0300 	movw	r3, #32768	; 0x8000
    6976:	f2c4 0303 	movt	r3, #16387	; 0x4003
    697a:	f248 0200 	movw	r2, #32768	; 0x8000
    697e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6982:	6c92      	ldr	r2, [r2, #72]	; 0x48
    6984:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    6988:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
    698a:	f04f 000a 	mov.w	r0, #10
    698e:	f7ff fda9 	bl	64e4 <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    6992:	f248 0300 	movw	r3, #32768	; 0x8000
    6996:	f2c4 0303 	movt	r3, #16387	; 0x4003
    699a:	f248 0200 	movw	r2, #32768	; 0x8000
    699e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    69a2:	6c92      	ldr	r2, [r2, #72]	; 0x48
    69a4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    69a8:	649a      	str	r2, [r3, #72]	; 0x48
    69aa:	e025      	b.n	69f8 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
    69ac:	68fa      	ldr	r2, [r7, #12]
    69ae:	f240 0300 	movw	r3, #0
    69b2:	f2c4 0301 	movt	r3, #16385	; 0x4001
    69b6:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
    69b8:	68fb      	ldr	r3, [r7, #12]
    69ba:	f04f 020b 	mov.w	r2, #11
    69be:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
    69c0:	f248 0300 	movw	r3, #32768	; 0x8000
    69c4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    69c8:	f248 0200 	movw	r2, #32768	; 0x8000
    69cc:	f2c4 0203 	movt	r2, #16387	; 0x4003
    69d0:	6c92      	ldr	r2, [r2, #72]	; 0x48
    69d2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    69d6:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
    69d8:	f04f 000b 	mov.w	r0, #11
    69dc:	f7ff fd82 	bl	64e4 <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    69e0:	f248 0300 	movw	r3, #32768	; 0x8000
    69e4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    69e8:	f248 0200 	movw	r2, #32768	; 0x8000
    69ec:	f2c4 0203 	movt	r2, #16387	; 0x4003
    69f0:	6c92      	ldr	r2, [r2, #72]	; 0x48
    69f2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    69f6:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
    69f8:	68fb      	ldr	r3, [r7, #12]
    69fa:	681b      	ldr	r3, [r3, #0]
    69fc:	f04f 0200 	mov.w	r2, #0
    6a00:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
    6a02:	68fb      	ldr	r3, [r7, #12]
    6a04:	681b      	ldr	r3, [r3, #0]
    6a06:	f04f 0200 	mov.w	r2, #0
    6a0a:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
    6a0c:	68fb      	ldr	r3, [r7, #12]
    6a0e:	681b      	ldr	r3, [r3, #0]
    6a10:	f103 0308 	add.w	r3, r3, #8
    6a14:	4618      	mov	r0, r3
    6a16:	f04f 0101 	mov.w	r1, #1
    6a1a:	f7ff fd81 	bl	6520 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
    6a1e:	68fb      	ldr	r3, [r7, #12]
    6a20:	681b      	ldr	r3, [r3, #0]
    6a22:	f103 0308 	add.w	r3, r3, #8
    6a26:	4618      	mov	r0, r3
    6a28:	f04f 0102 	mov.w	r1, #2
    6a2c:	f7ff fd78 	bl	6520 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
    6a30:	68fb      	ldr	r3, [r7, #12]
    6a32:	681b      	ldr	r3, [r3, #0]
    6a34:	f103 0308 	add.w	r3, r3, #8
    6a38:	4618      	mov	r0, r3
    6a3a:	f04f 0100 	mov.w	r1, #0
    6a3e:	f7ff fd6f 	bl	6520 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
    6a42:	68fb      	ldr	r3, [r7, #12]
    6a44:	681b      	ldr	r3, [r3, #0]
    6a46:	f103 0310 	add.w	r3, r3, #16
    6a4a:	4618      	mov	r0, r3
    6a4c:	f04f 0104 	mov.w	r1, #4
    6a50:	f7ff fd86 	bl	6560 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
    6a54:	68fb      	ldr	r3, [r7, #12]
    6a56:	681b      	ldr	r3, [r3, #0]
    6a58:	f103 0310 	add.w	r3, r3, #16
    6a5c:	4618      	mov	r0, r3
    6a5e:	f04f 0105 	mov.w	r1, #5
    6a62:	f7ff fd7d 	bl	6560 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
    6a66:	68fb      	ldr	r3, [r7, #12]
    6a68:	681b      	ldr	r3, [r3, #0]
    6a6a:	f103 0334 	add.w	r3, r3, #52	; 0x34
    6a6e:	4618      	mov	r0, r3
    6a70:	f04f 0101 	mov.w	r1, #1
    6a74:	f7ff fd74 	bl	6560 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
    6a78:	68fb      	ldr	r3, [r7, #12]
    6a7a:	681b      	ldr	r3, [r3, #0]
    6a7c:	f103 0334 	add.w	r3, r3, #52	; 0x34
    6a80:	4618      	mov	r0, r3
    6a82:	f04f 0100 	mov.w	r1, #0
    6a86:	f7ff fd6b 	bl	6560 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
    6a8a:	68fb      	ldr	r3, [r7, #12]
    6a8c:	681b      	ldr	r3, [r3, #0]
    6a8e:	f103 0338 	add.w	r3, r3, #56	; 0x38
    6a92:	4618      	mov	r0, r3
    6a94:	f04f 0101 	mov.w	r1, #1
    6a98:	f7ff fd62 	bl	6560 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
    6a9c:	68fb      	ldr	r3, [r7, #12]
    6a9e:	681b      	ldr	r3, [r3, #0]
    6aa0:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6aa4:	4618      	mov	r0, r3
    6aa6:	f04f 0105 	mov.w	r1, #5
    6aaa:	f7ff fd59 	bl	6560 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
    6aae:	68fb      	ldr	r3, [r7, #12]
    6ab0:	681b      	ldr	r3, [r3, #0]
    6ab2:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6ab6:	4618      	mov	r0, r3
    6ab8:	f04f 0106 	mov.w	r1, #6
    6abc:	f7ff fd50 	bl	6560 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
    6ac0:	68fb      	ldr	r3, [r7, #12]
    6ac2:	681b      	ldr	r3, [r3, #0]
    6ac4:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6ac8:	4618      	mov	r0, r3
    6aca:	f04f 0107 	mov.w	r1, #7
    6ace:	f7ff fd47 	bl	6560 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
    6ad2:	68fb      	ldr	r3, [r7, #12]
    6ad4:	681b      	ldr	r3, [r3, #0]
    6ad6:	f103 0338 	add.w	r3, r3, #56	; 0x38
    6ada:	4618      	mov	r0, r3
    6adc:	f04f 0103 	mov.w	r1, #3
    6ae0:	f7ff fd3e 	bl	6560 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
    6ae4:	68fb      	ldr	r3, [r7, #12]
    6ae6:	681b      	ldr	r3, [r3, #0]
    6ae8:	f04f 0200 	mov.w	r2, #0
    6aec:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
    6af0:	68fb      	ldr	r3, [r7, #12]
    6af2:	681b      	ldr	r3, [r3, #0]
    6af4:	f04f 0200 	mov.w	r2, #0
    6af8:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
    6afc:	68fb      	ldr	r3, [r7, #12]
    6afe:	681b      	ldr	r3, [r3, #0]
    6b00:	f04f 0200 	mov.w	r2, #0
    6b04:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
    6b08:	68f8      	ldr	r0, [r7, #12]
    6b0a:	68b9      	ldr	r1, [r7, #8]
    6b0c:	f7ff fe40 	bl	6790 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
    6b10:	68fb      	ldr	r3, [r7, #12]
    6b12:	681b      	ldr	r3, [r3, #0]
    6b14:	79fa      	ldrb	r2, [r7, #7]
    6b16:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
    6b18:	68fb      	ldr	r3, [r7, #12]
    6b1a:	68ba      	ldr	r2, [r7, #8]
    6b1c:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
    6b1e:	68fb      	ldr	r3, [r7, #12]
    6b20:	79fa      	ldrb	r2, [r7, #7]
    6b22:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
    6b24:	68fb      	ldr	r3, [r7, #12]
    6b26:	f04f 0200 	mov.w	r2, #0
    6b2a:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
    6b2c:	68fb      	ldr	r3, [r7, #12]
    6b2e:	f04f 0200 	mov.w	r2, #0
    6b32:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
    6b34:	68fb      	ldr	r3, [r7, #12]
    6b36:	f04f 0200 	mov.w	r2, #0
    6b3a:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
    6b3c:	68fb      	ldr	r3, [r7, #12]
    6b3e:	f04f 0200 	mov.w	r2, #0
    6b42:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
    6b44:	68fb      	ldr	r3, [r7, #12]
    6b46:	f04f 0200 	mov.w	r2, #0
    6b4a:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
    6b4c:	68fb      	ldr	r3, [r7, #12]
    6b4e:	f04f 0200 	mov.w	r2, #0
    6b52:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
    6b54:	68fb      	ldr	r3, [r7, #12]
    6b56:	f04f 0200 	mov.w	r2, #0
    6b5a:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
    6b5c:	68fb      	ldr	r3, [r7, #12]
    6b5e:	f04f 0200 	mov.w	r2, #0
    6b62:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
    6b64:	68fb      	ldr	r3, [r7, #12]
    6b66:	f04f 0200 	mov.w	r2, #0
    6b6a:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
    6b6c:	68fb      	ldr	r3, [r7, #12]
    6b6e:	f04f 0200 	mov.w	r2, #0
    6b72:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
    6b74:	68fb      	ldr	r3, [r7, #12]
    6b76:	f04f 0200 	mov.w	r2, #0
    6b7a:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
    6b7c:	68fb      	ldr	r3, [r7, #12]
    6b7e:	f04f 0200 	mov.w	r2, #0
    6b82:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
    6b84:	68fb      	ldr	r3, [r7, #12]
    6b86:	f04f 0200 	mov.w	r2, #0
    6b8a:	735a      	strb	r2, [r3, #13]
}
    6b8c:	f107 0710 	add.w	r7, r7, #16
    6b90:	46bd      	mov	sp, r7
    6b92:	bd80      	pop	{r7, pc}

00006b94 <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
    6b94:	b580      	push	{r7, lr}
    6b96:	b084      	sub	sp, #16
    6b98:	af00      	add	r7, sp, #0
    6b9a:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    6b9c:	687a      	ldr	r2, [r7, #4]
    6b9e:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    6ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ba6:	429a      	cmp	r2, r3
    6ba8:	d007      	beq.n	6bba <MSS_UART_isr+0x26>
    6baa:	687a      	ldr	r2, [r7, #4]
    6bac:	f24c 4380 	movw	r3, #50304	; 0xc480
    6bb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bb4:	429a      	cmp	r2, r3
    6bb6:	d000      	beq.n	6bba <MSS_UART_isr+0x26>
    6bb8:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    6bba:	687a      	ldr	r2, [r7, #4]
    6bbc:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    6bc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bc4:	429a      	cmp	r2, r3
    6bc6:	d007      	beq.n	6bd8 <MSS_UART_isr+0x44>
    6bc8:	687a      	ldr	r2, [r7, #4]
    6bca:	f24c 4380 	movw	r3, #50304	; 0xc480
    6bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6bd2:	429a      	cmp	r2, r3
    6bd4:	f040 80ef 	bne.w	6db6 <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
    6bd8:	687b      	ldr	r3, [r7, #4]
    6bda:	681b      	ldr	r3, [r3, #0]
    6bdc:	7a1b      	ldrb	r3, [r3, #8]
    6bde:	b2db      	uxtb	r3, r3
    6be0:	f003 030f 	and.w	r3, r3, #15
    6be4:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
    6be6:	7bfb      	ldrb	r3, [r7, #15]
    6be8:	2b0c      	cmp	r3, #12
    6bea:	f200 80d7 	bhi.w	6d9c <MSS_UART_isr+0x208>
    6bee:	a201      	add	r2, pc, #4	; (adr r2, 6bf4 <MSS_UART_isr+0x60>)
    6bf0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6bf4:	00006c29 	.word	0x00006c29
    6bf8:	00006d9d 	.word	0x00006d9d
    6bfc:	00006c47 	.word	0x00006c47
    6c00:	00006ca1 	.word	0x00006ca1
    6c04:	00006c65 	.word	0x00006c65
    6c08:	00006d9d 	.word	0x00006d9d
    6c0c:	00006c83 	.word	0x00006c83
    6c10:	00006d9d 	.word	0x00006d9d
    6c14:	00006d9d 	.word	0x00006d9d
    6c18:	00006d9d 	.word	0x00006d9d
    6c1c:	00006d9d 	.word	0x00006d9d
    6c20:	00006d9d 	.word	0x00006d9d
    6c24:	00006c65 	.word	0x00006c65
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
    6c28:	687b      	ldr	r3, [r7, #4]
    6c2a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6c2c:	2b00      	cmp	r3, #0
    6c2e:	d100      	bne.n	6c32 <MSS_UART_isr+0x9e>
    6c30:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
    6c32:	687b      	ldr	r3, [r7, #4]
    6c34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6c36:	2b00      	cmp	r3, #0
    6c38:	f000 80b2 	beq.w	6da0 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
    6c3c:	687b      	ldr	r3, [r7, #4]
    6c3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6c40:	6878      	ldr	r0, [r7, #4]
    6c42:	4798      	blx	r3
                }
            }
            break;
    6c44:	e0b7      	b.n	6db6 <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
    6c46:	687b      	ldr	r3, [r7, #4]
    6c48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6c4a:	2b00      	cmp	r3, #0
    6c4c:	d100      	bne.n	6c50 <MSS_UART_isr+0xbc>
    6c4e:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
    6c50:	687b      	ldr	r3, [r7, #4]
    6c52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6c54:	2b00      	cmp	r3, #0
    6c56:	f000 80a5 	beq.w	6da4 <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
    6c5a:	687b      	ldr	r3, [r7, #4]
    6c5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6c5e:	6878      	ldr	r0, [r7, #4]
    6c60:	4798      	blx	r3
                }
            }
            break;
    6c62:	e0a8      	b.n	6db6 <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
    6c64:	687b      	ldr	r3, [r7, #4]
    6c66:	6a1b      	ldr	r3, [r3, #32]
    6c68:	2b00      	cmp	r3, #0
    6c6a:	d100      	bne.n	6c6e <MSS_UART_isr+0xda>
    6c6c:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
    6c6e:	687b      	ldr	r3, [r7, #4]
    6c70:	6a1b      	ldr	r3, [r3, #32]
    6c72:	2b00      	cmp	r3, #0
    6c74:	f000 8098 	beq.w	6da8 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
    6c78:	687b      	ldr	r3, [r7, #4]
    6c7a:	6a1b      	ldr	r3, [r3, #32]
    6c7c:	6878      	ldr	r0, [r7, #4]
    6c7e:	4798      	blx	r3
                }
            }
            break;
    6c80:	e099      	b.n	6db6 <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
    6c82:	687b      	ldr	r3, [r7, #4]
    6c84:	69db      	ldr	r3, [r3, #28]
    6c86:	2b00      	cmp	r3, #0
    6c88:	d100      	bne.n	6c8c <MSS_UART_isr+0xf8>
    6c8a:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
    6c8c:	687b      	ldr	r3, [r7, #4]
    6c8e:	69db      	ldr	r3, [r3, #28]
    6c90:	2b00      	cmp	r3, #0
    6c92:	f000 808b 	beq.w	6dac <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
    6c96:	687b      	ldr	r3, [r7, #4]
    6c98:	69db      	ldr	r3, [r3, #28]
    6c9a:	6878      	ldr	r0, [r7, #4]
    6c9c:	4798      	blx	r3
                }
            }
            break;
    6c9e:	e08a      	b.n	6db6 <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
    6ca0:	687b      	ldr	r3, [r7, #4]
    6ca2:	681b      	ldr	r3, [r3, #0]
    6ca4:	f103 0328 	add.w	r3, r3, #40	; 0x28
    6ca8:	4618      	mov	r0, r3
    6caa:	f04f 0100 	mov.w	r1, #0
    6cae:	f7ff fc77 	bl	65a0 <read_bit_reg8>
    6cb2:	4603      	mov	r3, r0
    6cb4:	2b00      	cmp	r3, #0
    6cb6:	d00c      	beq.n	6cd2 <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
    6cb8:	687b      	ldr	r3, [r7, #4]
    6cba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6cbc:	2b00      	cmp	r3, #0
    6cbe:	d100      	bne.n	6cc2 <MSS_UART_isr+0x12e>
    6cc0:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
    6cc2:	687b      	ldr	r3, [r7, #4]
    6cc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6cc6:	2b00      	cmp	r3, #0
    6cc8:	d003      	beq.n	6cd2 <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
    6cca:	687b      	ldr	r3, [r7, #4]
    6ccc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6cce:	6878      	ldr	r0, [r7, #4]
    6cd0:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
    6cd2:	687b      	ldr	r3, [r7, #4]
    6cd4:	681b      	ldr	r3, [r3, #0]
    6cd6:	f103 0328 	add.w	r3, r3, #40	; 0x28
    6cda:	4618      	mov	r0, r3
    6cdc:	f04f 0101 	mov.w	r1, #1
    6ce0:	f7ff fc5e 	bl	65a0 <read_bit_reg8>
    6ce4:	4603      	mov	r3, r0
    6ce6:	2b00      	cmp	r3, #0
    6ce8:	d00c      	beq.n	6d04 <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
    6cea:	687b      	ldr	r3, [r7, #4]
    6cec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6cee:	2b00      	cmp	r3, #0
    6cf0:	d100      	bne.n	6cf4 <MSS_UART_isr+0x160>
    6cf2:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
    6cf4:	687b      	ldr	r3, [r7, #4]
    6cf6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6cf8:	2b00      	cmp	r3, #0
    6cfa:	d003      	beq.n	6d04 <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
    6cfc:	687b      	ldr	r3, [r7, #4]
    6cfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6d00:	6878      	ldr	r0, [r7, #4]
    6d02:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
    6d04:	687b      	ldr	r3, [r7, #4]
    6d06:	681b      	ldr	r3, [r3, #0]
    6d08:	f103 0328 	add.w	r3, r3, #40	; 0x28
    6d0c:	4618      	mov	r0, r3
    6d0e:	f04f 0102 	mov.w	r1, #2
    6d12:	f7ff fc45 	bl	65a0 <read_bit_reg8>
    6d16:	4603      	mov	r3, r0
    6d18:	2b00      	cmp	r3, #0
    6d1a:	d00c      	beq.n	6d36 <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
    6d1c:	687b      	ldr	r3, [r7, #4]
    6d1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    6d20:	2b00      	cmp	r3, #0
    6d22:	d100      	bne.n	6d26 <MSS_UART_isr+0x192>
    6d24:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
    6d26:	687b      	ldr	r3, [r7, #4]
    6d28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    6d2a:	2b00      	cmp	r3, #0
    6d2c:	d003      	beq.n	6d36 <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
    6d2e:	687b      	ldr	r3, [r7, #4]
    6d30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    6d32:	6878      	ldr	r0, [r7, #4]
    6d34:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
    6d36:	687b      	ldr	r3, [r7, #4]
    6d38:	681b      	ldr	r3, [r3, #0]
    6d3a:	f103 0328 	add.w	r3, r3, #40	; 0x28
    6d3e:	4618      	mov	r0, r3
    6d40:	f04f 0103 	mov.w	r1, #3
    6d44:	f7ff fc2c 	bl	65a0 <read_bit_reg8>
    6d48:	4603      	mov	r3, r0
    6d4a:	2b00      	cmp	r3, #0
    6d4c:	d00c      	beq.n	6d68 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
    6d4e:	687b      	ldr	r3, [r7, #4]
    6d50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6d52:	2b00      	cmp	r3, #0
    6d54:	d100      	bne.n	6d58 <MSS_UART_isr+0x1c4>
    6d56:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
    6d58:	687b      	ldr	r3, [r7, #4]
    6d5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6d5c:	2b00      	cmp	r3, #0
    6d5e:	d003      	beq.n	6d68 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
    6d60:	687b      	ldr	r3, [r7, #4]
    6d62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6d64:	6878      	ldr	r0, [r7, #4]
    6d66:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
    6d68:	687b      	ldr	r3, [r7, #4]
    6d6a:	681b      	ldr	r3, [r3, #0]
    6d6c:	f103 0328 	add.w	r3, r3, #40	; 0x28
    6d70:	4618      	mov	r0, r3
    6d72:	f04f 0104 	mov.w	r1, #4
    6d76:	f7ff fc13 	bl	65a0 <read_bit_reg8>
    6d7a:	4603      	mov	r3, r0
    6d7c:	2b00      	cmp	r3, #0
    6d7e:	d017      	beq.n	6db0 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
    6d80:	687b      	ldr	r3, [r7, #4]
    6d82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6d84:	2b00      	cmp	r3, #0
    6d86:	d100      	bne.n	6d8a <MSS_UART_isr+0x1f6>
    6d88:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
    6d8a:	687b      	ldr	r3, [r7, #4]
    6d8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6d8e:	2b00      	cmp	r3, #0
    6d90:	d010      	beq.n	6db4 <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
    6d92:	687b      	ldr	r3, [r7, #4]
    6d94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6d96:	6878      	ldr	r0, [r7, #4]
    6d98:	4798      	blx	r3
                    }
                }
                break;
    6d9a:	e00c      	b.n	6db6 <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
    6d9c:	be00      	bkpt	0x0000
    6d9e:	e00a      	b.n	6db6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
    6da0:	bf00      	nop
    6da2:	e008      	b.n	6db6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
    6da4:	bf00      	nop
    6da6:	e006      	b.n	6db6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
    6da8:	bf00      	nop
    6daa:	e004      	b.n	6db6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
    6dac:	bf00      	nop
    6dae:	e002      	b.n	6db6 <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
    6db0:	bf00      	nop
    6db2:	e000      	b.n	6db6 <MSS_UART_isr+0x222>
    6db4:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
    6db6:	f107 0710 	add.w	r7, r7, #16
    6dba:	46bd      	mov	sp, r7
    6dbc:	bd80      	pop	{r7, pc}
    6dbe:	bf00      	nop

00006dc0 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
    6dc0:	b580      	push	{r7, lr}
    6dc2:	b086      	sub	sp, #24
    6dc4:	af00      	add	r7, sp, #0
    6dc6:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    6dc8:	687a      	ldr	r2, [r7, #4]
    6dca:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    6dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6dd2:	429a      	cmp	r2, r3
    6dd4:	d007      	beq.n	6de6 <default_tx_handler+0x26>
    6dd6:	687a      	ldr	r2, [r7, #4]
    6dd8:	f24c 4380 	movw	r3, #50304	; 0xc480
    6ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6de0:	429a      	cmp	r2, r3
    6de2:	d000      	beq.n	6de6 <default_tx_handler+0x26>
    6de4:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    6de6:	687b      	ldr	r3, [r7, #4]
    6de8:	691b      	ldr	r3, [r3, #16]
    6dea:	2b00      	cmp	r3, #0
    6dec:	d100      	bne.n	6df0 <default_tx_handler+0x30>
    6dee:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
    6df0:	687b      	ldr	r3, [r7, #4]
    6df2:	695b      	ldr	r3, [r3, #20]
    6df4:	2b00      	cmp	r3, #0
    6df6:	d100      	bne.n	6dfa <default_tx_handler+0x3a>
    6df8:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    6dfa:	687a      	ldr	r2, [r7, #4]
    6dfc:	f24c 43c0 	movw	r3, #50368	; 0xc4c0
    6e00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6e04:	429a      	cmp	r2, r3
    6e06:	d006      	beq.n	6e16 <default_tx_handler+0x56>
    6e08:	687a      	ldr	r2, [r7, #4]
    6e0a:	f24c 4380 	movw	r3, #50304	; 0xc480
    6e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6e12:	429a      	cmp	r2, r3
    6e14:	d155      	bne.n	6ec2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
    6e16:	687b      	ldr	r3, [r7, #4]
    6e18:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    6e1a:	2b00      	cmp	r3, #0
    6e1c:	d051      	beq.n	6ec2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    6e1e:	687b      	ldr	r3, [r7, #4]
    6e20:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    6e22:	2b00      	cmp	r3, #0
    6e24:	d04d      	beq.n	6ec2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    6e26:	687b      	ldr	r3, [r7, #4]
    6e28:	681b      	ldr	r3, [r3, #0]
    6e2a:	7d1b      	ldrb	r3, [r3, #20]
    6e2c:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
    6e2e:	687b      	ldr	r3, [r7, #4]
    6e30:	7b5a      	ldrb	r2, [r3, #13]
    6e32:	7afb      	ldrb	r3, [r7, #11]
    6e34:	ea42 0303 	orr.w	r3, r2, r3
    6e38:	b2da      	uxtb	r2, r3
    6e3a:	687b      	ldr	r3, [r7, #4]
    6e3c:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
    6e3e:	7afb      	ldrb	r3, [r7, #11]
    6e40:	f003 0320 	and.w	r3, r3, #32
    6e44:	2b00      	cmp	r3, #0
    6e46:	d029      	beq.n	6e9c <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
    6e48:	f04f 0310 	mov.w	r3, #16
    6e4c:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
    6e4e:	687b      	ldr	r3, [r7, #4]
    6e50:	695a      	ldr	r2, [r3, #20]
    6e52:	687b      	ldr	r3, [r7, #4]
    6e54:	699b      	ldr	r3, [r3, #24]
    6e56:	ebc3 0302 	rsb	r3, r3, r2
    6e5a:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
    6e5c:	697b      	ldr	r3, [r7, #20]
    6e5e:	2b0f      	cmp	r3, #15
    6e60:	d801      	bhi.n	6e66 <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
    6e62:	697b      	ldr	r3, [r7, #20]
    6e64:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    6e66:	f04f 0300 	mov.w	r3, #0
    6e6a:	60fb      	str	r3, [r7, #12]
    6e6c:	e012      	b.n	6e94 <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    6e6e:	687b      	ldr	r3, [r7, #4]
    6e70:	681b      	ldr	r3, [r3, #0]
    6e72:	687a      	ldr	r2, [r7, #4]
    6e74:	6911      	ldr	r1, [r2, #16]
    6e76:	687a      	ldr	r2, [r7, #4]
    6e78:	6992      	ldr	r2, [r2, #24]
    6e7a:	440a      	add	r2, r1
    6e7c:	7812      	ldrb	r2, [r2, #0]
    6e7e:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
    6e80:	687b      	ldr	r3, [r7, #4]
    6e82:	699b      	ldr	r3, [r3, #24]
    6e84:	f103 0201 	add.w	r2, r3, #1
    6e88:	687b      	ldr	r3, [r7, #4]
    6e8a:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    6e8c:	68fb      	ldr	r3, [r7, #12]
    6e8e:	f103 0301 	add.w	r3, r3, #1
    6e92:	60fb      	str	r3, [r7, #12]
    6e94:	68fa      	ldr	r2, [r7, #12]
    6e96:	693b      	ldr	r3, [r7, #16]
    6e98:	429a      	cmp	r2, r3
    6e9a:	d3e8      	bcc.n	6e6e <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
    6e9c:	687b      	ldr	r3, [r7, #4]
    6e9e:	699a      	ldr	r2, [r3, #24]
    6ea0:	687b      	ldr	r3, [r7, #4]
    6ea2:	695b      	ldr	r3, [r3, #20]
    6ea4:	429a      	cmp	r2, r3
    6ea6:	d10c      	bne.n	6ec2 <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
    6ea8:	687b      	ldr	r3, [r7, #4]
    6eaa:	f04f 0200 	mov.w	r2, #0
    6eae:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
    6eb0:	687b      	ldr	r3, [r7, #4]
    6eb2:	681b      	ldr	r3, [r3, #0]
    6eb4:	f103 0304 	add.w	r3, r3, #4
    6eb8:	4618      	mov	r0, r3
    6eba:	f04f 0101 	mov.w	r1, #1
    6ebe:	f7ff fb4f 	bl	6560 <clear_bit_reg8>
        }
    }
}
    6ec2:	f107 0718 	add.w	r7, r7, #24
    6ec6:	46bd      	mov	sp, r7
    6ec8:	bd80      	pop	{r7, pc}
    6eca:	bf00      	nop

00006ecc <MSS_SYS_init>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
    6ecc:	b580      	push	{r7, lr}
    6ece:	b082      	sub	sp, #8
    6ed0:	af00      	add	r7, sp, #0
    6ed2:	6078      	str	r0, [r7, #4]
    g_event_handler = event_handler;
    6ed4:	f24b 337c 	movw	r3, #45948	; 0xb37c
    6ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6edc:	687a      	ldr	r2, [r7, #4]
    6ede:	601a      	str	r2, [r3, #0]
    g_last_response_length = 0u;
    6ee0:	f24b 337a 	movw	r3, #45946	; 0xb37a
    6ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ee8:	f04f 0200 	mov.w	r2, #0
    6eec:	801a      	strh	r2, [r3, #0]
    g_request_in_progress = 0u;
    6eee:	f24b 3379 	movw	r3, #45945	; 0xb379
    6ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ef6:	f04f 0200 	mov.w	r2, #0
    6efa:	701a      	strb	r2, [r3, #0]
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    6efc:	f248 0300 	movw	r3, #32768	; 0x8000
    6f00:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6f04:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    6f08:	f24b 3384 	movw	r3, #45956	; 0xb384
    6f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f10:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize the COMBLK used to communicate with the System Controller.
     */
    MSS_COMBLK_init(asynchronous_event_handler, g_response);
    6f12:	f646 7031 	movw	r0, #28465	; 0x6f31
    6f16:	f2c0 0000 	movt	r0, #0
    6f1a:	f24b 3180 	movw	r1, #45952	; 0xb380
    6f1e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    6f22:	f003 ffd1 	bl	aec8 <MSS_COMBLK_init>
}
    6f26:	f107 0708 	add.w	r7, r7, #8
    6f2a:	46bd      	mov	sp, r7
    6f2c:	bd80      	pop	{r7, pc}
    6f2e:	bf00      	nop

00006f30 <asynchronous_event_handler>:
#define TAMPER_HARDWARE_MONITOR_ERROR_OPCODE_RANGE_MAX   0xB7u

#define FACC_GLMUX_SEL_MASK         0x00001000u
#define DELAY_MORE_THAN_10US        5000U
static void asynchronous_event_handler(uint8_t event_opcode)
{
    6f30:	b580      	push	{r7, lr}
    6f32:	b086      	sub	sp, #24
    6f34:	af00      	add	r7, sp, #0
    6f36:	4603      	mov	r3, r0
    6f38:	71fb      	strb	r3, [r7, #7]
    if (event_opcode == FLASH_FREEZE_SHUTDOWN_OPCODE)
    6f3a:	79fb      	ldrb	r3, [r7, #7]
    6f3c:	2be0      	cmp	r3, #224	; 0xe0
    6f3e:	d12b      	bne.n	6f98 <asynchronous_event_handler+0x68>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the main clock to the  standby clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
    6f40:	f241 3388 	movw	r3, #5000	; 0x1388
    6f44:	60fb      	str	r3, [r7, #12]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6f46:	f248 0300 	movw	r3, #32768	; 0x8000
    6f4a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6f4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    6f52:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    6f56:	613b      	str	r3, [r7, #16]
            --timeout;
    6f58:	68fb      	ldr	r3, [r7, #12]
    6f5a:	f103 33ff 	add.w	r3, r3, #4294967295
    6f5e:	60fb      	str	r3, [r7, #12]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
    6f60:	693b      	ldr	r3, [r7, #16]
    6f62:	2b00      	cmp	r3, #0
    6f64:	d102      	bne.n	6f6c <asynchronous_event_handler+0x3c>
    6f66:	68fb      	ldr	r3, [r7, #12]
    6f68:	2b00      	cmp	r3, #0
    6f6a:	d1ec      	bne.n	6f46 <asynchronous_event_handler+0x16>

        /* Call the user's event handler. */
        if(g_event_handler != 0)
    6f6c:	f24b 337c 	movw	r3, #45948	; 0xb37c
    6f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f74:	681b      	ldr	r3, [r3, #0]
    6f76:	2b00      	cmp	r3, #0
    6f78:	d068      	beq.n	704c <asynchronous_event_handler+0x11c>
        {
            g_event_handler(event_opcode, g_response[1]);
    6f7a:	f24b 337c 	movw	r3, #45948	; 0xb37c
    6f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f82:	681a      	ldr	r2, [r3, #0]
    6f84:	f24b 3380 	movw	r3, #45952	; 0xb380
    6f88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6f8c:	785b      	ldrb	r3, [r3, #1]
    6f8e:	79f9      	ldrb	r1, [r7, #7]
    6f90:	4608      	mov	r0, r1
    6f92:	4619      	mov	r1, r3
    6f94:	4790      	blx	r2
    6f96:	e05c      	b.n	7052 <asynchronous_event_handler+0x122>
        }
    }
    else if (event_opcode == FLASH_FREEZE_EXIT_OPCODE)
    6f98:	79fb      	ldrb	r3, [r7, #7]
    6f9a:	2be1      	cmp	r3, #225	; 0xe1
    6f9c:	d12d      	bne.n	6ffa <asynchronous_event_handler+0xca>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the standby clock to the main clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
    6f9e:	f241 3388 	movw	r3, #5000	; 0x1388
    6fa2:	60bb      	str	r3, [r7, #8]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6fa4:	f248 0300 	movw	r3, #32768	; 0x8000
    6fa8:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6fac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    6fb0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    6fb4:	617b      	str	r3, [r7, #20]
            --timeout;
    6fb6:	68bb      	ldr	r3, [r7, #8]
    6fb8:	f103 33ff 	add.w	r3, r3, #4294967295
    6fbc:	60bb      	str	r3, [r7, #8]
        }
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
    6fbe:	697b      	ldr	r3, [r7, #20]
    6fc0:	2b00      	cmp	r3, #0
    6fc2:	d002      	beq.n	6fca <asynchronous_event_handler+0x9a>
    6fc4:	68bb      	ldr	r3, [r7, #8]
    6fc6:	2b00      	cmp	r3, #0
    6fc8:	d1ec      	bne.n	6fa4 <asynchronous_event_handler+0x74>
        
        /* Restore the clock dividers values of FACC1 register. */
        revert_clk_config();
    6fca:	f000 f8ab 	bl	7124 <revert_clk_config>
        
        if(g_event_handler != 0)
    6fce:	f24b 337c 	movw	r3, #45948	; 0xb37c
    6fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fd6:	681b      	ldr	r3, [r3, #0]
    6fd8:	2b00      	cmp	r3, #0
    6fda:	d039      	beq.n	7050 <asynchronous_event_handler+0x120>
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
    6fdc:	f24b 337c 	movw	r3, #45948	; 0xb37c
    6fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fe4:	681a      	ldr	r2, [r3, #0]
    6fe6:	f24b 3380 	movw	r3, #45952	; 0xb380
    6fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6fee:	785b      	ldrb	r3, [r3, #1]
    6ff0:	79f9      	ldrb	r1, [r7, #7]
    6ff2:	4608      	mov	r0, r1
    6ff4:	4619      	mov	r1, r3
    6ff6:	4790      	blx	r2
    6ff8:	e02b      	b.n	7052 <asynchronous_event_handler+0x122>
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
    6ffa:	79fb      	ldrb	r3, [r7, #7]
    6ffc:	2bf1      	cmp	r3, #241	; 0xf1
    6ffe:	d00f      	beq.n	7020 <asynchronous_event_handler+0xf0>
            ((event_opcode >= TAMPER_ATTEMPT_DETECT_OPCODE_RANGE_MIN) && \
    7000:	79fb      	ldrb	r3, [r7, #7]
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
    7002:	b25b      	sxtb	r3, r3
    7004:	2b00      	cmp	r3, #0
    7006:	da02      	bge.n	700e <asynchronous_event_handler+0xde>
    7008:	79fb      	ldrb	r3, [r7, #7]
    700a:	2b9f      	cmp	r3, #159	; 0x9f
    700c:	d908      	bls.n	7020 <asynchronous_event_handler+0xf0>
    700e:	79fb      	ldrb	r3, [r7, #7]
    7010:	2ba0      	cmp	r3, #160	; 0xa0
    7012:	d005      	beq.n	7020 <asynchronous_event_handler+0xf0>
    7014:	79fb      	ldrb	r3, [r7, #7]
    7016:	2bb0      	cmp	r3, #176	; 0xb0
    7018:	d91b      	bls.n	7052 <asynchronous_event_handler+0x122>
    701a:	79fb      	ldrb	r3, [r7, #7]
    701c:	2bb7      	cmp	r3, #183	; 0xb7
    701e:	d818      	bhi.n	7052 <asynchronous_event_handler+0x122>
            /* 
             * Inform to the application that new asynchronous message is received, 
             * only if application call-back function is registered during 
             * initialization. 
             */
            if(g_event_handler != 0)
    7020:	f24b 337c 	movw	r3, #45948	; 0xb37c
    7024:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7028:	681b      	ldr	r3, [r3, #0]
    702a:	2b00      	cmp	r3, #0
    702c:	d011      	beq.n	7052 <asynchronous_event_handler+0x122>
            {
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
    702e:	f24b 337c 	movw	r3, #45948	; 0xb37c
    7032:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7036:	681a      	ldr	r2, [r3, #0]
    7038:	f24b 3380 	movw	r3, #45952	; 0xb380
    703c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7040:	785b      	ldrb	r3, [r3, #1]
    7042:	79f9      	ldrb	r1, [r7, #7]
    7044:	4608      	mov	r0, r1
    7046:	4619      	mov	r1, r3
    7048:	4790      	blx	r2
    704a:	e002      	b.n	7052 <asynchronous_event_handler+0x122>
        while ((running_on_standby_clock == 0U) && (timeout != 0U));

        /* Call the user's event handler. */
        if(g_event_handler != 0)
        {
            g_event_handler(event_opcode, g_response[1]);
    704c:	bf00      	nop
    704e:	e000      	b.n	7052 <asynchronous_event_handler+0x122>
        revert_clk_config();
        
        if(g_event_handler != 0)
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
    7050:	bf00      	nop
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
            }
        }
    }
}
    7052:	f107 0718 	add.w	r7, r7, #24
    7056:	46bd      	mov	sp, r7
    7058:	bd80      	pop	{r7, pc}
    705a:	bf00      	nop

0000705c <determine_seq>:
 */
uint32_t divisor[4] = {0x00};
volatile uint8_t ind = 0;

static uint8_t* determine_seq(uint8_t val, uint8_t* len)
{
    705c:	b480      	push	{r7}
    705e:	b085      	sub	sp, #20
    7060:	af00      	add	r7, sp, #0
    7062:	4603      	mov	r3, r0
    7064:	6039      	str	r1, [r7, #0]
    7066:	71fb      	strb	r3, [r7, #7]
    uint8_t*seq;
    
    switch(val)
    7068:	79fb      	ldrb	r3, [r7, #7]
    706a:	2b06      	cmp	r3, #6
    706c:	d84c      	bhi.n	7108 <determine_seq+0xac>
    706e:	a201      	add	r2, pc, #4	; (adr r2, 7074 <determine_seq+0x18>)
    7070:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    7074:	00007091 	.word	0x00007091
    7078:	000070a5 	.word	0x000070a5
    707c:	000070b9 	.word	0x000070b9
    7080:	00007109 	.word	0x00007109
    7084:	000070cd 	.word	0x000070cd
    7088:	000070e1 	.word	0x000070e1
    708c:	000070f5 	.word	0x000070f5
    {
        case 0:
                seq = &div1_seq[0];
    7090:	f24b 3310 	movw	r3, #45840	; 0xb310
    7094:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7098:	60fb      	str	r3, [r7, #12]
                *len = 4;
    709a:	683b      	ldr	r3, [r7, #0]
    709c:	f04f 0204 	mov.w	r2, #4
    70a0:	701a      	strb	r2, [r3, #0]
            break;
    70a2:	e038      	b.n	7116 <determine_seq+0xba>

        case 1:
                seq = &div2_seq[0];
    70a4:	f24b 3314 	movw	r3, #45844	; 0xb314
    70a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70ac:	60fb      	str	r3, [r7, #12]
                *len = 3;
    70ae:	683b      	ldr	r3, [r7, #0]
    70b0:	f04f 0203 	mov.w	r2, #3
    70b4:	701a      	strb	r2, [r3, #0]
            break;
    70b6:	e02e      	b.n	7116 <determine_seq+0xba>

        case 2:
                seq = &div4_seq[0];
    70b8:	f24b 3318 	movw	r3, #45848	; 0xb318
    70bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70c0:	60fb      	str	r3, [r7, #12]
                *len = 5;
    70c2:	683b      	ldr	r3, [r7, #0]
    70c4:	f04f 0205 	mov.w	r2, #5
    70c8:	701a      	strb	r2, [r3, #0]
            break;
    70ca:	e024      	b.n	7116 <determine_seq+0xba>

        case 4:
                seq = &div8_seq[0];
    70cc:	f24b 3320 	movw	r3, #45856	; 0xb320
    70d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70d4:	60fb      	str	r3, [r7, #12]
                *len = 3;
    70d6:	683b      	ldr	r3, [r7, #0]
    70d8:	f04f 0203 	mov.w	r2, #3
    70dc:	701a      	strb	r2, [r3, #0]
            break;
    70de:	e01a      	b.n	7116 <determine_seq+0xba>

        case 5:
                seq = &div16_seq[0];
    70e0:	f24b 3324 	movw	r3, #45860	; 0xb324
    70e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70e8:	60fb      	str	r3, [r7, #12]
                *len = 2;
    70ea:	683b      	ldr	r3, [r7, #0]
    70ec:	f04f 0202 	mov.w	r2, #2
    70f0:	701a      	strb	r2, [r3, #0]
            break;
    70f2:	e010      	b.n	7116 <determine_seq+0xba>

        case 6:
                seq = &div32_seq[0];
    70f4:	f24b 3328 	movw	r3, #45864	; 0xb328
    70f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    70fc:	60fb      	str	r3, [r7, #12]
                *len = 2;
    70fe:	683b      	ldr	r3, [r7, #0]
    7100:	f04f 0202 	mov.w	r2, #2
    7104:	701a      	strb	r2, [r3, #0]
            break;
    7106:	e006      	b.n	7116 <determine_seq+0xba>

        default:
                *len = 0;
    7108:	683b      	ldr	r3, [r7, #0]
    710a:	f04f 0200 	mov.w	r2, #0
    710e:	701a      	strb	r2, [r3, #0]
                seq = NULL;
    7110:	f04f 0300 	mov.w	r3, #0
    7114:	60fb      	str	r3, [r7, #12]
            break;
    }
    
    return seq;
    7116:	68fb      	ldr	r3, [r7, #12]
}
    7118:	4618      	mov	r0, r3
    711a:	f107 0714 	add.w	r7, r7, #20
    711e:	46bd      	mov	sp, r7
    7120:	bc80      	pop	{r7}
    7122:	4770      	bx	lr

00007124 <revert_clk_config>:
/* SAR 80563 - Workaround for Glitchless Clock Multiplexer Switching Issue
 * Revert back original values of various divisor in FACC1 register after 
 * completing the fabric digest check/IAP/Flash Freeze service. 
 */
static void revert_clk_config(void)
{
    7124:	b580      	push	{r7, lr}
    7126:	b086      	sub	sp, #24
    7128:	af00      	add	r7, sp, #0
    uint8_t* sequence;
    uint8_t len;
    uint8_t var = 0;
    712a:	f04f 0300 	mov.w	r3, #0
    712e:	73fb      	strb	r3, [r7, #15]
    uint32_t temp = 0;
    7130:	f04f 0300 	mov.w	r3, #0
    7134:	613b      	str	r3, [r7, #16]
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    7136:	f248 0300 	movw	r3, #32768	; 0x8000
    713a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    713e:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    7142:	ea4f 4303 	mov.w	r3, r3, lsl #16
    7146:	ea4f 4313 	mov.w	r3, r3, lsr #16
    714a:	617b      	str	r3, [r7, #20]

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
    714c:	697a      	ldr	r2, [r7, #20]
    714e:	f64f 0302 	movw	r3, #63490	; 0xf802
    7152:	429a      	cmp	r2, r3
    7154:	d013      	beq.n	717e <revert_clk_config+0x5a>
    7156:	697a      	ldr	r2, [r7, #20]
    7158:	f64f 0303 	movw	r3, #63491	; 0xf803
    715c:	429a      	cmp	r2, r3
    715e:	d00e      	beq.n	717e <revert_clk_config+0x5a>
    7160:	697a      	ldr	r2, [r7, #20]
    7162:	f64f 0304 	movw	r3, #63492	; 0xf804
    7166:	429a      	cmp	r2, r3
    7168:	d009      	beq.n	717e <revert_clk_config+0x5a>
    716a:	697a      	ldr	r2, [r7, #20]
    716c:	f64f 0307 	movw	r3, #63495	; 0xf807
    7170:	429a      	cmp	r2, r3
    7172:	d004      	beq.n	717e <revert_clk_config+0x5a>
    7174:	697a      	ldr	r2, [r7, #20]
    7176:	f64f 0306 	movw	r3, #63494	; 0xf806
    717a:	429a      	cmp	r2, r3
    717c:	d10b      	bne.n	7196 <revert_clk_config+0x72>
       (0xF804u == device_version)||(0xF807u == device_version) ||   \
       (0xF806u == device_version))
    {
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    717e:	f248 0300 	movw	r3, #32768	; 0x8000
    7182:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7186:	f24b 3284 	movw	r2, #45956	; 0xb384
    718a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    718e:	6812      	ldr	r2, [r2, #0]
    7190:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
    7194:	e0eb      	b.n	736e <revert_clk_config+0x24a>
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    }

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    7196:	697a      	ldr	r2, [r7, #20]
    7198:	f64f 0305 	movw	r3, #63493	; 0xf805
    719c:	429a      	cmp	r2, r3
    719e:	f040 80e6 	bne.w	736e <revert_clk_config+0x24a>
    {
        sequence = determine_seq(divisor[0], &len);
    71a2:	f24b 3388 	movw	r3, #45960	; 0xb388
    71a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    71aa:	681b      	ldr	r3, [r3, #0]
    71ac:	b2da      	uxtb	r2, r3
    71ae:	f107 0307 	add.w	r3, r7, #7
    71b2:	4610      	mov	r0, r2
    71b4:	4619      	mov	r1, r3
    71b6:	f7ff ff51 	bl	705c <determine_seq>
    71ba:	4603      	mov	r3, r0
    71bc:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
    71be:	79fb      	ldrb	r3, [r7, #7]
    71c0:	73fb      	strb	r3, [r7, #15]
    71c2:	e021      	b.n	7208 <revert_clk_config+0xe4>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    71c4:	f248 0300 	movw	r3, #32768	; 0x8000
    71c8:	f2c4 0303 	movt	r3, #16387	; 0x4003
    71cc:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    71d0:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFFE3u;
    71d2:	693b      	ldr	r3, [r7, #16]
    71d4:	f023 031c 	bic.w	r3, r3, #28
    71d8:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    71da:	7bfb      	ldrb	r3, [r7, #15]
    71dc:	f103 32ff 	add.w	r2, r3, #4294967295
    71e0:	68bb      	ldr	r3, [r7, #8]
    71e2:	4413      	add	r3, r2
    71e4:	781b      	ldrb	r3, [r3, #0]
    71e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    71ea:	693a      	ldr	r2, [r7, #16]
    71ec:	ea42 0303 	orr.w	r3, r2, r3
    71f0:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
    71f2:	f248 0300 	movw	r3, #32768	; 0x8000
    71f6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    71fa:	693a      	ldr	r2, [r7, #16]
    71fc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    7200:	7bfb      	ldrb	r3, [r7, #15]
    7202:	f103 33ff 	add.w	r3, r3, #4294967295
    7206:	73fb      	strb	r3, [r7, #15]
    7208:	7bfb      	ldrb	r3, [r7, #15]
    720a:	2b00      	cmp	r3, #0
    720c:	d1da      	bne.n	71c4 <revert_clk_config+0xa0>
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
    720e:	f24b 3388 	movw	r3, #45960	; 0xb388
    7212:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7216:	685b      	ldr	r3, [r3, #4]
    7218:	b2da      	uxtb	r2, r3
    721a:	f107 0307 	add.w	r3, r7, #7
    721e:	4610      	mov	r0, r2
    7220:	4619      	mov	r1, r3
    7222:	f7ff ff1b 	bl	705c <determine_seq>
    7226:	4603      	mov	r3, r0
    7228:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
    722a:	79fb      	ldrb	r3, [r7, #7]
    722c:	73fb      	strb	r3, [r7, #15]
    722e:	e021      	b.n	7274 <revert_clk_config+0x150>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    7230:	f248 0300 	movw	r3, #32768	; 0x8000
    7234:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7238:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    723c:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFF1Fu;
    723e:	693b      	ldr	r3, [r7, #16]
    7240:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
    7244:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    7246:	7bfb      	ldrb	r3, [r7, #15]
    7248:	f103 32ff 	add.w	r2, r3, #4294967295
    724c:	68bb      	ldr	r3, [r7, #8]
    724e:	4413      	add	r3, r2
    7250:	781b      	ldrb	r3, [r3, #0]
    7252:	ea4f 1343 	mov.w	r3, r3, lsl #5
    7256:	693a      	ldr	r2, [r7, #16]
    7258:	ea42 0303 	orr.w	r3, r2, r3
    725c:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
    725e:	f248 0300 	movw	r3, #32768	; 0x8000
    7262:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7266:	693a      	ldr	r2, [r7, #16]
    7268:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    726c:	7bfb      	ldrb	r3, [r7, #15]
    726e:	f103 33ff 	add.w	r3, r3, #4294967295
    7272:	73fb      	strb	r3, [r7, #15]
    7274:	7bfb      	ldrb	r3, [r7, #15]
    7276:	2b00      	cmp	r3, #0
    7278:	d1da      	bne.n	7230 <revert_clk_config+0x10c>
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
    727a:	f24b 3388 	movw	r3, #45960	; 0xb388
    727e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7282:	689b      	ldr	r3, [r3, #8]
    7284:	b2da      	uxtb	r2, r3
    7286:	f107 0307 	add.w	r3, r7, #7
    728a:	4610      	mov	r0, r2
    728c:	4619      	mov	r1, r3
    728e:	f7ff fee5 	bl	705c <determine_seq>
    7292:	4603      	mov	r3, r0
    7294:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
    7296:	79fb      	ldrb	r3, [r7, #7]
    7298:	73fb      	strb	r3, [r7, #15]
    729a:	e021      	b.n	72e0 <revert_clk_config+0x1bc>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    729c:	f248 0300 	movw	r3, #32768	; 0x8000
    72a0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    72a4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    72a8:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFF1FFu;
    72aa:	693b      	ldr	r3, [r7, #16]
    72ac:	f423 6360 	bic.w	r3, r3, #3584	; 0xe00
    72b0:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    72b2:	7bfb      	ldrb	r3, [r7, #15]
    72b4:	f103 32ff 	add.w	r2, r3, #4294967295
    72b8:	68bb      	ldr	r3, [r7, #8]
    72ba:	4413      	add	r3, r2
    72bc:	781b      	ldrb	r3, [r3, #0]
    72be:	ea4f 2343 	mov.w	r3, r3, lsl #9
    72c2:	693a      	ldr	r2, [r7, #16]
    72c4:	ea42 0303 	orr.w	r3, r2, r3
    72c8:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
    72ca:	f248 0300 	movw	r3, #32768	; 0x8000
    72ce:	f2c4 0303 	movt	r3, #16387	; 0x4003
    72d2:	693a      	ldr	r2, [r7, #16]
    72d4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    72d8:	7bfb      	ldrb	r3, [r7, #15]
    72da:	f103 33ff 	add.w	r3, r3, #4294967295
    72de:	73fb      	strb	r3, [r7, #15]
    72e0:	7bfb      	ldrb	r3, [r7, #15]
    72e2:	2b00      	cmp	r3, #0
    72e4:	d1da      	bne.n	729c <revert_clk_config+0x178>
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
    72e6:	f24b 3388 	movw	r3, #45960	; 0xb388
    72ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
    72ee:	68db      	ldr	r3, [r3, #12]
    72f0:	b2da      	uxtb	r2, r3
    72f2:	f107 0307 	add.w	r3, r7, #7
    72f6:	4610      	mov	r0, r2
    72f8:	4619      	mov	r1, r3
    72fa:	f7ff feaf 	bl	705c <determine_seq>
    72fe:	4603      	mov	r3, r0
    7300:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
    7302:	79fb      	ldrb	r3, [r7, #7]
    7304:	73fb      	strb	r3, [r7, #15]
    7306:	e021      	b.n	734c <revert_clk_config+0x228>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    7308:	f248 0300 	movw	r3, #32768	; 0x8000
    730c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7310:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    7314:	613b      	str	r3, [r7, #16]
            temp &= 0xFFC7FFFFu;
    7316:	693b      	ldr	r3, [r7, #16]
    7318:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
    731c:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    731e:	7bfb      	ldrb	r3, [r7, #15]
    7320:	f103 32ff 	add.w	r2, r3, #4294967295
    7324:	68bb      	ldr	r3, [r7, #8]
    7326:	4413      	add	r3, r2
    7328:	781b      	ldrb	r3, [r3, #0]
    732a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    732e:	693a      	ldr	r2, [r7, #16]
    7330:	ea42 0303 	orr.w	r3, r2, r3
    7334:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
    7336:	f248 0300 	movw	r3, #32768	; 0x8000
    733a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    733e:	693a      	ldr	r2, [r7, #16]
    7340:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    7344:	7bfb      	ldrb	r3, [r7, #15]
    7346:	f103 33ff 	add.w	r3, r3, #4294967295
    734a:	73fb      	strb	r3, [r7, #15]
    734c:	7bfb      	ldrb	r3, [r7, #15]
    734e:	2b00      	cmp	r3, #0
    7350:	d1da      	bne.n	7308 <revert_clk_config+0x1e4>
        
        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 0 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from stage 2 
         * dividers (from CLK_SRC).
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & 0xFFFFEFFFu;
    7352:	f248 0300 	movw	r3, #32768	; 0x8000
    7356:	f2c4 0303 	movt	r3, #16387	; 0x4003
    735a:	f248 0200 	movw	r2, #32768	; 0x8000
    735e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    7362:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    7366:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    736a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    }
    else
    {
        /* Do Nothing. */
    }
}
    736e:	f107 0718 	add.w	r7, r7, #24
    7372:	46bd      	mov	sp, r7
    7374:	bd80      	pop	{r7, pc}
    7376:	bf00      	nop

00007378 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    7378:	b480      	push	{r7}
    737a:	b083      	sub	sp, #12
    737c:	af00      	add	r7, sp, #0
    737e:	4603      	mov	r3, r0
    7380:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    7382:	f24e 1300 	movw	r3, #57600	; 0xe100
    7386:	f2ce 0300 	movt	r3, #57344	; 0xe000
    738a:	f997 2007 	ldrsb.w	r2, [r7, #7]
    738e:	ea4f 1252 	mov.w	r2, r2, lsr #5
    7392:	79f9      	ldrb	r1, [r7, #7]
    7394:	f001 011f 	and.w	r1, r1, #31
    7398:	f04f 0001 	mov.w	r0, #1
    739c:	fa00 f101 	lsl.w	r1, r0, r1
    73a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    73a4:	f107 070c 	add.w	r7, r7, #12
    73a8:	46bd      	mov	sp, r7
    73aa:	bc80      	pop	{r7}
    73ac:	4770      	bx	lr
    73ae:	bf00      	nop

000073b0 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    73b0:	b480      	push	{r7}
    73b2:	b083      	sub	sp, #12
    73b4:	af00      	add	r7, sp, #0
    73b6:	4603      	mov	r3, r0
    73b8:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    73ba:	f24e 1300 	movw	r3, #57600	; 0xe100
    73be:	f2ce 0300 	movt	r3, #57344	; 0xe000
    73c2:	f997 2007 	ldrsb.w	r2, [r7, #7]
    73c6:	ea4f 1252 	mov.w	r2, r2, lsr #5
    73ca:	79f9      	ldrb	r1, [r7, #7]
    73cc:	f001 011f 	and.w	r1, r1, #31
    73d0:	f04f 0001 	mov.w	r0, #1
    73d4:	fa00 f101 	lsl.w	r1, r0, r1
    73d8:	f102 0220 	add.w	r2, r2, #32
    73dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    73e0:	f107 070c 	add.w	r7, r7, #12
    73e4:	46bd      	mov	sp, r7
    73e6:	bc80      	pop	{r7}
    73e8:	4770      	bx	lr
    73ea:	bf00      	nop

000073ec <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    73ec:	b480      	push	{r7}
    73ee:	b083      	sub	sp, #12
    73f0:	af00      	add	r7, sp, #0
    73f2:	4603      	mov	r3, r0
    73f4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    73f6:	f24e 1300 	movw	r3, #57600	; 0xe100
    73fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
    73fe:	f997 2007 	ldrsb.w	r2, [r7, #7]
    7402:	ea4f 1252 	mov.w	r2, r2, lsr #5
    7406:	79f9      	ldrb	r1, [r7, #7]
    7408:	f001 011f 	and.w	r1, r1, #31
    740c:	f04f 0001 	mov.w	r0, #1
    7410:	fa00 f101 	lsl.w	r1, r0, r1
    7414:	f102 0260 	add.w	r2, r2, #96	; 0x60
    7418:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    741c:	f107 070c 	add.w	r7, r7, #12
    7420:	46bd      	mov	sp, r7
    7422:	bc80      	pop	{r7}
    7424:	4770      	bx	lr
    7426:	bf00      	nop

00007428 <MSS_SPI_init>:
 */
void MSS_SPI_init
(
    mss_spi_instance_t * this_spi
)
{
    7428:	b580      	push	{r7, lr}
    742a:	b084      	sub	sp, #16
    742c:	af00      	add	r7, sp, #0
    742e:	6078      	str	r0, [r7, #4]
    uint16_t slave;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    7430:	687a      	ldr	r2, [r7, #4]
    7432:	f24c 5384 	movw	r3, #50564	; 0xc584
    7436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    743a:	429a      	cmp	r2, r3
    743c:	d007      	beq.n	744e <MSS_SPI_init+0x26>
    743e:	687a      	ldr	r2, [r7, #4]
    7440:	f24c 5300 	movw	r3, #50432	; 0xc500
    7444:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7448:	429a      	cmp	r2, r3
    744a:	d000      	beq.n	744e <MSS_SPI_init+0x26>
    744c:	be00      	bkpt	0x0000
     * Initialize SPI driver instance data. Relies on the majority
     * of data requiring 0 for initial state so we just need to fill
     * with 0s and finish off with a small number of non zero values.
     */
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
    744e:	687b      	ldr	r3, [r7, #4]
    7450:	791b      	ldrb	r3, [r3, #4]
    7452:	b25b      	sxtb	r3, r3
    7454:	4618      	mov	r0, r3
    7456:	f7ff ffab 	bl	73b0 <NVIC_DisableIRQ>

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    745a:	6878      	ldr	r0, [r7, #4]
    745c:	f04f 0100 	mov.w	r1, #0
    7460:	f04f 0284 	mov.w	r2, #132	; 0x84
    7464:	f004 f9b2 	bl	b7cc <memset>
    
    this_spi->cmd_done = 1u;
    7468:	687b      	ldr	r3, [r7, #4]
    746a:	f04f 0201 	mov.w	r2, #1
    746e:	625a      	str	r2, [r3, #36]	; 0x24

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
    7470:	f04f 0300 	mov.w	r3, #0
    7474:	81fb      	strh	r3, [r7, #14]
    7476:	e00d      	b.n	7494 <MSS_SPI_init+0x6c>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    7478:	89fb      	ldrh	r3, [r7, #14]
    747a:	687a      	ldr	r2, [r7, #4]
    747c:	f103 0306 	add.w	r3, r3, #6
    7480:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    7484:	4413      	add	r3, r2
    7486:	f04f 32ff 	mov.w	r2, #4294967295
    748a:	605a      	str	r2, [r3, #4]

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    
    this_spi->cmd_done = 1u;

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
    748c:	89fb      	ldrh	r3, [r7, #14]
    748e:	f103 0301 	add.w	r3, r3, #1
    7492:	81fb      	strh	r3, [r7, #14]
    7494:	89fb      	ldrh	r3, [r7, #14]
    7496:	2b07      	cmp	r3, #7
    7498:	d9ee      	bls.n	7478 <MSS_SPI_init+0x50>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    }

    if(this_spi == &g_mss_spi0)
    749a:	687a      	ldr	r2, [r7, #4]
    749c:	f24c 5384 	movw	r3, #50564	; 0xc584
    74a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    74a4:	429a      	cmp	r2, r3
    74a6:	d126      	bne.n	74f6 <MSS_SPI_init+0xce>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
    74a8:	687a      	ldr	r2, [r7, #4]
    74aa:	f241 0300 	movw	r3, #4096	; 0x1000
    74ae:	f2c4 0300 	movt	r3, #16384	; 0x4000
    74b2:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
    74b4:	687b      	ldr	r3, [r7, #4]
    74b6:	f04f 0202 	mov.w	r2, #2
    74ba:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
    74bc:	f248 0300 	movw	r3, #32768	; 0x8000
    74c0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    74c4:	f248 0200 	movw	r2, #32768	; 0x8000
    74c8:	f2c4 0203 	movt	r2, #16387	; 0x4003
    74cc:	6c92      	ldr	r2, [r2, #72]	; 0x48
    74ce:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    74d2:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
    74d4:	f04f 0002 	mov.w	r0, #2
    74d8:	f7ff ff88 	bl	73ec <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
    74dc:	f248 0300 	movw	r3, #32768	; 0x8000
    74e0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    74e4:	f248 0200 	movw	r2, #32768	; 0x8000
    74e8:	f2c4 0203 	movt	r2, #16387	; 0x4003
    74ec:	6c92      	ldr	r2, [r2, #72]	; 0x48
    74ee:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    74f2:	649a      	str	r2, [r3, #72]	; 0x48
    74f4:	e025      	b.n	7542 <MSS_SPI_init+0x11a>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
    74f6:	687a      	ldr	r2, [r7, #4]
    74f8:	f241 0300 	movw	r3, #4096	; 0x1000
    74fc:	f2c4 0301 	movt	r3, #16385	; 0x4001
    7500:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
    7502:	687b      	ldr	r3, [r7, #4]
    7504:	f04f 0203 	mov.w	r2, #3
    7508:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
    750a:	f248 0300 	movw	r3, #32768	; 0x8000
    750e:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7512:	f248 0200 	movw	r2, #32768	; 0x8000
    7516:	f2c4 0203 	movt	r2, #16387	; 0x4003
    751a:	6c92      	ldr	r2, [r2, #72]	; 0x48
    751c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    7520:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
    7522:	f04f 0003 	mov.w	r0, #3
    7526:	f7ff ff61 	bl	73ec <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
    752a:	f248 0300 	movw	r3, #32768	; 0x8000
    752e:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7532:	f248 0200 	movw	r2, #32768	; 0x8000
    7536:	f2c4 0203 	movt	r2, #16387	; 0x4003
    753a:	6c92      	ldr	r2, [r2, #72]	; 0x48
    753c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
    7540:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* De-assert reset bit. */
    this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
    7542:	687b      	ldr	r3, [r7, #4]
    7544:	681b      	ldr	r3, [r3, #0]
    7546:	687a      	ldr	r2, [r7, #4]
    7548:	6812      	ldr	r2, [r2, #0]
    754a:	6812      	ldr	r2, [r2, #0]
    754c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    7550:	601a      	str	r2, [r3, #0]
}
    7552:	f107 0710 	add.w	r7, r7, #16
    7556:	46bd      	mov	sp, r7
    7558:	bd80      	pop	{r7, pc}
    755a:	bf00      	nop

0000755c <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    mss_spi_instance_t * this_spi
)
{
    755c:	b580      	push	{r7, lr}
    755e:	b08a      	sub	sp, #40	; 0x28
    7560:	af00      	add	r7, sp, #0
    7562:	6078      	str	r0, [r7, #4]
    uint32_t slave_select;
    
    /*
     * Read current SPI hardware block configuration.
     */
    control_reg = this_spi->hw_reg->CONTROL;
    7564:	687b      	ldr	r3, [r7, #4]
    7566:	681b      	ldr	r3, [r3, #0]
    7568:	681b      	ldr	r3, [r3, #0]
    756a:	60fb      	str	r3, [r7, #12]
    clk_gen = this_spi->hw_reg->CLK_GEN;
    756c:	687b      	ldr	r3, [r7, #4]
    756e:	681b      	ldr	r3, [r3, #0]
    7570:	699b      	ldr	r3, [r3, #24]
    7572:	613b      	str	r3, [r7, #16]
    frame_size = this_spi->hw_reg->TXRXDF_SIZE;
    7574:	687b      	ldr	r3, [r7, #4]
    7576:	681b      	ldr	r3, [r3, #0]
    7578:	685b      	ldr	r3, [r3, #4]
    757a:	617b      	str	r3, [r7, #20]
    control2 = this_spi->hw_reg->CONTROL2;
    757c:	687b      	ldr	r3, [r7, #4]
    757e:	681b      	ldr	r3, [r3, #0]
    7580:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7582:	61bb      	str	r3, [r7, #24]
    packet_size = this_spi->hw_reg->PKTSIZE;
    7584:	687b      	ldr	r3, [r7, #4]
    7586:	681b      	ldr	r3, [r3, #0]
    7588:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    758a:	61fb      	str	r3, [r7, #28]
    cmd_size = this_spi->hw_reg->CMDSIZE;
    758c:	687b      	ldr	r3, [r7, #4]
    758e:	681b      	ldr	r3, [r3, #0]
    7590:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7592:	623b      	str	r3, [r7, #32]
    slave_select = this_spi->hw_reg->SLAVE_SELECT;
    7594:	687b      	ldr	r3, [r7, #4]
    7596:	681b      	ldr	r3, [r3, #0]
    7598:	69db      	ldr	r3, [r3, #28]
    759a:	627b      	str	r3, [r7, #36]	; 0x24
     
    /*
     * Reset the SPI hardware block.
     */
    if(this_spi == &g_mss_spi0)
    759c:	687a      	ldr	r2, [r7, #4]
    759e:	f24c 5384 	movw	r3, #50564	; 0xc584
    75a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    75a6:	429a      	cmp	r2, r3
    75a8:	d12e      	bne.n	7608 <recover_from_rx_overflow+0xac>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
    75aa:	687a      	ldr	r2, [r7, #4]
    75ac:	f241 0300 	movw	r3, #4096	; 0x1000
    75b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    75b4:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
    75b6:	687b      	ldr	r3, [r7, #4]
    75b8:	f04f 0202 	mov.w	r2, #2
    75bc:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
    75be:	f248 0300 	movw	r3, #32768	; 0x8000
    75c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    75c6:	f248 0200 	movw	r2, #32768	; 0x8000
    75ca:	f2c4 0203 	movt	r2, #16387	; 0x4003
    75ce:	6c92      	ldr	r2, [r2, #72]	; 0x48
    75d0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    75d4:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
    75d6:	f04f 0002 	mov.w	r0, #2
    75da:	f7ff ff07 	bl	73ec <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
    75de:	f248 0300 	movw	r3, #32768	; 0x8000
    75e2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    75e6:	f248 0200 	movw	r2, #32768	; 0x8000
    75ea:	f2c4 0203 	movt	r2, #16387	; 0x4003
    75ee:	6c92      	ldr	r2, [r2, #72]	; 0x48
    75f0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    75f4:	649a      	str	r2, [r3, #72]	; 0x48

        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
    75f6:	687b      	ldr	r3, [r7, #4]
    75f8:	681b      	ldr	r3, [r3, #0]
    75fa:	687a      	ldr	r2, [r7, #4]
    75fc:	6812      	ldr	r2, [r2, #0]
    75fe:	6812      	ldr	r2, [r2, #0]
    7600:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    7604:	601a      	str	r2, [r3, #0]
    7606:	e02d      	b.n	7664 <recover_from_rx_overflow+0x108>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
    7608:	687a      	ldr	r2, [r7, #4]
    760a:	f241 0300 	movw	r3, #4096	; 0x1000
    760e:	f2c4 0301 	movt	r3, #16385	; 0x4001
    7612:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
    7614:	687b      	ldr	r3, [r7, #4]
    7616:	f04f 0203 	mov.w	r2, #3
    761a:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
    761c:	f248 0300 	movw	r3, #32768	; 0x8000
    7620:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7624:	f248 0200 	movw	r2, #32768	; 0x8000
    7628:	f2c4 0203 	movt	r2, #16387	; 0x4003
    762c:	6c92      	ldr	r2, [r2, #72]	; 0x48
    762e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    7632:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
    7634:	f04f 0003 	mov.w	r0, #3
    7638:	f7ff fed8 	bl	73ec <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
    763c:	f248 0300 	movw	r3, #32768	; 0x8000
    7640:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7644:	f248 0200 	movw	r2, #32768	; 0x8000
    7648:	f2c4 0203 	movt	r2, #16387	; 0x4003
    764c:	6c92      	ldr	r2, [r2, #72]	; 0x48
    764e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
    7652:	649a      	str	r2, [r3, #72]	; 0x48
        
        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
    7654:	687b      	ldr	r3, [r7, #4]
    7656:	681b      	ldr	r3, [r3, #0]
    7658:	687a      	ldr	r2, [r7, #4]
    765a:	6812      	ldr	r2, [r2, #0]
    765c:	6812      	ldr	r2, [r2, #0]
    765e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    7662:	601a      	str	r2, [r3, #0]
    }
    
    /*
     * Restore SPI hardware block configuration.
     */
    control_reg &= ~(uint32_t)CTRL_ENABLE_MASK;
    7664:	68fb      	ldr	r3, [r7, #12]
    7666:	f023 0301 	bic.w	r3, r3, #1
    766a:	60fb      	str	r3, [r7, #12]
    this_spi->hw_reg->CONTROL = control_reg;
    766c:	687b      	ldr	r3, [r7, #4]
    766e:	681b      	ldr	r3, [r3, #0]
    7670:	68fa      	ldr	r2, [r7, #12]
    7672:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CLK_GEN = clk_gen;
    7674:	687b      	ldr	r3, [r7, #4]
    7676:	681b      	ldr	r3, [r3, #0]
    7678:	693a      	ldr	r2, [r7, #16]
    767a:	619a      	str	r2, [r3, #24]
    this_spi->hw_reg->TXRXDF_SIZE = frame_size;
    767c:	687b      	ldr	r3, [r7, #4]
    767e:	681b      	ldr	r3, [r3, #0]
    7680:	697a      	ldr	r2, [r7, #20]
    7682:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
    7684:	687b      	ldr	r3, [r7, #4]
    7686:	681b      	ldr	r3, [r3, #0]
    7688:	687a      	ldr	r2, [r7, #4]
    768a:	6812      	ldr	r2, [r2, #0]
    768c:	6812      	ldr	r2, [r2, #0]
    768e:	f042 0201 	orr.w	r2, r2, #1
    7692:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL2 = control2;
    7694:	687b      	ldr	r3, [r7, #4]
    7696:	681b      	ldr	r3, [r3, #0]
    7698:	69ba      	ldr	r2, [r7, #24]
    769a:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->PKTSIZE = packet_size;
    769c:	687b      	ldr	r3, [r7, #4]
    769e:	681b      	ldr	r3, [r3, #0]
    76a0:	69fa      	ldr	r2, [r7, #28]
    76a2:	631a      	str	r2, [r3, #48]	; 0x30
    this_spi->hw_reg->CMDSIZE = cmd_size;
    76a4:	687b      	ldr	r3, [r7, #4]
    76a6:	681b      	ldr	r3, [r3, #0]
    76a8:	6a3a      	ldr	r2, [r7, #32]
    76aa:	635a      	str	r2, [r3, #52]	; 0x34
    this_spi->hw_reg->SLAVE_SELECT = slave_select;
    76ac:	687b      	ldr	r3, [r7, #4]
    76ae:	681b      	ldr	r3, [r3, #0]
    76b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    76b2:	61da      	str	r2, [r3, #28]
}
    76b4:	f107 0728 	add.w	r7, r7, #40	; 0x28
    76b8:	46bd      	mov	sp, r7
    76ba:	bd80      	pop	{r7, pc}

000076bc <MSS_SPI_configure_master_mode>:
    mss_spi_slave_t         slave,
    mss_spi_protocol_mode_t protocol_mode,
    uint32_t                clk_div,
    uint8_t                 frame_bit_length
)
{
    76bc:	b580      	push	{r7, lr}
    76be:	b086      	sub	sp, #24
    76c0:	af00      	add	r7, sp, #0
    76c2:	60f8      	str	r0, [r7, #12]
    76c4:	607a      	str	r2, [r7, #4]
    76c6:	603b      	str	r3, [r7, #0]
    76c8:	460b      	mov	r3, r1
    76ca:	72fb      	strb	r3, [r7, #11]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    76cc:	68fa      	ldr	r2, [r7, #12]
    76ce:	f24c 5384 	movw	r3, #50564	; 0xc584
    76d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76d6:	429a      	cmp	r2, r3
    76d8:	d007      	beq.n	76ea <MSS_SPI_configure_master_mode+0x2e>
    76da:	68fa      	ldr	r2, [r7, #12]
    76dc:	f24c 5300 	movw	r3, #50432	; 0xc500
    76e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    76e4:	429a      	cmp	r2, r3
    76e6:	d000      	beq.n	76ea <MSS_SPI_configure_master_mode+0x2e>
    76e8:	be00      	bkpt	0x0000
    ASSERT(slave < MSS_SPI_MAX_NB_OF_SLAVES);
    76ea:	7afb      	ldrb	r3, [r7, #11]
    76ec:	2b07      	cmp	r3, #7
    76ee:	d900      	bls.n	76f2 <MSS_SPI_configure_master_mode+0x36>
    76f0:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
    76f2:	f897 3020 	ldrb.w	r3, [r7, #32]
    76f6:	2b20      	cmp	r3, #32
    76f8:	d900      	bls.n	76fc <MSS_SPI_configure_master_mode+0x40>
    76fa:	be00      	bkpt	0x0000
     /* Check that the requested clock divider is within range and an even number. */
    ASSERT(clk_div >= 2u);
    76fc:	683b      	ldr	r3, [r7, #0]
    76fe:	2b01      	cmp	r3, #1
    7700:	d800      	bhi.n	7704 <MSS_SPI_configure_master_mode+0x48>
    7702:	be00      	bkpt	0x0000
    ASSERT(clk_div <= 512u);
    7704:	683b      	ldr	r3, [r7, #0]
    7706:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    770a:	d900      	bls.n	770e <MSS_SPI_configure_master_mode+0x52>
    770c:	be00      	bkpt	0x0000
    ASSERT(0u == (clk_div & 0x00000001));
    770e:	683b      	ldr	r3, [r7, #0]
    7710:	f003 0301 	and.w	r3, r3, #1
    7714:	2b00      	cmp	r3, #0
    7716:	d000      	beq.n	771a <MSS_SPI_configure_master_mode+0x5e>
    7718:	be00      	bkpt	0x0000
   
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
    771a:	68fb      	ldr	r3, [r7, #12]
    771c:	791b      	ldrb	r3, [r3, #4]
    771e:	b25b      	sxtb	r3, r3
    7720:	4618      	mov	r0, r3
    7722:	f7ff fe45 	bl	73b0 <NVIC_DisableIRQ>

    /* Reset slave transfer mode to unknown to wipe slate clean */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
    7726:	68fb      	ldr	r3, [r7, #12]
    7728:	f04f 0200 	mov.w	r2, #0
    772c:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    7730:	68fb      	ldr	r3, [r7, #12]
    7732:	681b      	ldr	r3, [r3, #0]
    7734:	68fa      	ldr	r2, [r7, #12]
    7736:	6812      	ldr	r2, [r2, #0]
    7738:	6812      	ldr	r2, [r2, #0]
    773a:	f022 0201 	bic.w	r2, r2, #1
    773e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_MASTER_MASK;
    7740:	68fb      	ldr	r3, [r7, #12]
    7742:	681b      	ldr	r3, [r3, #0]
    7744:	68fa      	ldr	r2, [r7, #12]
    7746:	6812      	ldr	r2, [r2, #0]
    7748:	6812      	ldr	r2, [r2, #0]
    774a:	f042 0202 	orr.w	r2, r2, #2
    774e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
    7750:	68fb      	ldr	r3, [r7, #12]
    7752:	681b      	ldr	r3, [r3, #0]
    7754:	68fa      	ldr	r2, [r7, #12]
    7756:	6812      	ldr	r2, [r2, #0]
    7758:	6812      	ldr	r2, [r2, #0]
    775a:	f042 0201 	orr.w	r2, r2, #1
    775e:	601a      	str	r2, [r3, #0]
    /*
     * Keep track of the required register configuration for this slave. These
     * values will be used by the MSS_SPI_set_slave_select() function to configure
     * the master to match the slave being selected.
     */
    if(slave < MSS_SPI_MAX_NB_OF_SLAVES)     
    7760:	7afb      	ldrb	r3, [r7, #11]
    7762:	2b07      	cmp	r3, #7
    7764:	d847      	bhi.n	77f6 <MSS_SPI_configure_master_mode+0x13a>
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
    7766:	687b      	ldr	r3, [r7, #4]
    7768:	2b00      	cmp	r3, #0
    776a:	d00b      	beq.n	7784 <MSS_SPI_configure_master_mode+0xc8>
    776c:	687b      	ldr	r3, [r7, #4]
    776e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
    7772:	d007      	beq.n	7784 <MSS_SPI_configure_master_mode+0xc8>
    7774:	687b      	ldr	r3, [r7, #4]
    7776:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    777a:	d003      	beq.n	7784 <MSS_SPI_configure_master_mode+0xc8>
    777c:	687b      	ldr	r3, [r7, #4]
    777e:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
    7782:	d10f      	bne.n	77a4 <MSS_SPI_configure_master_mode+0xe8>
           (MSS_SPI_MODE2 == protocol_mode) || (MSS_SPI_MODE3 == protocol_mode))
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK | SPS_MASK |
    7784:	7afa      	ldrb	r2, [r7, #11]
    7786:	6879      	ldr	r1, [r7, #4]
    7788:	f240 1302 	movw	r3, #258	; 0x102
    778c:	f2c3 4300 	movt	r3, #13312	; 0x3400
    7790:	ea41 0303 	orr.w	r3, r1, r3
    7794:	68f9      	ldr	r1, [r7, #12]
    7796:	f102 0206 	add.w	r2, r2, #6
    779a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    779e:	440a      	add	r2, r1
    77a0:	6053      	str	r3, [r2, #4]
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
    77a2:	e00e      	b.n	77c2 <MSS_SPI_configure_master_mode+0x106>
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        else
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK |
    77a4:	7afa      	ldrb	r2, [r7, #11]
    77a6:	6879      	ldr	r1, [r7, #4]
    77a8:	f240 1302 	movw	r3, #258	; 0x102
    77ac:	f2c3 0300 	movt	r3, #12288	; 0x3000
    77b0:	ea41 0303 	orr.w	r3, r1, r3
    77b4:	68f9      	ldr	r1, [r7, #12]
    77b6:	f102 0206 	add.w	r2, r2, #6
    77ba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    77be:	440a      	add	r2, r1
    77c0:	6053      	str	r3, [r2, #4]
                                                   BIGFIFO_MASK | CTRL_CLKMODE_MASK |
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        this_spi->slaves_cfg[slave].txrxdf_size_reg = frame_bit_length;
    77c2:	7afb      	ldrb	r3, [r7, #11]
    77c4:	68fa      	ldr	r2, [r7, #12]
    77c6:	f103 0306 	add.w	r3, r3, #6
    77ca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    77ce:	4413      	add	r3, r2
    77d0:	f897 2020 	ldrb.w	r2, [r7, #32]
    77d4:	721a      	strb	r2, [r3, #8]

        clk_gen = (clk_div / 2u) - 1u;
    77d6:	683b      	ldr	r3, [r7, #0]
    77d8:	ea4f 0353 	mov.w	r3, r3, lsr #1
    77dc:	f103 33ff 	add.w	r3, r3, #4294967295
    77e0:	617b      	str	r3, [r7, #20]
        this_spi->slaves_cfg[slave].clk_gen = (uint8_t)clk_gen;
    77e2:	7afb      	ldrb	r3, [r7, #11]
    77e4:	697a      	ldr	r2, [r7, #20]
    77e6:	b2d2      	uxtb	r2, r2
    77e8:	68f9      	ldr	r1, [r7, #12]
    77ea:	f103 0306 	add.w	r3, r3, #6
    77ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    77f2:	440b      	add	r3, r1
    77f4:	725a      	strb	r2, [r3, #9]
    }
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
    77f6:	68fb      	ldr	r3, [r7, #12]
    77f8:	791b      	ldrb	r3, [r3, #4]
    77fa:	b25b      	sxtb	r3, r3
    77fc:	4618      	mov	r0, r3
    77fe:	f7ff fdbb 	bl	7378 <NVIC_EnableIRQ>
}
    7802:	f107 0718 	add.w	r7, r7, #24
    7806:	46bd      	mov	sp, r7
    7808:	bd80      	pop	{r7, pc}
    780a:	bf00      	nop

0000780c <MSS_SPI_set_slave_select>:
void MSS_SPI_set_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
    780c:	b580      	push	{r7, lr}
    780e:	b084      	sub	sp, #16
    7810:	af00      	add	r7, sp, #0
    7812:	6078      	str	r0, [r7, #4]
    7814:	460b      	mov	r3, r1
    7816:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    7818:	687a      	ldr	r2, [r7, #4]
    781a:	f24c 5384 	movw	r3, #50564	; 0xc584
    781e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7822:	429a      	cmp	r2, r3
    7824:	d007      	beq.n	7836 <MSS_SPI_set_slave_select+0x2a>
    7826:	687a      	ldr	r2, [r7, #4]
    7828:	f24c 5300 	movw	r3, #50432	; 0xc500
    782c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7830:	429a      	cmp	r2, r3
    7832:	d000      	beq.n	7836 <MSS_SPI_set_slave_select+0x2a>
    7834:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
    7836:	687b      	ldr	r3, [r7, #4]
    7838:	681b      	ldr	r3, [r3, #0]
    783a:	681b      	ldr	r3, [r3, #0]
    783c:	f003 0302 	and.w	r3, r3, #2
    7840:	2b00      	cmp	r3, #0
    7842:	d100      	bne.n	7846 <MSS_SPI_set_slave_select+0x3a>
    7844:	be00      	bkpt	0x0000
    
    ASSERT(this_spi->slaves_cfg[slave].ctrl_reg != NOT_CONFIGURED);
    7846:	78fb      	ldrb	r3, [r7, #3]
    7848:	687a      	ldr	r2, [r7, #4]
    784a:	f103 0306 	add.w	r3, r3, #6
    784e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    7852:	4413      	add	r3, r2
    7854:	685b      	ldr	r3, [r3, #4]
    7856:	f1b3 3fff 	cmp.w	r3, #4294967295
    785a:	d100      	bne.n	785e <MSS_SPI_set_slave_select+0x52>
    785c:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
    785e:	687b      	ldr	r3, [r7, #4]
    7860:	791b      	ldrb	r3, [r3, #4]
    7862:	b25b      	sxtb	r3, r3
    7864:	4618      	mov	r0, r3
    7866:	f7ff fda3 	bl	73b0 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
    786a:	687b      	ldr	r3, [r7, #4]
    786c:	681b      	ldr	r3, [r3, #0]
    786e:	689b      	ldr	r3, [r3, #8]
    7870:	f003 0304 	and.w	r3, r3, #4
    7874:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
    7876:	68fb      	ldr	r3, [r7, #12]
    7878:	2b00      	cmp	r3, #0
    787a:	d002      	beq.n	7882 <MSS_SPI_set_slave_select+0x76>
    {
         recover_from_rx_overflow(this_spi);
    787c:	6878      	ldr	r0, [r7, #4]
    787e:	f7ff fe6d 	bl	755c <recover_from_rx_overflow>
    }
    
    /* Set the clock rate. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    7882:	687b      	ldr	r3, [r7, #4]
    7884:	681b      	ldr	r3, [r3, #0]
    7886:	687a      	ldr	r2, [r7, #4]
    7888:	6812      	ldr	r2, [r2, #0]
    788a:	6812      	ldr	r2, [r2, #0]
    788c:	f022 0201 	bic.w	r2, r2, #1
    7890:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = this_spi->slaves_cfg[slave].ctrl_reg;
    7892:	687b      	ldr	r3, [r7, #4]
    7894:	681a      	ldr	r2, [r3, #0]
    7896:	78fb      	ldrb	r3, [r7, #3]
    7898:	6879      	ldr	r1, [r7, #4]
    789a:	f103 0306 	add.w	r3, r3, #6
    789e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    78a2:	440b      	add	r3, r1
    78a4:	685b      	ldr	r3, [r3, #4]
    78a6:	6013      	str	r3, [r2, #0]
    this_spi->hw_reg->CLK_GEN = this_spi->slaves_cfg[slave].clk_gen;
    78a8:	687b      	ldr	r3, [r7, #4]
    78aa:	681a      	ldr	r2, [r3, #0]
    78ac:	78fb      	ldrb	r3, [r7, #3]
    78ae:	6879      	ldr	r1, [r7, #4]
    78b0:	f103 0306 	add.w	r3, r3, #6
    78b4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    78b8:	440b      	add	r3, r1
    78ba:	7a5b      	ldrb	r3, [r3, #9]
    78bc:	6193      	str	r3, [r2, #24]
    this_spi->hw_reg->TXRXDF_SIZE = this_spi->slaves_cfg[slave].txrxdf_size_reg;
    78be:	687b      	ldr	r3, [r7, #4]
    78c0:	681a      	ldr	r2, [r3, #0]
    78c2:	78fb      	ldrb	r3, [r7, #3]
    78c4:	6879      	ldr	r1, [r7, #4]
    78c6:	f103 0306 	add.w	r3, r3, #6
    78ca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    78ce:	440b      	add	r3, r1
    78d0:	7a1b      	ldrb	r3, [r3, #8]
    78d2:	6053      	str	r3, [r2, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
    78d4:	687b      	ldr	r3, [r7, #4]
    78d6:	681b      	ldr	r3, [r3, #0]
    78d8:	687a      	ldr	r2, [r7, #4]
    78da:	6812      	ldr	r2, [r2, #0]
    78dc:	6812      	ldr	r2, [r2, #0]
    78de:	f042 0201 	orr.w	r2, r2, #1
    78e2:	601a      	str	r2, [r3, #0]
    
    /* Set slave select */
    this_spi->hw_reg->SLAVE_SELECT |= ((uint32_t)1 << (uint32_t)slave);
    78e4:	687b      	ldr	r3, [r7, #4]
    78e6:	681b      	ldr	r3, [r3, #0]
    78e8:	687a      	ldr	r2, [r7, #4]
    78ea:	6812      	ldr	r2, [r2, #0]
    78ec:	69d1      	ldr	r1, [r2, #28]
    78ee:	78fa      	ldrb	r2, [r7, #3]
    78f0:	f04f 0001 	mov.w	r0, #1
    78f4:	fa00 f202 	lsl.w	r2, r0, r2
    78f8:	ea41 0202 	orr.w	r2, r1, r2
    78fc:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
    78fe:	687b      	ldr	r3, [r7, #4]
    7900:	791b      	ldrb	r3, [r3, #4]
    7902:	b25b      	sxtb	r3, r3
    7904:	4618      	mov	r0, r3
    7906:	f7ff fd37 	bl	7378 <NVIC_EnableIRQ>
}
    790a:	f107 0710 	add.w	r7, r7, #16
    790e:	46bd      	mov	sp, r7
    7910:	bd80      	pop	{r7, pc}
    7912:	bf00      	nop

00007914 <MSS_SPI_clear_slave_select>:
void MSS_SPI_clear_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
    7914:	b580      	push	{r7, lr}
    7916:	b084      	sub	sp, #16
    7918:	af00      	add	r7, sp, #0
    791a:	6078      	str	r0, [r7, #4]
    791c:	460b      	mov	r3, r1
    791e:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    7920:	687a      	ldr	r2, [r7, #4]
    7922:	f24c 5384 	movw	r3, #50564	; 0xc584
    7926:	f2c2 0300 	movt	r3, #8192	; 0x2000
    792a:	429a      	cmp	r2, r3
    792c:	d007      	beq.n	793e <MSS_SPI_clear_slave_select+0x2a>
    792e:	687a      	ldr	r2, [r7, #4]
    7930:	f24c 5300 	movw	r3, #50432	; 0xc500
    7934:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7938:	429a      	cmp	r2, r3
    793a:	d000      	beq.n	793e <MSS_SPI_clear_slave_select+0x2a>
    793c:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
    793e:	687b      	ldr	r3, [r7, #4]
    7940:	681b      	ldr	r3, [r3, #0]
    7942:	681b      	ldr	r3, [r3, #0]
    7944:	f003 0302 	and.w	r3, r3, #2
    7948:	2b00      	cmp	r3, #0
    794a:	d100      	bne.n	794e <MSS_SPI_clear_slave_select+0x3a>
    794c:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
    794e:	687b      	ldr	r3, [r7, #4]
    7950:	791b      	ldrb	r3, [r3, #4]
    7952:	b25b      	sxtb	r3, r3
    7954:	4618      	mov	r0, r3
    7956:	f7ff fd2b 	bl	73b0 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
    795a:	687b      	ldr	r3, [r7, #4]
    795c:	681b      	ldr	r3, [r3, #0]
    795e:	689b      	ldr	r3, [r3, #8]
    7960:	f003 0304 	and.w	r3, r3, #4
    7964:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
    7966:	68fb      	ldr	r3, [r7, #12]
    7968:	2b00      	cmp	r3, #0
    796a:	d002      	beq.n	7972 <MSS_SPI_clear_slave_select+0x5e>
    {
         recover_from_rx_overflow(this_spi);
    796c:	6878      	ldr	r0, [r7, #4]
    796e:	f7ff fdf5 	bl	755c <recover_from_rx_overflow>
    }
    
    this_spi->hw_reg->SLAVE_SELECT &= ~((uint32_t)1 << (uint32_t)slave);
    7972:	687b      	ldr	r3, [r7, #4]
    7974:	681b      	ldr	r3, [r3, #0]
    7976:	687a      	ldr	r2, [r7, #4]
    7978:	6812      	ldr	r2, [r2, #0]
    797a:	69d1      	ldr	r1, [r2, #28]
    797c:	78fa      	ldrb	r2, [r7, #3]
    797e:	f04f 0001 	mov.w	r0, #1
    7982:	fa00 f202 	lsl.w	r2, r0, r2
    7986:	ea6f 0202 	mvn.w	r2, r2
    798a:	ea01 0202 	and.w	r2, r1, r2
    798e:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
    7990:	687b      	ldr	r3, [r7, #4]
    7992:	791b      	ldrb	r3, [r3, #4]
    7994:	b25b      	sxtb	r3, r3
    7996:	4618      	mov	r0, r3
    7998:	f7ff fcee 	bl	7378 <NVIC_EnableIRQ>
}
    799c:	f107 0710 	add.w	r7, r7, #16
    79a0:	46bd      	mov	sp, r7
    79a2:	bd80      	pop	{r7, pc}

000079a4 <MSS_SPI_transfer_frame>:
uint32_t MSS_SPI_transfer_frame
(
    mss_spi_instance_t * this_spi,
    uint32_t tx_bits
)
{
    79a4:	b480      	push	{r7}
    79a6:	b085      	sub	sp, #20
    79a8:	af00      	add	r7, sp, #0
    79aa:	6078      	str	r0, [r7, #4]
    79ac:	6039      	str	r1, [r7, #0]
    uint32_t rx_ready;
    uint32_t tx_done;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    79ae:	687a      	ldr	r2, [r7, #4]
    79b0:	f24c 5384 	movw	r3, #50564	; 0xc584
    79b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79b8:	429a      	cmp	r2, r3
    79ba:	d007      	beq.n	79cc <MSS_SPI_transfer_frame+0x28>
    79bc:	687a      	ldr	r2, [r7, #4]
    79be:	f24c 5300 	movw	r3, #50432	; 0xc500
    79c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    79c6:	429a      	cmp	r2, r3
    79c8:	d000      	beq.n	79cc <MSS_SPI_transfer_frame+0x28>
    79ca:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
    79cc:	687b      	ldr	r3, [r7, #4]
    79ce:	681b      	ldr	r3, [r3, #0]
    79d0:	681b      	ldr	r3, [r3, #0]
    79d2:	f003 0302 	and.w	r3, r3, #2
    79d6:	2b00      	cmp	r3, #0
    79d8:	d100      	bne.n	79dc <MSS_SPI_transfer_frame+0x38>
    79da:	be00      	bkpt	0x0000
    
    /* Ensure single frame transfer selected so interrupts work correctly */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
    79dc:	687b      	ldr	r3, [r7, #4]
    79de:	681a      	ldr	r2, [r3, #0]
    79e0:	687b      	ldr	r3, [r7, #4]
    79e2:	681b      	ldr	r3, [r3, #0]
    79e4:	6819      	ldr	r1, [r3, #0]
    79e6:	f240 03ff 	movw	r3, #255	; 0xff
    79ea:	f6cf 7300 	movt	r3, #65280	; 0xff00
    79ee:	ea01 0303 	and.w	r3, r1, r3
    79f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    79f6:	6013      	str	r3, [r2, #0]
                                | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
    79f8:	687b      	ldr	r3, [r7, #4]
    79fa:	681b      	ldr	r3, [r3, #0]
    79fc:	687a      	ldr	r2, [r7, #4]
    79fe:	6812      	ldr	r2, [r2, #0]
    7a00:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7a02:	f042 020c 	orr.w	r2, r2, #12
    7a06:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
    7a08:	687b      	ldr	r3, [r7, #4]
    7a0a:	681b      	ldr	r3, [r3, #0]
    7a0c:	683a      	ldr	r2, [r7, #0]
    7a0e:	615a      	str	r2, [r3, #20]
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    7a10:	687b      	ldr	r3, [r7, #4]
    7a12:	681b      	ldr	r3, [r3, #0]
    7a14:	689b      	ldr	r3, [r3, #8]
    7a16:	f003 0301 	and.w	r3, r3, #1
    7a1a:	60fb      	str	r3, [r7, #12]
    while(0u == tx_done)
    7a1c:	e005      	b.n	7a2a <MSS_SPI_transfer_frame+0x86>
    {
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    7a1e:	687b      	ldr	r3, [r7, #4]
    7a20:	681b      	ldr	r3, [r3, #0]
    7a22:	689b      	ldr	r3, [r3, #8]
    7a24:	f003 0301 	and.w	r3, r3, #1
    7a28:	60fb      	str	r3, [r7, #12]
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    while(0u == tx_done)
    7a2a:	68fb      	ldr	r3, [r7, #12]
    7a2c:	2b00      	cmp	r3, #0
    7a2e:	d0f6      	beq.n	7a1e <MSS_SPI_transfer_frame+0x7a>
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    7a30:	687b      	ldr	r3, [r7, #4]
    7a32:	681b      	ldr	r3, [r3, #0]
    7a34:	689b      	ldr	r3, [r3, #8]
    7a36:	f003 0302 	and.w	r3, r3, #2
    7a3a:	60bb      	str	r3, [r7, #8]
    while(0u == rx_ready)
    7a3c:	e005      	b.n	7a4a <MSS_SPI_transfer_frame+0xa6>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    7a3e:	687b      	ldr	r3, [r7, #4]
    7a40:	681b      	ldr	r3, [r3, #0]
    7a42:	689b      	ldr	r3, [r3, #8]
    7a44:	f003 0302 	and.w	r3, r3, #2
    7a48:	60bb      	str	r3, [r7, #8]
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    while(0u == rx_ready)
    7a4a:	68bb      	ldr	r3, [r7, #8]
    7a4c:	2b00      	cmp	r3, #0
    7a4e:	d0f6      	beq.n	7a3e <MSS_SPI_transfer_frame+0x9a>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    }
    /* Return Rx data. */
    return( this_spi->hw_reg->RX_DATA );
    7a50:	687b      	ldr	r3, [r7, #4]
    7a52:	681b      	ldr	r3, [r3, #0]
    7a54:	691b      	ldr	r3, [r3, #16]
}
    7a56:	4618      	mov	r0, r3
    7a58:	f107 0714 	add.w	r7, r7, #20
    7a5c:	46bd      	mov	sp, r7
    7a5e:	bc80      	pop	{r7}
    7a60:	4770      	bx	lr
    7a62:	bf00      	nop

00007a64 <MSS_SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rd_buffer,
    uint16_t rd_byte_size
)
{
    7a64:	b580      	push	{r7, lr}
    7a66:	b08e      	sub	sp, #56	; 0x38
    7a68:	af00      	add	r7, sp, #0
    7a6a:	60f8      	str	r0, [r7, #12]
    7a6c:	60b9      	str	r1, [r7, #8]
    7a6e:	603b      	str	r3, [r7, #0]
    7a70:	4613      	mov	r3, r2
    7a72:	80fb      	strh	r3, [r7, #6]
    uint16_t transfer_idx = 0u;
    7a74:	f04f 0300 	mov.w	r3, #0
    7a78:	837b      	strh	r3, [r7, #26]
    uint16_t tx_idx;
    uint16_t rx_idx;
    uint32_t frame_count;
    volatile uint32_t rx_raw;
    uint16_t transit = 0u;
    7a7a:	f04f 0300 	mov.w	r3, #0
    7a7e:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint32_t rx_overflow;
    uint32_t rx_fifo_empty;
    
    uint16_t transfer_size;     /* Total number of bytes transfered. */
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    7a80:	68fa      	ldr	r2, [r7, #12]
    7a82:	f24c 5384 	movw	r3, #50564	; 0xc584
    7a86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a8a:	429a      	cmp	r2, r3
    7a8c:	d007      	beq.n	7a9e <MSS_SPI_transfer_block+0x3a>
    7a8e:	68fa      	ldr	r2, [r7, #12]
    7a90:	f24c 5300 	movw	r3, #50432	; 0xc500
    7a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7a98:	429a      	cmp	r2, r3
    7a9a:	d000      	beq.n	7a9e <MSS_SPI_transfer_block+0x3a>
    7a9c:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
    7a9e:	68fb      	ldr	r3, [r7, #12]
    7aa0:	681b      	ldr	r3, [r3, #0]
    7aa2:	681b      	ldr	r3, [r3, #0]
    7aa4:	f003 0302 	and.w	r3, r3, #2
    7aa8:	2b00      	cmp	r3, #0
    7aaa:	d100      	bne.n	7aae <MSS_SPI_transfer_block+0x4a>
    7aac:	be00      	bkpt	0x0000
    
    /* Compute number of bytes to transfer. */
    transfer_size = cmd_byte_size + rd_byte_size;
    7aae:	88fa      	ldrh	r2, [r7, #6]
    7ab0:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
    7ab4:	4413      	add	r3, r2
    7ab6:	86fb      	strh	r3, [r7, #54]	; 0x36
    
    /* Adjust to 1 byte transfer to cater for DMA transfers. */
    if(0u == transfer_size)
    7ab8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    7aba:	2b00      	cmp	r3, #0
    7abc:	d103      	bne.n	7ac6 <MSS_SPI_transfer_block+0x62>
    {
        frame_count = 1u;
    7abe:	f04f 0301 	mov.w	r3, #1
    7ac2:	623b      	str	r3, [r7, #32]
    7ac4:	e001      	b.n	7aca <MSS_SPI_transfer_block+0x66>
    }
    else
    {
        frame_count = transfer_size;
    7ac6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    7ac8:	623b      	str	r3, [r7, #32]
    }

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
    7aca:	68fb      	ldr	r3, [r7, #12]
    7acc:	681b      	ldr	r3, [r3, #0]
    7ace:	68fa      	ldr	r2, [r7, #12]
    7ad0:	6812      	ldr	r2, [r2, #0]
    7ad2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7ad4:	f042 020c 	orr.w	r2, r2, #12
    7ad8:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
    7ada:	68fb      	ldr	r3, [r7, #12]
    7adc:	681b      	ldr	r3, [r3, #0]
    7ade:	689b      	ldr	r3, [r3, #8]
    7ae0:	f003 0304 	and.w	r3, r3, #4
    7ae4:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(rx_overflow)
    7ae6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7ae8:	2b00      	cmp	r3, #0
    7aea:	d002      	beq.n	7af2 <MSS_SPI_transfer_block+0x8e>
    {
         recover_from_rx_overflow(this_spi);
    7aec:	68f8      	ldr	r0, [r7, #12]
    7aee:	f7ff fd35 	bl	755c <recover_from_rx_overflow>
    }
    
    /* Set frame size to 8 bits and the frame count to the transfer size. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    7af2:	68fb      	ldr	r3, [r7, #12]
    7af4:	681b      	ldr	r3, [r3, #0]
    7af6:	68fa      	ldr	r2, [r7, #12]
    7af8:	6812      	ldr	r2, [r2, #0]
    7afa:	6812      	ldr	r2, [r2, #0]
    7afc:	f022 0201 	bic.w	r2, r2, #1
    7b00:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
    7b02:	68fb      	ldr	r3, [r7, #12]
    7b04:	6819      	ldr	r1, [r3, #0]
    7b06:	68fb      	ldr	r3, [r7, #12]
    7b08:	681b      	ldr	r3, [r3, #0]
    7b0a:	681b      	ldr	r3, [r3, #0]
    7b0c:	f240 02ff 	movw	r2, #255	; 0xff
    7b10:	f6cf 7200 	movt	r2, #65280	; 0xff00
    7b14:	ea03 0202 	and.w	r2, r3, r2
    7b18:	6a3b      	ldr	r3, [r7, #32]
    7b1a:	ea4f 2003 	mov.w	r0, r3, lsl #8
    7b1e:	f64f 7300 	movw	r3, #65280	; 0xff00
    7b22:	f2c0 03ff 	movt	r3, #255	; 0xff
    7b26:	ea00 0303 	and.w	r3, r0, r3
    7b2a:	ea42 0303 	orr.w	r3, r2, r3
    7b2e:	600b      	str	r3, [r1, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    7b30:	68fb      	ldr	r3, [r7, #12]
    7b32:	681b      	ldr	r3, [r3, #0]
    7b34:	f04f 0208 	mov.w	r2, #8
    7b38:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
    7b3a:	68fb      	ldr	r3, [r7, #12]
    7b3c:	681b      	ldr	r3, [r3, #0]
    7b3e:	68fa      	ldr	r2, [r7, #12]
    7b40:	6812      	ldr	r2, [r2, #0]
    7b42:	6812      	ldr	r2, [r2, #0]
    7b44:	f042 0201 	orr.w	r2, r2, #1
    7b48:	601a      	str	r2, [r3, #0]

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    7b4a:	68fb      	ldr	r3, [r7, #12]
    7b4c:	681b      	ldr	r3, [r3, #0]
    7b4e:	689b      	ldr	r3, [r3, #8]
    7b50:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7b54:	633b      	str	r3, [r7, #48]	; 0x30
    while(0u == rx_fifo_empty)
    7b56:	e009      	b.n	7b6c <MSS_SPI_transfer_block+0x108>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
    7b58:	68fb      	ldr	r3, [r7, #12]
    7b5a:	681b      	ldr	r3, [r3, #0]
    7b5c:	691b      	ldr	r3, [r3, #16]
    7b5e:	617b      	str	r3, [r7, #20]
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    7b60:	68fb      	ldr	r3, [r7, #12]
    7b62:	681b      	ldr	r3, [r3, #0]
    7b64:	689b      	ldr	r3, [r3, #8]
    7b66:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7b6a:	633b      	str	r3, [r7, #48]	; 0x30
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    while(0u == rx_fifo_empty)
    7b6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    7b6e:	2b00      	cmp	r3, #0
    7b70:	d0f2      	beq.n	7b58 <MSS_SPI_transfer_block+0xf4>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    }
    
    tx_idx = 0u;
    7b72:	f04f 0300 	mov.w	r3, #0
    7b76:	83bb      	strh	r3, [r7, #28]
    rx_idx = 0u;
    7b78:	f04f 0300 	mov.w	r3, #0
    7b7c:	83fb      	strh	r3, [r7, #30]
    if(tx_idx < cmd_byte_size)
    7b7e:	8bba      	ldrh	r2, [r7, #28]
    7b80:	88fb      	ldrh	r3, [r7, #6]
    7b82:	429a      	cmp	r2, r3
    7b84:	d20f      	bcs.n	7ba6 <MSS_SPI_transfer_block+0x142>
    {
        this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
    7b86:	68fb      	ldr	r3, [r7, #12]
    7b88:	681b      	ldr	r3, [r3, #0]
    7b8a:	8bb9      	ldrh	r1, [r7, #28]
    7b8c:	68ba      	ldr	r2, [r7, #8]
    7b8e:	440a      	add	r2, r1
    7b90:	7812      	ldrb	r2, [r2, #0]
    7b92:	615a      	str	r2, [r3, #20]
        ++tx_idx;
    7b94:	8bbb      	ldrh	r3, [r7, #28]
    7b96:	f103 0301 	add.w	r3, r3, #1
    7b9a:	83bb      	strh	r3, [r7, #28]
        ++transit;
    7b9c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7b9e:	f103 0301 	add.w	r3, r3, #1
    7ba2:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
    7ba4:	e06a      	b.n	7c7c <MSS_SPI_transfer_block+0x218>
        ++tx_idx;
        ++transit;
    }
    else
    {
        if(tx_idx < transfer_size)
    7ba6:	8bba      	ldrh	r2, [r7, #28]
    7ba8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    7baa:	429a      	cmp	r2, r3
    7bac:	d266      	bcs.n	7c7c <MSS_SPI_transfer_block+0x218>
        {
            this_spi->hw_reg->TX_DATA = 0x00u;
    7bae:	68fb      	ldr	r3, [r7, #12]
    7bb0:	681b      	ldr	r3, [r3, #0]
    7bb2:	f04f 0200 	mov.w	r2, #0
    7bb6:	615a      	str	r2, [r3, #20]
            ++tx_idx;
    7bb8:	8bbb      	ldrh	r3, [r7, #28]
    7bba:	f103 0301 	add.w	r3, r3, #1
    7bbe:	83bb      	strh	r3, [r7, #28]
            ++transit;
    7bc0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7bc2:	f103 0301 	add.w	r3, r3, #1
    7bc6:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
    7bc8:	e058      	b.n	7c7c <MSS_SPI_transfer_block+0x218>
    {
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    7bca:	68fb      	ldr	r3, [r7, #12]
    7bcc:	681b      	ldr	r3, [r3, #0]
    7bce:	689b      	ldr	r3, [r3, #8]
    7bd0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7bd4:	633b      	str	r3, [r7, #48]	; 0x30
        if(0u == rx_fifo_empty)
    7bd6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    7bd8:	2b00      	cmp	r3, #0
    7bda:	d11e      	bne.n	7c1a <MSS_SPI_transfer_block+0x1b6>
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;
    7bdc:	68fb      	ldr	r3, [r7, #12]
    7bde:	681b      	ldr	r3, [r3, #0]
    7be0:	691b      	ldr	r3, [r3, #16]
    7be2:	617b      	str	r3, [r7, #20]
            if(transfer_idx >= cmd_byte_size)
    7be4:	8b7a      	ldrh	r2, [r7, #26]
    7be6:	88fb      	ldrh	r3, [r7, #6]
    7be8:	429a      	cmp	r2, r3
    7bea:	d30e      	bcc.n	7c0a <MSS_SPI_transfer_block+0x1a6>
            {
                if(rx_idx < rd_byte_size)
    7bec:	8bfa      	ldrh	r2, [r7, #30]
    7bee:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
    7bf2:	429a      	cmp	r2, r3
    7bf4:	d205      	bcs.n	7c02 <MSS_SPI_transfer_block+0x19e>
                {
                    rd_buffer[rx_idx] = (uint8_t)rx_raw;   
    7bf6:	8bfa      	ldrh	r2, [r7, #30]
    7bf8:	683b      	ldr	r3, [r7, #0]
    7bfa:	4413      	add	r3, r2
    7bfc:	697a      	ldr	r2, [r7, #20]
    7bfe:	b2d2      	uxtb	r2, r2
    7c00:	701a      	strb	r2, [r3, #0]
                }
                ++rx_idx;
    7c02:	8bfb      	ldrh	r3, [r7, #30]
    7c04:	f103 0301 	add.w	r3, r3, #1
    7c08:	83fb      	strh	r3, [r7, #30]
            }
            ++transfer_idx;
    7c0a:	8b7b      	ldrh	r3, [r7, #26]
    7c0c:	f103 0301 	add.w	r3, r3, #1
    7c10:	837b      	strh	r3, [r7, #26]
            --transit;
    7c12:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7c14:	f103 33ff 	add.w	r3, r3, #4294967295
    7c18:	84fb      	strh	r3, [r7, #38]	; 0x26
        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
    7c1a:	68fb      	ldr	r3, [r7, #12]
    7c1c:	681b      	ldr	r3, [r3, #0]
    7c1e:	689b      	ldr	r3, [r3, #8]
    7c20:	f403 7380 	and.w	r3, r3, #256	; 0x100
    7c24:	62bb      	str	r3, [r7, #40]	; 0x28
        if(0u == tx_fifo_full)
    7c26:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7c28:	2b00      	cmp	r3, #0
    7c2a:	d127      	bne.n	7c7c <MSS_SPI_transfer_block+0x218>
        {
            if(transit < RX_FIFO_SIZE)
    7c2c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7c2e:	2b03      	cmp	r3, #3
    7c30:	d824      	bhi.n	7c7c <MSS_SPI_transfer_block+0x218>
            {
                /* Send another byte. */
                if(tx_idx < cmd_byte_size)
    7c32:	8bba      	ldrh	r2, [r7, #28]
    7c34:	88fb      	ldrh	r3, [r7, #6]
    7c36:	429a      	cmp	r2, r3
    7c38:	d20f      	bcs.n	7c5a <MSS_SPI_transfer_block+0x1f6>
                {
                    this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
    7c3a:	68fb      	ldr	r3, [r7, #12]
    7c3c:	681b      	ldr	r3, [r3, #0]
    7c3e:	8bb9      	ldrh	r1, [r7, #28]
    7c40:	68ba      	ldr	r2, [r7, #8]
    7c42:	440a      	add	r2, r1
    7c44:	7812      	ldrb	r2, [r2, #0]
    7c46:	615a      	str	r2, [r3, #20]
                    ++tx_idx;
    7c48:	8bbb      	ldrh	r3, [r7, #28]
    7c4a:	f103 0301 	add.w	r3, r3, #1
    7c4e:	83bb      	strh	r3, [r7, #28]
                    ++transit;
    7c50:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7c52:	f103 0301 	add.w	r3, r3, #1
    7c56:	84fb      	strh	r3, [r7, #38]	; 0x26
    7c58:	e010      	b.n	7c7c <MSS_SPI_transfer_block+0x218>
                }
                else
                {
                    if(tx_idx < transfer_size)
    7c5a:	8bba      	ldrh	r2, [r7, #28]
    7c5c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    7c5e:	429a      	cmp	r2, r3
    7c60:	d20c      	bcs.n	7c7c <MSS_SPI_transfer_block+0x218>
                    {
                        this_spi->hw_reg->TX_DATA = 0x00u;
    7c62:	68fb      	ldr	r3, [r7, #12]
    7c64:	681b      	ldr	r3, [r3, #0]
    7c66:	f04f 0200 	mov.w	r2, #0
    7c6a:	615a      	str	r2, [r3, #20]
                        ++tx_idx;
    7c6c:	8bbb      	ldrh	r3, [r7, #28]
    7c6e:	f103 0301 	add.w	r3, r3, #1
    7c72:	83bb      	strh	r3, [r7, #28]
                        ++transit;
    7c74:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
    7c76:	f103 0301 	add.w	r3, r3, #1
    7c7a:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
    7c7c:	8b7a      	ldrh	r2, [r7, #26]
    7c7e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    7c80:	429a      	cmp	r2, r3
    7c82:	d3a2      	bcc.n	7bca <MSS_SPI_transfer_block+0x166>
                    }
                }
            }
        }
    }
}
    7c84:	f107 0738 	add.w	r7, r7, #56	; 0x38
    7c88:	46bd      	mov	sp, r7
    7c8a:	bd80      	pop	{r7, pc}

00007c8c <fill_slave_tx_fifo>:
 */
static void fill_slave_tx_fifo
(
    mss_spi_instance_t * this_spi
)
{
    7c8c:	b480      	push	{r7}
    7c8e:	b085      	sub	sp, #20
    7c90:	af00      	add	r7, sp, #0
    7c92:	6078      	str	r0, [r7, #4]
    uint32_t guard = 0u;
    7c94:	f04f 0300 	mov.w	r3, #0
    7c98:	60fb      	str	r3, [r7, #12]

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7c9a:	e00e      	b.n	7cba <fill_slave_tx_fifo+0x2e>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    {
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
    7c9c:	687b      	ldr	r3, [r7, #4]
    7c9e:	681b      	ldr	r3, [r3, #0]
    7ca0:	687a      	ldr	r2, [r7, #4]
    7ca2:	6891      	ldr	r1, [r2, #8]
    7ca4:	687a      	ldr	r2, [r7, #4]
    7ca6:	6912      	ldr	r2, [r2, #16]
    7ca8:	440a      	add	r2, r1
    7caa:	7812      	ldrb	r2, [r2, #0]
    7cac:	615a      	str	r2, [r3, #20]
        ++this_spi->slave_tx_idx;
    7cae:	687b      	ldr	r3, [r7, #4]
    7cb0:	691b      	ldr	r3, [r3, #16]
    7cb2:	f103 0201 	add.w	r2, r3, #1
    7cb6:	687b      	ldr	r3, [r7, #4]
    7cb8:	611a      	str	r2, [r3, #16]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7cba:	687b      	ldr	r3, [r7, #4]
    7cbc:	681b      	ldr	r3, [r3, #0]
    7cbe:	689b      	ldr	r3, [r3, #8]
    7cc0:	f403 7380 	and.w	r3, r3, #256	; 0x100
    7cc4:	2b00      	cmp	r3, #0
    7cc6:	d105      	bne.n	7cd4 <fill_slave_tx_fifo+0x48>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    7cc8:	687b      	ldr	r3, [r7, #4]
    7cca:	691a      	ldr	r2, [r3, #16]
    7ccc:	687b      	ldr	r3, [r7, #4]
    7cce:	68db      	ldr	r3, [r3, #12]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7cd0:	429a      	cmp	r2, r3
    7cd2:	d3e3      	bcc.n	7c9c <fill_slave_tx_fifo+0x10>
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    7cd4:	687b      	ldr	r3, [r7, #4]
    7cd6:	691a      	ldr	r2, [r3, #16]
    7cd8:	687b      	ldr	r3, [r7, #4]
    7cda:	68db      	ldr	r3, [r3, #12]
    7cdc:	429a      	cmp	r2, r3
    7cde:	d31c      	bcc.n	7d1a <fill_slave_tx_fifo+0x8e>
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7ce0:	e00e      	b.n	7d00 <fill_slave_tx_fifo+0x74>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
        {
            /* Sending from command response buffer */
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
    7ce2:	687b      	ldr	r3, [r7, #4]
    7ce4:	681b      	ldr	r3, [r3, #0]
    7ce6:	687a      	ldr	r2, [r7, #4]
    7ce8:	6951      	ldr	r1, [r2, #20]
    7cea:	687a      	ldr	r2, [r7, #4]
    7cec:	69d2      	ldr	r2, [r2, #28]
    7cee:	440a      	add	r2, r1
    7cf0:	7812      	ldrb	r2, [r2, #0]
    7cf2:	615a      	str	r2, [r3, #20]
            ++this_spi->resp_buff_tx_idx;
    7cf4:	687b      	ldr	r3, [r7, #4]
    7cf6:	69db      	ldr	r3, [r3, #28]
    7cf8:	f103 0201 	add.w	r2, r3, #1
    7cfc:	687b      	ldr	r3, [r7, #4]
    7cfe:	61da      	str	r2, [r3, #28]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7d00:	687b      	ldr	r3, [r7, #4]
    7d02:	681b      	ldr	r3, [r3, #0]
    7d04:	689b      	ldr	r3, [r3, #8]
    7d06:	f403 7380 	and.w	r3, r3, #256	; 0x100
    7d0a:	2b00      	cmp	r3, #0
    7d0c:	d105      	bne.n	7d1a <fill_slave_tx_fifo+0x8e>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
    7d0e:	687b      	ldr	r3, [r7, #4]
    7d10:	69da      	ldr	r2, [r3, #28]
    7d12:	687b      	ldr	r3, [r7, #4]
    7d14:	699b      	ldr	r3, [r3, #24]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7d16:	429a      	cmp	r2, r3
    7d18:	d3e3      	bcc.n	7ce2 <fill_slave_tx_fifo+0x56>
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
    7d1a:	687b      	ldr	r3, [r7, #4]
    7d1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7d1e:	2b00      	cmp	r3, #0
    7d20:	d01f      	beq.n	7d62 <fill_slave_tx_fifo+0xd6>
    7d22:	687b      	ldr	r3, [r7, #4]
    7d24:	691a      	ldr	r2, [r3, #16]
    7d26:	687b      	ldr	r3, [r7, #4]
    7d28:	68db      	ldr	r3, [r3, #12]
    7d2a:	429a      	cmp	r2, r3
    7d2c:	d319      	bcc.n	7d62 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    7d2e:	687b      	ldr	r3, [r7, #4]
    7d30:	69da      	ldr	r2, [r3, #28]
    7d32:	687b      	ldr	r3, [r7, #4]
    7d34:	699b      	ldr	r3, [r3, #24]
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
    7d36:	429a      	cmp	r2, r3
    7d38:	d313      	bcc.n	7d62 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7d3a:	e008      	b.n	7d4e <fill_slave_tx_fifo+0xc2>
              (guard < BIG_FIFO_SIZE))
        {
            /* Nothing left so pad with 0s for consistency */
            this_spi->hw_reg->TX_DATA = 0x00u;
    7d3c:	687b      	ldr	r3, [r7, #4]
    7d3e:	681b      	ldr	r3, [r3, #0]
    7d40:	f04f 0200 	mov.w	r2, #0
    7d44:	615a      	str	r2, [r3, #20]
             * We use the guard count to cover the unlikely event that we are
             * never seeing the TX FIFO full because the data is being pulled
             * out as fast as we can stuff it in. In this event we never spend
             * more than a full FIFOs worth of time spinning here.
             */
            guard++;
    7d46:	68fb      	ldr	r3, [r7, #12]
    7d48:	f103 0301 	add.w	r3, r3, #1
    7d4c:	60fb      	str	r3, [r7, #12]
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
    7d4e:	687b      	ldr	r3, [r7, #4]
    7d50:	681b      	ldr	r3, [r3, #0]
    7d52:	689b      	ldr	r3, [r3, #8]
    7d54:	f403 7380 	and.w	r3, r3, #256	; 0x100
    7d58:	2b00      	cmp	r3, #0
    7d5a:	d102      	bne.n	7d62 <fill_slave_tx_fifo+0xd6>
    7d5c:	68fb      	ldr	r3, [r7, #12]
    7d5e:	2b1f      	cmp	r3, #31
    7d60:	d9ec      	bls.n	7d3c <fill_slave_tx_fifo+0xb0>
             */
            guard++;
        }
    }

}
    7d62:	f107 0714 	add.w	r7, r7, #20
    7d66:	46bd      	mov	sp, r7
    7d68:	bc80      	pop	{r7}
    7d6a:	4770      	bx	lr

00007d6c <read_slave_rx_fifo>:
 */
static void read_slave_rx_fifo
(
    mss_spi_instance_t * this_spi
)
{
    7d6c:	b580      	push	{r7, lr}
    7d6e:	b084      	sub	sp, #16
    7d70:	af00      	add	r7, sp, #0
    7d72:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    7d74:	687b      	ldr	r3, [r7, #4]
    7d76:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7d7a:	2b02      	cmp	r3, #2
    7d7c:	d115      	bne.n	7daa <read_slave_rx_fifo+0x3e>
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7d7e:	e00c      	b.n	7d9a <read_slave_rx_fifo+0x2e>
        {
            /* Single frame handling mode. */
            rx_frame = this_spi->hw_reg->RX_DATA;
    7d80:	687b      	ldr	r3, [r7, #4]
    7d82:	681b      	ldr	r3, [r3, #0]
    7d84:	691b      	ldr	r3, [r3, #16]
    7d86:	60fb      	str	r3, [r7, #12]
            if(0u != this_spi->frame_rx_handler)
    7d88:	687b      	ldr	r3, [r7, #4]
    7d8a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7d8c:	2b00      	cmp	r3, #0
    7d8e:	d004      	beq.n	7d9a <read_slave_rx_fifo+0x2e>
            {
                this_spi->frame_rx_handler( rx_frame );
    7d90:	687b      	ldr	r3, [r7, #4]
    7d92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7d94:	68fa      	ldr	r2, [r7, #12]
    7d96:	4610      	mov	r0, r2
    7d98:	4798      	blx	r3
{
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7d9a:	687b      	ldr	r3, [r7, #4]
    7d9c:	681b      	ldr	r3, [r3, #0]
    7d9e:	689b      	ldr	r3, [r3, #8]
    7da0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7da4:	2b00      	cmp	r3, #0
    7da6:	d0eb      	beq.n	7d80 <read_slave_rx_fifo+0x14>
    7da8:	e032      	b.n	7e10 <read_slave_rx_fifo+0xa4>
            {
                this_spi->frame_rx_handler( rx_frame );
            }
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    7daa:	687b      	ldr	r3, [r7, #4]
    7dac:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7db0:	2b01      	cmp	r3, #1
    7db2:	d125      	bne.n	7e00 <read_slave_rx_fifo+0x94>
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
    7db4:	e017      	b.n	7de6 <read_slave_rx_fifo+0x7a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
    7db6:	687b      	ldr	r3, [r7, #4]
    7db8:	681b      	ldr	r3, [r3, #0]
    7dba:	691b      	ldr	r3, [r3, #16]
    7dbc:	60fb      	str	r3, [r7, #12]
            if(this_spi->slave_rx_idx < this_spi->slave_rx_size)
    7dbe:	687b      	ldr	r3, [r7, #4]
    7dc0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    7dc2:	687b      	ldr	r3, [r7, #4]
    7dc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7dc6:	429a      	cmp	r2, r3
    7dc8:	d207      	bcs.n	7dda <read_slave_rx_fifo+0x6e>
            {
                this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
    7dca:	687b      	ldr	r3, [r7, #4]
    7dcc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7dce:	687b      	ldr	r3, [r7, #4]
    7dd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7dd2:	4413      	add	r3, r2
    7dd4:	68fa      	ldr	r2, [r7, #12]
    7dd6:	b2d2      	uxtb	r2, r2
    7dd8:	701a      	strb	r2, [r3, #0]
            }

            ++this_spi->slave_rx_idx;
    7dda:	687b      	ldr	r3, [r7, #4]
    7ddc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7dde:	f103 0201 	add.w	r2, r3, #1
    7de2:	687b      	ldr	r3, [r7, #4]
    7de4:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
    7de6:	687b      	ldr	r3, [r7, #4]
    7de8:	681b      	ldr	r3, [r3, #0]
    7dea:	689b      	ldr	r3, [r3, #8]
    7dec:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7df0:	2b00      	cmp	r3, #0
    7df2:	d0e0      	beq.n	7db6 <read_slave_rx_fifo+0x4a>
    7df4:	e00c      	b.n	7e10 <read_slave_rx_fifo+0xa4>
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
    7df6:	687b      	ldr	r3, [r7, #4]
    7df8:	681b      	ldr	r3, [r3, #0]
    7dfa:	691b      	ldr	r3, [r3, #16]
    7dfc:	60fb      	str	r3, [r7, #12]
    7dfe:	e000      	b.n	7e02 <read_slave_rx_fifo+0x96>
        }
    }
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7e00:	bf00      	nop
    7e02:	687b      	ldr	r3, [r7, #4]
    7e04:	681b      	ldr	r3, [r3, #0]
    7e06:	689b      	ldr	r3, [r3, #8]
    7e08:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7e0c:	2b00      	cmp	r3, #0
    7e0e:	d0f2      	beq.n	7df6 <read_slave_rx_fifo+0x8a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
        }
    }
}
    7e10:	f107 0710 	add.w	r7, r7, #16
    7e14:	46bd      	mov	sp, r7
    7e16:	bd80      	pop	{r7, pc}

00007e18 <mss_spi_isr>:
 */
static void mss_spi_isr
(
    mss_spi_instance_t * this_spi
)
{    
    7e18:	b580      	push	{r7, lr}
    7e1a:	b086      	sub	sp, #24
    7e1c:	af00      	add	r7, sp, #0
    7e1e:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    __I  uint32_t *this_mis = &this_spi->hw_reg->MIS;
    7e20:	687b      	ldr	r3, [r7, #4]
    7e22:	681b      	ldr	r3, [r3, #0]
    7e24:	f103 0320 	add.w	r3, r3, #32
    7e28:	613b      	str	r3, [r7, #16]

    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
    7e2a:	687a      	ldr	r2, [r7, #4]
    7e2c:	f24c 5384 	movw	r3, #50564	; 0xc584
    7e30:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7e34:	429a      	cmp	r2, r3
    7e36:	d007      	beq.n	7e48 <mss_spi_isr+0x30>
    7e38:	687a      	ldr	r2, [r7, #4]
    7e3a:	f24c 5300 	movw	r3, #50432	; 0xc500
    7e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7e42:	429a      	cmp	r2, r3
    7e44:	d000      	beq.n	7e48 <mss_spi_isr+0x30>
    7e46:	be00      	bkpt	0x0000
  
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    7e48:	693b      	ldr	r3, [r7, #16]
    7e4a:	681b      	ldr	r3, [r3, #0]
    7e4c:	f003 0302 	and.w	r3, r3, #2
    7e50:	2b00      	cmp	r3, #0
    7e52:	d052      	beq.n	7efa <mss_spi_isr+0xe2>
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    7e54:	687b      	ldr	r3, [r7, #4]
    7e56:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7e5a:	2b02      	cmp	r3, #2
    7e5c:	d115      	bne.n	7e8a <mss_spi_isr+0x72>
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7e5e:	e00c      	b.n	7e7a <mss_spi_isr+0x62>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
    7e60:	687b      	ldr	r3, [r7, #4]
    7e62:	681b      	ldr	r3, [r3, #0]
    7e64:	691b      	ldr	r3, [r3, #16]
    7e66:	60fb      	str	r3, [r7, #12]
                if(0u != this_spi->frame_rx_handler)
    7e68:	687b      	ldr	r3, [r7, #4]
    7e6a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7e6c:	2b00      	cmp	r3, #0
    7e6e:	d004      	beq.n	7e7a <mss_spi_isr+0x62>
                {
                    this_spi->frame_rx_handler( rx_frame );
    7e70:	687b      	ldr	r3, [r7, #4]
    7e72:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7e74:	68fa      	ldr	r2, [r7, #12]
    7e76:	4610      	mov	r0, r2
    7e78:	4798      	blx	r3
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7e7a:	687b      	ldr	r3, [r7, #4]
    7e7c:	681b      	ldr	r3, [r3, #0]
    7e7e:	689b      	ldr	r3, [r3, #8]
    7e80:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7e84:	2b00      	cmp	r3, #0
    7e86:	d0eb      	beq.n	7e60 <mss_spi_isr+0x48>
    7e88:	e032      	b.n	7ef0 <mss_spi_isr+0xd8>
                {
                    this_spi->frame_rx_handler( rx_frame );
                }
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    7e8a:	687b      	ldr	r3, [r7, #4]
    7e8c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7e90:	2b01      	cmp	r3, #1
    7e92:	d125      	bne.n	7ee0 <mss_spi_isr+0xc8>
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
    7e94:	e017      	b.n	7ec6 <mss_spi_isr+0xae>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;                /* Read from FIFO irrespective */
    7e96:	687b      	ldr	r3, [r7, #4]
    7e98:	681b      	ldr	r3, [r3, #0]
    7e9a:	691b      	ldr	r3, [r3, #16]
    7e9c:	60fb      	str	r3, [r7, #12]
                if(this_spi->slave_rx_idx < this_spi->slave_rx_size) /* Write to array if required */
    7e9e:	687b      	ldr	r3, [r7, #4]
    7ea0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    7ea2:	687b      	ldr	r3, [r7, #4]
    7ea4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7ea6:	429a      	cmp	r2, r3
    7ea8:	d207      	bcs.n	7eba <mss_spi_isr+0xa2>
                {
                    this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
    7eaa:	687b      	ldr	r3, [r7, #4]
    7eac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7eae:	687b      	ldr	r3, [r7, #4]
    7eb0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7eb2:	4413      	add	r3, r2
    7eb4:	68fa      	ldr	r2, [r7, #12]
    7eb6:	b2d2      	uxtb	r2, r2
    7eb8:	701a      	strb	r2, [r3, #0]
                }

                ++this_spi->slave_rx_idx;            
    7eba:	687b      	ldr	r3, [r7, #4]
    7ebc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7ebe:	f103 0201 	add.w	r2, r3, #1
    7ec2:	687b      	ldr	r3, [r7, #4]
    7ec4:	631a      	str	r2, [r3, #48]	; 0x30
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
    7ec6:	687b      	ldr	r3, [r7, #4]
    7ec8:	681b      	ldr	r3, [r3, #0]
    7eca:	689b      	ldr	r3, [r3, #8]
    7ecc:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7ed0:	2b00      	cmp	r3, #0
    7ed2:	d0e0      	beq.n	7e96 <mss_spi_isr+0x7e>
    7ed4:	e00c      	b.n	7ef0 <mss_spi_isr+0xd8>
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
    7ed6:	687b      	ldr	r3, [r7, #4]
    7ed8:	681b      	ldr	r3, [r3, #0]
    7eda:	691b      	ldr	r3, [r3, #16]
    7edc:	60fb      	str	r3, [r7, #12]
    7ede:	e000      	b.n	7ee2 <mss_spi_isr+0xca>
            }
        }
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
    7ee0:	bf00      	nop
    7ee2:	687b      	ldr	r3, [r7, #4]
    7ee4:	681b      	ldr	r3, [r3, #0]
    7ee6:	689b      	ldr	r3, [r3, #8]
    7ee8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7eec:	2b00      	cmp	r3, #0
    7eee:	d0f2      	beq.n	7ed6 <mss_spi_isr+0xbe>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
            }
        }

        this_spi->hw_reg->INT_CLEAR = RXDONE_IRQ_MASK;
    7ef0:	687b      	ldr	r3, [r7, #4]
    7ef2:	681b      	ldr	r3, [r3, #0]
    7ef4:	f04f 0202 	mov.w	r2, #2
    7ef8:	60da      	str	r2, [r3, #12]
    }

   /* Handle transmit. */
    if(0u != (*this_mis & TXDONE_IRQ_MASK))
    7efa:	693b      	ldr	r3, [r7, #16]
    7efc:	681b      	ldr	r3, [r3, #0]
    7efe:	f003 0301 	and.w	r3, r3, #1
    7f02:	b2db      	uxtb	r3, r3
    7f04:	2b00      	cmp	r3, #0
    7f06:	d012      	beq.n	7f2e <mss_spi_isr+0x116>
    {
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
    7f08:	687b      	ldr	r3, [r7, #4]
    7f0a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7f0e:	2b02      	cmp	r3, #2
    7f10:	d105      	bne.n	7f1e <mss_spi_isr+0x106>
        {
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
    7f12:	687b      	ldr	r3, [r7, #4]
    7f14:	681b      	ldr	r3, [r3, #0]
    7f16:	687a      	ldr	r2, [r7, #4]
    7f18:	6f92      	ldr	r2, [r2, #120]	; 0x78
    7f1a:	615a      	str	r2, [r3, #20]
    7f1c:	e002      	b.n	7f24 <mss_spi_isr+0x10c>
        }
        else /* Must be block mode so load FIFO to the max */
        {
            fill_slave_tx_fifo(this_spi);
    7f1e:	6878      	ldr	r0, [r7, #4]
    7f20:	f7ff feb4 	bl	7c8c <fill_slave_tx_fifo>
        }

        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
    7f24:	687b      	ldr	r3, [r7, #4]
    7f26:	681b      	ldr	r3, [r3, #0]
    7f28:	f04f 0201 	mov.w	r2, #1
    7f2c:	60da      	str	r2, [r3, #12]
    }
    
    /* Handle command interrupt. */
    if(0u != (*this_mis & CMD_IRQ_MASK))
    7f2e:	693b      	ldr	r3, [r7, #16]
    7f30:	681b      	ldr	r3, [r3, #0]
    7f32:	f003 0310 	and.w	r3, r3, #16
    7f36:	2b00      	cmp	r3, #0
    7f38:	d023      	beq.n	7f82 <mss_spi_isr+0x16a>
    {
        read_slave_rx_fifo(this_spi);
    7f3a:	6878      	ldr	r0, [r7, #4]
    7f3c:	f7ff ff16 	bl	7d6c <read_slave_rx_fifo>
        
        /*
         * Call the command handler if one exists.
         */
        if(0u != this_spi->cmd_handler)
    7f40:	687b      	ldr	r3, [r7, #4]
    7f42:	6a1b      	ldr	r3, [r3, #32]
    7f44:	2b00      	cmp	r3, #0
    7f46:	d00b      	beq.n	7f60 <mss_spi_isr+0x148>
        {
            (*this_spi->cmd_handler)(this_spi->slave_rx_buffer, this_spi->slave_rx_idx);
    7f48:	687b      	ldr	r3, [r7, #4]
    7f4a:	6a1b      	ldr	r3, [r3, #32]
    7f4c:	687a      	ldr	r2, [r7, #4]
    7f4e:	6a91      	ldr	r1, [r2, #40]	; 0x28
    7f50:	687a      	ldr	r2, [r7, #4]
    7f52:	6b12      	ldr	r2, [r2, #48]	; 0x30
    7f54:	4608      	mov	r0, r1
    7f56:	4611      	mov	r1, r2
    7f58:	4798      	blx	r3
            fill_slave_tx_fifo(this_spi);
    7f5a:	6878      	ldr	r0, [r7, #4]
    7f5c:	f7ff fe96 	bl	7c8c <fill_slave_tx_fifo>
        }
        /* Set cmd_done to indicate it is now safe to 0 fill TX FIFO */
        this_spi->cmd_done = 1u;
    7f60:	687b      	ldr	r3, [r7, #4]
    7f62:	f04f 0201 	mov.w	r2, #1
    7f66:	625a      	str	r2, [r3, #36]	; 0x24
        /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
    7f68:	687b      	ldr	r3, [r7, #4]
    7f6a:	681b      	ldr	r3, [r3, #0]
    7f6c:	687a      	ldr	r2, [r7, #4]
    7f6e:	6812      	ldr	r2, [r2, #0]
    7f70:	6a92      	ldr	r2, [r2, #40]	; 0x28
    7f72:	f022 0210 	bic.w	r2, r2, #16
    7f76:	629a      	str	r2, [r3, #40]	; 0x28
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
    7f78:	687b      	ldr	r3, [r7, #4]
    7f7a:	681b      	ldr	r3, [r3, #0]
    7f7c:	f04f 0210 	mov.w	r2, #16
    7f80:	60da      	str	r2, [r3, #12]
    }

    if(0u != (*this_mis & RXOVFLOW_IRQ_MASK))
    7f82:	693b      	ldr	r3, [r7, #16]
    7f84:	681b      	ldr	r3, [r3, #0]
    7f86:	f003 0304 	and.w	r3, r3, #4
    7f8a:	2b00      	cmp	r3, #0
    7f8c:	d00f      	beq.n	7fae <mss_spi_isr+0x196>
    {
        /*
         * Receive overflow, not a lot we can do for this. Reset the receive
         *  FIFO, clear the interrupt and hope it doesn't happen again...
         */
        this_spi->hw_reg->COMMAND |= RX_FIFO_RESET_MASK;
    7f8e:	687b      	ldr	r3, [r7, #4]
    7f90:	681b      	ldr	r3, [r3, #0]
    7f92:	687a      	ldr	r2, [r7, #4]
    7f94:	6812      	ldr	r2, [r2, #0]
    7f96:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7f98:	f042 0204 	orr.w	r2, r2, #4
    7f9c:	62da      	str	r2, [r3, #44]	; 0x2c
        recover_from_rx_overflow(this_spi);
    7f9e:	6878      	ldr	r0, [r7, #4]
    7fa0:	f7ff fadc 	bl	755c <recover_from_rx_overflow>
        this_spi->hw_reg->INT_CLEAR = RXOVFLOW_IRQ_MASK;
    7fa4:	687b      	ldr	r3, [r7, #4]
    7fa6:	681b      	ldr	r3, [r3, #0]
    7fa8:	f04f 0204 	mov.w	r2, #4
    7fac:	60da      	str	r2, [r3, #12]
     * slave TX FIFO data setup (if there is one).
     * In block mode this will probably not be very successful as we will
     * be out of synch with the master but the reset on SSEND will hopefully
     * take care of that for the next transfer.
     */
    if(0u != (*this_mis & TXURUN_IRQ_MASK))
    7fae:	693b      	ldr	r3, [r7, #16]
    7fb0:	681b      	ldr	r3, [r3, #0]
    7fb2:	f003 0308 	and.w	r3, r3, #8
    7fb6:	2b00      	cmp	r3, #0
    7fb8:	d031      	beq.n	801e <RAM_SIZE+0x1e>
    {
        this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
    7fba:	687b      	ldr	r3, [r7, #4]
    7fbc:	681b      	ldr	r3, [r3, #0]
    7fbe:	687a      	ldr	r2, [r7, #4]
    7fc0:	6812      	ldr	r2, [r2, #0]
    7fc2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7fc4:	f042 0208 	orr.w	r2, r2, #8
    7fc8:	62da      	str	r2, [r3, #44]	; 0x2c
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
    7fca:	687b      	ldr	r3, [r7, #4]
    7fcc:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    7fd0:	2b02      	cmp	r3, #2
    7fd2:	d113      	bne.n	7ffc <mss_spi_isr+0x1e4>
        {
            this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
    7fd4:	687b      	ldr	r3, [r7, #4]
    7fd6:	681a      	ldr	r2, [r3, #0]
    7fd8:	687b      	ldr	r3, [r7, #4]
    7fda:	681b      	ldr	r3, [r3, #0]
    7fdc:	6819      	ldr	r1, [r3, #0]
    7fde:	f240 03ff 	movw	r3, #255	; 0xff
    7fe2:	f6cf 7300 	movt	r3, #65280	; 0xff00
    7fe6:	ea01 0303 	and.w	r3, r1, r3
    7fea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    7fee:	6013      	str	r3, [r2, #0]
                                        | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
    7ff0:	687b      	ldr	r3, [r7, #4]
    7ff2:	681b      	ldr	r3, [r3, #0]
    7ff4:	687a      	ldr	r2, [r7, #4]
    7ff6:	6f92      	ldr	r2, [r2, #120]	; 0x78
    7ff8:	615a      	str	r2, [r3, #20]
    7ffa:	e00b      	b.n	8014 <RAM_SIZE+0x14>
        }
        else if( MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode )
    7ffc:	687b      	ldr	r3, [r7, #4]
    7ffe:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    8002:	2b01      	cmp	r3, #1
    8004:	d106      	bne.n	8014 <RAM_SIZE+0x14>
        {
            /* Block mode so reload FIFO to the max */
            this_spi->slave_tx_idx = 0u;
    8006:	687b      	ldr	r3, [r7, #4]
    8008:	f04f 0200 	mov.w	r2, #0
    800c:	611a      	str	r2, [r3, #16]
            fill_slave_tx_fifo(this_spi);
    800e:	6878      	ldr	r0, [r7, #4]
    8010:	f7ff fe3c 	bl	7c8c <fill_slave_tx_fifo>
        else
        {
            /* Not frame or block mode? Can't do anything here... */
        }

        this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK;
    8014:	687b      	ldr	r3, [r7, #4]
    8016:	681b      	ldr	r3, [r3, #0]
    8018:	f04f 0208 	mov.w	r2, #8
    801c:	60da      	str	r2, [r3, #12]
    /*
     * Handle slave select becoming de-asserted. Only enables if
     * we are operating in block mode, in frame mode we do everything
     * in the receive and transmit interrupt handlers.
     */
    if(0u != (*this_mis & SSEND_IRQ_MASK))
    801e:	693b      	ldr	r3, [r7, #16]
    8020:	681b      	ldr	r3, [r3, #0]
    8022:	f003 0320 	and.w	r3, r3, #32
    8026:	2b00      	cmp	r3, #0
    8028:	d049      	beq.n	80be <RAM_SIZE+0xbe>
    {
        uint32_t rx_size;
        
        read_slave_rx_fifo(this_spi);
    802a:	6878      	ldr	r0, [r7, #4]
    802c:	f7ff fe9e 	bl	7d6c <read_slave_rx_fifo>
        rx_size = this_spi->slave_rx_idx;
    8030:	687b      	ldr	r3, [r7, #4]
    8032:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8034:	617b      	str	r3, [r7, #20]
        /*
         * Re-enable command interrupt if required and clear all the response
         * buffer state in readiness for next response. This must be done
         * before reloading the TX FIFO.
         */
        if(0 != this_spi->cmd_handler)
    8036:	687b      	ldr	r3, [r7, #4]
    8038:	6a1b      	ldr	r3, [r3, #32]
    803a:	2b00      	cmp	r3, #0
    803c:	d01c      	beq.n	8078 <RAM_SIZE+0x78>
        {
            this_spi->cmd_done = 0u;
    803e:	687b      	ldr	r3, [r7, #4]
    8040:	f04f 0200 	mov.w	r2, #0
    8044:	625a      	str	r2, [r3, #36]	; 0x24
            this_spi->resp_tx_buffer = 0u;
    8046:	687b      	ldr	r3, [r7, #4]
    8048:	f04f 0200 	mov.w	r2, #0
    804c:	615a      	str	r2, [r3, #20]
            this_spi->resp_buff_size = 0u;
    804e:	687b      	ldr	r3, [r7, #4]
    8050:	f04f 0200 	mov.w	r2, #0
    8054:	619a      	str	r2, [r3, #24]
            this_spi->resp_buff_tx_idx = 0u;
    8056:	687b      	ldr	r3, [r7, #4]
    8058:	f04f 0200 	mov.w	r2, #0
    805c:	61da      	str	r2, [r3, #28]
            this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
    805e:	687b      	ldr	r3, [r7, #4]
    8060:	681b      	ldr	r3, [r3, #0]
    8062:	f04f 0210 	mov.w	r2, #16
    8066:	60da      	str	r2, [r3, #12]
            this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
    8068:	687b      	ldr	r3, [r7, #4]
    806a:	681b      	ldr	r3, [r3, #0]
    806c:	687a      	ldr	r2, [r7, #4]
    806e:	6812      	ldr	r2, [r2, #0]
    8070:	6a92      	ldr	r2, [r2, #40]	; 0x28
    8072:	f042 0210 	orr.w	r2, r2, #16
    8076:	629a      	str	r2, [r3, #40]	; 0x28
        /* 
         * Reset the transmit index to 0 to restart transmit at the start of the
         * transmit buffer in the next transaction. This also requires flushing
         * the Tx FIFO and refilling it with the start of Tx data buffer.
         */
        this_spi->slave_tx_idx = 0u;
    8078:	687b      	ldr	r3, [r7, #4]
    807a:	f04f 0200 	mov.w	r2, #0
    807e:	611a      	str	r2, [r3, #16]
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
    8080:	687b      	ldr	r3, [r7, #4]
    8082:	681b      	ldr	r3, [r3, #0]
    8084:	687a      	ldr	r2, [r7, #4]
    8086:	6812      	ldr	r2, [r2, #0]
    8088:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    808a:	f042 020c 	orr.w	r2, r2, #12
    808e:	62da      	str	r2, [r3, #44]	; 0x2c
        fill_slave_tx_fifo(this_spi);
    8090:	6878      	ldr	r0, [r7, #4]
    8092:	f7ff fdfb 	bl	7c8c <fill_slave_tx_fifo>
        
        /* Prepare to receive next packet. */
        this_spi->slave_rx_idx = 0u;
    8096:	687b      	ldr	r3, [r7, #4]
    8098:	f04f 0200 	mov.w	r2, #0
    809c:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * Call the receive handler if one exists.
         */
        if(0u != this_spi->block_rx_handler)
    809e:	687b      	ldr	r3, [r7, #4]
    80a0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    80a2:	2b00      	cmp	r3, #0
    80a4:	d006      	beq.n	80b4 <RAM_SIZE+0xb4>
        {
            (*this_spi->block_rx_handler)(this_spi->slave_rx_buffer, rx_size);
    80a6:	687b      	ldr	r3, [r7, #4]
    80a8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    80aa:	687a      	ldr	r2, [r7, #4]
    80ac:	6a92      	ldr	r2, [r2, #40]	; 0x28
    80ae:	4610      	mov	r0, r2
    80b0:	6979      	ldr	r1, [r7, #20]
    80b2:	4798      	blx	r3
        }
        
        this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
    80b4:	687b      	ldr	r3, [r7, #4]
    80b6:	681b      	ldr	r3, [r3, #0]
    80b8:	f04f 0220 	mov.w	r2, #32
    80bc:	60da      	str	r2, [r3, #12]
    }
}
    80be:	f107 0718 	add.w	r7, r7, #24
    80c2:	46bd      	mov	sp, r7
    80c4:	bd80      	pop	{r7, pc}
    80c6:	bf00      	nop

000080c8 <SPI0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI0_IRQHandler(void)
#else
void SPI0_IRQHandler( void )
#endif
{
    80c8:	4668      	mov	r0, sp
    80ca:	f020 0107 	bic.w	r1, r0, #7
    80ce:	468d      	mov	sp, r1
    80d0:	b589      	push	{r0, r3, r7, lr}
    80d2:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi0);
    80d4:	f24c 5084 	movw	r0, #50564	; 0xc584
    80d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    80dc:	f7ff fe9c 	bl	7e18 <mss_spi_isr>
}
    80e0:	46bd      	mov	sp, r7
    80e2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    80e6:	4685      	mov	sp, r0
    80e8:	4770      	bx	lr
    80ea:	bf00      	nop

000080ec <SPI1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI1_IRQHandler(void)
#else
void SPI1_IRQHandler(void)
#endif
{
    80ec:	4668      	mov	r0, sp
    80ee:	f020 0107 	bic.w	r1, r0, #7
    80f2:	468d      	mov	sp, r1
    80f4:	b589      	push	{r0, r3, r7, lr}
    80f6:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi1);
    80f8:	f24c 5000 	movw	r0, #50432	; 0xc500
    80fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    8100:	f7ff fe8a 	bl	7e18 <mss_spi_isr>
}
    8104:	46bd      	mov	sp, r7
    8106:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    810a:	4685      	mov	sp, r0
    810c:	4770      	bx	lr
    810e:	bf00      	nop

00008110 <NVM_write>:
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
    8110:	b580      	push	{r7, lr}
    8112:	b08e      	sub	sp, #56	; 0x38
    8114:	af02      	add	r7, sp, #8
    8116:	60f8      	str	r0, [r7, #12]
    8118:	60b9      	str	r1, [r7, #8]
    811a:	607a      	str	r2, [r7, #4]
    811c:	603b      	str	r3, [r7, #0]
    nvm_status_t status;
    nvm_status_t lock_status = NVM_SUCCESS;
    811e:	f04f 0300 	mov.w	r3, #0
    8122:	75fb      	strb	r3, [r7, #23]
    uint32_t nvm_offset;
    uint32_t device_version;
    uint32_t initial_nvm_config;

    g_do_not_lock_page = OFF;
    8124:	f24b 3398 	movw	r3, #45976	; 0xb398
    8128:	f2c2 0300 	movt	r3, #8192	; 0x2000
    812c:	f04f 0200 	mov.w	r2, #0
    8130:	701a      	strb	r2, [r3, #0]
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    8132:	f248 0300 	movw	r3, #32768	; 0x8000
    8136:	f2c4 0303 	movt	r3, #16387	; 0x4003
    813a:	68db      	ldr	r3, [r3, #12]
    813c:	623b      	str	r3, [r7, #32]
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    813e:	f248 0300 	movw	r3, #32768	; 0x8000
    8142:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8146:	6a3a      	ldr	r2, [r7, #32]
    8148:	f442 52ff 	orr.w	r2, r2, #8160	; 0x1fe0
    814c:	60da      	str	r2, [r3, #12]

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) ||
    814e:	68fa      	ldr	r2, [r7, #12]
    8150:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    8154:	f2c6 0307 	movt	r3, #24583	; 0x6007
    8158:	429a      	cmp	r2, r3
    815a:	d814      	bhi.n	8186 <NVM_write+0x76>
    815c:	68fa      	ldr	r2, [r7, #12]
    815e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    8162:	f2c0 0307 	movt	r3, #7
    8166:	429a      	cmp	r2, r3
    8168:	d904      	bls.n	8174 <NVM_write+0x64>
    816a:	68fa      	ldr	r2, [r7, #12]
    816c:	f06f 4320 	mvn.w	r3, #2684354560	; 0xa0000000
    8170:	429a      	cmp	r2, r3
    8172:	d908      	bls.n	8186 <NVM_write+0x76>
    8174:	68bb      	ldr	r3, [r7, #8]
    8176:	2b00      	cmp	r3, #0
    8178:	d005      	beq.n	8186 <NVM_write+0x76>
    817a:	687b      	ldr	r3, [r7, #4]
    817c:	2b00      	cmp	r3, #0
    817e:	d002      	beq.n	8186 <NVM_write+0x76>
    8180:	683b      	ldr	r3, [r7, #0]
    8182:	2b02      	cmp	r3, #2
    8184:	d903      	bls.n	818e <NVM_write+0x7e>
        (start_addr < NVM_BASE_ADDRESS)) ||
        (0u == pidata) ||
        (0u == length) ||
        (lock_page > PARAM_LOCK_PAGE_FLAG))
    {
        status =  NVM_INVALID_PARAMETER;
    8186:	f04f 0307 	mov.w	r3, #7
    818a:	75bb      	strb	r3, [r7, #22]
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) ||
    818c:	e0c1      	b.n	8312 <NVM_write+0x202>

        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
    818e:	f248 0300 	movw	r3, #32768	; 0x8000
    8192:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8196:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    819a:	61fb      	str	r3, [r7, #28]
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
    819c:	69fa      	ldr	r2, [r7, #28]
    819e:	f64f 0302 	movw	r3, #63490	; 0xf802
    81a2:	429a      	cmp	r2, r3
    81a4:	d006      	beq.n	81b4 <NVM_write+0xa4>
    81a6:	69fa      	ldr	r2, [r7, #28]
    81a8:	f64f 0302 	movw	r3, #63490	; 0xf802
    81ac:	f2c0 0301 	movt	r3, #1
    81b0:	429a      	cmp	r2, r3
    81b2:	d102      	bne.n	81ba <NVM_write+0xaa>
        {
            lock_page = NVM_DO_NOT_LOCK_PAGE;
    81b4:	f04f 0300 	mov.w	r3, #0
    81b8:	603b      	str	r3, [r7, #0]
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  
    81ba:	68fb      	ldr	r3, [r7, #12]
    81bc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    81c0:	f423 0378 	bic.w	r3, r3, #16252928	; 0xf80000
    81c4:	61bb      	str	r3, [r7, #24]
        
        /* 
         * SAR 70908.
         * Check nvm offset is in protection or reserved area of eNVM
         */
        status = check_protection_reserved_nvm(nvm_offset, length);
    81c6:	69b8      	ldr	r0, [r7, #24]
    81c8:	6879      	ldr	r1, [r7, #4]
    81ca:	f000 fb5b 	bl	8884 <check_protection_reserved_nvm>
    81ce:	4603      	mov	r3, r0
    81d0:	75bb      	strb	r3, [r7, #22]

        if(NVM_SUCCESS == status)
    81d2:	7dbb      	ldrb	r3, [r7, #22]
    81d4:	2b00      	cmp	r3, #0
    81d6:	f040 809c 	bne.w	8312 <NVM_write+0x202>
        {
            /* 
             * SAR 79545. 
             * If eNVM write or No R/W protected is enabled, then don't lock the page
             */
            if((g_do_not_lock_page == ON)  && (NVM_LOCK_PAGE == lock_page)) 
    81da:	f24b 3398 	movw	r3, #45976	; 0xb398
    81de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    81e2:	781b      	ldrb	r3, [r3, #0]
    81e4:	2b01      	cmp	r3, #1
    81e6:	d108      	bne.n	81fa <NVM_write+0xea>
    81e8:	683b      	ldr	r3, [r7, #0]
    81ea:	2b01      	cmp	r3, #1
    81ec:	d105      	bne.n	81fa <NVM_write+0xea>
            {
                lock_page = NVM_DO_NOT_LOCK_PAGE;
    81ee:	f04f 0300 	mov.w	r3, #0
    81f2:	603b      	str	r3, [r7, #0]
                lock_status = NVM_PAGE_LOCK_WARNING;
    81f4:	f04f 0304 	mov.w	r3, #4
    81f8:	75fb      	strb	r3, [r7, #23]
            }
            
            device_version = device_version & 0xFFFFu;
    81fa:	69fb      	ldr	r3, [r7, #28]
    81fc:	ea4f 4303 	mov.w	r3, r3, lsl #16
    8200:	ea4f 4313 	mov.w	r3, r3, lsr #16
    8204:	61fb      	str	r3, [r7, #28]
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
    8206:	69fa      	ldr	r2, [r7, #28]
    8208:	f64f 0307 	movw	r3, #63495	; 0xf807
    820c:	429a      	cmp	r2, r3
    820e:	d004      	beq.n	821a <NVM_write+0x10a>
    8210:	69fa      	ldr	r2, [r7, #28]
    8212:	f64f 0306 	movw	r3, #63494	; 0xf806
    8216:	429a      	cmp	r2, r3
    8218:	d116      	bne.n	8248 <NVM_write+0x138>
            {
                if(((nvm_offset >= NVM1_BOTTOM_OFFSET) || ((nvm_offset + length) > NVM1_BOTTOM_OFFSET))
    821a:	69ba      	ldr	r2, [r7, #24]
    821c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8220:	f2c0 0303 	movt	r3, #3
    8224:	429a      	cmp	r2, r3
    8226:	d805      	bhi.n	8234 <NVM_write+0x124>
    8228:	69ba      	ldr	r2, [r7, #24]
    822a:	687b      	ldr	r3, [r7, #4]
    822c:	4413      	add	r3, r2
    822e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    8232:	d918      	bls.n	8266 <NVM_write+0x156>
    8234:	683b      	ldr	r3, [r7, #0]
    8236:	2b01      	cmp	r3, #1
    8238:	d117      	bne.n	826a <NVM_write+0x15a>
                            && (NVM_LOCK_PAGE == lock_page)) 
                {
                    lock_page = NVM_DO_NOT_LOCK_PAGE;
    823a:	f04f 0300 	mov.w	r3, #0
    823e:	603b      	str	r3, [r7, #0]
                    lock_status = NVM_PAGE_LOCK_WARNING;
    8240:	f04f 0304 	mov.w	r3, #4
    8244:	75fb      	strb	r3, [r7, #23]
            }
            
            device_version = device_version & 0xFFFFu;
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
    8246:	e011      	b.n	826c <NVM_write+0x15c>
                    lock_page = NVM_DO_NOT_LOCK_PAGE;
                    lock_status = NVM_PAGE_LOCK_WARNING;
                }
            }
            /* Don't lock pages of 060 device */
            else if((0xF808u == device_version) && (NVM_LOCK_PAGE == lock_page)) 
    8248:	69fa      	ldr	r2, [r7, #28]
    824a:	f64f 0308 	movw	r3, #63496	; 0xf808
    824e:	429a      	cmp	r2, r3
    8250:	d10c      	bne.n	826c <NVM_write+0x15c>
    8252:	683b      	ldr	r3, [r7, #0]
    8254:	2b01      	cmp	r3, #1
    8256:	d109      	bne.n	826c <NVM_write+0x15c>
            {
                lock_page = NVM_DO_NOT_LOCK_PAGE;
    8258:	f04f 0300 	mov.w	r3, #0
    825c:	603b      	str	r3, [r7, #0]
                lock_status = NVM_PAGE_LOCK_WARNING;
    825e:	f04f 0304 	mov.w	r3, #4
    8262:	75fb      	strb	r3, [r7, #23]
    8264:	e002      	b.n	826c <NVM_write+0x15c>
            }
            
            device_version = device_version & 0xFFFFu;
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
    8266:	bf00      	nop
    8268:	e000      	b.n	826c <NVM_write+0x15c>
    826a:	bf00      	nop
                lock_page = NVM_DO_NOT_LOCK_PAGE;
                lock_status = NVM_PAGE_LOCK_WARNING;
            }
            
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);
    826c:	69b8      	ldr	r0, [r7, #24]
    826e:	6879      	ldr	r1, [r7, #4]
    8270:	f000 f8f0 	bl	8454 <get_ctrl_access>
    8274:	4603      	mov	r3, r0
    8276:	75bb      	strb	r3, [r7, #22]

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    8278:	7dbb      	ldrb	r3, [r7, #22]
    827a:	2b00      	cmp	r3, #0
    827c:	d149      	bne.n	8312 <NVM_write+0x202>
            {
                uint32_t remaining_length = length;
    827e:	687b      	ldr	r3, [r7, #4]
    8280:	627b      	str	r3, [r7, #36]	; 0x24
                uint32_t errors_and_warnings;
                
                while(remaining_length > 0u)
    8282:	e041      	b.n	8308 <NVM_write+0x1f8>
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;
    8284:	f04f 0300 	mov.w	r3, #0
    8288:	613b      	str	r3, [r7, #16]

                    length_written = write_nvm(start_addr + (length - remaining_length),
    828a:	687a      	ldr	r2, [r7, #4]
    828c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    828e:	ebc3 0202 	rsb	r2, r3, r2
    8292:	68fb      	ldr	r3, [r7, #12]
    8294:	441a      	add	r2, r3
                                                &pidata[length - remaining_length],
    8296:	6879      	ldr	r1, [r7, #4]
    8298:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    829a:	ebc3 0101 	rsb	r1, r3, r1
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    829e:	68bb      	ldr	r3, [r7, #8]
    82a0:	440b      	add	r3, r1
    82a2:	f107 0110 	add.w	r1, r7, #16
    82a6:	9100      	str	r1, [sp, #0]
    82a8:	4610      	mov	r0, r2
    82aa:	4619      	mov	r1, r3
    82ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    82ae:	683b      	ldr	r3, [r7, #0]
    82b0:	f000 f982 	bl	85b8 <write_nvm>
    82b4:	4603      	mov	r3, r0
    82b6:	62fb      	str	r3, [r7, #44]	; 0x2c
                                                remaining_length,
                                                lock_page,
                                                &nvm_hw_status);

                    /* Check for errors and warnings. */
                    errors_and_warnings = nvm_hw_status & (WRITE_ERROR_MASK | MSS_NVM_WRCNT_OVER);
    82b8:	693a      	ldr	r2, [r7, #16]
    82ba:	f240 033e 	movw	r3, #62	; 0x3e
    82be:	f2c0 0304 	movt	r3, #4
    82c2:	ea02 0303 	and.w	r3, r2, r3
    82c6:	62bb      	str	r3, [r7, #40]	; 0x28
                    if(errors_and_warnings)
    82c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    82ca:	2b00      	cmp	r3, #0
    82cc:	d005      	beq.n	82da <NVM_write+0x1ca>
                        * Ensure that the status returned by the NVM_write()
                        * function is NVM_WRITE_THRESHOLD_WARNING if at least one
                        * of the written eNVM pages indicate a write over
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
    82ce:	693b      	ldr	r3, [r7, #16]
    82d0:	4618      	mov	r0, r3
    82d2:	f000 f839 	bl	8348 <get_error_code>
    82d6:	4603      	mov	r3, r0
    82d8:	75bb      	strb	r3, [r7, #22]
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
    82da:	7dbb      	ldrb	r3, [r7, #22]
    82dc:	2b00      	cmp	r3, #0
    82de:	d002      	beq.n	82e6 <NVM_write+0x1d6>
    82e0:	7dbb      	ldrb	r3, [r7, #22]
    82e2:	2b05      	cmp	r3, #5
    82e4:	d10d      	bne.n	8302 <NVM_write+0x1f2>
                    {
                        if(remaining_length > length_written)
    82e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    82e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    82ea:	429a      	cmp	r2, r3
    82ec:	d905      	bls.n	82fa <NVM_write+0x1ea>
                        {
                            remaining_length -= length_written;
    82ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    82f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    82f2:	ebc3 0302 	rsb	r3, r3, r2
    82f6:	627b      	str	r3, [r7, #36]	; 0x24
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
    82f8:	e006      	b.n	8308 <NVM_write+0x1f8>
                        {
                            remaining_length -= length_written;
                        }
                        else
                        {
                            remaining_length = 0u;
    82fa:	f04f 0300 	mov.w	r3, #0
    82fe:	627b      	str	r3, [r7, #36]	; 0x24
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
    8300:	e002      	b.n	8308 <NVM_write+0x1f8>
                            remaining_length = 0u;
                        }
                    }
                    else
                    {
                        remaining_length = 0u;
    8302:	f04f 0300 	mov.w	r3, #0
    8306:	627b      	str	r3, [r7, #36]	; 0x24
            if(NVM_SUCCESS == status)
            {
                uint32_t remaining_length = length;
                uint32_t errors_and_warnings;
                
                while(remaining_length > 0u)
    8308:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    830a:	2b00      	cmp	r3, #0
    830c:	d1ba      	bne.n	8284 <NVM_write+0x174>
                    }

                }

                /* Release eNVM controllers so that other masters can gain access to it. */
                release_ctrl_access();
    830e:	f000 f8e1 	bl	84d4 <release_ctrl_access>
            }
        }
    }

    g_do_not_lock_page = OFF;
    8312:	f24b 3398 	movw	r3, #45976	; 0xb398
    8316:	f2c2 0300 	movt	r3, #8192	; 0x2000
    831a:	f04f 0200 	mov.w	r2, #0
    831e:	701a      	strb	r2, [r3, #0]

    /* Restore back to original value. */
    SYSREG->ENVM_CR = initial_nvm_config;
    8320:	f248 0300 	movw	r3, #32768	; 0x8000
    8324:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8328:	6a3a      	ldr	r2, [r7, #32]
    832a:	60da      	str	r2, [r3, #12]
    
    if((NVM_SUCCESS == status) && (NVM_PAGE_LOCK_WARNING == lock_status))
    832c:	7dbb      	ldrb	r3, [r7, #22]
    832e:	2b00      	cmp	r3, #0
    8330:	d104      	bne.n	833c <NVM_write+0x22c>
    8332:	7dfb      	ldrb	r3, [r7, #23]
    8334:	2b04      	cmp	r3, #4
    8336:	d101      	bne.n	833c <NVM_write+0x22c>
    {
        status = lock_status;
    8338:	7dfb      	ldrb	r3, [r7, #23]
    833a:	75bb      	strb	r3, [r7, #22]
    }
    return status;
    833c:	7dbb      	ldrb	r3, [r7, #22]
}
    833e:	4618      	mov	r0, r3
    8340:	f107 0730 	add.w	r7, r7, #48	; 0x30
    8344:	46bd      	mov	sp, r7
    8346:	bd80      	pop	{r7, pc}

00008348 <get_error_code>:
                 MSS_NVM_WRCNT_OVER | \
                 MSS_NVM_WR_DENIED)
  
 */
static nvm_status_t get_error_code(uint32_t nvm_hw_status)
{
    8348:	b480      	push	{r7}
    834a:	b085      	sub	sp, #20
    834c:	af00      	add	r7, sp, #0
    834e:	6078      	str	r0, [r7, #4]
    nvm_status_t status;
    
    if(nvm_hw_status & MSS_NVM_WR_DENIED)
    8350:	687b      	ldr	r3, [r7, #4]
    8352:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    8356:	2b00      	cmp	r3, #0
    8358:	d003      	beq.n	8362 <get_error_code+0x1a>
    {
        status = NVM_PROTECTION_ERROR;
    835a:	f04f 0301 	mov.w	r3, #1
    835e:	73fb      	strb	r3, [r7, #15]
    8360:	e01d      	b.n	839e <get_error_code+0x56>
    }
    else if(nvm_hw_status & MSS_NVM_PEFAIL_LOCK)
    8362:	687b      	ldr	r3, [r7, #4]
    8364:	f003 0310 	and.w	r3, r3, #16
    8368:	2b00      	cmp	r3, #0
    836a:	d003      	beq.n	8374 <get_error_code+0x2c>
    {
        status = NVM_PAGE_LOCK_ERROR;
    836c:	f04f 0303 	mov.w	r3, #3
    8370:	73fb      	strb	r3, [r7, #15]
    8372:	e014      	b.n	839e <get_error_code+0x56>
    }
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
    8374:	687b      	ldr	r3, [r7, #4]
    8376:	f003 030e 	and.w	r3, r3, #14
    837a:	2b00      	cmp	r3, #0
    837c:	d003      	beq.n	8386 <get_error_code+0x3e>
            MSS_NVM_EVERIFY_FAIL | MSS_NVM_WVERIFY_FAIL))
    {
        status = NVM_VERIFY_FAILURE;
    837e:	f04f 0302 	mov.w	r3, #2
    8382:	73fb      	strb	r3, [r7, #15]
    8384:	e00b      	b.n	839e <get_error_code+0x56>
    }
    else if(nvm_hw_status & MSS_NVM_WRCNT_OVER)
    8386:	687b      	ldr	r3, [r7, #4]
    8388:	f003 0320 	and.w	r3, r3, #32
    838c:	2b00      	cmp	r3, #0
    838e:	d003      	beq.n	8398 <get_error_code+0x50>
    {
        status = NVM_WRITE_THRESHOLD_WARNING;
    8390:	f04f 0305 	mov.w	r3, #5
    8394:	73fb      	strb	r3, [r7, #15]
    8396:	e002      	b.n	839e <get_error_code+0x56>
    }
    else
    {
        status = NVM_SUCCESS;
    8398:	f04f 0300 	mov.w	r3, #0
    839c:	73fb      	strb	r3, [r7, #15]
    }
    
    return status;
    839e:	7bfb      	ldrb	r3, [r7, #15]
}
    83a0:	4618      	mov	r0, r3
    83a2:	f107 0714 	add.w	r7, r7, #20
    83a6:	46bd      	mov	sp, r7
    83a8:	bc80      	pop	{r7}
    83aa:	4770      	bx	lr

000083ac <request_nvm_access>:
#define CORTEX_M3_ACCESS_GRANTED    0x05u

static uint8_t g_envm_ctrl_locks = 0x00u;

static nvm_status_t request_nvm_access(uint32_t nvm_block_id)
{
    83ac:	b480      	push	{r7}
    83ae:	b087      	sub	sp, #28
    83b0:	af00      	add	r7, sp, #0
    83b2:	6078      	str	r0, [r7, #4]
    nvm_status_t status = NVM_SUCCESS;
    83b4:	f04f 0300 	mov.w	r3, #0
    83b8:	74fb      	strb	r3, [r7, #19]
    
    /*
     * Use the SystemCoreClock frequency to compute a delay counter value giving
     * us a delay in the 500ms range. This is a very approximate delay.
     */
    timeout_counter = SystemCoreClock / 16u;
    83ba:	f24b 332c 	movw	r3, #45868	; 0xb32c
    83be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83c2:	681b      	ldr	r3, [r3, #0]
    83c4:	ea4f 1313 	mov.w	r3, r3, lsr #4
    83c8:	60fb      	str	r3, [r7, #12]
    
    /*
     * Gain access to eNVM controller.
     */
    do {
        g_nvm[nvm_block_id]->REQ_ACCESS = REQUEST_NVM_ACCESS;
    83ca:	687a      	ldr	r2, [r7, #4]
    83cc:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    83d0:	f2c0 0300 	movt	r3, #0
    83d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    83d8:	f04f 0201 	mov.w	r2, #1
    83dc:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        access = g_nvm[nvm_block_id]->REQ_ACCESS;
    83e0:	687a      	ldr	r2, [r7, #4]
    83e2:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    83e6:	f2c0 0300 	movt	r3, #0
    83ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    83ee:	f8d3 31fc 	ldr.w	r3, [r3, #508]	; 0x1fc
    83f2:	617b      	str	r3, [r7, #20]
        if(access != CORTEX_M3_ACCESS_GRANTED)
    83f4:	697b      	ldr	r3, [r7, #20]
    83f6:	2b05      	cmp	r3, #5
    83f8:	d009      	beq.n	840e <request_nvm_access+0x62>
            /*
             * Time out if another AHB master locked access to eNVM to prevent
             * the Cortex-M3 from locking up on eNVM write if some other part
             * of the system fails from releasing the eNVM.
             */
            --timeout_counter;
    83fa:	68fb      	ldr	r3, [r7, #12]
    83fc:	f103 33ff 	add.w	r3, r3, #4294967295
    8400:	60fb      	str	r3, [r7, #12]
            if(0u == timeout_counter)
    8402:	68fb      	ldr	r3, [r7, #12]
    8404:	2b00      	cmp	r3, #0
    8406:	d102      	bne.n	840e <request_nvm_access+0x62>
            {
                status = NVM_IN_USE_BY_OTHER_MASTER;
    8408:	f04f 0306 	mov.w	r3, #6
    840c:	74fb      	strb	r3, [r7, #19]
            }
        }
    } while((access != CORTEX_M3_ACCESS_GRANTED) && (NVM_SUCCESS == status));
    840e:	697b      	ldr	r3, [r7, #20]
    8410:	2b05      	cmp	r3, #5
    8412:	d002      	beq.n	841a <request_nvm_access+0x6e>
    8414:	7cfb      	ldrb	r3, [r7, #19]
    8416:	2b00      	cmp	r3, #0
    8418:	d0d7      	beq.n	83ca <request_nvm_access+0x1e>
    
    /*
     * Mark controller as locked if successful so that it will be unlocked by a
     * call to release_ctrl_access.
     */
    if(NVM_SUCCESS == status)
    841a:	7cfb      	ldrb	r3, [r7, #19]
    841c:	2b00      	cmp	r3, #0
    841e:	d112      	bne.n	8446 <request_nvm_access+0x9a>
    {
        g_envm_ctrl_locks |= (uint8_t)((uint32_t)0x01 << nvm_block_id);
    8420:	687b      	ldr	r3, [r7, #4]
    8422:	f04f 0201 	mov.w	r2, #1
    8426:	fa02 f303 	lsl.w	r3, r2, r3
    842a:	b2da      	uxtb	r2, r3
    842c:	f24b 3399 	movw	r3, #45977	; 0xb399
    8430:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8434:	781b      	ldrb	r3, [r3, #0]
    8436:	ea42 0303 	orr.w	r3, r2, r3
    843a:	b2da      	uxtb	r2, r3
    843c:	f24b 3399 	movw	r3, #45977	; 0xb399
    8440:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8444:	701a      	strb	r2, [r3, #0]
    }
    
    return status;
    8446:	7cfb      	ldrb	r3, [r7, #19]
}
    8448:	4618      	mov	r0, r3
    844a:	f107 071c 	add.w	r7, r7, #28
    844e:	46bd      	mov	sp, r7
    8450:	bc80      	pop	{r7}
    8452:	4770      	bx	lr

00008454 <get_ctrl_access>:

/**************************************************************************//**
 * Get access to eNVM controller for eNVM0 and eNVM1
 */
static nvm_status_t get_ctrl_access(uint32_t nvm_offset, uint32_t length)
{
    8454:	b580      	push	{r7, lr}
    8456:	b084      	sub	sp, #16
    8458:	af00      	add	r7, sp, #0
    845a:	6078      	str	r0, [r7, #4]
    845c:	6039      	str	r1, [r7, #0]
    nvm_status_t access_req_status;
    
    /*
     * Gain access to eNVM controller(s).
     */
    if(nvm_offset < NVM1_BOTTOM_OFFSET)
    845e:	687a      	ldr	r2, [r7, #4]
    8460:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8464:	f2c0 0303 	movt	r3, #3
    8468:	429a      	cmp	r2, r3
    846a:	d821      	bhi.n	84b0 <get_ctrl_access+0x5c>
    {
        access_req_status = request_nvm_access(NVM_BLOCK_0);
    846c:	f04f 0000 	mov.w	r0, #0
    8470:	f7ff ff9c 	bl	83ac <request_nvm_access>
    8474:	4603      	mov	r3, r0
    8476:	72fb      	strb	r3, [r7, #11]
        if(NVM_SUCCESS == access_req_status)
    8478:	7afb      	ldrb	r3, [r7, #11]
    847a:	2b00      	cmp	r3, #0
    847c:	d11f      	bne.n	84be <get_ctrl_access+0x6a>
        {
            uint32_t last_offset;
            last_offset = nvm_offset + (length - 0x1u);
    847e:	683a      	ldr	r2, [r7, #0]
    8480:	687b      	ldr	r3, [r7, #4]
    8482:	4413      	add	r3, r2
    8484:	f103 33ff 	add.w	r3, r3, #4294967295
    8488:	60fb      	str	r3, [r7, #12]
            if(last_offset >= NVM1_BOTTOM_OFFSET)
    848a:	68fa      	ldr	r2, [r7, #12]
    848c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8490:	f2c0 0303 	movt	r3, #3
    8494:	429a      	cmp	r2, r3
    8496:	d914      	bls.n	84c2 <get_ctrl_access+0x6e>
            {
                access_req_status = request_nvm_access(NVM_BLOCK_1);
    8498:	f04f 0001 	mov.w	r0, #1
    849c:	f7ff ff86 	bl	83ac <request_nvm_access>
    84a0:	4603      	mov	r3, r0
    84a2:	72fb      	strb	r3, [r7, #11]
                if(NVM_IN_USE_BY_OTHER_MASTER == access_req_status)
    84a4:	7afb      	ldrb	r3, [r7, #11]
    84a6:	2b06      	cmp	r3, #6
    84a8:	d10d      	bne.n	84c6 <get_ctrl_access+0x72>
                {
                    release_ctrl_access();
    84aa:	f000 f813 	bl	84d4 <release_ctrl_access>
    84ae:	e00b      	b.n	84c8 <get_ctrl_access+0x74>
            }
        }
    }
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    84b0:	f04f 0001 	mov.w	r0, #1
    84b4:	f7ff ff7a 	bl	83ac <request_nvm_access>
    84b8:	4603      	mov	r3, r0
    84ba:	72fb      	strb	r3, [r7, #11]
    84bc:	e004      	b.n	84c8 <get_ctrl_access+0x74>
            if(last_offset >= NVM1_BOTTOM_OFFSET)
            {
                access_req_status = request_nvm_access(NVM_BLOCK_1);
                if(NVM_IN_USE_BY_OTHER_MASTER == access_req_status)
                {
                    release_ctrl_access();
    84be:	bf00      	nop
    84c0:	e002      	b.n	84c8 <get_ctrl_access+0x74>
    84c2:	bf00      	nop
    84c4:	e000      	b.n	84c8 <get_ctrl_access+0x74>
    84c6:	bf00      	nop
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    }
    
    return access_req_status;
    84c8:	7afb      	ldrb	r3, [r7, #11]
}
    84ca:	4618      	mov	r0, r3
    84cc:	f107 0710 	add.w	r7, r7, #16
    84d0:	46bd      	mov	sp, r7
    84d2:	bd80      	pop	{r7, pc}

000084d4 <release_ctrl_access>:
 */
#define NVM_BLOCK_0_LOCK_MASK   0x01u
#define NVM_BLOCK_1_LOCK_MASK   0x02u

static void release_ctrl_access(void)
{
    84d4:	b480      	push	{r7}
    84d6:	b083      	sub	sp, #12
    84d8:	af00      	add	r7, sp, #0
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    84da:	f24b 3399 	movw	r3, #45977	; 0xb399
    84de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    84e2:	781b      	ldrb	r3, [r3, #0]
    84e4:	f003 0301 	and.w	r3, r3, #1
    84e8:	71fb      	strb	r3, [r7, #7]
    if(block_locked)
    84ea:	79fb      	ldrb	r3, [r7, #7]
    84ec:	2b00      	cmp	r3, #0
    84ee:	d015      	beq.n	851c <release_ctrl_access+0x48>
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    84f0:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    84f4:	f2c0 0300 	movt	r3, #0
    84f8:	681b      	ldr	r3, [r3, #0]
    84fa:	f04f 0200 	mov.w	r2, #0
    84fe:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    8502:	f24b 3399 	movw	r3, #45977	; 0xb399
    8506:	f2c2 0300 	movt	r3, #8192	; 0x2000
    850a:	781b      	ldrb	r3, [r3, #0]
    850c:	461a      	mov	r2, r3
    850e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    8512:	f24b 3399 	movw	r3, #45977	; 0xb399
    8516:	f2c2 0300 	movt	r3, #8192	; 0x2000
    851a:	701a      	strb	r2, [r3, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    851c:	f24b 3399 	movw	r3, #45977	; 0xb399
    8520:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8524:	781b      	ldrb	r3, [r3, #0]
    8526:	f003 0302 	and.w	r3, r3, #2
    852a:	71fb      	strb	r3, [r7, #7]
    if(block_locked)
    852c:	79fb      	ldrb	r3, [r7, #7]
    852e:	2b00      	cmp	r3, #0
    8530:	d015      	beq.n	855e <release_ctrl_access+0x8a>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    8532:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    8536:	f2c0 0300 	movt	r3, #0
    853a:	685b      	ldr	r3, [r3, #4]
    853c:	f04f 0200 	mov.w	r2, #0
    8540:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    8544:	f24b 3399 	movw	r3, #45977	; 0xb399
    8548:	f2c2 0300 	movt	r3, #8192	; 0x2000
    854c:	781b      	ldrb	r3, [r3, #0]
    854e:	461a      	mov	r2, r3
    8550:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    8554:	f24b 3399 	movw	r3, #45977	; 0xb399
    8558:	f2c2 0300 	movt	r3, #8192	; 0x2000
    855c:	701a      	strb	r2, [r3, #0]
    }
}
    855e:	f107 070c 	add.w	r7, r7, #12
    8562:	46bd      	mov	sp, r7
    8564:	bc80      	pop	{r7}
    8566:	4770      	bx	lr

00008568 <wait_nvm_ready>:

/**************************************************************************//**
 * Wait for NVM to become ready from busy state
 */
static uint32_t wait_nvm_ready(uint32_t block) 
{
    8568:	b480      	push	{r7}
    856a:	b087      	sub	sp, #28
    856c:	af00      	add	r7, sp, #0
    856e:	6078      	str	r0, [r7, #4]
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    8570:	f04f 0300 	mov.w	r3, #0
    8574:	617b      	str	r3, [r7, #20]
    8576:	e014      	b.n	85a2 <wait_nvm_ready+0x3a>
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
    8578:	687a      	ldr	r2, [r7, #4]
    857a:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    857e:	f2c0 0300 	movt	r3, #0
    8582:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8586:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
    858a:	60fb      	str	r3, [r7, #12]
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
    858c:	68fb      	ldr	r3, [r7, #12]
    858e:	f003 0301 	and.w	r3, r3, #1
    8592:	613b      	str	r3, [r7, #16]
        } while(0u == ctrl_ready);
    8594:	693b      	ldr	r3, [r7, #16]
    8596:	2b00      	cmp	r3, #0
    8598:	d0ee      	beq.n	8578 <wait_nvm_ready+0x10>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    859a:	697b      	ldr	r3, [r7, #20]
    859c:	f103 0301 	add.w	r3, r3, #1
    85a0:	617b      	str	r3, [r7, #20]
    85a2:	697b      	ldr	r3, [r7, #20]
    85a4:	2b01      	cmp	r3, #1
    85a6:	d9e7      	bls.n	8578 <wait_nvm_ready+0x10>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
    85a8:	68fb      	ldr	r3, [r7, #12]
}
    85aa:	4618      	mov	r0, r3
    85ac:	f107 071c 	add.w	r7, r7, #28
    85b0:	46bd      	mov	sp, r7
    85b2:	bc80      	pop	{r7}
    85b4:	4770      	bx	lr
    85b6:	bf00      	nop

000085b8 <write_nvm>:
    const uint8_t * pidata,
    uint32_t  length,
    uint32_t  lock_page,
    uint32_t * p_status
)
{
    85b8:	b580      	push	{r7, lr}
    85ba:	b08a      	sub	sp, #40	; 0x28
    85bc:	af00      	add	r7, sp, #0
    85be:	60f8      	str	r0, [r7, #12]
    85c0:	60b9      	str	r1, [r7, #8]
    85c2:	607a      	str	r2, [r7, #4]
    85c4:	603b      	str	r3, [r7, #0]
    uint32_t length_written;
    uint32_t offset;
   
    *p_status = 0u;
    85c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    85c8:	f04f 0200 	mov.w	r2, #0
    85cc:	601a      	str	r2, [r3, #0]
    
    /* Ignore upper address bits to ignore remapping setting. */    
    offset = addr & NVM_OFFSET_SIGNIFICANT_BITS;
    85ce:	68fb      	ldr	r3, [r7, #12]
    85d0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    85d4:	f423 0378 	bic.w	r3, r3, #16252928	; 0xf80000
    85d8:	61fb      	str	r3, [r7, #28]
    
    ASSERT(offset <= NVM1_TOP_OFFSET);
    85da:	69fa      	ldr	r2, [r7, #28]
    85dc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    85e0:	f2c0 0307 	movt	r3, #7
    85e4:	429a      	cmp	r2, r3
    85e6:	d900      	bls.n	85ea <write_nvm+0x32>
    85e8:	be00      	bkpt	0x0000
    
    /* Adjust length to fit within one page. */
    length_written = get_remaining_page_length(offset, length);
    85ea:	69f8      	ldr	r0, [r7, #28]
    85ec:	6879      	ldr	r1, [r7, #4]
    85ee:	f000 f88f 	bl	8710 <get_remaining_page_length>
    85f2:	4603      	mov	r3, r0
    85f4:	61bb      	str	r3, [r7, #24]
    
    if(offset <= NVM1_TOP_OFFSET)
    85f6:	69fa      	ldr	r2, [r7, #28]
    85f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    85fc:	f2c0 0307 	movt	r3, #7
    8600:	429a      	cmp	r2, r3
    8602:	d87e      	bhi.n	8702 <write_nvm+0x14a>
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    8604:	69fa      	ldr	r2, [r7, #28]
    8606:	f64f 73ff 	movw	r3, #65535	; 0xffff
    860a:	f2c0 0303 	movt	r3, #3
    860e:	429a      	cmp	r2, r3
    8610:	d803      	bhi.n	861a <write_nvm+0x62>
        {
            block = NVM_BLOCK_0;
    8612:	f04f 0300 	mov.w	r3, #0
    8616:	623b      	str	r3, [r7, #32]
    8618:	e006      	b.n	8628 <write_nvm+0x70>
        }
        else
        {
            block = NVM_BLOCK_1;
    861a:	f04f 0301 	mov.w	r3, #1
    861e:	623b      	str	r3, [r7, #32]
            offset = offset - NVM1_BOTTOM_OFFSET;
    8620:	69fb      	ldr	r3, [r7, #28]
    8622:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
    8626:	61fb      	str	r3, [r7, #28]
        }
        
        if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    8628:	6a3a      	ldr	r2, [r7, #32]
    862a:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    862e:	f2c0 0300 	movt	r3, #0
    8632:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8636:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
    863a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    863e:	2b00      	cmp	r3, #0
    8640:	d013      	beq.n	866a <write_nvm+0xb2>
        {
            /* Clear the access denied flag */
            g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
    8642:	6a3a      	ldr	r2, [r7, #32]
    8644:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    8648:	f2c0 0300 	movt	r3, #0
    864c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    8650:	6a39      	ldr	r1, [r7, #32]
    8652:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    8656:	f2c0 0300 	movt	r3, #0
    865a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    865e:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
    8662:	f043 0302 	orr.w	r3, r3, #2
    8666:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
        }

        fill_wd_buffer(pidata, length_written, block, offset);
    866a:	68b8      	ldr	r0, [r7, #8]
    866c:	69b9      	ldr	r1, [r7, #24]
    866e:	6a3a      	ldr	r2, [r7, #32]
    8670:	69fb      	ldr	r3, [r7, #28]
    8672:	f000 f86f 	bl	8754 <fill_wd_buffer>

        /* Set requested locking option. */
        g_nvm[block]->PAGE_LOCK = lock_page;
    8676:	6a3a      	ldr	r2, [r7, #32]
    8678:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    867c:	f2c0 0300 	movt	r3, #0
    8680:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8684:	683a      	ldr	r2, [r7, #0]
    8686:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
    868a:	6a3a      	ldr	r2, [r7, #32]
    868c:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    8690:	f2c0 0300 	movt	r3, #0
    8694:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    8698:	69fb      	ldr	r3, [r7, #28]
    869a:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
    869e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    86a2:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    86a6:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
        
        /* Wait for NVM to become ready. */
        ctrl_status = wait_nvm_ready(block);
    86aa:	6a38      	ldr	r0, [r7, #32]
    86ac:	f7ff ff5c 	bl	8568 <wait_nvm_ready>
    86b0:	4603      	mov	r3, r0
    86b2:	617b      	str	r3, [r7, #20]

        /* Check for errors. */
        errors = ctrl_status & WRITE_ERROR_MASK;
    86b4:	697a      	ldr	r2, [r7, #20]
    86b6:	f240 031e 	movw	r3, #30
    86ba:	f2c0 0304 	movt	r3, #4
    86be:	ea02 0303 	and.w	r3, r2, r3
    86c2:	627b      	str	r3, [r7, #36]	; 0x24
        if(errors)
    86c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    86c6:	2b00      	cmp	r3, #0
    86c8:	d003      	beq.n	86d2 <write_nvm+0x11a>
        {
            *p_status = ctrl_status;
    86ca:	697a      	ldr	r2, [r7, #20]
    86cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    86ce:	601a      	str	r2, [r3, #0]
    86d0:	e017      	b.n	8702 <write_nvm+0x14a>
        }
        else
        {
            /* Perform a verify. */
            g_nvm[block]->CMD = VERIFY_ADS | (offset & PAGE_ADDR_MASK);
    86d2:	6a3a      	ldr	r2, [r7, #32]
    86d4:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    86d8:	f2c0 0300 	movt	r3, #0
    86dc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    86e0:	69fb      	ldr	r3, [r7, #28]
    86e2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    86e6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    86ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    86ee:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
            /* Wait for NVM to become ready. */
            ctrl_status = wait_nvm_ready(block);
    86f2:	6a38      	ldr	r0, [r7, #32]
    86f4:	f7ff ff38 	bl	8568 <wait_nvm_ready>
    86f8:	4603      	mov	r3, r0
    86fa:	617b      	str	r3, [r7, #20]

            *p_status = ctrl_status;
    86fc:	697a      	ldr	r2, [r7, #20]
    86fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8700:	601a      	str	r2, [r3, #0]
        }
    }
    
    return length_written;
    8702:	69bb      	ldr	r3, [r7, #24]
}
    8704:	4618      	mov	r0, r3
    8706:	f107 0728 	add.w	r7, r7, #40	; 0x28
    870a:	46bd      	mov	sp, r7
    870c:	bd80      	pop	{r7, pc}
    870e:	bf00      	nop

00008710 <get_remaining_page_length>:
  indicates that the WD[] buffer will have to be seeded with the existing
  content of the eNVM before copying the data to program to eNVM into the WD[]
  buffer.
 */
static uint32_t get_remaining_page_length(uint32_t offset, uint32_t length)
{
    8710:	b480      	push	{r7}
    8712:	b085      	sub	sp, #20
    8714:	af00      	add	r7, sp, #0
    8716:	6078      	str	r0, [r7, #4]
    8718:	6039      	str	r1, [r7, #0]
    uint32_t start_page_plus_one;
    uint32_t last_page;
    
    start_page_plus_one = (offset / BYTES_PER_PAGE) + 1u;
    871a:	687b      	ldr	r3, [r7, #4]
    871c:	ea4f 13d3 	mov.w	r3, r3, lsr #7
    8720:	f103 0301 	add.w	r3, r3, #1
    8724:	60bb      	str	r3, [r7, #8]
    last_page = (offset + length) / BYTES_PER_PAGE;
    8726:	687a      	ldr	r2, [r7, #4]
    8728:	683b      	ldr	r3, [r7, #0]
    872a:	4413      	add	r3, r2
    872c:	ea4f 13d3 	mov.w	r3, r3, lsr #7
    8730:	60fb      	str	r3, [r7, #12]
    if(last_page >= start_page_plus_one)
    8732:	68fa      	ldr	r2, [r7, #12]
    8734:	68bb      	ldr	r3, [r7, #8]
    8736:	429a      	cmp	r2, r3
    8738:	d305      	bcc.n	8746 <get_remaining_page_length+0x36>
    {
        length = BYTES_PER_PAGE - (offset % BYTES_PER_PAGE);
    873a:	687b      	ldr	r3, [r7, #4]
    873c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8740:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
    8744:	603b      	str	r3, [r7, #0]
    }
    
    return length;
    8746:	683b      	ldr	r3, [r7, #0]
}
    8748:	4618      	mov	r0, r3
    874a:	f107 0714 	add.w	r7, r7, #20
    874e:	46bd      	mov	sp, r7
    8750:	bc80      	pop	{r7}
    8752:	4770      	bx	lr

00008754 <fill_wd_buffer>:
    const uint8_t * p_data,
    uint32_t  length,
    uint32_t block,
    uint32_t offset
)
{
    8754:	b480      	push	{r7}
    8756:	b08b      	sub	sp, #44	; 0x2c
    8758:	af00      	add	r7, sp, #0
    875a:	60f8      	str	r0, [r7, #12]
    875c:	60b9      	str	r1, [r7, #8]
    875e:	607a      	str	r2, [r7, #4]
    8760:	603b      	str	r3, [r7, #0]
    uint32_t inc;
    uint32_t wd_offset;
    
    if(length != BYTES_PER_PAGE)
    8762:	68bb      	ldr	r3, [r7, #8]
    8764:	2b80      	cmp	r3, #128	; 0x80
    8766:	d067      	beq.n	8838 <fill_wd_buffer+0xe4>
        uint32_t first_non_written_word;
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
    8768:	687b      	ldr	r3, [r7, #4]
    876a:	ea4f 4283 	mov.w	r2, r3, lsl #18
    876e:	683b      	ldr	r3, [r7, #0]
    8770:	4413      	add	r3, r2
    8772:	f103 43c0 	add.w	r3, r3, #1610612736	; 0x60000000
    8776:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    877a:	61fb      	str	r3, [r7, #28]
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
    877c:	683b      	ldr	r3, [r7, #0]
    877e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8782:	ea4f 0393 	mov.w	r3, r3, lsr #2
    8786:	623b      	str	r3, [r7, #32]
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
    8788:	683b      	ldr	r3, [r7, #0]
    878a:	f003 0303 	and.w	r3, r3, #3
    878e:	2b00      	cmp	r3, #0
    8790:	d003      	beq.n	879a <fill_wd_buffer+0x46>
        {
            ++nb_non_written_words;
    8792:	6a3b      	ldr	r3, [r7, #32]
    8794:	f103 0301 	add.w	r3, r3, #1
    8798:	623b      	str	r3, [r7, #32]
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    879a:	f04f 0300 	mov.w	r3, #0
    879e:	617b      	str	r3, [r7, #20]
    87a0:	e015      	b.n	87ce <fill_wd_buffer+0x7a>
        {
            g_nvm32[block]->WD[inc] = p_nvm32[inc];
    87a2:	687a      	ldr	r2, [r7, #4]
    87a4:	f64b 03d8 	movw	r3, #47320	; 0xb8d8
    87a8:	f2c0 0300 	movt	r3, #0
    87ac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    87b0:	697a      	ldr	r2, [r7, #20]
    87b2:	6979      	ldr	r1, [r7, #20]
    87b4:	ea4f 0081 	mov.w	r0, r1, lsl #2
    87b8:	69f9      	ldr	r1, [r7, #28]
    87ba:	4401      	add	r1, r0
    87bc:	6809      	ldr	r1, [r1, #0]
    87be:	f102 0220 	add.w	r2, r2, #32
    87c2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    87c6:	697b      	ldr	r3, [r7, #20]
    87c8:	f103 0301 	add.w	r3, r3, #1
    87cc:	617b      	str	r3, [r7, #20]
    87ce:	697b      	ldr	r3, [r7, #20]
    87d0:	2b1f      	cmp	r3, #31
    87d2:	d803      	bhi.n	87dc <fill_wd_buffer+0x88>
    87d4:	697a      	ldr	r2, [r7, #20]
    87d6:	6a3b      	ldr	r3, [r7, #32]
    87d8:	429a      	cmp	r2, r3
    87da:	d3e2      	bcc.n	87a2 <fill_wd_buffer+0x4e>
        
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
    87dc:	683a      	ldr	r2, [r7, #0]
    87de:	68bb      	ldr	r3, [r7, #8]
    87e0:	4413      	add	r3, r2
    87e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    87e6:	ea4f 0393 	mov.w	r3, r3, lsr #2
    87ea:	627b      	str	r3, [r7, #36]	; 0x24
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
    87ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    87ee:	f1c3 0320 	rsb	r3, r3, #32
    87f2:	623b      	str	r3, [r7, #32]
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    87f4:	f04f 0300 	mov.w	r3, #0
    87f8:	617b      	str	r3, [r7, #20]
    87fa:	e019      	b.n	8830 <fill_wd_buffer+0xdc>
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    87fc:	687a      	ldr	r2, [r7, #4]
    87fe:	f64b 03d8 	movw	r3, #47320	; 0xb8d8
    8802:	f2c0 0300 	movt	r3, #0
    8806:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    880a:	6a79      	ldr	r1, [r7, #36]	; 0x24
    880c:	697a      	ldr	r2, [r7, #20]
    880e:	440a      	add	r2, r1
    8810:	6a78      	ldr	r0, [r7, #36]	; 0x24
    8812:	6979      	ldr	r1, [r7, #20]
    8814:	4401      	add	r1, r0
    8816:	ea4f 0081 	mov.w	r0, r1, lsl #2
    881a:	69f9      	ldr	r1, [r7, #28]
    881c:	4401      	add	r1, r0
    881e:	6809      	ldr	r1, [r1, #0]
    8820:	f102 0220 	add.w	r2, r2, #32
    8824:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    8828:	697b      	ldr	r3, [r7, #20]
    882a:	f103 0301 	add.w	r3, r3, #1
    882e:	617b      	str	r3, [r7, #20]
    8830:	697a      	ldr	r2, [r7, #20]
    8832:	6a3b      	ldr	r3, [r7, #32]
    8834:	429a      	cmp	r2, r3
    8836:	d3e1      	bcc.n	87fc <fill_wd_buffer+0xa8>
    }
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    8838:	683b      	ldr	r3, [r7, #0]
    883a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    883e:	61bb      	str	r3, [r7, #24]
    for(inc = 0u; inc < length; ++inc)
    8840:	f04f 0300 	mov.w	r3, #0
    8844:	617b      	str	r3, [r7, #20]
    8846:	e014      	b.n	8872 <fill_wd_buffer+0x11e>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8848:	687a      	ldr	r2, [r7, #4]
    884a:	f64b 03d0 	movw	r3, #47312	; 0xb8d0
    884e:	f2c0 0300 	movt	r3, #0
    8852:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8856:	69b9      	ldr	r1, [r7, #24]
    8858:	697a      	ldr	r2, [r7, #20]
    885a:	4411      	add	r1, r2
    885c:	68f8      	ldr	r0, [r7, #12]
    885e:	697a      	ldr	r2, [r7, #20]
    8860:	4402      	add	r2, r0
    8862:	7812      	ldrb	r2, [r2, #0]
    8864:	440b      	add	r3, r1
    8866:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    886a:	697b      	ldr	r3, [r7, #20]
    886c:	f103 0301 	add.w	r3, r3, #1
    8870:	617b      	str	r3, [r7, #20]
    8872:	697a      	ldr	r2, [r7, #20]
    8874:	68bb      	ldr	r3, [r7, #8]
    8876:	429a      	cmp	r2, r3
    8878:	d3e6      	bcc.n	8848 <fill_wd_buffer+0xf4>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    }
}
    887a:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    887e:	46bd      	mov	sp, r7
    8880:	bc80      	pop	{r7}
    8882:	4770      	bx	lr

00008884 <check_protection_reserved_nvm>:
 *  0x7C000 - 0x7CFFF - 4KB(32 pages) user lower1(bottom) protected area of eNVM1 memory.
 *  0x7B000 - 0x7BFFF - 4KB(32 pages) user upper1(top) protected area of eNVM1 memory.          
 *
 */
static nvm_status_t check_protection_reserved_nvm(uint32_t offset, uint32_t length)
{
    8884:	b580      	push	{r7, lr}
    8886:	b08c      	sub	sp, #48	; 0x30
    8888:	af00      	add	r7, sp, #0
    888a:	6078      	str	r0, [r7, #4]
    888c:	6039      	str	r1, [r7, #0]
    uint32_t protection_user0;
    uint32_t protection_user1;
    uint32_t protection_user2;
    uint32_t protection_user3;
    uint32_t protection_flag;
    uint32_t length_minus_one = 0u;
    888e:	f04f 0300 	mov.w	r3, #0
    8892:	62bb      	str	r3, [r7, #40]	; 0x28
    nvm_status_t status = NVM_SUCCESS;
    8894:	f04f 0300 	mov.w	r3, #0
    8898:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    if(0u != length)
    889c:	683b      	ldr	r3, [r7, #0]
    889e:	2b00      	cmp	r3, #0
    88a0:	d003      	beq.n	88aa <check_protection_reserved_nvm+0x26>
    {
        length_minus_one = length - 1u;
    88a2:	683b      	ldr	r3, [r7, #0]
    88a4:	f103 33ff 	add.w	r3, r3, #4294967295
    88a8:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    88aa:	f248 0300 	movw	r3, #32768	; 0x8000
    88ae:	f2c4 0303 	movt	r3, #16387	; 0x4003
    88b2:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    88b6:	ea4f 4303 	mov.w	r3, r3, lsl #16
    88ba:	ea4f 4313 	mov.w	r3, r3, lsr #16
    88be:	60fb      	str	r3, [r7, #12]
    
    protection_flag = PROTECTION_OFF;
    88c0:	f04f 0300 	mov.w	r3, #0
    88c4:	627b      	str	r3, [r7, #36]	; 0x24
    
    /* 005 device */
    if(0xF805u == device_version)
    88c6:	68fa      	ldr	r2, [r7, #12]
    88c8:	f64f 0305 	movw	r3, #63493	; 0xf805
    88cc:	429a      	cmp	r2, r3
    88ce:	f040 80a6 	bne.w	8a1e <check_protection_reserved_nvm+0x19a>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    88d2:	f248 0300 	movw	r3, #32768	; 0x8000
    88d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    88da:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
    88de:	f649 1399 	movw	r3, #39321	; 0x9999
    88e2:	f2c0 0300 	movt	r3, #0
    88e6:	ea02 0303 	and.w	r3, r2, r3
    88ea:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    88ec:	693a      	ldr	r2, [r7, #16]
    88ee:	f649 1399 	movw	r3, #39321	; 0x9999
    88f2:	429a      	cmp	r2, r3
    88f4:	d054      	beq.n	89a0 <check_protection_reserved_nvm+0x11c>
        {
            protection_user0 = (protection_data & 0x000Fu);
    88f6:	693b      	ldr	r3, [r7, #16]
    88f8:	f003 030f 	and.w	r3, r3, #15
    88fc:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
    88fe:	693b      	ldr	r3, [r7, #16]
    8900:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8904:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8908:	61bb      	str	r3, [r7, #24]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (WRITE_ONLY == protection_user1) ||
    890a:	697b      	ldr	r3, [r7, #20]
    890c:	2b08      	cmp	r3, #8
    890e:	d008      	beq.n	8922 <check_protection_reserved_nvm+0x9e>
    8910:	69bb      	ldr	r3, [r7, #24]
    8912:	2b08      	cmp	r3, #8
    8914:	d005      	beq.n	8922 <check_protection_reserved_nvm+0x9e>
    8916:	697b      	ldr	r3, [r7, #20]
    8918:	2b00      	cmp	r3, #0
    891a:	d002      	beq.n	8922 <check_protection_reserved_nvm+0x9e>
    891c:	69bb      	ldr	r3, [r7, #24]
    891e:	2b00      	cmp	r3, #0
    8920:	d106      	bne.n	8930 <check_protection_reserved_nvm+0xac>
               (NO_READ_WRITE == protection_user0) || (NO_READ_WRITE == protection_user1))
            {
                g_do_not_lock_page = ON;
    8922:	f24b 3398 	movw	r3, #45976	; 0xb398
    8926:	f2c2 0300 	movt	r3, #8192	; 0x2000
    892a:	f04f 0201 	mov.w	r2, #1
    892e:	701a      	strb	r2, [r3, #0]
            
            /* 
             * SAR 70908.
             * Checking NVM0 lower protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0)
    8930:	697b      	ldr	r3, [r7, #20]
    8932:	2b09      	cmp	r3, #9
    8934:	d00a      	beq.n	894c <check_protection_reserved_nvm+0xc8>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
    8936:	687a      	ldr	r2, [r7, #4]
    8938:	f640 73ff 	movw	r3, #4095	; 0xfff
    893c:	429a      	cmp	r2, r3
    893e:	d805      	bhi.n	894c <check_protection_reserved_nvm+0xc8>
                {
                    protection_flag = protection_check(protection_user0, length);
    8940:	6978      	ldr	r0, [r7, #20]
    8942:	6839      	ldr	r1, [r7, #0]
    8944:	f000 fade 	bl	8f04 <protection_check>
    8948:	4603      	mov	r3, r0
    894a:	627b      	str	r3, [r7, #36]	; 0x24
            
            /*
             * SAR 70908.
             * Checking NVM0 upper protected area is Read or Write or 'No R/W' access 
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
    894c:	69bb      	ldr	r3, [r7, #24]
    894e:	2b09      	cmp	r3, #9
    8950:	d026      	beq.n	89a0 <check_protection_reserved_nvm+0x11c>
    8952:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8954:	2b00      	cmp	r3, #0
    8956:	d123      	bne.n	89a0 <check_protection_reserved_nvm+0x11c>
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) && 
    8958:	687a      	ldr	r2, [r7, #4]
    895a:	f64e 73ff 	movw	r3, #61439	; 0xefff
    895e:	f2c0 0301 	movt	r3, #1
    8962:	429a      	cmp	r2, r3
    8964:	d906      	bls.n	8974 <check_protection_reserved_nvm+0xf0>
    8966:	687a      	ldr	r2, [r7, #4]
    8968:	f64f 73ff 	movw	r3, #65535	; 0xffff
    896c:	f2c0 0301 	movt	r3, #1
    8970:	429a      	cmp	r2, r3
    8972:	d90f      	bls.n	8994 <check_protection_reserved_nvm+0x110>
                    (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8974:	687a      	ldr	r2, [r7, #4]
    8976:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8978:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) && 
    897a:	f64e 73ff 	movw	r3, #61439	; 0xefff
    897e:	f2c0 0301 	movt	r3, #1
    8982:	429a      	cmp	r2, r3
    8984:	d90c      	bls.n	89a0 <check_protection_reserved_nvm+0x11c>
    8986:	687a      	ldr	r2, [r7, #4]
    8988:	f64e 73ff 	movw	r3, #61439	; 0xefff
    898c:	f2c0 0301 	movt	r3, #1
    8990:	429a      	cmp	r2, r3
    8992:	d805      	bhi.n	89a0 <check_protection_reserved_nvm+0x11c>
                    (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < OO5_UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
    8994:	69b8      	ldr	r0, [r7, #24]
    8996:	6839      	ldr	r1, [r7, #0]
    8998:	f000 fab4 	bl	8f04 <protection_check>
    899c:	4603      	mov	r3, r0
    899e:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }
        }
        
        /* Check the eNVM memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    89a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    89a2:	2b01      	cmp	r3, #1
    89a4:	d104      	bne.n	89b0 <check_protection_reserved_nvm+0x12c>
        {
            /* Status is protection error if lower or upper area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
    89a6:	f04f 0301 	mov.w	r3, #1
    89aa:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
    89ae:	e2a2      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > OO5_UPPER0_PROTECT_TOP_OFFSET)
    89b0:	687a      	ldr	r2, [r7, #4]
    89b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    89b4:	441a      	add	r2, r3
    89b6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    89ba:	f2c0 0301 	movt	r3, #1
    89be:	429a      	cmp	r2, r3
    89c0:	d904      	bls.n	89cc <check_protection_reserved_nvm+0x148>
            {
                status = NVM_INVALID_PARAMETER;
    89c2:	f04f 0307 	mov.w	r3, #7
    89c6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
    89ca:	e294      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
    89cc:	687a      	ldr	r2, [r7, #4]
    89ce:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    89d2:	f2c0 0301 	movt	r3, #1
    89d6:	429a      	cmp	r2, r3
    89d8:	d906      	bls.n	89e8 <check_protection_reserved_nvm+0x164>
    89da:	687a      	ldr	r2, [r7, #4]
    89dc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    89e0:	f2c0 0301 	movt	r3, #1
    89e4:	429a      	cmp	r2, r3
    89e6:	d90f      	bls.n	8a08 <check_protection_reserved_nvm+0x184>
                    (((offset + length_minus_one) >= OO5_NVM_RSV_OFFSET) &&
    89e8:	687a      	ldr	r2, [r7, #4]
    89ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
    89ec:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
    89ee:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    89f2:	f2c0 0301 	movt	r3, #1
    89f6:	429a      	cmp	r2, r3
    89f8:	d90c      	bls.n	8a14 <check_protection_reserved_nvm+0x190>
    89fa:	687a      	ldr	r2, [r7, #4]
    89fc:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    8a00:	f2c0 0301 	movt	r3, #1
    8a04:	429a      	cmp	r2, r3
    8a06:	d805      	bhi.n	8a14 <check_protection_reserved_nvm+0x190>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
    8a08:	f04f 0301 	mov.w	r3, #1
    8a0c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
    8a10:	bf00      	nop
    8a12:	e270      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
    8a14:	f04f 0300 	mov.w	r3, #0
    8a18:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    8a1c:	e26b      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    8a1e:	68fa      	ldr	r2, [r7, #12]
    8a20:	f64f 0302 	movw	r3, #63490	; 0xf802
    8a24:	429a      	cmp	r2, r3
    8a26:	d00a      	beq.n	8a3e <check_protection_reserved_nvm+0x1ba>
    8a28:	68fa      	ldr	r2, [r7, #12]
    8a2a:	f64f 0303 	movw	r3, #63491	; 0xf803
    8a2e:	429a      	cmp	r2, r3
    8a30:	d005      	beq.n	8a3e <check_protection_reserved_nvm+0x1ba>
    8a32:	68fa      	ldr	r2, [r7, #12]
    8a34:	f64f 0304 	movw	r3, #63492	; 0xf804
    8a38:	429a      	cmp	r2, r3
    8a3a:	f040 80a6 	bne.w	8b8a <check_protection_reserved_nvm+0x306>
    {    
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    8a3e:	f248 0300 	movw	r3, #32768	; 0x8000
    8a42:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8a46:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
    8a4a:	f649 1399 	movw	r3, #39321	; 0x9999
    8a4e:	f2c0 0300 	movt	r3, #0
    8a52:	ea02 0303 	and.w	r3, r2, r3
    8a56:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    8a58:	693a      	ldr	r2, [r7, #16]
    8a5a:	f649 1399 	movw	r3, #39321	; 0x9999
    8a5e:	429a      	cmp	r2, r3
    8a60:	d054      	beq.n	8b0c <check_protection_reserved_nvm+0x288>
        {
            protection_user0 = (protection_data & 0x000Fu);
    8a62:	693b      	ldr	r3, [r7, #16]
    8a64:	f003 030f 	and.w	r3, r3, #15
    8a68:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
    8a6a:	693b      	ldr	r3, [r7, #16]
    8a6c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8a70:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8a74:	61bb      	str	r3, [r7, #24]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (WRITE_ONLY == protection_user1) ||
    8a76:	697b      	ldr	r3, [r7, #20]
    8a78:	2b08      	cmp	r3, #8
    8a7a:	d008      	beq.n	8a8e <check_protection_reserved_nvm+0x20a>
    8a7c:	69bb      	ldr	r3, [r7, #24]
    8a7e:	2b08      	cmp	r3, #8
    8a80:	d005      	beq.n	8a8e <check_protection_reserved_nvm+0x20a>
    8a82:	697b      	ldr	r3, [r7, #20]
    8a84:	2b00      	cmp	r3, #0
    8a86:	d002      	beq.n	8a8e <check_protection_reserved_nvm+0x20a>
    8a88:	69bb      	ldr	r3, [r7, #24]
    8a8a:	2b00      	cmp	r3, #0
    8a8c:	d106      	bne.n	8a9c <check_protection_reserved_nvm+0x218>
               (NO_READ_WRITE == protection_user0) || (NO_READ_WRITE == protection_user1))
            {
                g_do_not_lock_page = ON;
    8a8e:	f24b 3398 	movw	r3, #45976	; 0xb398
    8a92:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a96:	f04f 0201 	mov.w	r2, #1
    8a9a:	701a      	strb	r2, [r3, #0]
            
            /* 
             * SAR 70908.
             * Check NVM0 lower protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0)
    8a9c:	697b      	ldr	r3, [r7, #20]
    8a9e:	2b09      	cmp	r3, #9
    8aa0:	d00a      	beq.n	8ab8 <check_protection_reserved_nvm+0x234>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
    8aa2:	687a      	ldr	r2, [r7, #4]
    8aa4:	f640 73ff 	movw	r3, #4095	; 0xfff
    8aa8:	429a      	cmp	r2, r3
    8aaa:	d805      	bhi.n	8ab8 <check_protection_reserved_nvm+0x234>
                {
                    protection_flag = protection_check(protection_user0, length);
    8aac:	6978      	ldr	r0, [r7, #20]
    8aae:	6839      	ldr	r1, [r7, #0]
    8ab0:	f000 fa28 	bl	8f04 <protection_check>
    8ab4:	4603      	mov	r3, r0
    8ab6:	627b      	str	r3, [r7, #36]	; 0x24
            
            /* 
             * SAR 70908.
             * Check NVM0 upper protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
    8ab8:	69bb      	ldr	r3, [r7, #24]
    8aba:	2b09      	cmp	r3, #9
    8abc:	d026      	beq.n	8b0c <check_protection_reserved_nvm+0x288>
    8abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8ac0:	2b00      	cmp	r3, #0
    8ac2:	d123      	bne.n	8b0c <check_protection_reserved_nvm+0x288>
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8ac4:	687a      	ldr	r2, [r7, #4]
    8ac6:	f64e 73ff 	movw	r3, #61439	; 0xefff
    8aca:	f2c0 0303 	movt	r3, #3
    8ace:	429a      	cmp	r2, r3
    8ad0:	d906      	bls.n	8ae0 <check_protection_reserved_nvm+0x25c>
    8ad2:	687a      	ldr	r2, [r7, #4]
    8ad4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8ad8:	f2c0 0303 	movt	r3, #3
    8adc:	429a      	cmp	r2, r3
    8ade:	d90f      	bls.n	8b00 <check_protection_reserved_nvm+0x27c>
                    (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8ae0:	687a      	ldr	r2, [r7, #4]
    8ae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8ae4:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8ae6:	f64e 73ff 	movw	r3, #61439	; 0xefff
    8aea:	f2c0 0303 	movt	r3, #3
    8aee:	429a      	cmp	r2, r3
    8af0:	d90c      	bls.n	8b0c <check_protection_reserved_nvm+0x288>
    8af2:	687a      	ldr	r2, [r7, #4]
    8af4:	f64e 73ff 	movw	r3, #61439	; 0xefff
    8af8:	f2c0 0303 	movt	r3, #3
    8afc:	429a      	cmp	r2, r3
    8afe:	d805      	bhi.n	8b0c <check_protection_reserved_nvm+0x288>
                    (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
    8b00:	69b8      	ldr	r0, [r7, #24]
    8b02:	6839      	ldr	r1, [r7, #0]
    8b04:	f000 f9fe 	bl	8f04 <protection_check>
    8b08:	4603      	mov	r3, r0
    8b0a:	627b      	str	r3, [r7, #36]	; 0x24
                }
            } 
        }
        
        /* Check eNVM lower or upper area of memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    8b0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8b0e:	2b01      	cmp	r3, #1
    8b10:	d104      	bne.n	8b1c <check_protection_reserved_nvm+0x298>
        {
            /* Status is protection error if lower or upper area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
    8b12:	f04f 0301 	mov.w	r3, #1
    8b16:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    8b1a:	e1ec      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
             /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
    8b1c:	687a      	ldr	r2, [r7, #4]
    8b1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8b20:	441a      	add	r2, r3
    8b22:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8b26:	f2c0 0303 	movt	r3, #3
    8b2a:	429a      	cmp	r2, r3
    8b2c:	d904      	bls.n	8b38 <check_protection_reserved_nvm+0x2b4>
            {
                status = NVM_INVALID_PARAMETER;
    8b2e:	f04f 0307 	mov.w	r3, #7
    8b32:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    8b36:	e1de      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8b38:	687a      	ldr	r2, [r7, #4]
    8b3a:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    8b3e:	f2c0 0303 	movt	r3, #3
    8b42:	429a      	cmp	r2, r3
    8b44:	d906      	bls.n	8b54 <check_protection_reserved_nvm+0x2d0>
    8b46:	687a      	ldr	r2, [r7, #4]
    8b48:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8b4c:	f2c0 0303 	movt	r3, #3
    8b50:	429a      	cmp	r2, r3
    8b52:	d90f      	bls.n	8b74 <check_protection_reserved_nvm+0x2f0>
                    (((offset + length_minus_one) >= NVM0_RSV_OFFSET) && (offset < NVM0_RSV_OFFSET)))
    8b54:	687a      	ldr	r2, [r7, #4]
    8b56:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8b58:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8b5a:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    8b5e:	f2c0 0303 	movt	r3, #3
    8b62:	429a      	cmp	r2, r3
    8b64:	d90c      	bls.n	8b80 <check_protection_reserved_nvm+0x2fc>
    8b66:	687a      	ldr	r2, [r7, #4]
    8b68:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
    8b6c:	f2c0 0303 	movt	r3, #3
    8b70:	429a      	cmp	r2, r3
    8b72:	d805      	bhi.n	8b80 <check_protection_reserved_nvm+0x2fc>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
    8b74:	f04f 0301 	mov.w	r3, #1
    8b78:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8b7c:	bf00      	nop
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    8b7e:	e1ba      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
    8b80:	f04f 0300 	mov.w	r3, #0
    8b84:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    8b88:	e1b5      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            }
        }
    }
    
    /* 060 device */
    else if(0xF808u == device_version)
    8b8a:	68fa      	ldr	r2, [r7, #12]
    8b8c:	f64f 0308 	movw	r3, #63496	; 0xf808
    8b90:	429a      	cmp	r2, r3
    8b92:	f040 809f 	bne.w	8cd4 <check_protection_reserved_nvm+0x450>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    8b96:	f248 0300 	movw	r3, #32768	; 0x8000
    8b9a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8b9e:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
    8ba2:	f649 1399 	movw	r3, #39321	; 0x9999
    8ba6:	f2c0 0300 	movt	r3, #0
    8baa:	ea02 0303 	and.w	r3, r2, r3
    8bae:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower0/1 or upper0/1 area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    8bb0:	693a      	ldr	r2, [r7, #16]
    8bb2:	f649 1399 	movw	r3, #39321	; 0x9999
    8bb6:	429a      	cmp	r2, r3
    8bb8:	d04d      	beq.n	8c56 <check_protection_reserved_nvm+0x3d2>
        {
            protection_user0 = (protection_data & 0x000Fu);
    8bba:	693b      	ldr	r3, [r7, #16]
    8bbc:	f003 030f 	and.w	r3, r3, #15
    8bc0:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
    8bc2:	693b      	ldr	r3, [r7, #16]
    8bc4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8bc8:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8bcc:	61bb      	str	r3, [r7, #24]
            protection_user2 = ((protection_data & 0x0F00u) >> 8u);
    8bce:	693b      	ldr	r3, [r7, #16]
    8bd0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    8bd4:	ea4f 2313 	mov.w	r3, r3, lsr #8
    8bd8:	61fb      	str	r3, [r7, #28]
            protection_user3 = ((protection_data & 0xF000u) >> 12u);
    8bda:	693b      	ldr	r3, [r7, #16]
    8bdc:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
    8be0:	ea4f 3313 	mov.w	r3, r3, lsr #12
    8be4:	623b      	str	r3, [r7, #32]
            
            /* 
             * SAR 70908.
             * Check NVM0 lower0 protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0) 
    8be6:	697b      	ldr	r3, [r7, #20]
    8be8:	2b09      	cmp	r3, #9
    8bea:	d00a      	beq.n	8c02 <check_protection_reserved_nvm+0x37e>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */  
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
    8bec:	687a      	ldr	r2, [r7, #4]
    8bee:	f640 73ff 	movw	r3, #4095	; 0xfff
    8bf2:	429a      	cmp	r2, r3
    8bf4:	d805      	bhi.n	8c02 <check_protection_reserved_nvm+0x37e>
                {
                    protection_flag = protection_check(protection_user0, length);
    8bf6:	6978      	ldr	r0, [r7, #20]
    8bf8:	6839      	ldr	r1, [r7, #0]
    8bfa:	f000 f983 	bl	8f04 <protection_check>
    8bfe:	4603      	mov	r3, r0
    8c00:	627b      	str	r3, [r7, #36]	; 0x24
            
            /* 
             * SAR 70908.
             * Check NVM0 upper1 protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
    8c02:	6a3b      	ldr	r3, [r7, #32]
    8c04:	2b09      	cmp	r3, #9
    8c06:	d026      	beq.n	8c56 <check_protection_reserved_nvm+0x3d2>
    8c08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8c0a:	2b00      	cmp	r3, #0
    8c0c:	d123      	bne.n	8c56 <check_protection_reserved_nvm+0x3d2>
            {
                /* Check the offset or (offset + length) is in the range of upper1 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8c0e:	687a      	ldr	r2, [r7, #4]
    8c10:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8c14:	f2c0 0303 	movt	r3, #3
    8c18:	429a      	cmp	r2, r3
    8c1a:	d906      	bls.n	8c2a <check_protection_reserved_nvm+0x3a6>
    8c1c:	687a      	ldr	r2, [r7, #4]
    8c1e:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8c22:	f2c0 0303 	movt	r3, #3
    8c26:	429a      	cmp	r2, r3
    8c28:	d90f      	bls.n	8c4a <check_protection_reserved_nvm+0x3c6>
                    (offset <= NVM0_UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8c2a:	687a      	ldr	r2, [r7, #4]
    8c2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8c2e:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper1 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8c30:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8c34:	f2c0 0303 	movt	r3, #3
    8c38:	429a      	cmp	r2, r3
    8c3a:	d90c      	bls.n	8c56 <check_protection_reserved_nvm+0x3d2>
    8c3c:	687a      	ldr	r2, [r7, #4]
    8c3e:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8c42:	f2c0 0303 	movt	r3, #3
    8c46:	429a      	cmp	r2, r3
    8c48:	d805      	bhi.n	8c56 <check_protection_reserved_nvm+0x3d2>
                    (offset <= NVM0_UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < NVM0_UPPER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user3, length);
    8c4a:	6a38      	ldr	r0, [r7, #32]
    8c4c:	6839      	ldr	r1, [r7, #0]
    8c4e:	f000 f959 	bl	8f04 <protection_check>
    8c52:	4603      	mov	r3, r0
    8c54:	627b      	str	r3, [r7, #36]	; 0x24
        
        /* Check eNVM lower0 or upper1 memory is protected or not.
         * No protection check for  0x3F000 - 0x3FFFF and 0x3E000 - 0x3EFFF lower1/upper0 
         * protected area of eNVM0 memory because it's fall under eNVM reserved area    
         */
        if(PROTECTION_ON == protection_flag)
    8c56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8c58:	2b01      	cmp	r3, #1
    8c5a:	d104      	bne.n	8c66 <check_protection_reserved_nvm+0x3e2>
        {
            /* Status is protection error if lower0 or upper1 area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
    8c5c:	f04f 0301 	mov.w	r3, #1
    8c60:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
    8c64:	e147      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory*/
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
    8c66:	687a      	ldr	r2, [r7, #4]
    8c68:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8c6a:	441a      	add	r2, r3
    8c6c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8c70:	f2c0 0303 	movt	r3, #3
    8c74:	429a      	cmp	r2, r3
    8c76:	d904      	bls.n	8c82 <check_protection_reserved_nvm+0x3fe>
            {
                status = NVM_INVALID_PARAMETER;
    8c78:	f04f 0307 	mov.w	r3, #7
    8c7c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
    8c80:	e139      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8c82:	687a      	ldr	r2, [r7, #4]
    8c84:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8c88:	f2c0 0303 	movt	r3, #3
    8c8c:	429a      	cmp	r2, r3
    8c8e:	d906      	bls.n	8c9e <check_protection_reserved_nvm+0x41a>
    8c90:	687a      	ldr	r2, [r7, #4]
    8c92:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8c96:	f2c0 0303 	movt	r3, #3
    8c9a:	429a      	cmp	r2, r3
    8c9c:	d90f      	bls.n	8cbe <check_protection_reserved_nvm+0x43a>
                    (((offset + length_minus_one) >= O60_NVM_RSV_OFFSET) &&
    8c9e:	687a      	ldr	r2, [r7, #4]
    8ca0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8ca2:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8ca4:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8ca8:	f2c0 0303 	movt	r3, #3
    8cac:	429a      	cmp	r2, r3
    8cae:	d90c      	bls.n	8cca <check_protection_reserved_nvm+0x446>
    8cb0:	687a      	ldr	r2, [r7, #4]
    8cb2:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8cb6:	f2c0 0303 	movt	r3, #3
    8cba:	429a      	cmp	r2, r3
    8cbc:	d805      	bhi.n	8cca <check_protection_reserved_nvm+0x446>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
    8cbe:	f04f 0301 	mov.w	r3, #1
    8cc2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
    8cc6:	bf00      	nop
    8cc8:	e115      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
    8cca:	f04f 0300 	mov.w	r3, #0
    8cce:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    8cd2:	e110      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            }
        }    
    }
    
    /* 090/150 device */
    else if((0xF807u == device_version) || (0xF806u == device_version))
    8cd4:	68fa      	ldr	r2, [r7, #12]
    8cd6:	f64f 0307 	movw	r3, #63495	; 0xf807
    8cda:	429a      	cmp	r2, r3
    8cdc:	d005      	beq.n	8cea <check_protection_reserved_nvm+0x466>
    8cde:	68fa      	ldr	r2, [r7, #12]
    8ce0:	f64f 0306 	movw	r3, #63494	; 0xf806
    8ce4:	429a      	cmp	r2, r3
    8ce6:	f040 8106 	bne.w	8ef6 <check_protection_reserved_nvm+0x672>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    8cea:	f248 0300 	movw	r3, #32768	; 0x8000
    8cee:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8cf2:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
    8cf6:	f649 1399 	movw	r3, #39321	; 0x9999
    8cfa:	f2c0 0300 	movt	r3, #0
    8cfe:	ea02 0303 	and.w	r3, r2, r3
    8d02:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    8d04:	693a      	ldr	r2, [r7, #16]
    8d06:	f649 1399 	movw	r3, #39321	; 0x9999
    8d0a:	429a      	cmp	r2, r3
    8d0c:	f000 80b6 	beq.w	8e7c <check_protection_reserved_nvm+0x5f8>
        {
            protection_user0 = (protection_data & 0x000Fu);
    8d10:	693b      	ldr	r3, [r7, #16]
    8d12:	f003 030f 	and.w	r3, r3, #15
    8d16:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
    8d18:	693b      	ldr	r3, [r7, #16]
    8d1a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8d1e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    8d22:	61bb      	str	r3, [r7, #24]
            protection_user2 = ((protection_data & 0x0F00u) >> 8u);
    8d24:	693b      	ldr	r3, [r7, #16]
    8d26:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    8d2a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    8d2e:	61fb      	str	r3, [r7, #28]
            protection_user3 = ((protection_data & 0xF000u) >> 12u);
    8d30:	693b      	ldr	r3, [r7, #16]
    8d32:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
    8d36:	ea4f 3313 	mov.w	r3, r3, lsr #12
    8d3a:	623b      	str	r3, [r7, #32]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (NO_READ_WRITE == protection_user0))
    8d3c:	697b      	ldr	r3, [r7, #20]
    8d3e:	2b08      	cmp	r3, #8
    8d40:	d002      	beq.n	8d48 <check_protection_reserved_nvm+0x4c4>
    8d42:	697b      	ldr	r3, [r7, #20]
    8d44:	2b00      	cmp	r3, #0
    8d46:	d10d      	bne.n	8d64 <check_protection_reserved_nvm+0x4e0>
            {
              if(offset < NVM1_BOTTOM_OFFSET)
    8d48:	687a      	ldr	r2, [r7, #4]
    8d4a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8d4e:	f2c0 0303 	movt	r3, #3
    8d52:	429a      	cmp	r2, r3
    8d54:	d806      	bhi.n	8d64 <check_protection_reserved_nvm+0x4e0>
              {
                 g_do_not_lock_page = ON;
    8d56:	f24b 3398 	movw	r3, #45976	; 0xb398
    8d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d5e:	f04f 0201 	mov.w	r2, #1
    8d62:	701a      	strb	r2, [r3, #0]

            /* 
             * SAR 70908.
             * Check NVM0 lower0 protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0) 
    8d64:	697b      	ldr	r3, [r7, #20]
    8d66:	2b09      	cmp	r3, #9
    8d68:	d00a      	beq.n	8d80 <check_protection_reserved_nvm+0x4fc>
            {
                /* Check the offset is in the range of lower0 protect memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
    8d6a:	687a      	ldr	r2, [r7, #4]
    8d6c:	f640 73ff 	movw	r3, #4095	; 0xfff
    8d70:	429a      	cmp	r2, r3
    8d72:	d805      	bhi.n	8d80 <check_protection_reserved_nvm+0x4fc>
                {
                    protection_flag = protection_check(protection_user0, length);
    8d74:	6978      	ldr	r0, [r7, #20]
    8d76:	6839      	ldr	r1, [r7, #0]
    8d78:	f000 f8c4 	bl	8f04 <protection_check>
    8d7c:	4603      	mov	r3, r0
    8d7e:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check NVM1 upper1 protected area is Read or Write or 'No R/W' access
             */            
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
    8d80:	6a3b      	ldr	r3, [r7, #32]
    8d82:	2b09      	cmp	r3, #9
    8d84:	d026      	beq.n	8dd4 <check_protection_reserved_nvm+0x550>
    8d86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8d88:	2b00      	cmp	r3, #0
    8d8a:	d123      	bne.n	8dd4 <check_protection_reserved_nvm+0x550>
            {
                /* Check the offset or (offset + length)is in the range of upper1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8d8c:	687a      	ldr	r2, [r7, #4]
    8d8e:	f64a 73ff 	movw	r3, #45055	; 0xafff
    8d92:	f2c0 0307 	movt	r3, #7
    8d96:	429a      	cmp	r2, r3
    8d98:	d906      	bls.n	8da8 <check_protection_reserved_nvm+0x524>
    8d9a:	687a      	ldr	r2, [r7, #4]
    8d9c:	f64b 73ff 	movw	r3, #49151	; 0xbfff
    8da0:	f2c0 0307 	movt	r3, #7
    8da4:	429a      	cmp	r2, r3
    8da6:	d90f      	bls.n	8dc8 <check_protection_reserved_nvm+0x544>
                    (offset <= UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8da8:	687a      	ldr	r2, [r7, #4]
    8daa:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8dac:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length)is in the range of upper1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
    8dae:	f64a 73ff 	movw	r3, #45055	; 0xafff
    8db2:	f2c0 0307 	movt	r3, #7
    8db6:	429a      	cmp	r2, r3
    8db8:	d90c      	bls.n	8dd4 <check_protection_reserved_nvm+0x550>
    8dba:	687a      	ldr	r2, [r7, #4]
    8dbc:	f64a 73ff 	movw	r3, #45055	; 0xafff
    8dc0:	f2c0 0307 	movt	r3, #7
    8dc4:	429a      	cmp	r2, r3
    8dc6:	d805      	bhi.n	8dd4 <check_protection_reserved_nvm+0x550>
                    (offset <= UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < UPPER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user3, length);
    8dc8:	6a38      	ldr	r0, [r7, #32]
    8dca:	6839      	ldr	r1, [r7, #0]
    8dcc:	f000 f89a 	bl	8f04 <protection_check>
    8dd0:	4603      	mov	r3, r0
    8dd2:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check NVM1 lower1 protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user2) && (OFF == protection_flag))
    8dd4:	69fb      	ldr	r3, [r7, #28]
    8dd6:	2b09      	cmp	r3, #9
    8dd8:	d026      	beq.n	8e28 <check_protection_reserved_nvm+0x5a4>
    8dda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8ddc:	2b00      	cmp	r3, #0
    8dde:	d123      	bne.n	8e28 <check_protection_reserved_nvm+0x5a4>
            {
                /* Check the offset or (offset + length)is in the range of lower1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
    8de0:	687a      	ldr	r2, [r7, #4]
    8de2:	f64b 73ff 	movw	r3, #49151	; 0xbfff
    8de6:	f2c0 0307 	movt	r3, #7
    8dea:	429a      	cmp	r2, r3
    8dec:	d906      	bls.n	8dfc <check_protection_reserved_nvm+0x578>
    8dee:	687a      	ldr	r2, [r7, #4]
    8df0:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8df4:	f2c0 0307 	movt	r3, #7
    8df8:	429a      	cmp	r2, r3
    8dfa:	d90f      	bls.n	8e1c <check_protection_reserved_nvm+0x598>
                    (offset <= LOWER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
    8dfc:	687a      	ldr	r2, [r7, #4]
    8dfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e00:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user2) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length)is in the range of lower1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
    8e02:	f64b 73ff 	movw	r3, #49151	; 0xbfff
    8e06:	f2c0 0307 	movt	r3, #7
    8e0a:	429a      	cmp	r2, r3
    8e0c:	d90c      	bls.n	8e28 <check_protection_reserved_nvm+0x5a4>
    8e0e:	687a      	ldr	r2, [r7, #4]
    8e10:	f64b 73ff 	movw	r3, #49151	; 0xbfff
    8e14:	f2c0 0307 	movt	r3, #7
    8e18:	429a      	cmp	r2, r3
    8e1a:	d805      	bhi.n	8e28 <check_protection_reserved_nvm+0x5a4>
                    (offset <= LOWER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < LOWER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user2, length);
    8e1c:	69f8      	ldr	r0, [r7, #28]
    8e1e:	6839      	ldr	r1, [r7, #0]
    8e20:	f000 f870 	bl	8f04 <protection_check>
    8e24:	4603      	mov	r3, r0
    8e26:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check eNVM0 upper0 protected area(in eNVM1) is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
    8e28:	69bb      	ldr	r3, [r7, #24]
    8e2a:	2b09      	cmp	r3, #9
    8e2c:	d026      	beq.n	8e7c <check_protection_reserved_nvm+0x5f8>
    8e2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8e30:	2b00      	cmp	r3, #0
    8e32:	d123      	bne.n	8e7c <check_protection_reserved_nvm+0x5f8>
            {
                /* Check the offset or (offset + length) is in the range of upper0
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8e34:	687a      	ldr	r2, [r7, #4]
    8e36:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8e3a:	f2c0 0307 	movt	r3, #7
    8e3e:	429a      	cmp	r2, r3
    8e40:	d906      	bls.n	8e50 <check_protection_reserved_nvm+0x5cc>
    8e42:	687a      	ldr	r2, [r7, #4]
    8e44:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8e48:	f2c0 0307 	movt	r3, #7
    8e4c:	429a      	cmp	r2, r3
    8e4e:	d90f      	bls.n	8e70 <check_protection_reserved_nvm+0x5ec>
                    (offset <= NVM0_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8e50:	687a      	ldr	r2, [r7, #4]
    8e52:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e54:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper0
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
    8e56:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8e5a:	f2c0 0307 	movt	r3, #7
    8e5e:	429a      	cmp	r2, r3
    8e60:	d90c      	bls.n	8e7c <check_protection_reserved_nvm+0x5f8>
    8e62:	687a      	ldr	r2, [r7, #4]
    8e64:	f64c 73ff 	movw	r3, #53247	; 0xcfff
    8e68:	f2c0 0307 	movt	r3, #7
    8e6c:	429a      	cmp	r2, r3
    8e6e:	d805      	bhi.n	8e7c <check_protection_reserved_nvm+0x5f8>
                    (offset <= NVM0_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < NVM0_UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
    8e70:	69b8      	ldr	r0, [r7, #24]
    8e72:	6839      	ldr	r1, [r7, #0]
    8e74:	f000 f846 	bl	8f04 <protection_check>
    8e78:	4603      	mov	r3, r0
    8e7a:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }
        }

        /* Check eNVM lower0/1 and upper0/1 memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    8e7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8e7e:	2b01      	cmp	r3, #1
    8e80:	d104      	bne.n	8e8c <check_protection_reserved_nvm+0x608>
        {
           /* Status is protection error if lower or upper area of eNVM0 or 
            * eNVM1 is protected 
            */
            status = NVM_PROTECTION_ERROR;
    8e82:	f04f 0301 	mov.w	r3, #1
    8e86:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    8e8a:	e034      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > NVM1_TOP_OFFSET)
    8e8c:	687a      	ldr	r2, [r7, #4]
    8e8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e90:	441a      	add	r2, r3
    8e92:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8e96:	f2c0 0307 	movt	r3, #7
    8e9a:	429a      	cmp	r2, r3
    8e9c:	d904      	bls.n	8ea8 <check_protection_reserved_nvm+0x624>
            {
                status = NVM_INVALID_PARAMETER;
    8e9e:	f04f 0307 	mov.w	r3, #7
    8ea2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    8ea6:	e026      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
    8ea8:	687a      	ldr	r2, [r7, #4]
    8eaa:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8eae:	f2c0 0307 	movt	r3, #7
    8eb2:	429a      	cmp	r2, r3
    8eb4:	d906      	bls.n	8ec4 <check_protection_reserved_nvm+0x640>
    8eb6:	687a      	ldr	r2, [r7, #4]
    8eb8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8ebc:	f2c0 0307 	movt	r3, #7
    8ec0:	429a      	cmp	r2, r3
    8ec2:	d90f      	bls.n	8ee4 <check_protection_reserved_nvm+0x660>
                    (((offset + length_minus_one) >= NVM1_RSV_OFFSET) &&
    8ec4:	687a      	ldr	r2, [r7, #4]
    8ec6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8ec8:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
    8eca:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8ece:	f2c0 0307 	movt	r3, #7
    8ed2:	429a      	cmp	r2, r3
    8ed4:	d90b      	bls.n	8eee <check_protection_reserved_nvm+0x66a>
    8ed6:	687a      	ldr	r2, [r7, #4]
    8ed8:	f64d 73ff 	movw	r3, #57343	; 0xdfff
    8edc:	f2c0 0307 	movt	r3, #7
    8ee0:	429a      	cmp	r2, r3
    8ee2:	d804      	bhi.n	8eee <check_protection_reserved_nvm+0x66a>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
    8ee4:	f04f 0301 	mov.w	r3, #1
    8ee8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
    8eec:	e003      	b.n	8ef6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if offset or (offset + length) is 
                     * in RW access of eNVM memory
                     */
                    status = NVM_SUCCESS;
    8eee:	f04f 0300 	mov.w	r3, #0
    8ef2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                }
            }
        }
    }
    return status;
    8ef6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
    8efa:	4618      	mov	r0, r3
    8efc:	f107 0730 	add.w	r7, r7, #48	; 0x30
    8f00:	46bd      	mov	sp, r7
    8f02:	bd80      	pop	{r7, pc}

00008f04 <protection_check>:
 *
 * if the eNVM0 or eNVM1 lower/upper protected area with W-Only or No_RW
 * access then return with protection on
 */
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    8f04:	b480      	push	{r7}
    8f06:	b085      	sub	sp, #20
    8f08:	af00      	add	r7, sp, #0
    8f0a:	6078      	str	r0, [r7, #4]
    8f0c:	6039      	str	r1, [r7, #0]
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    8f0e:	687b      	ldr	r3, [r7, #4]
    8f10:	2b01      	cmp	r3, #1
    8f12:	d106      	bne.n	8f22 <protection_check+0x1e>
    8f14:	683b      	ldr	r3, [r7, #0]
    8f16:	2b00      	cmp	r3, #0
    8f18:	d103      	bne.n	8f22 <protection_check+0x1e>
    {
        protect_flag = PROTECTION_OFF;
    8f1a:	f04f 0300 	mov.w	r3, #0
    8f1e:	60fb      	str	r3, [r7, #12]
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    8f20:	e002      	b.n	8f28 <protection_check+0x24>
    {
        protect_flag = PROTECTION_OFF;
    }
    else
    {
        protect_flag = PROTECTION_ON;
    8f22:	f04f 0301 	mov.w	r3, #1
    8f26:	60fb      	str	r3, [r7, #12]
    }
    return protect_flag;
    8f28:	68fb      	ldr	r3, [r7, #12]
}
    8f2a:	4618      	mov	r0, r3
    8f2c:	f107 0714 	add.w	r7, r7, #20
    8f30:	46bd      	mov	sp, r7
    8f32:	bc80      	pop	{r7}
    8f34:	4770      	bx	lr
    8f36:	bf00      	nop

00008f38 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    8f38:	b480      	push	{r7}
    8f3a:	b083      	sub	sp, #12
    8f3c:	af00      	add	r7, sp, #0
    8f3e:	4603      	mov	r3, r0
    8f40:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    8f42:	f24e 1300 	movw	r3, #57600	; 0xe100
    8f46:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8f4a:	f997 2007 	ldrsb.w	r2, [r7, #7]
    8f4e:	ea4f 1252 	mov.w	r2, r2, lsr #5
    8f52:	79f9      	ldrb	r1, [r7, #7]
    8f54:	f001 011f 	and.w	r1, r1, #31
    8f58:	f04f 0001 	mov.w	r0, #1
    8f5c:	fa00 f101 	lsl.w	r1, r0, r1
    8f60:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    8f64:	f107 070c 	add.w	r7, r7, #12
    8f68:	46bd      	mov	sp, r7
    8f6a:	bc80      	pop	{r7}
    8f6c:	4770      	bx	lr
    8f6e:	bf00      	nop

00008f70 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    8f70:	b480      	push	{r7}
    8f72:	b083      	sub	sp, #12
    8f74:	af00      	add	r7, sp, #0
    8f76:	4603      	mov	r3, r0
    8f78:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    8f7a:	f24e 1300 	movw	r3, #57600	; 0xe100
    8f7e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8f82:	f997 2007 	ldrsb.w	r2, [r7, #7]
    8f86:	ea4f 1252 	mov.w	r2, r2, lsr #5
    8f8a:	79f9      	ldrb	r1, [r7, #7]
    8f8c:	f001 011f 	and.w	r1, r1, #31
    8f90:	f04f 0001 	mov.w	r0, #1
    8f94:	fa00 f101 	lsl.w	r1, r0, r1
    8f98:	f102 0220 	add.w	r2, r2, #32
    8f9c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    8fa0:	f107 070c 	add.w	r7, r7, #12
    8fa4:	46bd      	mov	sp, r7
    8fa6:	bc80      	pop	{r7}
    8fa8:	4770      	bx	lr
    8faa:	bf00      	nop

00008fac <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    8fac:	b480      	push	{r7}
    8fae:	b083      	sub	sp, #12
    8fb0:	af00      	add	r7, sp, #0
    8fb2:	4603      	mov	r3, r0
    8fb4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    8fb6:	f24e 1300 	movw	r3, #57600	; 0xe100
    8fba:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8fbe:	f997 2007 	ldrsb.w	r2, [r7, #7]
    8fc2:	ea4f 1252 	mov.w	r2, r2, lsr #5
    8fc6:	79f9      	ldrb	r1, [r7, #7]
    8fc8:	f001 011f 	and.w	r1, r1, #31
    8fcc:	f04f 0001 	mov.w	r0, #1
    8fd0:	fa00 f101 	lsl.w	r1, r0, r1
    8fd4:	f102 0260 	add.w	r2, r2, #96	; 0x60
    8fd8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    8fdc:	f107 070c 	add.w	r7, r7, #12
    8fe0:	46bd      	mov	sp, r7
    8fe2:	bc80      	pop	{r7}
    8fe4:	4770      	bx	lr
    8fe6:	bf00      	nop

00008fe8 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
    8fe8:	b580      	push	{r7, lr}
    8fea:	b082      	sub	sp, #8
    8fec:	af00      	add	r7, sp, #0
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    8fee:	f248 0300 	movw	r3, #32768	; 0x8000
    8ff2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8ff6:	f248 0200 	movw	r2, #32768	; 0x8000
    8ffa:	f2c4 0203 	movt	r2, #16387	; 0x4003
    8ffe:	6c92      	ldr	r2, [r2, #72]	; 0x48
    9000:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    9004:	649a      	str	r2, [r3, #72]	; 0x48
    SYSREG->SOFT_RST_CR |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
    9006:	f248 0300 	movw	r3, #32768	; 0x8000
    900a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    900e:	f248 0200 	movw	r2, #32768	; 0x8000
    9012:	f2c4 0203 	movt	r2, #16387	; 0x4003
    9016:	6c92      	ldr	r2, [r2, #72]	; 0x48
    9018:	f042 72f0 	orr.w	r2, r2, #31457280	; 0x1e00000
    901c:	649a      	str	r2, [r3, #72]	; 0x48
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
    901e:	f04f 0300 	mov.w	r3, #0
    9022:	607b      	str	r3, [r7, #4]
    9024:	e017      	b.n	9056 <MSS_GPIO_init+0x6e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
    9026:	687a      	ldr	r2, [r7, #4]
    9028:	f64b 1360 	movw	r3, #47456	; 0xb960
    902c:	f2c0 0300 	movt	r3, #0
    9030:	5c9b      	ldrb	r3, [r3, r2]
    9032:	b25b      	sxtb	r3, r3
    9034:	4618      	mov	r0, r3
    9036:	f7ff ff9b 	bl	8f70 <NVIC_DisableIRQ>
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    903a:	687a      	ldr	r2, [r7, #4]
    903c:	f64b 1360 	movw	r3, #47456	; 0xb960
    9040:	f2c0 0300 	movt	r3, #0
    9044:	5c9b      	ldrb	r3, [r3, r2]
    9046:	b25b      	sxtb	r3, r3
    9048:	4618      	mov	r0, r3
    904a:	f7ff ffaf 	bl	8fac <NVIC_ClearPendingIRQ>
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
    904e:	687b      	ldr	r3, [r7, #4]
    9050:	f103 0301 	add.w	r3, r3, #1
    9054:	607b      	str	r3, [r7, #4]
    9056:	687b      	ldr	r3, [r7, #4]
    9058:	2b1f      	cmp	r3, #31
    905a:	d9e4      	bls.n	9026 <MSS_GPIO_init+0x3e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
    905c:	f248 0300 	movw	r3, #32768	; 0x8000
    9060:	f2c4 0303 	movt	r3, #16387	; 0x4003
    9064:	f248 0200 	movw	r2, #32768	; 0x8000
    9068:	f2c4 0203 	movt	r2, #16387	; 0x4003
    906c:	6c92      	ldr	r2, [r2, #72]	; 0x48
    906e:	f022 72f0 	bic.w	r2, r2, #31457280	; 0x1e00000
    9072:	649a      	str	r2, [r3, #72]	; 0x48
                             SYSREG_GPIO_15_8_SOFTRESET_MASK |
                             SYSREG_GPIO_23_16_SOFTRESET_MASK |
                             SYSREG_GPIO_31_24_SOFTRESET_MASK);
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
    9074:	f248 0300 	movw	r3, #32768	; 0x8000
    9078:	f2c4 0303 	movt	r3, #16387	; 0x4003
    907c:	f248 0200 	movw	r2, #32768	; 0x8000
    9080:	f2c4 0203 	movt	r2, #16387	; 0x4003
    9084:	6c92      	ldr	r2, [r2, #72]	; 0x48
    9086:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
    908a:	649a      	str	r2, [r3, #72]	; 0x48
}
    908c:	f107 0708 	add.w	r7, r7, #8
    9090:	46bd      	mov	sp, r7
    9092:	bd80      	pop	{r7, pc}

00009094 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
    9094:	b480      	push	{r7}
    9096:	b085      	sub	sp, #20
    9098:	af00      	add	r7, sp, #0
    909a:	4603      	mov	r3, r0
    909c:	6039      	str	r1, [r7, #0]
    909e:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    90a0:	79fb      	ldrb	r3, [r7, #7]
    90a2:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    90a4:	68fb      	ldr	r3, [r7, #12]
    90a6:	2b1f      	cmp	r3, #31
    90a8:	d900      	bls.n	90ac <MSS_GPIO_config+0x18>
    90aa:	be00      	bkpt	0x0000

    if(gpio_idx < NB_OF_GPIO)
    90ac:	68fb      	ldr	r3, [r7, #12]
    90ae:	2b1f      	cmp	r3, #31
    90b0:	d808      	bhi.n	90c4 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
    90b2:	68fa      	ldr	r2, [r7, #12]
    90b4:	f64b 03e0 	movw	r3, #47328	; 0xb8e0
    90b8:	f2c0 0300 	movt	r3, #0
    90bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    90c0:	683a      	ldr	r2, [r7, #0]
    90c2:	601a      	str	r2, [r3, #0]
    }
}
    90c4:	f107 0714 	add.w	r7, r7, #20
    90c8:	46bd      	mov	sp, r7
    90ca:	bc80      	pop	{r7}
    90cc:	4770      	bx	lr
    90ce:	bf00      	nop

000090d0 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t port_id,
    uint8_t value
)
{
    90d0:	b480      	push	{r7}
    90d2:	b085      	sub	sp, #20
    90d4:	af00      	add	r7, sp, #0
    90d6:	4602      	mov	r2, r0
    90d8:	460b      	mov	r3, r1
    90da:	71fa      	strb	r2, [r7, #7]
    90dc:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_setting;
    uint32_t gpio_idx = (uint32_t)port_id;
    90de:	79fb      	ldrb	r3, [r7, #7]
    90e0:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    90e2:	68fb      	ldr	r3, [r7, #12]
    90e4:	2b1f      	cmp	r3, #31
    90e6:	d900      	bls.n	90ea <MSS_GPIO_set_output+0x1a>
    90e8:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
    90ea:	68fb      	ldr	r3, [r7, #12]
    90ec:	2b1f      	cmp	r3, #31
    90ee:	d822      	bhi.n	9136 <MSS_GPIO_set_output+0x66>
    {
        gpio_setting = GPIO->GPIO_OUT;
    90f0:	f243 0300 	movw	r3, #12288	; 0x3000
    90f4:	f2c4 0301 	movt	r3, #16385	; 0x4001
    90f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    90fc:	60bb      	str	r3, [r7, #8]
        gpio_setting &= ~((uint32_t)0x01u << gpio_idx);
    90fe:	68fb      	ldr	r3, [r7, #12]
    9100:	f04f 0201 	mov.w	r2, #1
    9104:	fa02 f303 	lsl.w	r3, r2, r3
    9108:	ea6f 0303 	mvn.w	r3, r3
    910c:	68ba      	ldr	r2, [r7, #8]
    910e:	ea02 0303 	and.w	r3, r2, r3
    9112:	60bb      	str	r3, [r7, #8]
        gpio_setting |= ((uint32_t)value & 0x01u) << gpio_idx;
    9114:	79bb      	ldrb	r3, [r7, #6]
    9116:	f003 0201 	and.w	r2, r3, #1
    911a:	68fb      	ldr	r3, [r7, #12]
    911c:	fa02 f303 	lsl.w	r3, r2, r3
    9120:	68ba      	ldr	r2, [r7, #8]
    9122:	ea42 0303 	orr.w	r3, r2, r3
    9126:	60bb      	str	r3, [r7, #8]
        GPIO->GPIO_OUT = gpio_setting;
    9128:	f243 0300 	movw	r3, #12288	; 0x3000
    912c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    9130:	68ba      	ldr	r2, [r7, #8]
    9132:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }
}
    9136:	f107 0714 	add.w	r7, r7, #20
    913a:	46bd      	mov	sp, r7
    913c:	bc80      	pop	{r7}
    913e:	4770      	bx	lr

00009140 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
    9140:	b580      	push	{r7, lr}
    9142:	b084      	sub	sp, #16
    9144:	af00      	add	r7, sp, #0
    9146:	4603      	mov	r3, r0
    9148:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    914a:	79fb      	ldrb	r3, [r7, #7]
    914c:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    914e:	68fb      	ldr	r3, [r7, #12]
    9150:	2b1f      	cmp	r3, #31
    9152:	d900      	bls.n	9156 <MSS_GPIO_enable_irq+0x16>
    9154:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
    9156:	68fb      	ldr	r3, [r7, #12]
    9158:	2b1f      	cmp	r3, #31
    915a:	d81d      	bhi.n	9198 <MSS_GPIO_enable_irq+0x58>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    915c:	68fa      	ldr	r2, [r7, #12]
    915e:	f64b 03e0 	movw	r3, #47328	; 0xb8e0
    9162:	f2c0 0300 	movt	r3, #0
    9166:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    916a:	681b      	ldr	r3, [r3, #0]
    916c:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
    916e:	68fa      	ldr	r2, [r7, #12]
    9170:	f64b 03e0 	movw	r3, #47328	; 0xb8e0
    9174:	f2c0 0300 	movt	r3, #0
    9178:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    917c:	68ba      	ldr	r2, [r7, #8]
    917e:	f042 0208 	orr.w	r2, r2, #8
    9182:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ(g_gpio_irqn_lut[gpio_idx]);
    9184:	68fa      	ldr	r2, [r7, #12]
    9186:	f64b 1360 	movw	r3, #47456	; 0xb960
    918a:	f2c0 0300 	movt	r3, #0
    918e:	5c9b      	ldrb	r3, [r3, r2]
    9190:	b25b      	sxtb	r3, r3
    9192:	4618      	mov	r0, r3
    9194:	f7ff fed0 	bl	8f38 <NVIC_EnableIRQ>
    }
}
    9198:	f107 0710 	add.w	r7, r7, #16
    919c:	46bd      	mov	sp, r7
    919e:	bd80      	pop	{r7, pc}

000091a0 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
    91a0:	b480      	push	{r7}
    91a2:	b085      	sub	sp, #20
    91a4:	af00      	add	r7, sp, #0
    91a6:	4603      	mov	r3, r0
    91a8:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
    91aa:	79fb      	ldrb	r3, [r7, #7]
    91ac:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    91ae:	68fb      	ldr	r3, [r7, #12]
    91b0:	2b1f      	cmp	r3, #31
    91b2:	d900      	bls.n	91b6 <MSS_GPIO_clear_irq+0x16>
    91b4:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
    91b6:	68fb      	ldr	r3, [r7, #12]
    91b8:	2b1f      	cmp	r3, #31
    91ba:	d80a      	bhi.n	91d2 <MSS_GPIO_clear_irq+0x32>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
    91bc:	f243 0300 	movw	r3, #12288	; 0x3000
    91c0:	f2c4 0301 	movt	r3, #16385	; 0x4001
    91c4:	68fa      	ldr	r2, [r7, #12]
    91c6:	f04f 0101 	mov.w	r1, #1
    91ca:	fa01 f202 	lsl.w	r2, r1, r2
    91ce:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
    __ASM volatile ("dsb");
    91d2:	f3bf 8f4f 	dsb	sy

}
    91d6:	f107 0714 	add.w	r7, r7, #20
    91da:	46bd      	mov	sp, r7
    91dc:	bc80      	pop	{r7}
    91de:	4770      	bx	lr

000091e0 <TMR_init>:
    addr_t address,
    uint8_t mode,
    uint32_t prescale,
    uint32_t load_value
)
{
    91e0:	b580      	push	{r7, lr}
    91e2:	b084      	sub	sp, #16
    91e4:	af00      	add	r7, sp, #0
    91e6:	60f8      	str	r0, [r7, #12]
    91e8:	60b9      	str	r1, [r7, #8]
    91ea:	603b      	str	r3, [r7, #0]
    91ec:	4613      	mov	r3, r2
    91ee:	71fb      	strb	r3, [r7, #7]
    HAL_ASSERT( this_timer != NULL_timer_instance )
    91f0:	f24b 339c 	movw	r3, #45980	; 0xb39c
    91f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    91f8:	681b      	ldr	r3, [r3, #0]
    91fa:	68fa      	ldr	r2, [r7, #12]
    91fc:	429a      	cmp	r2, r3
    91fe:	d100      	bne.n	9202 <TMR_init+0x22>
    9200:	be00      	bkpt	0x0000
    HAL_ASSERT( prescale <= PRESCALER_DIV_1024 )
    9202:	683b      	ldr	r3, [r7, #0]
    9204:	2b09      	cmp	r3, #9
    9206:	d900      	bls.n	920a <TMR_init+0x2a>
    9208:	be00      	bkpt	0x0000
    HAL_ASSERT( load_value != 0 )
    920a:	69bb      	ldr	r3, [r7, #24]
    920c:	2b00      	cmp	r3, #0
    920e:	d100      	bne.n	9212 <TMR_init+0x32>
    9210:	be00      	bkpt	0x0000
    
    this_timer->base_address = address;
    9212:	68fb      	ldr	r3, [r7, #12]
    9214:	68ba      	ldr	r2, [r7, #8]
    9216:	601a      	str	r2, [r3, #0]

    /* Disable interrupts. */
    HAL_set_32bit_reg_field( address, InterruptEnable,0 );
    9218:	68bb      	ldr	r3, [r7, #8]
    921a:	f103 0308 	add.w	r3, r3, #8
    921e:	4618      	mov	r0, r3
    9220:	f04f 0101 	mov.w	r1, #1
    9224:	f04f 0202 	mov.w	r2, #2
    9228:	f04f 0300 	mov.w	r3, #0
    922c:	f7fd f916 	bl	645c <HW_set_32bit_reg_field>

    /* Disable timer. */
    HAL_set_32bit_reg_field( address, TimerEnable, 0 );
    9230:	68bb      	ldr	r3, [r7, #8]
    9232:	f103 0308 	add.w	r3, r3, #8
    9236:	4618      	mov	r0, r3
    9238:	f04f 0100 	mov.w	r1, #0
    923c:	f04f 0201 	mov.w	r2, #1
    9240:	f04f 0300 	mov.w	r3, #0
    9244:	f7fd f90a 	bl	645c <HW_set_32bit_reg_field>

    /* Clear pending interrupt. */
    HAL_set_32bit_reg( address, TimerIntClr, 1 );
    9248:	68bb      	ldr	r3, [r7, #8]
    924a:	f103 0310 	add.w	r3, r3, #16
    924e:	4618      	mov	r0, r3
    9250:	f04f 0101 	mov.w	r1, #1
    9254:	f7fd f8fe 	bl	6454 <HW_set_32bit_reg>

    /* Configure prescaler and load value. */    
    HAL_set_32bit_reg( address, TimerPrescale, prescale );
    9258:	68bb      	ldr	r3, [r7, #8]
    925a:	f103 030c 	add.w	r3, r3, #12
    925e:	4618      	mov	r0, r3
    9260:	6839      	ldr	r1, [r7, #0]
    9262:	f7fd f8f7 	bl	6454 <HW_set_32bit_reg>
    HAL_set_32bit_reg( address, TimerLoad, load_value );
    9266:	68b8      	ldr	r0, [r7, #8]
    9268:	69b9      	ldr	r1, [r7, #24]
    926a:	f7fd f8f3 	bl	6454 <HW_set_32bit_reg>

    /* Set the interrupt mode. */
    if ( mode == TMR_CONTINUOUS_MODE )
    926e:	79fb      	ldrb	r3, [r7, #7]
    9270:	2b00      	cmp	r3, #0
    9272:	d10c      	bne.n	928e <TMR_init+0xae>
    {
        HAL_set_32bit_reg_field( address, TimerMode, 0 );
    9274:	68bb      	ldr	r3, [r7, #8]
    9276:	f103 0308 	add.w	r3, r3, #8
    927a:	4618      	mov	r0, r3
    927c:	f04f 0102 	mov.w	r1, #2
    9280:	f04f 0204 	mov.w	r2, #4
    9284:	f04f 0300 	mov.w	r3, #0
    9288:	f7fd f8e8 	bl	645c <HW_set_32bit_reg_field>
    928c:	e00b      	b.n	92a6 <TMR_init+0xc6>
    }
    else
    {
        /* TMR_ONE_SHOT_MODE */
        HAL_set_32bit_reg_field( address, TimerMode, 1 );
    928e:	68bb      	ldr	r3, [r7, #8]
    9290:	f103 0308 	add.w	r3, r3, #8
    9294:	4618      	mov	r0, r3
    9296:	f04f 0102 	mov.w	r1, #2
    929a:	f04f 0204 	mov.w	r2, #4
    929e:	f04f 0301 	mov.w	r3, #1
    92a2:	f7fd f8db 	bl	645c <HW_set_32bit_reg_field>
    }
}
    92a6:	f107 0710 	add.w	r7, r7, #16
    92aa:	46bd      	mov	sp, r7
    92ac:	bd80      	pop	{r7, pc}
    92ae:	bf00      	nop

000092b0 <TMR_start>:
void
TMR_start
(
    timer_instance_t * this_timer
)
{
    92b0:	b580      	push	{r7, lr}
    92b2:	b082      	sub	sp, #8
    92b4:	af00      	add	r7, sp, #0
    92b6:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
    92b8:	f24b 339c 	movw	r3, #45980	; 0xb39c
    92bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    92c0:	681b      	ldr	r3, [r3, #0]
    92c2:	687a      	ldr	r2, [r7, #4]
    92c4:	429a      	cmp	r2, r3
    92c6:	d100      	bne.n	92ca <TMR_start+0x1a>
    92c8:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, TimerEnable, 1 );
    92ca:	687b      	ldr	r3, [r7, #4]
    92cc:	681b      	ldr	r3, [r3, #0]
    92ce:	f103 0308 	add.w	r3, r3, #8
    92d2:	4618      	mov	r0, r3
    92d4:	f04f 0100 	mov.w	r1, #0
    92d8:	f04f 0201 	mov.w	r2, #1
    92dc:	f04f 0301 	mov.w	r3, #1
    92e0:	f7fd f8bc 	bl	645c <HW_set_32bit_reg_field>
}
    92e4:	f107 0708 	add.w	r7, r7, #8
    92e8:	46bd      	mov	sp, r7
    92ea:	bd80      	pop	{r7, pc}

000092ec <TMR_stop>:
void
TMR_stop
(
    timer_instance_t * this_timer
)
{
    92ec:	b580      	push	{r7, lr}
    92ee:	b082      	sub	sp, #8
    92f0:	af00      	add	r7, sp, #0
    92f2:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
    92f4:	f24b 339c 	movw	r3, #45980	; 0xb39c
    92f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    92fc:	681b      	ldr	r3, [r3, #0]
    92fe:	687a      	ldr	r2, [r7, #4]
    9300:	429a      	cmp	r2, r3
    9302:	d100      	bne.n	9306 <TMR_stop+0x1a>
    9304:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, TimerEnable, 0 );
    9306:	687b      	ldr	r3, [r7, #4]
    9308:	681b      	ldr	r3, [r3, #0]
    930a:	f103 0308 	add.w	r3, r3, #8
    930e:	4618      	mov	r0, r3
    9310:	f04f 0100 	mov.w	r1, #0
    9314:	f04f 0201 	mov.w	r2, #1
    9318:	f04f 0300 	mov.w	r3, #0
    931c:	f7fd f89e 	bl	645c <HW_set_32bit_reg_field>
}
    9320:	f107 0708 	add.w	r7, r7, #8
    9324:	46bd      	mov	sp, r7
    9326:	bd80      	pop	{r7, pc}

00009328 <TMR_enable_int>:
void
TMR_enable_int
(
    timer_instance_t * this_timer
)
{
    9328:	b580      	push	{r7, lr}
    932a:	b082      	sub	sp, #8
    932c:	af00      	add	r7, sp, #0
    932e:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
    9330:	f24b 339c 	movw	r3, #45980	; 0xb39c
    9334:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9338:	681b      	ldr	r3, [r3, #0]
    933a:	687a      	ldr	r2, [r7, #4]
    933c:	429a      	cmp	r2, r3
    933e:	d100      	bne.n	9342 <TMR_enable_int+0x1a>
    9340:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, InterruptEnable, 1 );
    9342:	687b      	ldr	r3, [r7, #4]
    9344:	681b      	ldr	r3, [r3, #0]
    9346:	f103 0308 	add.w	r3, r3, #8
    934a:	4618      	mov	r0, r3
    934c:	f04f 0101 	mov.w	r1, #1
    9350:	f04f 0202 	mov.w	r2, #2
    9354:	f04f 0301 	mov.w	r3, #1
    9358:	f7fd f880 	bl	645c <HW_set_32bit_reg_field>
}
    935c:	f107 0708 	add.w	r7, r7, #8
    9360:	46bd      	mov	sp, r7
    9362:	bd80      	pop	{r7, pc}

00009364 <TMR_clear_int>:
void
TMR_clear_int
(
    timer_instance_t * this_timer
)
{
    9364:	b580      	push	{r7, lr}
    9366:	b082      	sub	sp, #8
    9368:	af00      	add	r7, sp, #0
    936a:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
    936c:	f24b 339c 	movw	r3, #45980	; 0xb39c
    9370:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9374:	681b      	ldr	r3, [r3, #0]
    9376:	687a      	ldr	r2, [r7, #4]
    9378:	429a      	cmp	r2, r3
    937a:	d100      	bne.n	937e <TMR_clear_int+0x1a>
    937c:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg( this_timer->base_address, TimerIntClr, 0x01 );
    937e:	687b      	ldr	r3, [r7, #4]
    9380:	681b      	ldr	r3, [r3, #0]
    9382:	f103 0310 	add.w	r3, r3, #16
    9386:	4618      	mov	r0, r3
    9388:	f04f 0101 	mov.w	r1, #1
    938c:	f7fd f862 	bl	6454 <HW_set_32bit_reg>
}
    9390:	f107 0708 	add.w	r7, r7, #8
    9394:	46bd      	mov	sp, r7
    9396:	bd80      	pop	{r7, pc}

00009398 <SPI_init>:
(
    spi_instance_t * this_spi,
    addr_t base_addr,
    uint16_t fifo_depth
)
{
    9398:	b580      	push	{r7, lr}
    939a:	b084      	sub	sp, #16
    939c:	af00      	add	r7, sp, #0
    939e:	60f8      	str	r0, [r7, #12]
    93a0:	60b9      	str	r1, [r7, #8]
    93a2:	4613      	mov	r3, r2
    93a4:	80fb      	strh	r3, [r7, #6]
    HAL_ASSERT( NULL_INSTANCE != this_spi );
    93a6:	68fb      	ldr	r3, [r7, #12]
    93a8:	2b00      	cmp	r3, #0
    93aa:	d100      	bne.n	93ae <SPI_init+0x16>
    93ac:	be00      	bkpt	0x0000
    HAL_ASSERT( NULL_ADDR != base_addr );
    93ae:	68bb      	ldr	r3, [r7, #8]
    93b0:	2b00      	cmp	r3, #0
    93b2:	d100      	bne.n	93b6 <SPI_init+0x1e>
    93b4:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_FIFO_DEPTH  >= fifo_depth );
    93b6:	88fb      	ldrh	r3, [r7, #6]
    93b8:	2b20      	cmp	r3, #32
    93ba:	d900      	bls.n	93be <SPI_init+0x26>
    93bc:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MIN_FIFO_DEPTH  <= fifo_depth );
    93be:	88fb      	ldrh	r3, [r7, #6]
    93c0:	2b00      	cmp	r3, #0
    93c2:	d100      	bne.n	93c6 <SPI_init+0x2e>
    93c4:	be00      	bkpt	0x0000

    if( ( NULL_INSTANCE != this_spi ) && ( base_addr != NULL_ADDR ) )
    93c6:	68fb      	ldr	r3, [r7, #12]
    93c8:	2b00      	cmp	r3, #0
    93ca:	d052      	beq.n	9472 <SPI_init+0xda>
    93cc:	68bb      	ldr	r3, [r7, #8]
    93ce:	2b00      	cmp	r3, #0
    93d0:	d04f      	beq.n	9472 <SPI_init+0xda>
         * Relies on the fact that byte filling with 0x00 will equate
         * to 0 for any non byte sized items too.
         */

        /* First fill struct with 0s */
        memset( this_spi, 0, sizeof(spi_instance_t) );
    93d2:	68f8      	ldr	r0, [r7, #12]
    93d4:	f04f 0100 	mov.w	r1, #0
    93d8:	f04f 0248 	mov.w	r2, #72	; 0x48
    93dc:	f002 f9f6 	bl	b7cc <memset>

        /* Configure CoreSPI instance attributes */
        this_spi->base_addr = (addr_t)base_addr;
    93e0:	68fb      	ldr	r3, [r7, #12]
    93e2:	68ba      	ldr	r2, [r7, #8]
    93e4:	601a      	str	r2, [r3, #0]

        /* Store FIFO depth or fall back to minimum if out of range */
        if( ( SPI_MAX_FIFO_DEPTH  >= fifo_depth ) && ( SPI_MIN_FIFO_DEPTH  <= fifo_depth ) )
    93e6:	88fb      	ldrh	r3, [r7, #6]
    93e8:	2b20      	cmp	r3, #32
    93ea:	d807      	bhi.n	93fc <SPI_init+0x64>
    93ec:	88fb      	ldrh	r3, [r7, #6]
    93ee:	2b00      	cmp	r3, #0
    93f0:	d004      	beq.n	93fc <SPI_init+0x64>
        {
            this_spi->fifo_depth = fifo_depth;
    93f2:	68fb      	ldr	r3, [r7, #12]
    93f4:	88fa      	ldrh	r2, [r7, #6]
    93f6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

        /* Configure CoreSPI instance attributes */
        this_spi->base_addr = (addr_t)base_addr;

        /* Store FIFO depth or fall back to minimum if out of range */
        if( ( SPI_MAX_FIFO_DEPTH  >= fifo_depth ) && ( SPI_MIN_FIFO_DEPTH  <= fifo_depth ) )
    93fa:	e004      	b.n	9406 <SPI_init+0x6e>
        {
            this_spi->fifo_depth = fifo_depth;
        }
        else
        {
            this_spi->fifo_depth = SPI_MIN_FIFO_DEPTH;
    93fc:	68fb      	ldr	r3, [r7, #12]
    93fe:	f04f 0201 	mov.w	r2, #1
    9402:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        }
        /* Make sure the CoreSPI is disabled while we configure it */
        HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
    9406:	68fb      	ldr	r3, [r7, #12]
    9408:	681b      	ldr	r3, [r3, #0]
    940a:	4618      	mov	r0, r3
    940c:	f04f 0100 	mov.w	r1, #0
    9410:	f04f 0201 	mov.w	r2, #1
    9414:	f04f 0300 	mov.w	r3, #0
    9418:	f7fd f850 	bl	64bc <HW_set_8bit_reg_field>

        /* Ensure all slaves are deselected */
        HAL_set_8bit_reg( this_spi->base_addr, SSEL, 0u );
    941c:	68fb      	ldr	r3, [r7, #12]
    941e:	681b      	ldr	r3, [r3, #0]
    9420:	f103 0324 	add.w	r3, r3, #36	; 0x24
    9424:	4618      	mov	r0, r3
    9426:	f04f 0100 	mov.w	r1, #0
    942a:	f7fd f843 	bl	64b4 <HW_set_8bit_reg>

        /* Flush the receive and transmit FIFOs*/
        HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
    942e:	68fb      	ldr	r3, [r7, #12]
    9430:	681b      	ldr	r3, [r3, #0]
    9432:	f103 031c 	add.w	r3, r3, #28
    9436:	4618      	mov	r0, r3
    9438:	f04f 0103 	mov.w	r1, #3
    943c:	f7fd f83a 	bl	64b4 <HW_set_8bit_reg>

        /* Clear all interrupts */
        HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
    9440:	68fb      	ldr	r3, [r7, #12]
    9442:	681b      	ldr	r3, [r3, #0]
    9444:	f103 0304 	add.w	r3, r3, #4
    9448:	4618      	mov	r0, r3
    944a:	f04f 01ff 	mov.w	r1, #255	; 0xff
    944e:	f7fd f831 	bl	64b4 <HW_set_8bit_reg>

        /* Ensure RXAVAIL, TXRFM, SSEND and CMDINT are disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL2, 0u );
    9452:	68fb      	ldr	r3, [r7, #12]
    9454:	681b      	ldr	r3, [r3, #0]
    9456:	f103 0318 	add.w	r3, r3, #24
    945a:	4618      	mov	r0, r3
    945c:	f04f 0100 	mov.w	r1, #0
    9460:	f7fd f828 	bl	64b4 <HW_set_8bit_reg>
        /*
         * Enable the CoreSPI in the reset default of master mode
         * with TXUNDERRUN, RXOVFLOW and TXDONE interrupts disabled.
         * The driver does not currently use interrupts in master mode.
         */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL1,  ENABLE | CTRL1_MASTER_MASK );
    9464:	68fb      	ldr	r3, [r7, #12]
    9466:	681b      	ldr	r3, [r3, #0]
    9468:	4618      	mov	r0, r3
    946a:	f04f 0103 	mov.w	r1, #3
    946e:	f7fd f821 	bl	64b4 <HW_set_8bit_reg>
    }
}
    9472:	f107 0710 	add.w	r7, r7, #16
    9476:	46bd      	mov	sp, r7
    9478:	bd80      	pop	{r7, pc}
    947a:	bf00      	nop

0000947c <SPI_configure_master_mode>:
 */
void SPI_configure_master_mode
(
    spi_instance_t * this_spi
)
{
    947c:	b580      	push	{r7, lr}
    947e:	b082      	sub	sp, #8
    9480:	af00      	add	r7, sp, #0
    9482:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( NULL_INSTANCE != this_spi );
    9484:	687b      	ldr	r3, [r7, #4]
    9486:	2b00      	cmp	r3, #0
    9488:	d100      	bne.n	948c <SPI_configure_master_mode+0x10>
    948a:	be00      	bkpt	0x0000
    
    if( NULL_INSTANCE != this_spi )
    948c:	687b      	ldr	r3, [r7, #4]
    948e:	2b00      	cmp	r3, #0
    9490:	d031      	beq.n	94f6 <SPI_configure_master_mode+0x7a>
    {
        /* Disable the CoreSPI for a little while, while we configure the CoreSPI */
        HAL_set_8bit_reg_field(this_spi->base_addr, CTRL1_ENABLE, DISABLE);
    9492:	687b      	ldr	r3, [r7, #4]
    9494:	681b      	ldr	r3, [r3, #0]
    9496:	4618      	mov	r0, r3
    9498:	f04f 0100 	mov.w	r1, #0
    949c:	f04f 0201 	mov.w	r2, #1
    94a0:	f04f 0300 	mov.w	r3, #0
    94a4:	f7fd f80a 	bl	64bc <HW_set_8bit_reg_field>

        /* Reset slave transfer mode to unknown in case it has been set previously */
        this_spi->slave_xfer_mode = SPI_SLAVE_XFER_NONE;
    94a8:	687b      	ldr	r3, [r7, #4]
    94aa:	f04f 0200 	mov.w	r2, #0
    94ae:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

        /* Flush the receive and transmit FIFOs*/
        HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
    94b2:	687b      	ldr	r3, [r7, #4]
    94b4:	681b      	ldr	r3, [r3, #0]
    94b6:	f103 031c 	add.w	r3, r3, #28
    94ba:	4618      	mov	r0, r3
    94bc:	f04f 0103 	mov.w	r1, #3
    94c0:	f7fc fff8 	bl	64b4 <HW_set_8bit_reg>

        /* Clear all interrupts */
        HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
    94c4:	687b      	ldr	r3, [r7, #4]
    94c6:	681b      	ldr	r3, [r3, #0]
    94c8:	f103 0304 	add.w	r3, r3, #4
    94cc:	4618      	mov	r0, r3
    94ce:	f04f 01ff 	mov.w	r1, #255	; 0xff
    94d2:	f7fc ffef 	bl	64b4 <HW_set_8bit_reg>

        /* Ensure RXAVAIL, TXRFM, SSEND and CMDINT are disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL2, 0u );
    94d6:	687b      	ldr	r3, [r7, #4]
    94d8:	681b      	ldr	r3, [r3, #0]
    94da:	f103 0318 	add.w	r3, r3, #24
    94de:	4618      	mov	r0, r3
    94e0:	f04f 0100 	mov.w	r1, #0
    94e4:	f7fc ffe6 	bl	64b4 <HW_set_8bit_reg>

        /* Enable the CoreSPI in master mode with TXUNDERRUN, RXOVFLOW and TXDONE interrupts disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL1, ENABLE | CTRL1_MASTER_MASK );
    94e8:	687b      	ldr	r3, [r7, #4]
    94ea:	681b      	ldr	r3, [r3, #0]
    94ec:	4618      	mov	r0, r3
    94ee:	f04f 0103 	mov.w	r1, #3
    94f2:	f7fc ffdf 	bl	64b4 <HW_set_8bit_reg>
    }
}
    94f6:	f107 0708 	add.w	r7, r7, #8
    94fa:	46bd      	mov	sp, r7
    94fc:	bd80      	pop	{r7, pc}
    94fe:	bf00      	nop

00009500 <SPI_set_slave_select>:
void SPI_set_slave_select
(
    spi_instance_t * this_spi,
    spi_slave_t slave
)
{
    9500:	b580      	push	{r7, lr}
    9502:	b084      	sub	sp, #16
    9504:	af00      	add	r7, sp, #0
    9506:	6078      	str	r0, [r7, #4]
    9508:	460b      	mov	r3, r1
    950a:	70fb      	strb	r3, [r7, #3]
    spi_slave_t temp = (spi_slave_t)(0x00u) ;
    950c:	f04f 0300 	mov.w	r3, #0
    9510:	73fb      	strb	r3, [r7, #15]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
    9512:	687b      	ldr	r3, [r7, #4]
    9514:	2b00      	cmp	r3, #0
    9516:	d100      	bne.n	951a <SPI_set_slave_select+0x1a>
    9518:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_NB_OF_SLAVES > slave );
    951a:	78fb      	ldrb	r3, [r7, #3]
    951c:	2b07      	cmp	r3, #7
    951e:	d900      	bls.n	9522 <SPI_set_slave_select+0x22>
    9520:	be00      	bkpt	0x0000
    
    if( ( NULL_INSTANCE != this_spi ) && ( SPI_MAX_NB_OF_SLAVES > slave ) )
    9522:	687b      	ldr	r3, [r7, #4]
    9524:	2b00      	cmp	r3, #0
    9526:	d03a      	beq.n	959e <SPI_set_slave_select+0x9e>
    9528:	78fb      	ldrb	r3, [r7, #3]
    952a:	2b07      	cmp	r3, #7
    952c:	d837      	bhi.n	959e <SPI_set_slave_select+0x9e>
    {
        /* This function is only intended to be used with an SPI master */
        if( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) )
    952e:	687b      	ldr	r3, [r7, #4]
    9530:	681b      	ldr	r3, [r3, #0]
    9532:	4618      	mov	r0, r3
    9534:	f04f 0101 	mov.w	r1, #1
    9538:	f04f 0202 	mov.w	r2, #2
    953c:	f7fc ffcc 	bl	64d8 <HW_get_8bit_reg_field>
    9540:	4603      	mov	r3, r0
    9542:	2b00      	cmp	r3, #0
    9544:	d02b      	beq.n	959e <SPI_set_slave_select+0x9e>
        {
            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW ) )
    9546:	687b      	ldr	r3, [r7, #4]
    9548:	681b      	ldr	r3, [r3, #0]
    954a:	f103 0320 	add.w	r3, r3, #32
    954e:	4618      	mov	r0, r3
    9550:	f04f 0104 	mov.w	r1, #4
    9554:	f04f 0210 	mov.w	r2, #16
    9558:	f7fc ffbe 	bl	64d8 <HW_get_8bit_reg_field>
    955c:	4603      	mov	r3, r0
    955e:	2b01      	cmp	r3, #1
    9560:	d102      	bne.n	9568 <SPI_set_slave_select+0x68>
            {
                 recover_from_rx_overflow( this_spi );
    9562:	6878      	ldr	r0, [r7, #4]
    9564:	f000 fa76 	bl	9a54 <recover_from_rx_overflow>
            }
            /* Set the correct slave select bit */
            temp = (spi_slave_t)( HAL_get_8bit_reg( this_spi->base_addr, SSEL ) | ((uint32_t)1u << (uint32_t)slave) );
    9568:	687b      	ldr	r3, [r7, #4]
    956a:	681b      	ldr	r3, [r3, #0]
    956c:	f103 0324 	add.w	r3, r3, #36	; 0x24
    9570:	4618      	mov	r0, r3
    9572:	f7fc ffa1 	bl	64b8 <HW_get_8bit_reg>
    9576:	4603      	mov	r3, r0
    9578:	461a      	mov	r2, r3
    957a:	78fb      	ldrb	r3, [r7, #3]
    957c:	f04f 0101 	mov.w	r1, #1
    9580:	fa01 f303 	lsl.w	r3, r1, r3
    9584:	b2db      	uxtb	r3, r3
    9586:	ea42 0303 	orr.w	r3, r2, r3
    958a:	73fb      	strb	r3, [r7, #15]
            HAL_set_8bit_reg( this_spi->base_addr, SSEL, (uint_fast8_t)temp );
    958c:	687b      	ldr	r3, [r7, #4]
    958e:	681b      	ldr	r3, [r3, #0]
    9590:	f103 0224 	add.w	r2, r3, #36	; 0x24
    9594:	7bfb      	ldrb	r3, [r7, #15]
    9596:	4610      	mov	r0, r2
    9598:	4619      	mov	r1, r3
    959a:	f7fc ff8b 	bl	64b4 <HW_set_8bit_reg>
        }
    }
}
    959e:	f107 0710 	add.w	r7, r7, #16
    95a2:	46bd      	mov	sp, r7
    95a4:	bd80      	pop	{r7, pc}
    95a6:	bf00      	nop

000095a8 <SPI_clear_slave_select>:
void SPI_clear_slave_select
(
    spi_instance_t * this_spi,
    spi_slave_t slave
)
{
    95a8:	b580      	push	{r7, lr}
    95aa:	b084      	sub	sp, #16
    95ac:	af00      	add	r7, sp, #0
    95ae:	6078      	str	r0, [r7, #4]
    95b0:	460b      	mov	r3, r1
    95b2:	70fb      	strb	r3, [r7, #3]
    spi_slave_t temp = (spi_slave_t) (0x00u) ;
    95b4:	f04f 0300 	mov.w	r3, #0
    95b8:	73fb      	strb	r3, [r7, #15]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
    95ba:	687b      	ldr	r3, [r7, #4]
    95bc:	2b00      	cmp	r3, #0
    95be:	d100      	bne.n	95c2 <SPI_clear_slave_select+0x1a>
    95c0:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_NB_OF_SLAVES > slave );
    95c2:	78fb      	ldrb	r3, [r7, #3]
    95c4:	2b07      	cmp	r3, #7
    95c6:	d900      	bls.n	95ca <SPI_clear_slave_select+0x22>
    95c8:	be00      	bkpt	0x0000
    
    if( ( NULL_INSTANCE != this_spi ) && ( SPI_MAX_NB_OF_SLAVES > slave ) )
    95ca:	687b      	ldr	r3, [r7, #4]
    95cc:	2b00      	cmp	r3, #0
    95ce:	d03d      	beq.n	964c <SPI_clear_slave_select+0xa4>
    95d0:	78fb      	ldrb	r3, [r7, #3]
    95d2:	2b07      	cmp	r3, #7
    95d4:	d83a      	bhi.n	964c <SPI_clear_slave_select+0xa4>
    {
        /* This function is only intended to be used with an SPI master. */
        if( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) )
    95d6:	687b      	ldr	r3, [r7, #4]
    95d8:	681b      	ldr	r3, [r3, #0]
    95da:	4618      	mov	r0, r3
    95dc:	f04f 0101 	mov.w	r1, #1
    95e0:	f04f 0202 	mov.w	r2, #2
    95e4:	f7fc ff78 	bl	64d8 <HW_get_8bit_reg_field>
    95e8:	4603      	mov	r3, r0
    95ea:	2b00      	cmp	r3, #0
    95ec:	d02e      	beq.n	964c <SPI_clear_slave_select+0xa4>
        {
            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW) )
    95ee:	687b      	ldr	r3, [r7, #4]
    95f0:	681b      	ldr	r3, [r3, #0]
    95f2:	f103 0320 	add.w	r3, r3, #32
    95f6:	4618      	mov	r0, r3
    95f8:	f04f 0104 	mov.w	r1, #4
    95fc:	f04f 0210 	mov.w	r2, #16
    9600:	f7fc ff6a 	bl	64d8 <HW_get_8bit_reg_field>
    9604:	4603      	mov	r3, r0
    9606:	2b01      	cmp	r3, #1
    9608:	d102      	bne.n	9610 <SPI_clear_slave_select+0x68>
            {
                 recover_from_rx_overflow( this_spi );
    960a:	6878      	ldr	r0, [r7, #4]
    960c:	f000 fa22 	bl	9a54 <recover_from_rx_overflow>
            }
            /* Clear the correct slave select bit */
            temp = (spi_slave_t)( HAL_get_8bit_reg( this_spi->base_addr, SSEL ) & ~((uint32_t)1u << (uint32_t)slave) );
    9610:	687b      	ldr	r3, [r7, #4]
    9612:	681b      	ldr	r3, [r3, #0]
    9614:	f103 0324 	add.w	r3, r3, #36	; 0x24
    9618:	4618      	mov	r0, r3
    961a:	f7fc ff4d 	bl	64b8 <HW_get_8bit_reg>
    961e:	4603      	mov	r3, r0
    9620:	461a      	mov	r2, r3
    9622:	78fb      	ldrb	r3, [r7, #3]
    9624:	f04f 0101 	mov.w	r1, #1
    9628:	fa01 f303 	lsl.w	r3, r1, r3
    962c:	b2db      	uxtb	r3, r3
    962e:	ea6f 0303 	mvn.w	r3, r3
    9632:	b2db      	uxtb	r3, r3
    9634:	ea02 0303 	and.w	r3, r2, r3
    9638:	73fb      	strb	r3, [r7, #15]
            HAL_set_8bit_reg( this_spi->base_addr, SSEL, (uint_fast8_t)temp ) ;
    963a:	687b      	ldr	r3, [r7, #4]
    963c:	681b      	ldr	r3, [r3, #0]
    963e:	f103 0224 	add.w	r2, r3, #36	; 0x24
    9642:	7bfb      	ldrb	r3, [r7, #15]
    9644:	4610      	mov	r0, r2
    9646:	4619      	mov	r1, r3
    9648:	f7fc ff34 	bl	64b4 <HW_set_8bit_reg>
        }
    }
}
    964c:	f107 0710 	add.w	r7, r7, #16
    9650:	46bd      	mov	sp, r7
    9652:	bd80      	pop	{r7, pc}

00009654 <SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rx_buffer,
    uint16_t rx_byte_size
)
{
    9654:	b590      	push	{r4, r7, lr}
    9656:	b089      	sub	sp, #36	; 0x24
    9658:	af00      	add	r7, sp, #0
    965a:	60f8      	str	r0, [r7, #12]
    965c:	60b9      	str	r1, [r7, #8]
    965e:	603b      	str	r3, [r7, #0]
    9660:	4613      	mov	r3, r2
    9662:	80fb      	strh	r3, [r7, #6]
    uint32_t transfer_size = 0U;   /* Total number of bytes to  transfer. */
    9664:	f04f 0300 	mov.w	r3, #0
    9668:	617b      	str	r3, [r7, #20]
    uint16_t transfer_idx = 0U;    /* Number of bytes transferred so far */
    966a:	f04f 0300 	mov.w	r3, #0
    966e:	833b      	strh	r3, [r7, #24]
    uint16_t tx_idx = 0u;          /* Number of valid data bytes sent */
    9670:	f04f 0300 	mov.w	r3, #0
    9674:	837b      	strh	r3, [r7, #26]
    uint16_t rx_idx = 0u;          /* Number of valid response bytes received */
    9676:	f04f 0300 	mov.w	r3, #0
    967a:	83bb      	strh	r3, [r7, #28]
    uint16_t transit = 0U;         /* Number of bytes "in flight" to avoid FIFO errors */
    967c:	f04f 0300 	mov.w	r3, #0
    9680:	83fb      	strh	r3, [r7, #30]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
    9682:	68fb      	ldr	r3, [r7, #12]
    9684:	2b00      	cmp	r3, #0
    9686:	d100      	bne.n	968a <SPI_transfer_block+0x36>
    9688:	be00      	bkpt	0x0000

    if( NULL_INSTANCE != this_spi )
    968a:	68fb      	ldr	r3, [r7, #12]
    968c:	2b00      	cmp	r3, #0
    968e:	f000 81dd 	beq.w	9a4c <SPI_transfer_block+0x3f8>
    {
        /* This function is only intended to be used with an SPI master. */
        if( ( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) ) &&
    9692:	68fb      	ldr	r3, [r7, #12]
    9694:	681b      	ldr	r3, [r3, #0]
    9696:	4618      	mov	r0, r3
    9698:	f04f 0101 	mov.w	r1, #1
    969c:	f04f 0202 	mov.w	r2, #2
    96a0:	f7fc ff1a 	bl	64d8 <HW_get_8bit_reg_field>
    96a4:	4603      	mov	r3, r0
    96a6:	2b00      	cmp	r3, #0
    96a8:	f000 81d0 	beq.w	9a4c <SPI_transfer_block+0x3f8>
            /* Check for empty transfer as well */
            ( 0u != ( (uint32_t)cmd_byte_size + (uint32_t)rx_byte_size ) ) )
    96ac:	88fa      	ldrh	r2, [r7, #6]
    96ae:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    96b0:	4413      	add	r3, r2
    HAL_ASSERT( NULL_INSTANCE != this_spi );

    if( NULL_INSTANCE != this_spi )
    {
        /* This function is only intended to be used with an SPI master. */
        if( ( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) ) &&
    96b2:	2b00      	cmp	r3, #0
    96b4:	f000 81ca 	beq.w	9a4c <SPI_transfer_block+0x3f8>
            /*
             * tansfer_size is one less than the real amount as we have to write
             * the last frame separately to trigger the slave deselect in case
             * the SPS option is in place.
             */
            transfer_size = ( (uint32_t)cmd_byte_size + (uint32_t)rx_byte_size ) - 1u;
    96b8:	88fa      	ldrh	r2, [r7, #6]
    96ba:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    96bc:	4413      	add	r3, r2
    96be:	f103 33ff 	add.w	r3, r3, #4294967295
    96c2:	617b      	str	r3, [r7, #20]
            /* Flush the receive and transmit FIFOs */
            HAL_set_8bit_reg(this_spi->base_addr, CMD, (uint32_t)(CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK ));
    96c4:	68fb      	ldr	r3, [r7, #12]
    96c6:	681b      	ldr	r3, [r3, #0]
    96c8:	f103 031c 	add.w	r3, r3, #28
    96cc:	4618      	mov	r0, r3
    96ce:	f04f 0103 	mov.w	r1, #3
    96d2:	f7fc feef 	bl	64b4 <HW_set_8bit_reg>

            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW) )
    96d6:	68fb      	ldr	r3, [r7, #12]
    96d8:	681b      	ldr	r3, [r3, #0]
    96da:	f103 0320 	add.w	r3, r3, #32
    96de:	4618      	mov	r0, r3
    96e0:	f04f 0104 	mov.w	r1, #4
    96e4:	f04f 0210 	mov.w	r2, #16
    96e8:	f7fc fef6 	bl	64d8 <HW_get_8bit_reg_field>
    96ec:	4603      	mov	r3, r0
    96ee:	2b01      	cmp	r3, #1
    96f0:	d102      	bne.n	96f8 <SPI_transfer_block+0xa4>
            {
                 recover_from_rx_overflow( this_spi );
    96f2:	68f8      	ldr	r0, [r7, #12]
    96f4:	f000 f9ae 	bl	9a54 <recover_from_rx_overflow>
            }

            /* Disable the Core SPI for a little bit, while we load the TX FIFO */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
    96f8:	68fb      	ldr	r3, [r7, #12]
    96fa:	681b      	ldr	r3, [r3, #0]
    96fc:	4618      	mov	r0, r3
    96fe:	f04f 0100 	mov.w	r1, #0
    9702:	f04f 0201 	mov.w	r2, #1
    9706:	f04f 0300 	mov.w	r3, #0
    970a:	f7fc fed7 	bl	64bc <HW_set_8bit_reg_field>

            while( ( tx_idx < transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
    970e:	e021      	b.n	9754 <SPI_transfer_block+0x100>
            {
                if( tx_idx < cmd_byte_size )
    9710:	8b7a      	ldrh	r2, [r7, #26]
    9712:	88fb      	ldrh	r3, [r7, #6]
    9714:	429a      	cmp	r2, r3
    9716:	d20c      	bcs.n	9732 <SPI_transfer_block+0xde>
                {
                    /* Push out valid data */
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, (uint32_t)cmd_buffer[tx_idx] );
    9718:	68fb      	ldr	r3, [r7, #12]
    971a:	681b      	ldr	r3, [r3, #0]
    971c:	f103 020c 	add.w	r2, r3, #12
    9720:	8b79      	ldrh	r1, [r7, #26]
    9722:	68bb      	ldr	r3, [r7, #8]
    9724:	440b      	add	r3, r1
    9726:	781b      	ldrb	r3, [r3, #0]
    9728:	4610      	mov	r0, r2
    972a:	4619      	mov	r1, r3
    972c:	f7fc fe92 	bl	6454 <HW_set_32bit_reg>
    9730:	e008      	b.n	9744 <SPI_transfer_block+0xf0>
                }
                else
                {
                    /* Push out 0s to get data back from slave */
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
    9732:	68fb      	ldr	r3, [r7, #12]
    9734:	681b      	ldr	r3, [r3, #0]
    9736:	f103 030c 	add.w	r3, r3, #12
    973a:	4618      	mov	r0, r3
    973c:	f04f 0100 	mov.w	r1, #0
    9740:	f7fc fe88 	bl	6454 <HW_set_32bit_reg>
                }
                ++transit;
    9744:	8bfb      	ldrh	r3, [r7, #30]
    9746:	f103 0301 	add.w	r3, r3, #1
    974a:	83fb      	strh	r3, [r7, #30]
                ++tx_idx;
    974c:	8b7b      	ldrh	r3, [r7, #26]
    974e:	f103 0301 	add.w	r3, r3, #1
    9752:	837b      	strh	r3, [r7, #26]
            }

            /* Disable the Core SPI for a little bit, while we load the TX FIFO */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );

            while( ( tx_idx < transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
    9754:	8b7a      	ldrh	r2, [r7, #26]
    9756:	697b      	ldr	r3, [r7, #20]
    9758:	429a      	cmp	r2, r3
    975a:	d205      	bcs.n	9768 <SPI_transfer_block+0x114>
    975c:	68fb      	ldr	r3, [r7, #12]
    975e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    9762:	8b7a      	ldrh	r2, [r7, #26]
    9764:	429a      	cmp	r2, r3
    9766:	d3d3      	bcc.n	9710 <SPI_transfer_block+0xbc>
                ++transit;
                ++tx_idx;
            }

            /* If room left to put last frame in before the off, then do it */
            if( ( tx_idx == transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
    9768:	8b7a      	ldrh	r2, [r7, #26]
    976a:	697b      	ldr	r3, [r7, #20]
    976c:	429a      	cmp	r2, r3
    976e:	d127      	bne.n	97c0 <SPI_transfer_block+0x16c>
    9770:	68fb      	ldr	r3, [r7, #12]
    9772:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    9776:	8b7a      	ldrh	r2, [r7, #26]
    9778:	429a      	cmp	r2, r3
    977a:	d221      	bcs.n	97c0 <SPI_transfer_block+0x16c>
            {
                if( tx_idx < cmd_byte_size )
    977c:	8b7a      	ldrh	r2, [r7, #26]
    977e:	88fb      	ldrh	r3, [r7, #6]
    9780:	429a      	cmp	r2, r3
    9782:	d20c      	bcs.n	979e <SPI_transfer_block+0x14a>
                {
                    /* Push out valid data, not expecting any reply this time */
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, (uint32_t)cmd_buffer[tx_idx] );
    9784:	68fb      	ldr	r3, [r7, #12]
    9786:	681b      	ldr	r3, [r3, #0]
    9788:	f103 0228 	add.w	r2, r3, #40	; 0x28
    978c:	8b79      	ldrh	r1, [r7, #26]
    978e:	68bb      	ldr	r3, [r7, #8]
    9790:	440b      	add	r3, r1
    9792:	781b      	ldrb	r3, [r3, #0]
    9794:	4610      	mov	r0, r2
    9796:	4619      	mov	r1, r3
    9798:	f7fc fe5c 	bl	6454 <HW_set_32bit_reg>
    979c:	e008      	b.n	97b0 <SPI_transfer_block+0x15c>
                }
                else
                {
                    /* Push out last 0 to get data back from slave */
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, 0U );
    979e:	68fb      	ldr	r3, [r7, #12]
    97a0:	681b      	ldr	r3, [r3, #0]
    97a2:	f103 0328 	add.w	r3, r3, #40	; 0x28
    97a6:	4618      	mov	r0, r3
    97a8:	f04f 0100 	mov.w	r1, #0
    97ac:	f7fc fe52 	bl	6454 <HW_set_32bit_reg>
                }

                ++transit;
    97b0:	8bfb      	ldrh	r3, [r7, #30]
    97b2:	f103 0301 	add.w	r3, r3, #1
    97b6:	83fb      	strh	r3, [r7, #30]
                ++tx_idx;
    97b8:	8b7b      	ldrh	r3, [r7, #26]
    97ba:	f103 0301 	add.w	r3, r3, #1
    97be:	837b      	strh	r3, [r7, #26]
            }

            /* FIFO is all loaded up so enable Core SPI to start transfer */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, ENABLE );
    97c0:	68fb      	ldr	r3, [r7, #12]
    97c2:	681b      	ldr	r3, [r3, #0]
    97c4:	4618      	mov	r0, r3
    97c6:	f04f 0100 	mov.w	r1, #0
    97ca:	f04f 0201 	mov.w	r2, #1
    97ce:	f04f 0301 	mov.w	r3, #1
    97d2:	f7fc fe73 	bl	64bc <HW_set_8bit_reg_field>
             *
             * First stage transfers remaining command bytes (if any).
             * At this stage anything in the RX FIFO can be discarded as it is
             * not part of a valid response.
             */
            while( tx_idx < cmd_byte_size )
    97d6:	e047      	b.n	9868 <SPI_transfer_block+0x214>
            {
                if( transit < this_spi->fifo_depth )
    97d8:	68fb      	ldr	r3, [r7, #12]
    97da:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    97de:	8bfa      	ldrh	r2, [r7, #30]
    97e0:	429a      	cmp	r2, r3
    97e2:	d224      	bcs.n	982e <SPI_transfer_block+0x1da>
                {
                    /* Send another byte. */
                    if( tx_idx == transfer_size ) /* Last frame is special... */
    97e4:	8b7a      	ldrh	r2, [r7, #26]
    97e6:	697b      	ldr	r3, [r7, #20]
    97e8:	429a      	cmp	r2, r3
    97ea:	d10c      	bne.n	9806 <SPI_transfer_block+0x1b2>
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXLAST, (uint32_t)cmd_buffer[tx_idx] );
    97ec:	68fb      	ldr	r3, [r7, #12]
    97ee:	681b      	ldr	r3, [r3, #0]
    97f0:	f103 0228 	add.w	r2, r3, #40	; 0x28
    97f4:	8b79      	ldrh	r1, [r7, #26]
    97f6:	68bb      	ldr	r3, [r7, #8]
    97f8:	440b      	add	r3, r1
    97fa:	781b      	ldrb	r3, [r3, #0]
    97fc:	4610      	mov	r0, r2
    97fe:	4619      	mov	r1, r3
    9800:	f7fc fe28 	bl	6454 <HW_set_32bit_reg>
    9804:	e00b      	b.n	981e <SPI_transfer_block+0x1ca>
                    }
                    else
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXDATA, (uint32_t)cmd_buffer[tx_idx] );
    9806:	68fb      	ldr	r3, [r7, #12]
    9808:	681b      	ldr	r3, [r3, #0]
    980a:	f103 020c 	add.w	r2, r3, #12
    980e:	8b79      	ldrh	r1, [r7, #26]
    9810:	68bb      	ldr	r3, [r7, #8]
    9812:	440b      	add	r3, r1
    9814:	781b      	ldrb	r3, [r3, #0]
    9816:	4610      	mov	r0, r2
    9818:	4619      	mov	r1, r3
    981a:	f7fc fe1b 	bl	6454 <HW_set_32bit_reg>
                    }
                    ++tx_idx;
    981e:	8b7b      	ldrh	r3, [r7, #26]
    9820:	f103 0301 	add.w	r3, r3, #1
    9824:	837b      	strh	r3, [r7, #26]
                    ++transit;
    9826:	8bfb      	ldrh	r3, [r7, #30]
    9828:	f103 0301 	add.w	r3, r3, #1
    982c:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field( this_spi->base_addr, STATUS_RXEMPTY ) )
    982e:	68fb      	ldr	r3, [r7, #12]
    9830:	681b      	ldr	r3, [r3, #0]
    9832:	f103 0320 	add.w	r3, r3, #32
    9836:	4618      	mov	r0, r3
    9838:	f04f 0102 	mov.w	r1, #2
    983c:	f04f 0204 	mov.w	r2, #4
    9840:	f7fc fe4a 	bl	64d8 <HW_get_8bit_reg_field>
    9844:	4603      	mov	r3, r0
    9846:	2b00      	cmp	r3, #0
    9848:	d10e      	bne.n	9868 <SPI_transfer_block+0x214>
                {
                    /* Read and discard. */
                    HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
    984a:	68fb      	ldr	r3, [r7, #12]
    984c:	681b      	ldr	r3, [r3, #0]
    984e:	f103 0308 	add.w	r3, r3, #8
    9852:	4618      	mov	r0, r3
    9854:	f7fc fe00 	bl	6458 <HW_get_32bit_reg>
                    ++transfer_idx;
    9858:	8b3b      	ldrh	r3, [r7, #24]
    985a:	f103 0301 	add.w	r3, r3, #1
    985e:	833b      	strh	r3, [r7, #24]
                    --transit;
    9860:	8bfb      	ldrh	r3, [r7, #30]
    9862:	f103 33ff 	add.w	r3, r3, #4294967295
    9866:	83fb      	strh	r3, [r7, #30]
             *
             * First stage transfers remaining command bytes (if any).
             * At this stage anything in the RX FIFO can be discarded as it is
             * not part of a valid response.
             */
            while( tx_idx < cmd_byte_size )
    9868:	8b7a      	ldrh	r2, [r7, #26]
    986a:	88fb      	ldrh	r3, [r7, #6]
    986c:	429a      	cmp	r2, r3
    986e:	d3b3      	bcc.n	97d8 <SPI_transfer_block+0x184>
            /*
             * Now, we are writing dummy bytes to push through the response from
             * the slave but we still have to keep discarding any read data that
             * corresponds with one of our command bytes.
             */
            while( transfer_idx < cmd_byte_size )
    9870:	e037      	b.n	98e2 <SPI_transfer_block+0x28e>
            {
                if( transit < this_spi->fifo_depth )
    9872:	68fb      	ldr	r3, [r7, #12]
    9874:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    9878:	8bfa      	ldrh	r2, [r7, #30]
    987a:	429a      	cmp	r2, r3
    987c:	d214      	bcs.n	98a8 <SPI_transfer_block+0x254>
                {
                    if( tx_idx < transfer_size )
    987e:	8b7a      	ldrh	r2, [r7, #26]
    9880:	697b      	ldr	r3, [r7, #20]
    9882:	429a      	cmp	r2, r3
    9884:	d210      	bcs.n	98a8 <SPI_transfer_block+0x254>
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
    9886:	68fb      	ldr	r3, [r7, #12]
    9888:	681b      	ldr	r3, [r3, #0]
    988a:	f103 030c 	add.w	r3, r3, #12
    988e:	4618      	mov	r0, r3
    9890:	f04f 0100 	mov.w	r1, #0
    9894:	f7fc fdde 	bl	6454 <HW_set_32bit_reg>
                        ++tx_idx;
    9898:	8b7b      	ldrh	r3, [r7, #26]
    989a:	f103 0301 	add.w	r3, r3, #1
    989e:	837b      	strh	r3, [r7, #26]
                        ++transit;
    98a0:	8bfb      	ldrh	r3, [r7, #30]
    98a2:	f103 0301 	add.w	r3, r3, #1
    98a6:	83fb      	strh	r3, [r7, #30]
                    }
                }
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
    98a8:	68fb      	ldr	r3, [r7, #12]
    98aa:	681b      	ldr	r3, [r3, #0]
    98ac:	f103 0320 	add.w	r3, r3, #32
    98b0:	4618      	mov	r0, r3
    98b2:	f04f 0102 	mov.w	r1, #2
    98b6:	f04f 0204 	mov.w	r2, #4
    98ba:	f7fc fe0d 	bl	64d8 <HW_get_8bit_reg_field>
    98be:	4603      	mov	r3, r0
    98c0:	2b00      	cmp	r3, #0
    98c2:	d10e      	bne.n	98e2 <SPI_transfer_block+0x28e>
                {
                    /* Read and discard. */
                    HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
    98c4:	68fb      	ldr	r3, [r7, #12]
    98c6:	681b      	ldr	r3, [r3, #0]
    98c8:	f103 0308 	add.w	r3, r3, #8
    98cc:	4618      	mov	r0, r3
    98ce:	f7fc fdc3 	bl	6458 <HW_get_32bit_reg>
                    ++transfer_idx;
    98d2:	8b3b      	ldrh	r3, [r7, #24]
    98d4:	f103 0301 	add.w	r3, r3, #1
    98d8:	833b      	strh	r3, [r7, #24]
                    --transit;
    98da:	8bfb      	ldrh	r3, [r7, #30]
    98dc:	f103 33ff 	add.w	r3, r3, #4294967295
    98e0:	83fb      	strh	r3, [r7, #30]
            /*
             * Now, we are writing dummy bytes to push through the response from
             * the slave but we still have to keep discarding any read data that
             * corresponds with one of our command bytes.
             */
            while( transfer_idx < cmd_byte_size )
    98e2:	8b3a      	ldrh	r2, [r7, #24]
    98e4:	88fb      	ldrh	r3, [r7, #6]
    98e6:	429a      	cmp	r2, r3
    98e8:	d3c3      	bcc.n	9872 <SPI_transfer_block+0x21e>
            }
            /*
             * Now we are now only sending dummy data to push through the
             * valid response data which we store in the response buffer.
             */
            while( tx_idx < transfer_size )
    98ea:	e03e      	b.n	996a <SPI_transfer_block+0x316>
            {
                if( transit < this_spi->fifo_depth )
    98ec:	68fb      	ldr	r3, [r7, #12]
    98ee:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    98f2:	8bfa      	ldrh	r2, [r7, #30]
    98f4:	429a      	cmp	r2, r3
    98f6:	d210      	bcs.n	991a <SPI_transfer_block+0x2c6>
                {
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
    98f8:	68fb      	ldr	r3, [r7, #12]
    98fa:	681b      	ldr	r3, [r3, #0]
    98fc:	f103 030c 	add.w	r3, r3, #12
    9900:	4618      	mov	r0, r3
    9902:	f04f 0100 	mov.w	r1, #0
    9906:	f7fc fda5 	bl	6454 <HW_set_32bit_reg>
                    ++tx_idx;
    990a:	8b7b      	ldrh	r3, [r7, #26]
    990c:	f103 0301 	add.w	r3, r3, #1
    9910:	837b      	strh	r3, [r7, #26]
                    ++transit;
    9912:	8bfb      	ldrh	r3, [r7, #30]
    9914:	f103 0301 	add.w	r3, r3, #1
    9918:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
    991a:	68fb      	ldr	r3, [r7, #12]
    991c:	681b      	ldr	r3, [r3, #0]
    991e:	f103 0320 	add.w	r3, r3, #32
    9922:	4618      	mov	r0, r3
    9924:	f04f 0102 	mov.w	r1, #2
    9928:	f04f 0204 	mov.w	r2, #4
    992c:	f7fc fdd4 	bl	64d8 <HW_get_8bit_reg_field>
    9930:	4603      	mov	r3, r0
    9932:	2b00      	cmp	r3, #0
    9934:	d119      	bne.n	996a <SPI_transfer_block+0x316>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
    9936:	8bba      	ldrh	r2, [r7, #28]
    9938:	683b      	ldr	r3, [r7, #0]
    993a:	eb02 0403 	add.w	r4, r2, r3
    993e:	68fb      	ldr	r3, [r7, #12]
    9940:	681b      	ldr	r3, [r3, #0]
    9942:	f103 0308 	add.w	r3, r3, #8
    9946:	4618      	mov	r0, r3
    9948:	f7fc fd86 	bl	6458 <HW_get_32bit_reg>
    994c:	4603      	mov	r3, r0
    994e:	b2db      	uxtb	r3, r3
    9950:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
    9952:	8bbb      	ldrh	r3, [r7, #28]
    9954:	f103 0301 	add.w	r3, r3, #1
    9958:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
    995a:	8b3b      	ldrh	r3, [r7, #24]
    995c:	f103 0301 	add.w	r3, r3, #1
    9960:	833b      	strh	r3, [r7, #24]
                    --transit;
    9962:	8bfb      	ldrh	r3, [r7, #30]
    9964:	f103 33ff 	add.w	r3, r3, #4294967295
    9968:	83fb      	strh	r3, [r7, #30]
            }
            /*
             * Now we are now only sending dummy data to push through the
             * valid response data which we store in the response buffer.
             */
            while( tx_idx < transfer_size )
    996a:	8b7a      	ldrh	r2, [r7, #26]
    996c:	697b      	ldr	r3, [r7, #20]
    996e:	429a      	cmp	r2, r3
    9970:	d3bc      	bcc.n	98ec <SPI_transfer_block+0x298>
                    ++transfer_idx;
                    --transit;
                }
            }
            /* If we still need to send the last frame */
            while( tx_idx == transfer_size )
    9972:	e03e      	b.n	99f2 <SPI_transfer_block+0x39e>
            {
                if( transit < this_spi->fifo_depth )
    9974:	68fb      	ldr	r3, [r7, #12]
    9976:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    997a:	8bfa      	ldrh	r2, [r7, #30]
    997c:	429a      	cmp	r2, r3
    997e:	d210      	bcs.n	99a2 <SPI_transfer_block+0x34e>
                {
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, 0U );
    9980:	68fb      	ldr	r3, [r7, #12]
    9982:	681b      	ldr	r3, [r3, #0]
    9984:	f103 0328 	add.w	r3, r3, #40	; 0x28
    9988:	4618      	mov	r0, r3
    998a:	f04f 0100 	mov.w	r1, #0
    998e:	f7fc fd61 	bl	6454 <HW_set_32bit_reg>
                    ++tx_idx;
    9992:	8b7b      	ldrh	r3, [r7, #26]
    9994:	f103 0301 	add.w	r3, r3, #1
    9998:	837b      	strh	r3, [r7, #26]
                    ++transit;
    999a:	8bfb      	ldrh	r3, [r7, #30]
    999c:	f103 0301 	add.w	r3, r3, #1
    99a0:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field( this_spi->base_addr, STATUS_RXEMPTY ) )
    99a2:	68fb      	ldr	r3, [r7, #12]
    99a4:	681b      	ldr	r3, [r3, #0]
    99a6:	f103 0320 	add.w	r3, r3, #32
    99aa:	4618      	mov	r0, r3
    99ac:	f04f 0102 	mov.w	r1, #2
    99b0:	f04f 0204 	mov.w	r2, #4
    99b4:	f7fc fd90 	bl	64d8 <HW_get_8bit_reg_field>
    99b8:	4603      	mov	r3, r0
    99ba:	2b00      	cmp	r3, #0
    99bc:	d119      	bne.n	99f2 <SPI_transfer_block+0x39e>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
    99be:	8bba      	ldrh	r2, [r7, #28]
    99c0:	683b      	ldr	r3, [r7, #0]
    99c2:	eb02 0403 	add.w	r4, r2, r3
    99c6:	68fb      	ldr	r3, [r7, #12]
    99c8:	681b      	ldr	r3, [r3, #0]
    99ca:	f103 0308 	add.w	r3, r3, #8
    99ce:	4618      	mov	r0, r3
    99d0:	f7fc fd42 	bl	6458 <HW_get_32bit_reg>
    99d4:	4603      	mov	r3, r0
    99d6:	b2db      	uxtb	r3, r3
    99d8:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
    99da:	8bbb      	ldrh	r3, [r7, #28]
    99dc:	f103 0301 	add.w	r3, r3, #1
    99e0:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
    99e2:	8b3b      	ldrh	r3, [r7, #24]
    99e4:	f103 0301 	add.w	r3, r3, #1
    99e8:	833b      	strh	r3, [r7, #24]
                    --transit;
    99ea:	8bfb      	ldrh	r3, [r7, #30]
    99ec:	f103 33ff 	add.w	r3, r3, #4294967295
    99f0:	83fb      	strh	r3, [r7, #30]
                    ++transfer_idx;
                    --transit;
                }
            }
            /* If we still need to send the last frame */
            while( tx_idx == transfer_size )
    99f2:	8b7a      	ldrh	r2, [r7, #26]
    99f4:	697b      	ldr	r3, [r7, #20]
    99f6:	429a      	cmp	r2, r3
    99f8:	d0bc      	beq.n	9974 <SPI_transfer_block+0x320>
            }
            /*
             * Finally, we are now finished sending data and are only reading
             * valid response data which we store in the response buffer.
             */
            while( transfer_idx <= transfer_size )
    99fa:	e023      	b.n	9a44 <SPI_transfer_block+0x3f0>
            {
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
    99fc:	68fb      	ldr	r3, [r7, #12]
    99fe:	681b      	ldr	r3, [r3, #0]
    9a00:	f103 0320 	add.w	r3, r3, #32
    9a04:	4618      	mov	r0, r3
    9a06:	f04f 0102 	mov.w	r1, #2
    9a0a:	f04f 0204 	mov.w	r2, #4
    9a0e:	f7fc fd63 	bl	64d8 <HW_get_8bit_reg_field>
    9a12:	4603      	mov	r3, r0
    9a14:	2b00      	cmp	r3, #0
    9a16:	d115      	bne.n	9a44 <SPI_transfer_block+0x3f0>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
    9a18:	8bba      	ldrh	r2, [r7, #28]
    9a1a:	683b      	ldr	r3, [r7, #0]
    9a1c:	eb02 0403 	add.w	r4, r2, r3
    9a20:	68fb      	ldr	r3, [r7, #12]
    9a22:	681b      	ldr	r3, [r3, #0]
    9a24:	f103 0308 	add.w	r3, r3, #8
    9a28:	4618      	mov	r0, r3
    9a2a:	f7fc fd15 	bl	6458 <HW_get_32bit_reg>
    9a2e:	4603      	mov	r3, r0
    9a30:	b2db      	uxtb	r3, r3
    9a32:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
    9a34:	8bbb      	ldrh	r3, [r7, #28]
    9a36:	f103 0301 	add.w	r3, r3, #1
    9a3a:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
    9a3c:	8b3b      	ldrh	r3, [r7, #24]
    9a3e:	f103 0301 	add.w	r3, r3, #1
    9a42:	833b      	strh	r3, [r7, #24]
            }
            /*
             * Finally, we are now finished sending data and are only reading
             * valid response data which we store in the response buffer.
             */
            while( transfer_idx <= transfer_size )
    9a44:	8b3a      	ldrh	r2, [r7, #24]
    9a46:	697b      	ldr	r3, [r7, #20]
    9a48:	429a      	cmp	r2, r3
    9a4a:	d9d7      	bls.n	99fc <SPI_transfer_block+0x3a8>
                    ++transfer_idx;
                }
            }
        }
    }
}
    9a4c:	f107 0724 	add.w	r7, r7, #36	; 0x24
    9a50:	46bd      	mov	sp, r7
    9a52:	bd90      	pop	{r4, r7, pc}

00009a54 <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    const spi_instance_t * this_spi
)
{
    9a54:	b580      	push	{r7, lr}
    9a56:	b082      	sub	sp, #8
    9a58:	af00      	add	r7, sp, #0
    9a5a:	6078      	str	r0, [r7, #4]
    /* Disable CoreSPI */
    HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
    9a5c:	687b      	ldr	r3, [r7, #4]
    9a5e:	681b      	ldr	r3, [r3, #0]
    9a60:	4618      	mov	r0, r3
    9a62:	f04f 0100 	mov.w	r1, #0
    9a66:	f04f 0201 	mov.w	r2, #1
    9a6a:	f04f 0300 	mov.w	r3, #0
    9a6e:	f7fc fd25 	bl	64bc <HW_set_8bit_reg_field>

    /* Reset TX and RX FIFOs */
    HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
    9a72:	687b      	ldr	r3, [r7, #4]
    9a74:	681b      	ldr	r3, [r3, #0]
    9a76:	f103 031c 	add.w	r3, r3, #28
    9a7a:	4618      	mov	r0, r3
    9a7c:	f04f 0103 	mov.w	r1, #3
    9a80:	f7fc fd18 	bl	64b4 <HW_set_8bit_reg>

    /* Clear all interrupts */
    HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
    9a84:	687b      	ldr	r3, [r7, #4]
    9a86:	681b      	ldr	r3, [r3, #0]
    9a88:	f103 0304 	add.w	r3, r3, #4
    9a8c:	4618      	mov	r0, r3
    9a8e:	f04f 01ff 	mov.w	r1, #255	; 0xff
    9a92:	f7fc fd0f 	bl	64b4 <HW_set_8bit_reg>

    /* Enable CoreSPI */
    HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, ENABLE );
    9a96:	687b      	ldr	r3, [r7, #4]
    9a98:	681b      	ldr	r3, [r3, #0]
    9a9a:	4618      	mov	r0, r3
    9a9c:	f04f 0100 	mov.w	r1, #0
    9aa0:	f04f 0201 	mov.w	r2, #1
    9aa4:	f04f 0301 	mov.w	r3, #1
    9aa8:	f7fc fd08 	bl	64bc <HW_set_8bit_reg_field>
}
    9aac:	f107 0708 	add.w	r7, r7, #8
    9ab0:	46bd      	mov	sp, r7
    9ab2:	bd80      	pop	{r7, pc}

00009ab4 <I2C_init>:
    i2c_instance_t * this_i2c,
    addr_t base_address,
    uint8_t ser_address,
    i2c_clock_divider_t ser_clock_speed
)
{
    9ab4:	b580      	push	{r7, lr}
    9ab6:	b086      	sub	sp, #24
    9ab8:	af00      	add	r7, sp, #0
    9aba:	60f8      	str	r0, [r7, #12]
    9abc:	60b9      	str	r1, [r7, #8]
    9abe:	71fa      	strb	r2, [r7, #7]
    9ac0:	71bb      	strb	r3, [r7, #6]
    psr_t saved_psr;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
    9ac2:	79bb      	ldrb	r3, [r7, #6]
    9ac4:	617b      	str	r3, [r7, #20]
    
    /*
     * We need to disable ints while doing this as there is no guarantee we
     * have not been called already and the ISR is active.
     */
    saved_psr = HAL_disable_interrupts();
    9ac6:	f001 f99f 	bl	ae08 <HAL_disable_interrupts>
    9aca:	4603      	mov	r3, r0
    9acc:	613b      	str	r3, [r7, #16]
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    memset(this_i2c, 0, sizeof(i2c_instance_t));
    9ace:	68f8      	ldr	r0, [r7, #12]
    9ad0:	f04f 0100 	mov.w	r1, #0
    9ad4:	f04f 026c 	mov.w	r2, #108	; 0x6c
    9ad8:	f001 fe78 	bl	b7cc <memset>
    
    /*
     * Set base address of I2C hardware used by this instance.
     */
    this_i2c->base_address = base_address;
    9adc:	68fb      	ldr	r3, [r7, #12]
    9ade:	68ba      	ldr	r2, [r7, #8]
    9ae0:	601a      	str	r2, [r3, #0]

    /*
     * Update Serial address of the device
     */
    this_i2c->ser_address = ((uint_fast8_t)ser_address << 1u);
    9ae2:	79fb      	ldrb	r3, [r7, #7]
    9ae4:	ea4f 0243 	mov.w	r2, r3, lsl #1
    9ae8:	68fb      	ldr	r3, [r7, #12]
    9aea:	605a      	str	r2, [r3, #4]
    
    /*
     * Configure hardware.
     */
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x00); /* Reset I2C hardware. */
    9aec:	68fb      	ldr	r3, [r7, #12]
    9aee:	681b      	ldr	r3, [r3, #0]
    9af0:	4618      	mov	r0, r3
    9af2:	f04f 0106 	mov.w	r1, #6
    9af6:	f04f 0240 	mov.w	r2, #64	; 0x40
    9afa:	f04f 0300 	mov.w	r3, #0
    9afe:	f7fc fcdd 	bl	64bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x01); /* set enable bit */
    9b02:	68fb      	ldr	r3, [r7, #12]
    9b04:	681b      	ldr	r3, [r3, #0]
    9b06:	4618      	mov	r0, r3
    9b08:	f04f 0106 	mov.w	r1, #6
    9b0c:	f04f 0240 	mov.w	r2, #64	; 0x40
    9b10:	f04f 0301 	mov.w	r3, #1
    9b14:	f7fc fcd2 	bl	64bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR2, ( (clock_speed >> 2) & 0x01) );
    9b18:	68fb      	ldr	r3, [r7, #12]
    9b1a:	681a      	ldr	r2, [r3, #0]
    9b1c:	697b      	ldr	r3, [r7, #20]
    9b1e:	ea4f 0393 	mov.w	r3, r3, lsr #2
    9b22:	f003 0301 	and.w	r3, r3, #1
    9b26:	4610      	mov	r0, r2
    9b28:	f04f 0107 	mov.w	r1, #7
    9b2c:	f04f 0280 	mov.w	r2, #128	; 0x80
    9b30:	f7fc fcc4 	bl	64bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR1, ( (clock_speed >> 1) & 0x01) );
    9b34:	68fb      	ldr	r3, [r7, #12]
    9b36:	681a      	ldr	r2, [r3, #0]
    9b38:	697b      	ldr	r3, [r7, #20]
    9b3a:	ea4f 0353 	mov.w	r3, r3, lsr #1
    9b3e:	f003 0301 	and.w	r3, r3, #1
    9b42:	4610      	mov	r0, r2
    9b44:	f04f 0101 	mov.w	r1, #1
    9b48:	f04f 0202 	mov.w	r2, #2
    9b4c:	f7fc fcb6 	bl	64bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR0, ( clock_speed & 0x01) );
    9b50:	68fb      	ldr	r3, [r7, #12]
    9b52:	681a      	ldr	r2, [r3, #0]
    9b54:	697b      	ldr	r3, [r7, #20]
    9b56:	f003 0301 	and.w	r3, r3, #1
    9b5a:	4610      	mov	r0, r2
    9b5c:	f04f 0100 	mov.w	r1, #0
    9b60:	f04f 0201 	mov.w	r2, #1
    9b64:	f7fc fcaa 	bl	64bc <HW_set_8bit_reg_field>

    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS, this_i2c->ser_address);
    9b68:	68fb      	ldr	r3, [r7, #12]
    9b6a:	681b      	ldr	r3, [r3, #0]
    9b6c:	f103 020c 	add.w	r2, r3, #12
    9b70:	68fb      	ldr	r3, [r7, #12]
    9b72:	685b      	ldr	r3, [r3, #4]
    9b74:	4610      	mov	r0, r2
    9b76:	4619      	mov	r1, r3
    9b78:	f7fc fc9c 	bl	64b4 <HW_set_8bit_reg>
    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS1, this_i2c->ser_address);
    9b7c:	68fb      	ldr	r3, [r7, #12]
    9b7e:	681b      	ldr	r3, [r3, #0]
    9b80:	f103 021c 	add.w	r2, r3, #28
    9b84:	68fb      	ldr	r3, [r7, #12]
    9b86:	685b      	ldr	r3, [r3, #4]
    9b88:	4610      	mov	r0, r2
    9b8a:	4619      	mov	r1, r3
    9b8c:	f7fc fc92 	bl	64b4 <HW_set_8bit_reg>
    
    /*
     * Finally safe to enable interrupts.
     */
    HAL_restore_interrupts( saved_psr );
    9b90:	6938      	ldr	r0, [r7, #16]
    9b92:	f001 f93d 	bl	ae10 <HAL_restore_interrupts>
}
    9b96:	f107 0718 	add.w	r7, r7, #24
    9b9a:	46bd      	mov	sp, r7
    9b9c:	bd80      	pop	{r7, pc}
    9b9e:	bf00      	nop

00009ba0 <I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
    9ba0:	b580      	push	{r7, lr}
    9ba2:	b086      	sub	sp, #24
    9ba4:	af00      	add	r7, sp, #0
    9ba6:	60f8      	str	r0, [r7, #12]
    9ba8:	607a      	str	r2, [r7, #4]
    9baa:	460a      	mov	r2, r1
    9bac:	72fa      	strb	r2, [r7, #11]
    9bae:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
    9bb0:	f001 f92a 	bl	ae08 <HAL_disable_interrupts>
    9bb4:	4603      	mov	r3, r0
    9bb6:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    9bb8:	68fb      	ldr	r3, [r7, #12]
    9bba:	7b1b      	ldrb	r3, [r3, #12]
    9bbc:	2b00      	cmp	r3, #0
    9bbe:	d103      	bne.n	9bc8 <I2C_write+0x28>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
    9bc0:	68fb      	ldr	r3, [r7, #12]
    9bc2:	f04f 0201 	mov.w	r2, #1
    9bc6:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
    9bc8:	68fb      	ldr	r3, [r7, #12]
    9bca:	f04f 0201 	mov.w	r2, #1
    9bce:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    9bd2:	7afb      	ldrb	r3, [r7, #11]
    9bd4:	ea4f 0243 	mov.w	r2, r3, lsl #1
    9bd8:	68fb      	ldr	r3, [r7, #12]
    9bda:	609a      	str	r2, [r3, #8]
    this_i2c->dir = WRITE_DIR;
    9bdc:	68fb      	ldr	r3, [r7, #12]
    9bde:	f04f 0200 	mov.w	r2, #0
    9be2:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_buffer = write_buffer;
    9be4:	68fb      	ldr	r3, [r7, #12]
    9be6:	687a      	ldr	r2, [r7, #4]
    9be8:	619a      	str	r2, [r3, #24]
    this_i2c->master_tx_size = write_size;
    9bea:	887a      	ldrh	r2, [r7, #2]
    9bec:	68fb      	ldr	r3, [r7, #12]
    9bee:	61da      	str	r2, [r3, #28]
    this_i2c->master_tx_idx = 0u;
    9bf0:	68fb      	ldr	r3, [r7, #12]
    9bf2:	f04f 0200 	mov.w	r2, #0
    9bf6:	621a      	str	r2, [r3, #32]

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
    9bf8:	68fb      	ldr	r3, [r7, #12]
    9bfa:	f04f 0201 	mov.w	r2, #1
    9bfe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    this_i2c->options = options;
    9c02:	68fb      	ldr	r3, [r7, #12]
    9c04:	f897 2020 	ldrb.w	r2, [r7, #32]
    9c08:	751a      	strb	r2, [r3, #20]

    if(I2C_IN_PROGRESS == this_i2c->slave_status)
    9c0a:	68fb      	ldr	r3, [r7, #12]
    9c0c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    9c10:	b2db      	uxtb	r3, r3
    9c12:	2b01      	cmp	r3, #1
    9c14:	d105      	bne.n	9c22 <I2C_write+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
    9c16:	68fb      	ldr	r3, [r7, #12]
    9c18:	f04f 0201 	mov.w	r2, #1
    9c1c:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    9c20:	e00a      	b.n	9c38 <I2C_write+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    9c22:	68fb      	ldr	r3, [r7, #12]
    9c24:	681b      	ldr	r3, [r3, #0]
    9c26:	4618      	mov	r0, r3
    9c28:	f04f 0105 	mov.w	r1, #5
    9c2c:	f04f 0220 	mov.w	r2, #32
    9c30:	f04f 0301 	mov.w	r3, #1
    9c34:	f7fc fc42 	bl	64bc <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
    9c38:	68fb      	ldr	r3, [r7, #12]
    9c3a:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
    9c3e:	2b01      	cmp	r3, #1
    9c40:	d10a      	bne.n	9c58 <I2C_write+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
    9c42:	68fb      	ldr	r3, [r7, #12]
    9c44:	681b      	ldr	r3, [r3, #0]
    9c46:	4618      	mov	r0, r3
    9c48:	f04f 0103 	mov.w	r1, #3
    9c4c:	f04f 0208 	mov.w	r2, #8
    9c50:	f04f 0300 	mov.w	r3, #0
    9c54:	f7fc fc32 	bl	64bc <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
    9c58:	68fb      	ldr	r3, [r7, #12]
    9c5a:	681b      	ldr	r3, [r3, #0]
    9c5c:	f103 0304 	add.w	r3, r3, #4
    9c60:	4618      	mov	r0, r3
    9c62:	f7fc fc29 	bl	64b8 <HW_get_8bit_reg>
    9c66:	4603      	mov	r3, r0
    9c68:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
    9c6a:	7cfb      	ldrb	r3, [r7, #19]
    9c6c:	b2db      	uxtb	r3, r3
    9c6e:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
    9c70:	68f8      	ldr	r0, [r7, #12]
    9c72:	f000 fec9 	bl	aa08 <I2C_enable_irq>

    HAL_restore_interrupts( saved_psr );
    9c76:	6978      	ldr	r0, [r7, #20]
    9c78:	f001 f8ca 	bl	ae10 <HAL_restore_interrupts>
}
    9c7c:	f107 0718 	add.w	r7, r7, #24
    9c80:	46bd      	mov	sp, r7
    9c82:	bd80      	pop	{r7, pc}

00009c84 <I2C_read>:
    uint8_t serial_addr,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    9c84:	b580      	push	{r7, lr}
    9c86:	b086      	sub	sp, #24
    9c88:	af00      	add	r7, sp, #0
    9c8a:	60f8      	str	r0, [r7, #12]
    9c8c:	607a      	str	r2, [r7, #4]
    9c8e:	460a      	mov	r2, r1
    9c90:	72fa      	strb	r2, [r7, #11]
    9c92:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
    9c94:	f001 f8b8 	bl	ae08 <HAL_disable_interrupts>
    9c98:	4603      	mov	r3, r0
    9c9a:	617b      	str	r3, [r7, #20]
    
    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
    9c9c:	68fb      	ldr	r3, [r7, #12]
    9c9e:	7b1b      	ldrb	r3, [r3, #12]
    9ca0:	2b00      	cmp	r3, #0
    9ca2:	d103      	bne.n	9cac <I2C_read+0x28>
    {
      this_i2c->transaction = MASTER_READ_TRANSACTION;
    9ca4:	68fb      	ldr	r3, [r7, #12]
    9ca6:	f04f 0202 	mov.w	r2, #2
    9caa:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_READ_TRANSACTION ;
    9cac:	68fb      	ldr	r3, [r7, #12]
    9cae:	f04f 0202 	mov.w	r2, #2
    9cb2:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    9cb6:	7afb      	ldrb	r3, [r7, #11]
    9cb8:	ea4f 0243 	mov.w	r2, r3, lsl #1
    9cbc:	68fb      	ldr	r3, [r7, #12]
    9cbe:	609a      	str	r2, [r3, #8]

    this_i2c->dir = READ_DIR;
    9cc0:	68fb      	ldr	r3, [r7, #12]
    9cc2:	f04f 0201 	mov.w	r2, #1
    9cc6:	625a      	str	r2, [r3, #36]	; 0x24

    this_i2c->master_rx_buffer = read_buffer;
    9cc8:	68fb      	ldr	r3, [r7, #12]
    9cca:	687a      	ldr	r2, [r7, #4]
    9ccc:	629a      	str	r2, [r3, #40]	; 0x28
    this_i2c->master_rx_size = read_size;
    9cce:	887a      	ldrh	r2, [r7, #2]
    9cd0:	68fb      	ldr	r3, [r7, #12]
    9cd2:	62da      	str	r2, [r3, #44]	; 0x2c
    this_i2c->master_rx_idx = 0u;
    9cd4:	68fb      	ldr	r3, [r7, #12]
    9cd6:	f04f 0200 	mov.w	r2, #0
    9cda:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
    9cdc:	68fb      	ldr	r3, [r7, #12]
    9cde:	f04f 0201 	mov.w	r2, #1
    9ce2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    this_i2c->options = options;
    9ce6:	68fb      	ldr	r3, [r7, #12]
    9ce8:	f897 2020 	ldrb.w	r2, [r7, #32]
    9cec:	751a      	strb	r2, [r3, #20]
    
    if(I2C_IN_PROGRESS == this_i2c->slave_status)
    9cee:	68fb      	ldr	r3, [r7, #12]
    9cf0:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    9cf4:	b2db      	uxtb	r3, r3
    9cf6:	2b01      	cmp	r3, #1
    9cf8:	d105      	bne.n	9d06 <I2C_read+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
    9cfa:	68fb      	ldr	r3, [r7, #12]
    9cfc:	f04f 0201 	mov.w	r2, #1
    9d00:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    9d04:	e00a      	b.n	9d1c <I2C_read+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    9d06:	68fb      	ldr	r3, [r7, #12]
    9d08:	681b      	ldr	r3, [r3, #0]
    9d0a:	4618      	mov	r0, r3
    9d0c:	f04f 0105 	mov.w	r1, #5
    9d10:	f04f 0220 	mov.w	r2, #32
    9d14:	f04f 0301 	mov.w	r3, #1
    9d18:	f7fc fbd0 	bl	64bc <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
    9d1c:	68fb      	ldr	r3, [r7, #12]
    9d1e:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
    9d22:	2b01      	cmp	r3, #1
    9d24:	d10a      	bne.n	9d3c <I2C_read+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
    9d26:	68fb      	ldr	r3, [r7, #12]
    9d28:	681b      	ldr	r3, [r3, #0]
    9d2a:	4618      	mov	r0, r3
    9d2c:	f04f 0103 	mov.w	r1, #3
    9d30:	f04f 0208 	mov.w	r2, #8
    9d34:	f04f 0300 	mov.w	r3, #0
    9d38:	f7fc fbc0 	bl	64bc <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
    9d3c:	68fb      	ldr	r3, [r7, #12]
    9d3e:	681b      	ldr	r3, [r3, #0]
    9d40:	f103 0304 	add.w	r3, r3, #4
    9d44:	4618      	mov	r0, r3
    9d46:	f7fc fbb7 	bl	64b8 <HW_get_8bit_reg>
    9d4a:	4603      	mov	r3, r0
    9d4c:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
    9d4e:	7cfb      	ldrb	r3, [r7, #19]
    9d50:	b2db      	uxtb	r3, r3
    9d52:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
    9d54:	68f8      	ldr	r0, [r7, #12]
    9d56:	f000 fe57 	bl	aa08 <I2C_enable_irq>
    HAL_restore_interrupts( saved_psr );
    9d5a:	6978      	ldr	r0, [r7, #20]
    9d5c:	f001 f858 	bl	ae10 <HAL_restore_interrupts>
}
    9d60:	f107 0718 	add.w	r7, r7, #24
    9d64:	46bd      	mov	sp, r7
    9d66:	bd80      	pop	{r7, pc}

00009d68 <I2C_write_read>:
    uint16_t offset_size,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
    9d68:	b580      	push	{r7, lr}
    9d6a:	b086      	sub	sp, #24
    9d6c:	af00      	add	r7, sp, #0
    9d6e:	60f8      	str	r0, [r7, #12]
    9d70:	607a      	str	r2, [r7, #4]
    9d72:	460a      	mov	r2, r1
    9d74:	72fa      	strb	r2, [r7, #11]
    9d76:	807b      	strh	r3, [r7, #2]
    HAL_ASSERT(offset_size > 0u);
    9d78:	887b      	ldrh	r3, [r7, #2]
    9d7a:	2b00      	cmp	r3, #0
    9d7c:	d100      	bne.n	9d80 <I2C_write_read+0x18>
    9d7e:	be00      	bkpt	0x0000
    HAL_ASSERT(addr_offset != (uint8_t *)0);
    9d80:	687b      	ldr	r3, [r7, #4]
    9d82:	2b00      	cmp	r3, #0
    9d84:	d100      	bne.n	9d88 <I2C_write_read+0x20>
    9d86:	be00      	bkpt	0x0000
    HAL_ASSERT(read_size > 0u);
    9d88:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    9d8a:	2b00      	cmp	r3, #0
    9d8c:	d100      	bne.n	9d90 <I2C_write_read+0x28>
    9d8e:	be00      	bkpt	0x0000
    HAL_ASSERT(read_buffer != (uint8_t *)0);
    9d90:	6a3b      	ldr	r3, [r7, #32]
    9d92:	2b00      	cmp	r3, #0
    9d94:	d100      	bne.n	9d98 <I2C_write_read+0x30>
    9d96:	be00      	bkpt	0x0000
    
    this_i2c->master_status = I2C_FAILED;
    9d98:	68fb      	ldr	r3, [r7, #12]
    9d9a:	f04f 0202 	mov.w	r2, #2
    9d9e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    if((read_size > 0u) && (offset_size > 0u))
    9da2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    9da4:	2b00      	cmp	r3, #0
    9da6:	d072      	beq.n	9e8e <I2C_write_read+0x126>
    9da8:	887b      	ldrh	r3, [r7, #2]
    9daa:	2b00      	cmp	r3, #0
    9dac:	d06f      	beq.n	9e8e <I2C_write_read+0x126>
    {
        psr_t saved_psr;
        volatile uint8_t stat_ctrl;

        saved_psr = HAL_disable_interrupts();
    9dae:	f001 f82b 	bl	ae08 <HAL_disable_interrupts>
    9db2:	4603      	mov	r3, r0
    9db4:	617b      	str	r3, [r7, #20]

        /* Update the transaction only when there is no transaction going on I2C */
        if( this_i2c->transaction == NO_TRANSACTION)
    9db6:	68fb      	ldr	r3, [r7, #12]
    9db8:	7b1b      	ldrb	r3, [r3, #12]
    9dba:	2b00      	cmp	r3, #0
    9dbc:	d103      	bne.n	9dc6 <I2C_write_read+0x5e>
        {
            this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
    9dbe:	68fb      	ldr	r3, [r7, #12]
    9dc0:	f04f 0203 	mov.w	r2, #3
    9dc4:	731a      	strb	r2, [r3, #12]
        }

        /* Update the Pending transaction information so that transaction can restarted */
        this_i2c->pending_transaction = MASTER_RANDOM_READ_TRANSACTION ;
    9dc6:	68fb      	ldr	r3, [r7, #12]
    9dc8:	f04f 0203 	mov.w	r2, #3
    9dcc:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

        /* Update target address */
        this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
    9dd0:	7afb      	ldrb	r3, [r7, #11]
    9dd2:	ea4f 0243 	mov.w	r2, r3, lsl #1
    9dd6:	68fb      	ldr	r3, [r7, #12]
    9dd8:	609a      	str	r2, [r3, #8]

        this_i2c->dir = WRITE_DIR;
    9dda:	68fb      	ldr	r3, [r7, #12]
    9ddc:	f04f 0200 	mov.w	r2, #0
    9de0:	625a      	str	r2, [r3, #36]	; 0x24

        this_i2c->master_tx_buffer = addr_offset;
    9de2:	68fb      	ldr	r3, [r7, #12]
    9de4:	687a      	ldr	r2, [r7, #4]
    9de6:	619a      	str	r2, [r3, #24]
        this_i2c->master_tx_size = offset_size;
    9de8:	887a      	ldrh	r2, [r7, #2]
    9dea:	68fb      	ldr	r3, [r7, #12]
    9dec:	61da      	str	r2, [r3, #28]
        this_i2c->master_tx_idx = 0u;
    9dee:	68fb      	ldr	r3, [r7, #12]
    9df0:	f04f 0200 	mov.w	r2, #0
    9df4:	621a      	str	r2, [r3, #32]

        this_i2c->master_rx_buffer = read_buffer;
    9df6:	68fb      	ldr	r3, [r7, #12]
    9df8:	6a3a      	ldr	r2, [r7, #32]
    9dfa:	629a      	str	r2, [r3, #40]	; 0x28
        this_i2c->master_rx_size = read_size;
    9dfc:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    9dfe:	68fb      	ldr	r3, [r7, #12]
    9e00:	62da      	str	r2, [r3, #44]	; 0x2c
        this_i2c->master_rx_idx = 0u;
    9e02:	68fb      	ldr	r3, [r7, #12]
    9e04:	f04f 0200 	mov.w	r2, #0
    9e08:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* Set I2C status in progress */
        this_i2c->master_status = I2C_IN_PROGRESS;
    9e0a:	68fb      	ldr	r3, [r7, #12]
    9e0c:	f04f 0201 	mov.w	r2, #1
    9e10:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        this_i2c->options = options;
    9e14:	68fb      	ldr	r3, [r7, #12]
    9e16:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
    9e1a:	751a      	strb	r2, [r3, #20]
        
        if(I2C_IN_PROGRESS == this_i2c->slave_status)
    9e1c:	68fb      	ldr	r3, [r7, #12]
    9e1e:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    9e22:	b2db      	uxtb	r3, r3
    9e24:	2b01      	cmp	r3, #1
    9e26:	d105      	bne.n	9e34 <I2C_write_read+0xcc>
        {
            this_i2c->is_transaction_pending = 1u;
    9e28:	68fb      	ldr	r3, [r7, #12]
    9e2a:	f04f 0201 	mov.w	r2, #1
    9e2e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    9e32:	e00a      	b.n	9e4a <I2C_write_read+0xe2>
        }
        else
        {
            HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    9e34:	68fb      	ldr	r3, [r7, #12]
    9e36:	681b      	ldr	r3, [r3, #0]
    9e38:	4618      	mov	r0, r3
    9e3a:	f04f 0105 	mov.w	r1, #5
    9e3e:	f04f 0220 	mov.w	r2, #32
    9e42:	f04f 0301 	mov.w	r3, #1
    9e46:	f7fc fb39 	bl	64bc <HW_set_8bit_reg_field>
        /*
         * Clear interrupts if required (depends on repeated starts).
         * Since the Bus is on hold, only then prior status needs to
         * be cleared.
         */
        if ( I2C_HOLD_BUS == this_i2c->bus_status )
    9e4a:	68fb      	ldr	r3, [r7, #12]
    9e4c:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
    9e50:	2b01      	cmp	r3, #1
    9e52:	d10a      	bne.n	9e6a <I2C_write_read+0x102>
        {
            HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
    9e54:	68fb      	ldr	r3, [r7, #12]
    9e56:	681b      	ldr	r3, [r3, #0]
    9e58:	4618      	mov	r0, r3
    9e5a:	f04f 0103 	mov.w	r1, #3
    9e5e:	f04f 0208 	mov.w	r2, #8
    9e62:	f04f 0300 	mov.w	r3, #0
    9e66:	f7fc fb29 	bl	64bc <HW_set_8bit_reg_field>
        }

        stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
    9e6a:	68fb      	ldr	r3, [r7, #12]
    9e6c:	681b      	ldr	r3, [r3, #0]
    9e6e:	f103 0304 	add.w	r3, r3, #4
    9e72:	4618      	mov	r0, r3
    9e74:	f7fc fb20 	bl	64b8 <HW_get_8bit_reg>
    9e78:	4603      	mov	r3, r0
    9e7a:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
    9e7c:	7cfb      	ldrb	r3, [r7, #19]
    9e7e:	b2db      	uxtb	r3, r3
    9e80:	74fb      	strb	r3, [r7, #19]
            
        /* Enable the interrupt. ( Re-enable) */
        I2C_enable_irq( this_i2c );
    9e82:	68f8      	ldr	r0, [r7, #12]
    9e84:	f000 fdc0 	bl	aa08 <I2C_enable_irq>

        HAL_restore_interrupts( saved_psr );
    9e88:	6978      	ldr	r0, [r7, #20]
    9e8a:	f000 ffc1 	bl	ae10 <HAL_restore_interrupts>
    }
}
    9e8e:	f107 0718 	add.w	r7, r7, #24
    9e92:	46bd      	mov	sp, r7
    9e94:	bd80      	pop	{r7, pc}
    9e96:	bf00      	nop

00009e98 <I2C_wait_complete>:
i2c_status_t I2C_wait_complete
(
    i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
    9e98:	b580      	push	{r7, lr}
    9e9a:	b084      	sub	sp, #16
    9e9c:	af00      	add	r7, sp, #0
    9e9e:	6078      	str	r0, [r7, #4]
    9ea0:	6039      	str	r1, [r7, #0]
     * Because we have no idea of what CPU we are supposed to be running on
     * we need to guard this write to the timeout value to avoid ISR/user code
     * interaction issues. Checking the status below should be fine as only a
     * single byte should change in that.
     */
    saved_psr = HAL_disable_interrupts();
    9ea2:	f000 ffb1 	bl	ae08 <HAL_disable_interrupts>
    9ea6:	4603      	mov	r3, r0
    9ea8:	60fb      	str	r3, [r7, #12]
    this_i2c->master_timeout_ms = timeout_ms;
    9eaa:	687b      	ldr	r3, [r7, #4]
    9eac:	683a      	ldr	r2, [r7, #0]
    9eae:	639a      	str	r2, [r3, #56]	; 0x38
    HAL_restore_interrupts( saved_psr );
    9eb0:	68f8      	ldr	r0, [r7, #12]
    9eb2:	f000 ffad 	bl	ae10 <HAL_restore_interrupts>

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
    9eb6:	687b      	ldr	r3, [r7, #4]
    9eb8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    9ebc:	72fb      	strb	r3, [r7, #11]
    } while(I2C_IN_PROGRESS == i2c_status);
    9ebe:	7afb      	ldrb	r3, [r7, #11]
    9ec0:	2b01      	cmp	r3, #1
    9ec2:	d0f8      	beq.n	9eb6 <I2C_wait_complete+0x1e>
    return i2c_status;
    9ec4:	7afb      	ldrb	r3, [r7, #11]
}
    9ec6:	4618      	mov	r0, r3
    9ec8:	f107 0710 	add.w	r7, r7, #16
    9ecc:	46bd      	mov	sp, r7
    9ece:	bd80      	pop	{r7, pc}

00009ed0 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    i2c_instance_t * this_i2c
)
{
    9ed0:	b580      	push	{r7, lr}
    9ed2:	b082      	sub	sp, #8
    9ed4:	af00      	add	r7, sp, #0
    9ed6:	6078      	str	r0, [r7, #4]
    /*
     * This function is only called from within the ISR and so does not need
     * guarding on the register access.
     */
    if( 0 != this_i2c->is_slave_enabled )
    9ed8:	687b      	ldr	r3, [r7, #4]
    9eda:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
    9ede:	2b00      	cmp	r3, #0
    9ee0:	d00a      	beq.n	9ef8 <enable_slave_if_required+0x28>
    {
        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
    9ee2:	687b      	ldr	r3, [r7, #4]
    9ee4:	681b      	ldr	r3, [r3, #0]
    9ee6:	4618      	mov	r0, r3
    9ee8:	f04f 0102 	mov.w	r1, #2
    9eec:	f04f 0204 	mov.w	r2, #4
    9ef0:	f04f 0301 	mov.w	r3, #1
    9ef4:	f7fc fae2 	bl	64bc <HW_set_8bit_reg_field>
    }
}
    9ef8:	f107 0708 	add.w	r7, r7, #8
    9efc:	46bd      	mov	sp, r7
    9efe:	bd80      	pop	{r7, pc}

00009f00 <I2C_isr>:
 */
void I2C_isr
(
    i2c_instance_t * this_i2c
)
{
    9f00:	b5b0      	push	{r4, r5, r7, lr}
    9f02:	b084      	sub	sp, #16
    9f04:	af00      	add	r7, sp, #0
    9f06:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
    9f08:	f04f 0301 	mov.w	r3, #1
    9f0c:	73bb      	strb	r3, [r7, #14]

    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
    9f0e:	687b      	ldr	r3, [r7, #4]
    9f10:	681b      	ldr	r3, [r3, #0]
    9f12:	f103 0304 	add.w	r3, r3, #4
    9f16:	4618      	mov	r0, r3
    9f18:	f7fc face 	bl	64b8 <HW_get_8bit_reg>
    9f1c:	4603      	mov	r3, r0
    9f1e:	72fb      	strb	r3, [r7, #11]
    
    switch( status )
    9f20:	7afb      	ldrb	r3, [r7, #11]
    9f22:	b2db      	uxtb	r3, r3
    9f24:	f1a3 0308 	sub.w	r3, r3, #8
    9f28:	2bd8      	cmp	r3, #216	; 0xd8
    9f2a:	f200 84e3 	bhi.w	a8f4 <I2C_isr+0x9f4>
    9f2e:	a201      	add	r2, pc, #4	; (adr r2, 9f34 <I2C_isr+0x34>)
    9f30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9f34:	0000a299 	.word	0x0000a299
    9f38:	0000a8f5 	.word	0x0000a8f5
    9f3c:	0000a8f5 	.word	0x0000a8f5
    9f40:	0000a8f5 	.word	0x0000a8f5
    9f44:	0000a8f5 	.word	0x0000a8f5
    9f48:	0000a8f5 	.word	0x0000a8f5
    9f4c:	0000a8f5 	.word	0x0000a8f5
    9f50:	0000a8f5 	.word	0x0000a8f5
    9f54:	0000a299 	.word	0x0000a299
    9f58:	0000a8f5 	.word	0x0000a8f5
    9f5c:	0000a8f5 	.word	0x0000a8f5
    9f60:	0000a8f5 	.word	0x0000a8f5
    9f64:	0000a8f5 	.word	0x0000a8f5
    9f68:	0000a8f5 	.word	0x0000a8f5
    9f6c:	0000a8f5 	.word	0x0000a8f5
    9f70:	0000a8f5 	.word	0x0000a8f5
    9f74:	0000a36f 	.word	0x0000a36f
    9f78:	0000a8f5 	.word	0x0000a8f5
    9f7c:	0000a8f5 	.word	0x0000a8f5
    9f80:	0000a8f5 	.word	0x0000a8f5
    9f84:	0000a8f5 	.word	0x0000a8f5
    9f88:	0000a8f5 	.word	0x0000a8f5
    9f8c:	0000a8f5 	.word	0x0000a8f5
    9f90:	0000a8f5 	.word	0x0000a8f5
    9f94:	0000a33f 	.word	0x0000a33f
    9f98:	0000a8f5 	.word	0x0000a8f5
    9f9c:	0000a8f5 	.word	0x0000a8f5
    9fa0:	0000a8f5 	.word	0x0000a8f5
    9fa4:	0000a8f5 	.word	0x0000a8f5
    9fa8:	0000a8f5 	.word	0x0000a8f5
    9fac:	0000a8f5 	.word	0x0000a8f5
    9fb0:	0000a8f5 	.word	0x0000a8f5
    9fb4:	0000a36f 	.word	0x0000a36f
    9fb8:	0000a8f5 	.word	0x0000a8f5
    9fbc:	0000a8f5 	.word	0x0000a8f5
    9fc0:	0000a8f5 	.word	0x0000a8f5
    9fc4:	0000a8f5 	.word	0x0000a8f5
    9fc8:	0000a8f5 	.word	0x0000a8f5
    9fcc:	0000a8f5 	.word	0x0000a8f5
    9fd0:	0000a8f5 	.word	0x0000a8f5
    9fd4:	0000a41f 	.word	0x0000a41f
    9fd8:	0000a8f5 	.word	0x0000a8f5
    9fdc:	0000a8f5 	.word	0x0000a8f5
    9fe0:	0000a8f5 	.word	0x0000a8f5
    9fe4:	0000a8f5 	.word	0x0000a8f5
    9fe8:	0000a8f5 	.word	0x0000a8f5
    9fec:	0000a8f5 	.word	0x0000a8f5
    9ff0:	0000a8f5 	.word	0x0000a8f5
    9ff4:	0000a327 	.word	0x0000a327
    9ff8:	0000a8f5 	.word	0x0000a8f5
    9ffc:	0000a8f5 	.word	0x0000a8f5
    a000:	0000a8f5 	.word	0x0000a8f5
    a004:	0000a8f5 	.word	0x0000a8f5
    a008:	0000a8f5 	.word	0x0000a8f5
    a00c:	0000a8f5 	.word	0x0000a8f5
    a010:	0000a8f5 	.word	0x0000a8f5
    a014:	0000a44f 	.word	0x0000a44f
    a018:	0000a8f5 	.word	0x0000a8f5
    a01c:	0000a8f5 	.word	0x0000a8f5
    a020:	0000a8f5 	.word	0x0000a8f5
    a024:	0000a8f5 	.word	0x0000a8f5
    a028:	0000a8f5 	.word	0x0000a8f5
    a02c:	0000a8f5 	.word	0x0000a8f5
    a030:	0000a8f5 	.word	0x0000a8f5
    a034:	0000a4cf 	.word	0x0000a4cf
    a038:	0000a8f5 	.word	0x0000a8f5
    a03c:	0000a8f5 	.word	0x0000a8f5
    a040:	0000a8f5 	.word	0x0000a8f5
    a044:	0000a8f5 	.word	0x0000a8f5
    a048:	0000a8f5 	.word	0x0000a8f5
    a04c:	0000a8f5 	.word	0x0000a8f5
    a050:	0000a8f5 	.word	0x0000a8f5
    a054:	0000a4ff 	.word	0x0000a4ff
    a058:	0000a8f5 	.word	0x0000a8f5
    a05c:	0000a8f5 	.word	0x0000a8f5
    a060:	0000a8f5 	.word	0x0000a8f5
    a064:	0000a8f5 	.word	0x0000a8f5
    a068:	0000a8f5 	.word	0x0000a8f5
    a06c:	0000a8f5 	.word	0x0000a8f5
    a070:	0000a8f5 	.word	0x0000a8f5
    a074:	0000a54f 	.word	0x0000a54f
    a078:	0000a8f5 	.word	0x0000a8f5
    a07c:	0000a8f5 	.word	0x0000a8f5
    a080:	0000a8f5 	.word	0x0000a8f5
    a084:	0000a8f5 	.word	0x0000a8f5
    a088:	0000a8f5 	.word	0x0000a8f5
    a08c:	0000a8f5 	.word	0x0000a8f5
    a090:	0000a8f5 	.word	0x0000a8f5
    a094:	0000a619 	.word	0x0000a619
    a098:	0000a8f5 	.word	0x0000a8f5
    a09c:	0000a8f5 	.word	0x0000a8f5
    a0a0:	0000a8f5 	.word	0x0000a8f5
    a0a4:	0000a8f5 	.word	0x0000a8f5
    a0a8:	0000a8f5 	.word	0x0000a8f5
    a0ac:	0000a8f5 	.word	0x0000a8f5
    a0b0:	0000a8f5 	.word	0x0000a8f5
    a0b4:	0000a60f 	.word	0x0000a60f
    a0b8:	0000a8f5 	.word	0x0000a8f5
    a0bc:	0000a8f5 	.word	0x0000a8f5
    a0c0:	0000a8f5 	.word	0x0000a8f5
    a0c4:	0000a8f5 	.word	0x0000a8f5
    a0c8:	0000a8f5 	.word	0x0000a8f5
    a0cc:	0000a8f5 	.word	0x0000a8f5
    a0d0:	0000a8f5 	.word	0x0000a8f5
    a0d4:	0000a619 	.word	0x0000a619
    a0d8:	0000a8f5 	.word	0x0000a8f5
    a0dc:	0000a8f5 	.word	0x0000a8f5
    a0e0:	0000a8f5 	.word	0x0000a8f5
    a0e4:	0000a8f5 	.word	0x0000a8f5
    a0e8:	0000a8f5 	.word	0x0000a8f5
    a0ec:	0000a8f5 	.word	0x0000a8f5
    a0f0:	0000a8f5 	.word	0x0000a8f5
    a0f4:	0000a60f 	.word	0x0000a60f
    a0f8:	0000a8f5 	.word	0x0000a8f5
    a0fc:	0000a8f5 	.word	0x0000a8f5
    a100:	0000a8f5 	.word	0x0000a8f5
    a104:	0000a8f5 	.word	0x0000a8f5
    a108:	0000a8f5 	.word	0x0000a8f5
    a10c:	0000a8f5 	.word	0x0000a8f5
    a110:	0000a8f5 	.word	0x0000a8f5
    a114:	0000a675 	.word	0x0000a675
    a118:	0000a8f5 	.word	0x0000a8f5
    a11c:	0000a8f5 	.word	0x0000a8f5
    a120:	0000a8f5 	.word	0x0000a8f5
    a124:	0000a8f5 	.word	0x0000a8f5
    a128:	0000a8f5 	.word	0x0000a8f5
    a12c:	0000a8f5 	.word	0x0000a8f5
    a130:	0000a8f5 	.word	0x0000a8f5
    a134:	0000a5c3 	.word	0x0000a5c3
    a138:	0000a8f5 	.word	0x0000a8f5
    a13c:	0000a8f5 	.word	0x0000a8f5
    a140:	0000a8f5 	.word	0x0000a8f5
    a144:	0000a8f5 	.word	0x0000a8f5
    a148:	0000a8f5 	.word	0x0000a8f5
    a14c:	0000a8f5 	.word	0x0000a8f5
    a150:	0000a8f5 	.word	0x0000a8f5
    a154:	0000a675 	.word	0x0000a675
    a158:	0000a8f5 	.word	0x0000a8f5
    a15c:	0000a8f5 	.word	0x0000a8f5
    a160:	0000a8f5 	.word	0x0000a8f5
    a164:	0000a8f5 	.word	0x0000a8f5
    a168:	0000a8f5 	.word	0x0000a8f5
    a16c:	0000a8f5 	.word	0x0000a8f5
    a170:	0000a8f5 	.word	0x0000a8f5
    a174:	0000a5c3 	.word	0x0000a5c3
    a178:	0000a8f5 	.word	0x0000a8f5
    a17c:	0000a8f5 	.word	0x0000a8f5
    a180:	0000a8f5 	.word	0x0000a8f5
    a184:	0000a8f5 	.word	0x0000a8f5
    a188:	0000a8f5 	.word	0x0000a8f5
    a18c:	0000a8f5 	.word	0x0000a8f5
    a190:	0000a8f5 	.word	0x0000a8f5
    a194:	0000a6e7 	.word	0x0000a6e7
    a198:	0000a8f5 	.word	0x0000a8f5
    a19c:	0000a8f5 	.word	0x0000a8f5
    a1a0:	0000a8f5 	.word	0x0000a8f5
    a1a4:	0000a8f5 	.word	0x0000a8f5
    a1a8:	0000a8f5 	.word	0x0000a8f5
    a1ac:	0000a8f5 	.word	0x0000a8f5
    a1b0:	0000a8f5 	.word	0x0000a8f5
    a1b4:	0000a7d9 	.word	0x0000a7d9
    a1b8:	0000a8f5 	.word	0x0000a8f5
    a1bc:	0000a8f5 	.word	0x0000a8f5
    a1c0:	0000a8f5 	.word	0x0000a8f5
    a1c4:	0000a8f5 	.word	0x0000a8f5
    a1c8:	0000a8f5 	.word	0x0000a8f5
    a1cc:	0000a8f5 	.word	0x0000a8f5
    a1d0:	0000a8f5 	.word	0x0000a8f5
    a1d4:	0000a7d9 	.word	0x0000a7d9
    a1d8:	0000a8f5 	.word	0x0000a8f5
    a1dc:	0000a8f5 	.word	0x0000a8f5
    a1e0:	0000a8f5 	.word	0x0000a8f5
    a1e4:	0000a8f5 	.word	0x0000a8f5
    a1e8:	0000a8f5 	.word	0x0000a8f5
    a1ec:	0000a8f5 	.word	0x0000a8f5
    a1f0:	0000a8f5 	.word	0x0000a8f5
    a1f4:	0000a7d9 	.word	0x0000a7d9
    a1f8:	0000a8f5 	.word	0x0000a8f5
    a1fc:	0000a8f5 	.word	0x0000a8f5
    a200:	0000a8f5 	.word	0x0000a8f5
    a204:	0000a8f5 	.word	0x0000a8f5
    a208:	0000a8f5 	.word	0x0000a8f5
    a20c:	0000a8f5 	.word	0x0000a8f5
    a210:	0000a8f5 	.word	0x0000a8f5
    a214:	0000a8a3 	.word	0x0000a8a3
    a218:	0000a8f5 	.word	0x0000a8f5
    a21c:	0000a8f5 	.word	0x0000a8f5
    a220:	0000a8f5 	.word	0x0000a8f5
    a224:	0000a8f5 	.word	0x0000a8f5
    a228:	0000a8f5 	.word	0x0000a8f5
    a22c:	0000a8f5 	.word	0x0000a8f5
    a230:	0000a8f5 	.word	0x0000a8f5
    a234:	0000a8a3 	.word	0x0000a8a3
    a238:	0000a8f5 	.word	0x0000a8f5
    a23c:	0000a8f5 	.word	0x0000a8f5
    a240:	0000a8f5 	.word	0x0000a8f5
    a244:	0000a8f5 	.word	0x0000a8f5
    a248:	0000a8f5 	.word	0x0000a8f5
    a24c:	0000a8f5 	.word	0x0000a8f5
    a250:	0000a8f5 	.word	0x0000a8f5
    a254:	0000a8f5 	.word	0x0000a8f5
    a258:	0000a8f5 	.word	0x0000a8f5
    a25c:	0000a8f5 	.word	0x0000a8f5
    a260:	0000a8f5 	.word	0x0000a8f5
    a264:	0000a8f5 	.word	0x0000a8f5
    a268:	0000a8f5 	.word	0x0000a8f5
    a26c:	0000a8f5 	.word	0x0000a8f5
    a270:	0000a8f5 	.word	0x0000a8f5
    a274:	0000a7ab 	.word	0x0000a7ab
    a278:	0000a8f5 	.word	0x0000a8f5
    a27c:	0000a8f5 	.word	0x0000a8f5
    a280:	0000a8f5 	.word	0x0000a8f5
    a284:	0000a8f5 	.word	0x0000a8f5
    a288:	0000a8f5 	.word	0x0000a8f5
    a28c:	0000a8f5 	.word	0x0000a8f5
    a290:	0000a8f5 	.word	0x0000a8f5
    a294:	0000a949 	.word	0x0000a949
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            HAL_set_8bit_reg_field( this_i2c->base_address, STA, 0x00u);
    a298:	687b      	ldr	r3, [r7, #4]
    a29a:	681b      	ldr	r3, [r3, #0]
    a29c:	4618      	mov	r0, r3
    a29e:	f04f 0105 	mov.w	r1, #5
    a2a2:	f04f 0220 	mov.w	r2, #32
    a2a6:	f04f 0300 	mov.w	r3, #0
    a2aa:	f7fc f907 	bl	64bc <HW_set_8bit_reg_field>
            HAL_set_8bit_reg( this_i2c->base_address, DATA, this_i2c->target_addr); /* write call address */
    a2ae:	687b      	ldr	r3, [r7, #4]
    a2b0:	681b      	ldr	r3, [r3, #0]
    a2b2:	f103 0208 	add.w	r2, r3, #8
    a2b6:	687b      	ldr	r3, [r7, #4]
    a2b8:	689b      	ldr	r3, [r3, #8]
    a2ba:	4610      	mov	r0, r2
    a2bc:	4619      	mov	r1, r3
    a2be:	f7fc f8f9 	bl	64b4 <HW_set_8bit_reg>
            HAL_set_8bit_reg_field( this_i2c->base_address, DIR, this_i2c->dir); /* set direction bit */
    a2c2:	687b      	ldr	r3, [r7, #4]
    a2c4:	681b      	ldr	r3, [r3, #0]
    a2c6:	f103 0208 	add.w	r2, r3, #8
    a2ca:	687b      	ldr	r3, [r7, #4]
    a2cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a2ce:	4610      	mov	r0, r2
    a2d0:	f04f 0100 	mov.w	r1, #0
    a2d4:	f04f 0201 	mov.w	r2, #1
    a2d8:	f7fc f8f0 	bl	64bc <HW_set_8bit_reg_field>
            if(this_i2c->dir == WRITE_DIR)
    a2dc:	687b      	ldr	r3, [r7, #4]
    a2de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a2e0:	2b00      	cmp	r3, #0
    a2e2:	d104      	bne.n	a2ee <I2C_isr+0x3ee>
            {
                 this_i2c->master_tx_idx = 0u;
    a2e4:	687b      	ldr	r3, [r7, #4]
    a2e6:	f04f 0200 	mov.w	r2, #0
    a2ea:	621a      	str	r2, [r3, #32]
    a2ec:	e003      	b.n	a2f6 <I2C_isr+0x3f6>
            }
            else
            {
                 this_i2c->master_rx_idx = 0u;
    a2ee:	687b      	ldr	r3, [r7, #4]
    a2f0:	f04f 0200 	mov.w	r2, #0
    a2f4:	631a      	str	r2, [r3, #48]	; 0x30
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
    a2f6:	687b      	ldr	r3, [r7, #4]
    a2f8:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
    a2fc:	2b00      	cmp	r3, #0
    a2fe:	d004      	beq.n	a30a <I2C_isr+0x40a>
            {
                this_i2c->is_transaction_pending = 0u;
    a300:	687b      	ldr	r3, [r7, #4]
    a302:	f04f 0200 	mov.w	r2, #0
    a306:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
    a30a:	687b      	ldr	r3, [r7, #4]
    a30c:	7b1a      	ldrb	r2, [r3, #12]
    a30e:	687b      	ldr	r3, [r7, #4]
    a310:	f893 306a 	ldrb.w	r3, [r3, #106]	; 0x6a
    a314:	429a      	cmp	r2, r3
    a316:	f000 8319 	beq.w	a94c <I2C_isr+0xa4c>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
    a31a:	687b      	ldr	r3, [r7, #4]
    a31c:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
    a320:	687b      	ldr	r3, [r7, #4]
    a322:	731a      	strb	r2, [r3, #12]
            }
            break;
    a324:	e31b      	b.n	a95e <I2C_isr+0xa5e>
            
        case ST_LOST_ARB:
              /* Set start bit.  Let's keep trying!  Don't give up! */
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    a326:	687b      	ldr	r3, [r7, #4]
    a328:	681b      	ldr	r3, [r3, #0]
    a32a:	4618      	mov	r0, r3
    a32c:	f04f 0105 	mov.w	r1, #5
    a330:	f04f 0220 	mov.w	r2, #32
    a334:	f04f 0301 	mov.w	r3, #1
    a338:	f7fc f8c0 	bl	64bc <HW_set_8bit_reg_field>
              break;
    a33c:	e30f      	b.n	a95e <I2C_isr+0xa5e>
              break;

        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
    a33e:	687b      	ldr	r3, [r7, #4]
    a340:	681b      	ldr	r3, [r3, #0]
    a342:	4618      	mov	r0, r3
    a344:	f04f 0104 	mov.w	r1, #4
    a348:	f04f 0210 	mov.w	r2, #16
    a34c:	f04f 0301 	mov.w	r3, #1
    a350:	f7fc f8b4 	bl	64bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
    a354:	687b      	ldr	r3, [r7, #4]
    a356:	f04f 0202 	mov.w	r2, #2
    a35a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            this_i2c->transaction = NO_TRANSACTION;
    a35e:	687b      	ldr	r3, [r7, #4]
    a360:	f04f 0200 	mov.w	r2, #0
    a364:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
    a366:	6878      	ldr	r0, [r7, #4]
    a368:	f7ff fdb2 	bl	9ed0 <enable_slave_if_required>
            break;
    a36c:	e2f7      	b.n	a95e <I2C_isr+0xa5e>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
    a36e:	687b      	ldr	r3, [r7, #4]
    a370:	6a1a      	ldr	r2, [r3, #32]
    a372:	687b      	ldr	r3, [r7, #4]
    a374:	69db      	ldr	r3, [r3, #28]
    a376:	429a      	cmp	r2, r3
    a378:	d212      	bcs.n	a3a0 <I2C_isr+0x4a0>
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
    a37a:	687b      	ldr	r3, [r7, #4]
    a37c:	681b      	ldr	r3, [r3, #0]
    a37e:	f103 0108 	add.w	r1, r3, #8
    a382:	687b      	ldr	r3, [r7, #4]
    a384:	699a      	ldr	r2, [r3, #24]
    a386:	687b      	ldr	r3, [r7, #4]
    a388:	6a1b      	ldr	r3, [r3, #32]
    a38a:	441a      	add	r2, r3
    a38c:	7812      	ldrb	r2, [r2, #0]
    a38e:	f103 0001 	add.w	r0, r3, #1
    a392:	687b      	ldr	r3, [r7, #4]
    a394:	6218      	str	r0, [r3, #32]
    a396:	4608      	mov	r0, r1
    a398:	4611      	mov	r1, r2
    a39a:	f7fc f88b 	bl	64b4 <HW_set_8bit_reg>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
    a39e:	e2de      	b.n	a95e <I2C_isr+0xa5e>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
    a3a0:	687b      	ldr	r3, [r7, #4]
    a3a2:	7b1b      	ldrb	r3, [r3, #12]
    a3a4:	2b03      	cmp	r3, #3
    a3a6:	d10f      	bne.n	a3c8 <I2C_isr+0x4c8>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
    a3a8:	687b      	ldr	r3, [r7, #4]
    a3aa:	f04f 0201 	mov.w	r2, #1
    a3ae:	625a      	str	r2, [r3, #36]	; 0x24
                 HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    a3b0:	687b      	ldr	r3, [r7, #4]
    a3b2:	681b      	ldr	r3, [r3, #0]
    a3b4:	4618      	mov	r0, r3
    a3b6:	f04f 0105 	mov.w	r1, #5
    a3ba:	f04f 0220 	mov.w	r2, #32
    a3be:	f04f 0301 	mov.w	r3, #1
    a3c2:	f7fc f87b 	bl	64bc <HW_set_8bit_reg_field>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
    a3c6:	e2ca      	b.n	a95e <I2C_isr+0xa5e>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
    a3c8:	687b      	ldr	r3, [r7, #4]
    a3ca:	f04f 0200 	mov.w	r2, #0
    a3ce:	731a      	strb	r2, [r3, #12]
                hold_bus = this_i2c->options & I2C_HOLD_BUS;
    a3d0:	687b      	ldr	r3, [r7, #4]
    a3d2:	7d1b      	ldrb	r3, [r3, #20]
    a3d4:	f003 0301 	and.w	r3, r3, #1
    a3d8:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
    a3da:	687b      	ldr	r3, [r7, #4]
    a3dc:	7b7a      	ldrb	r2, [r7, #13]
    a3de:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                if ( hold_bus == 0u )
    a3e2:	7b7b      	ldrb	r3, [r7, #13]
    a3e4:	2b00      	cmp	r3, #0
    a3e6:	d10e      	bne.n	a406 <I2C_isr+0x506>
                { 
                    HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
    a3e8:	687b      	ldr	r3, [r7, #4]
    a3ea:	681b      	ldr	r3, [r3, #0]
    a3ec:	4618      	mov	r0, r3
    a3ee:	f04f 0104 	mov.w	r1, #4
    a3f2:	f04f 0210 	mov.w	r2, #16
    a3f6:	f04f 0301 	mov.w	r3, #1
    a3fa:	f7fc f85f 	bl	64bc <HW_set_8bit_reg_field>
                    enable_slave_if_required(this_i2c);
    a3fe:	6878      	ldr	r0, [r7, #4]
    a400:	f7ff fd66 	bl	9ed0 <enable_slave_if_required>
    a404:	e005      	b.n	a412 <I2C_isr+0x512>
                }
                else
                {
                    I2C_disable_irq( this_i2c );
    a406:	6878      	ldr	r0, [r7, #4]
    a408:	f000 fb48 	bl	aa9c <I2C_disable_irq>
                    clear_irq = 0u;
    a40c:	f04f 0300 	mov.w	r3, #0
    a410:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = I2C_SUCCESS;
    a412:	687b      	ldr	r3, [r7, #4]
    a414:	f04f 0200 	mov.w	r2, #0
    a418:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }
            break;
    a41c:	e29f      	b.n	a95e <I2C_isr+0xa5e>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);/* xmt stop condition */
    a41e:	687b      	ldr	r3, [r7, #4]
    a420:	681b      	ldr	r3, [r3, #0]
    a422:	4618      	mov	r0, r3
    a424:	f04f 0104 	mov.w	r1, #4
    a428:	f04f 0210 	mov.w	r2, #16
    a42c:	f04f 0301 	mov.w	r3, #1
    a430:	f7fc f844 	bl	64bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
    a434:	687b      	ldr	r3, [r7, #4]
    a436:	f04f 0202 	mov.w	r2, #2
    a43a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    a43e:	687b      	ldr	r3, [r7, #4]
    a440:	f04f 0200 	mov.w	r2, #0
    a444:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
    a446:	6878      	ldr	r0, [r7, #4]
    a448:	f7ff fd42 	bl	9ed0 <enable_slave_if_required>
            break;
    a44c:	e287      	b.n	a95e <I2C_isr+0xa5e>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
    a44e:	687b      	ldr	r3, [r7, #4]
    a450:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    a452:	2b01      	cmp	r3, #1
    a454:	d90b      	bls.n	a46e <I2C_isr+0x56e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
    a456:	687b      	ldr	r3, [r7, #4]
    a458:	681b      	ldr	r3, [r3, #0]
    a45a:	4618      	mov	r0, r3
    a45c:	f04f 0102 	mov.w	r1, #2
    a460:	f04f 0204 	mov.w	r2, #4
    a464:	f04f 0301 	mov.w	r3, #1
    a468:	f7fc f828 	bl	64bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    a46c:	e277      	b.n	a95e <I2C_isr+0xa5e>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
            }
            else if(1u == this_i2c->master_rx_size)
    a46e:	687b      	ldr	r3, [r7, #4]
    a470:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    a472:	2b01      	cmp	r3, #1
    a474:	d10b      	bne.n	a48e <I2C_isr+0x58e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
    a476:	687b      	ldr	r3, [r7, #4]
    a478:	681b      	ldr	r3, [r3, #0]
    a47a:	4618      	mov	r0, r3
    a47c:	f04f 0102 	mov.w	r1, #2
    a480:	f04f 0204 	mov.w	r2, #4
    a484:	f04f 0300 	mov.w	r3, #0
    a488:	f7fc f818 	bl	64bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
    a48c:	e267      	b.n	a95e <I2C_isr+0xa5e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
    a48e:	687b      	ldr	r3, [r7, #4]
    a490:	681b      	ldr	r3, [r3, #0]
    a492:	4618      	mov	r0, r3
    a494:	f04f 0102 	mov.w	r1, #2
    a498:	f04f 0204 	mov.w	r2, #4
    a49c:	f04f 0301 	mov.w	r3, #1
    a4a0:	f7fc f80c 	bl	64bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
    a4a4:	687b      	ldr	r3, [r7, #4]
    a4a6:	681b      	ldr	r3, [r3, #0]
    a4a8:	4618      	mov	r0, r3
    a4aa:	f04f 0104 	mov.w	r1, #4
    a4ae:	f04f 0210 	mov.w	r2, #16
    a4b2:	f04f 0301 	mov.w	r3, #1
    a4b6:	f7fc f801 	bl	64bc <HW_set_8bit_reg_field>
                this_i2c->master_status = I2C_SUCCESS;
    a4ba:	687b      	ldr	r3, [r7, #4]
    a4bc:	f04f 0200 	mov.w	r2, #0
    a4c0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                this_i2c->transaction = NO_TRANSACTION;
    a4c4:	687b      	ldr	r3, [r7, #4]
    a4c6:	f04f 0200 	mov.w	r2, #0
    a4ca:	731a      	strb	r2, [r3, #12]
            }
            break;
    a4cc:	e247      	b.n	a95e <I2C_isr+0xa5e>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
    a4ce:	687b      	ldr	r3, [r7, #4]
    a4d0:	681b      	ldr	r3, [r3, #0]
    a4d2:	4618      	mov	r0, r3
    a4d4:	f04f 0104 	mov.w	r1, #4
    a4d8:	f04f 0210 	mov.w	r2, #16
    a4dc:	f04f 0301 	mov.w	r3, #1
    a4e0:	f7fb ffec 	bl	64bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
    a4e4:	687b      	ldr	r3, [r7, #4]
    a4e6:	f04f 0202 	mov.w	r2, #2
    a4ea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    a4ee:	687b      	ldr	r3, [r7, #4]
    a4f0:	f04f 0200 	mov.w	r2, #0
    a4f4:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
    a4f6:	6878      	ldr	r0, [r7, #4]
    a4f8:	f7ff fcea 	bl	9ed0 <enable_slave_if_required>
            break;
    a4fc:	e22f      	b.n	a95e <I2C_isr+0xa5e>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
    a4fe:	687b      	ldr	r3, [r7, #4]
    a500:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a502:	687a      	ldr	r2, [r7, #4]
    a504:	6b14      	ldr	r4, [r2, #48]	; 0x30
    a506:	eb03 0504 	add.w	r5, r3, r4
    a50a:	687b      	ldr	r3, [r7, #4]
    a50c:	681b      	ldr	r3, [r3, #0]
    a50e:	f103 0308 	add.w	r3, r3, #8
    a512:	4618      	mov	r0, r3
    a514:	f7fb ffd0 	bl	64b8 <HW_get_8bit_reg>
    a518:	4603      	mov	r3, r0
    a51a:	702b      	strb	r3, [r5, #0]
    a51c:	f104 0201 	add.w	r2, r4, #1
    a520:	687b      	ldr	r3, [r7, #4]
    a522:	631a      	str	r2, [r3, #48]	; 0x30
            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
    a524:	687b      	ldr	r3, [r7, #4]
    a526:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    a528:	687b      	ldr	r3, [r7, #4]
    a52a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    a52c:	f103 33ff 	add.w	r3, r3, #4294967295
    a530:	429a      	cmp	r2, r3
    a532:	f0c0 820d 	bcc.w	a950 <I2C_isr+0xa50>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
    a536:	687b      	ldr	r3, [r7, #4]
    a538:	681b      	ldr	r3, [r3, #0]
    a53a:	4618      	mov	r0, r3
    a53c:	f04f 0102 	mov.w	r1, #2
    a540:	f04f 0204 	mov.w	r2, #4
    a544:	f04f 0300 	mov.w	r3, #0
    a548:	f7fb ffb8 	bl	64bc <HW_set_8bit_reg_field>
            }
            break;
    a54c:	e207      	b.n	a95e <I2C_isr+0xa5e>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
    a54e:	687b      	ldr	r3, [r7, #4]
    a550:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    a552:	687b      	ldr	r3, [r7, #4]
    a554:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    a556:	eb02 0403 	add.w	r4, r2, r3
    a55a:	687b      	ldr	r3, [r7, #4]
    a55c:	681b      	ldr	r3, [r3, #0]
    a55e:	f103 0308 	add.w	r3, r3, #8
    a562:	4618      	mov	r0, r3
    a564:	f7fb ffa8 	bl	64b8 <HW_get_8bit_reg>
    a568:	4603      	mov	r3, r0
    a56a:	7023      	strb	r3, [r4, #0]
          
            hold_bus = this_i2c->options & I2C_HOLD_BUS; 
    a56c:	687b      	ldr	r3, [r7, #4]
    a56e:	7d1b      	ldrb	r3, [r3, #20]
    a570:	f003 0301 	and.w	r3, r3, #1
    a574:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
    a576:	687b      	ldr	r3, [r7, #4]
    a578:	7b7a      	ldrb	r2, [r7, #13]
    a57a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
            if ( hold_bus == 0u )
    a57e:	7b7b      	ldrb	r3, [r7, #13]
    a580:	2b00      	cmp	r3, #0
    a582:	d10e      	bne.n	a5a2 <I2C_isr+0x6a2>
            { 
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
    a584:	687b      	ldr	r3, [r7, #4]
    a586:	681b      	ldr	r3, [r3, #0]
    a588:	4618      	mov	r0, r3
    a58a:	f04f 0104 	mov.w	r1, #4
    a58e:	f04f 0210 	mov.w	r2, #16
    a592:	f04f 0301 	mov.w	r3, #1
    a596:	f7fb ff91 	bl	64bc <HW_set_8bit_reg_field>

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
    a59a:	6878      	ldr	r0, [r7, #4]
    a59c:	f7ff fc98 	bl	9ed0 <enable_slave_if_required>
    a5a0:	e005      	b.n	a5ae <I2C_isr+0x6ae>
            }
            else
            {
                I2C_disable_irq( this_i2c );
    a5a2:	6878      	ldr	r0, [r7, #4]
    a5a4:	f000 fa7a 	bl	aa9c <I2C_disable_irq>
                clear_irq = 0u;
    a5a8:	f04f 0300 	mov.w	r3, #0
    a5ac:	73bb      	strb	r3, [r7, #14]
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    a5ae:	687b      	ldr	r3, [r7, #4]
    a5b0:	f04f 0200 	mov.w	r2, #0
    a5b4:	731a      	strb	r2, [r3, #12]
            this_i2c->master_status = I2C_SUCCESS;
    a5b6:	687b      	ldr	r3, [r7, #4]
    a5b8:	f04f 0200 	mov.w	r2, #0
    a5bc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            break;
    a5c0:	e1cd      	b.n	a95e <I2C_isr+0xa5e>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
    a5c2:	687b      	ldr	r3, [r7, #4]
    a5c4:	681b      	ldr	r3, [r3, #0]
    a5c6:	4618      	mov	r0, r3
    a5c8:	f04f 0102 	mov.w	r1, #2
    a5cc:	f04f 0204 	mov.w	r2, #4
    a5d0:	f04f 0301 	mov.w	r3, #1
    a5d4:	f7fb ff72 	bl	64bc <HW_set_8bit_reg_field>

            this_i2c->transaction = NO_TRANSACTION;
    a5d8:	687b      	ldr	r3, [r7, #4]
    a5da:	f04f 0200 	mov.w	r2, #0
    a5de:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_status = I2C_SUCCESS;
    a5e0:	687b      	ldr	r3, [r7, #4]
    a5e2:	f04f 0200 	mov.w	r2, #0
    a5e6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    a5ea:	687b      	ldr	r3, [r7, #4]
    a5ec:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
    a5f0:	2b00      	cmp	r3, #0
    a5f2:	f000 81af 	beq.w	a954 <I2C_isr+0xa54>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    a5f6:	687b      	ldr	r3, [r7, #4]
    a5f8:	681b      	ldr	r3, [r3, #0]
    a5fa:	4618      	mov	r0, r3
    a5fc:	f04f 0105 	mov.w	r1, #5
    a600:	f04f 0220 	mov.w	r2, #32
    a604:	f04f 0301 	mov.w	r3, #1
    a608:	f7fb ff58 	bl	64bc <HW_set_8bit_reg_field>
            }
            break;
    a60c:	e1a7      	b.n	a95e <I2C_isr+0xa5e>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
    a60e:	687b      	ldr	r3, [r7, #4]
    a610:	f04f 0201 	mov.w	r2, #1
    a614:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */
            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
    a618:	687b      	ldr	r3, [r7, #4]
    a61a:	f04f 0204 	mov.w	r2, #4
    a61e:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_rx_idx = 0u;
    a620:	687b      	ldr	r3, [r7, #4]
    a622:	f04f 0200 	mov.w	r2, #0
    a626:	651a      	str	r2, [r3, #80]	; 0x50
            this_i2c->random_read_addr = 0u;
    a628:	687b      	ldr	r3, [r7, #4]
    a62a:	f04f 0200 	mov.w	r2, #0
    a62e:	611a      	str	r2, [r3, #16]
            /*
             * If Start Bit is set clear it, but store that information since it is because of
             * pending transaction
             */
            if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
    a630:	687b      	ldr	r3, [r7, #4]
    a632:	681b      	ldr	r3, [r3, #0]
    a634:	4618      	mov	r0, r3
    a636:	f04f 0105 	mov.w	r1, #5
    a63a:	f04f 0220 	mov.w	r2, #32
    a63e:	f7fb ff4b 	bl	64d8 <HW_get_8bit_reg_field>
    a642:	4603      	mov	r3, r0
    a644:	2b00      	cmp	r3, #0
    a646:	d00f      	beq.n	a668 <I2C_isr+0x768>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
    a648:	687b      	ldr	r3, [r7, #4]
    a64a:	681b      	ldr	r3, [r3, #0]
    a64c:	4618      	mov	r0, r3
    a64e:	f04f 0105 	mov.w	r1, #5
    a652:	f04f 0220 	mov.w	r2, #32
    a656:	f04f 0300 	mov.w	r3, #0
    a65a:	f7fb ff2f 	bl	64bc <HW_set_8bit_reg_field>
                this_i2c->is_transaction_pending = 1u;
    a65e:	687b      	ldr	r3, [r7, #4]
    a660:	f04f 0201 	mov.w	r2, #1
    a664:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            }
            this_i2c->slave_status = I2C_IN_PROGRESS;
    a668:	687b      	ldr	r3, [r7, #4]
    a66a:	f04f 0201 	mov.w	r2, #1
    a66e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
    a672:	e174      	b.n	a95e <I2C_isr+0xa5e>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    a674:	687b      	ldr	r3, [r7, #4]
    a676:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a678:	2b00      	cmp	r3, #0
    a67a:	d021      	beq.n	a6c0 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
    a67c:	687b      	ldr	r3, [r7, #4]
    a67e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a680:	687b      	ldr	r3, [r7, #4]
    a682:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
    a684:	429a      	cmp	r2, r3
    a686:	d21b      	bcs.n	a6c0 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = HAL_get_8bit_reg(this_i2c->base_address, DATA);
    a688:	687b      	ldr	r3, [r7, #4]
    a68a:	681b      	ldr	r3, [r3, #0]
    a68c:	f103 0308 	add.w	r3, r3, #8
    a690:	4618      	mov	r0, r3
    a692:	f7fb ff11 	bl	64b8 <HW_get_8bit_reg>
    a696:	4603      	mov	r3, r0
    a698:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
    a69a:	687b      	ldr	r3, [r7, #4]
    a69c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a69e:	687b      	ldr	r3, [r7, #4]
    a6a0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    a6a2:	441a      	add	r2, r3
    a6a4:	7b39      	ldrb	r1, [r7, #12]
    a6a6:	7011      	strb	r1, [r2, #0]
    a6a8:	f103 0201 	add.w	r2, r3, #1
    a6ac:	687b      	ldr	r3, [r7, #4]
    a6ae:	651a      	str	r2, [r3, #80]	; 0x50
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
    a6b0:	687b      	ldr	r3, [r7, #4]
    a6b2:	691b      	ldr	r3, [r3, #16]
    a6b4:	ea4f 2203 	mov.w	r2, r3, lsl #8
    a6b8:	7b3b      	ldrb	r3, [r7, #12]
    a6ba:	441a      	add	r2, r3
    a6bc:	687b      	ldr	r3, [r7, #4]
    a6be:	611a      	str	r2, [r3, #16]
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
    a6c0:	687b      	ldr	r3, [r7, #4]
    a6c2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a6c4:	687b      	ldr	r3, [r7, #4]
    a6c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a6c8:	429a      	cmp	r2, r3
    a6ca:	f0c0 8145 	bcc.w	a958 <I2C_isr+0xa58>
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
    a6ce:	687b      	ldr	r3, [r7, #4]
    a6d0:	681b      	ldr	r3, [r3, #0]
    a6d2:	4618      	mov	r0, r3
    a6d4:	f04f 0102 	mov.w	r1, #2
    a6d8:	f04f 0204 	mov.w	r2, #4
    a6dc:	f04f 0300 	mov.w	r3, #0
    a6e0:	f7fb feec 	bl	64bc <HW_set_8bit_reg_field>
            }
            break;
    a6e4:	e13b      	b.n	a95e <I2C_isr+0xa5e>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
    a6e6:	687b      	ldr	r3, [r7, #4]
    a6e8:	7b1b      	ldrb	r3, [r3, #12]
    a6ea:	2b04      	cmp	r3, #4
    a6ec:	d13c      	bne.n	a768 <I2C_isr+0x868>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
    a6ee:	687b      	ldr	r3, [r7, #4]
    a6f0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a6f2:	687b      	ldr	r3, [r7, #4]
    a6f4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    a6f6:	429a      	cmp	r2, r3
    a6f8:	d103      	bne.n	a702 <I2C_isr+0x802>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
    a6fa:	687b      	ldr	r3, [r7, #4]
    a6fc:	691a      	ldr	r2, [r3, #16]
    a6fe:	687b      	ldr	r3, [r7, #4]
    a700:	645a      	str	r2, [r3, #68]	; 0x44
                }
                /* Call the slave's write transaction handler if it exists. */
                if ( this_i2c->slave_write_handler != 0u )
    a702:	687b      	ldr	r3, [r7, #4]
    a704:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    a706:	2b00      	cmp	r3, #0
    a708:	d022      	beq.n	a750 <I2C_isr+0x850>
                {
                    i2c_slave_handler_ret_t h_ret;
                    h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
    a70a:	687b      	ldr	r3, [r7, #4]
    a70c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    a70e:	687a      	ldr	r2, [r7, #4]
    a710:	6c91      	ldr	r1, [r2, #72]	; 0x48
    a712:	687a      	ldr	r2, [r7, #4]
    a714:	6d12      	ldr	r2, [r2, #80]	; 0x50
    a716:	b292      	uxth	r2, r2
    a718:	6878      	ldr	r0, [r7, #4]
    a71a:	4798      	blx	r3
    a71c:	4603      	mov	r3, r0
    a71e:	73fb      	strb	r3, [r7, #15]
                    if ( I2C_REENABLE_SLAVE_RX == h_ret )
    a720:	7bfb      	ldrb	r3, [r7, #15]
    a722:	2b00      	cmp	r3, #0
    a724:	d103      	bne.n	a72e <I2C_isr+0x82e>
                    {
                        /* There is a small risk that the write handler could
                         * call I2C_disable_slave() but return
                         * I2C_REENABLE_SLAVE_RX in error so we only enable
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
    a726:	6878      	ldr	r0, [r7, #4]
    a728:	f7ff fbd2 	bl	9ed0 <enable_slave_if_required>
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
    a72c:	e023      	b.n	a776 <I2C_isr+0x876>
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
                    }
                    else
                    {
                        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x0u );
    a72e:	687b      	ldr	r3, [r7, #4]
    a730:	681b      	ldr	r3, [r3, #0]
    a732:	4618      	mov	r0, r3
    a734:	f04f 0102 	mov.w	r1, #2
    a738:	f04f 0204 	mov.w	r2, #4
    a73c:	f04f 0300 	mov.w	r3, #0
    a740:	f7fb febc 	bl	64bc <HW_set_8bit_reg_field>
                        /* Clear slave mode flag as well otherwise in mixed
                         * master/slave applications, the AA bit will get set by
                         * subsequent master operations. */
                        this_i2c->is_slave_enabled = 0u;
    a744:	687b      	ldr	r3, [r7, #4]
    a746:	f04f 0200 	mov.w	r2, #0
    a74a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
    a74e:	e012      	b.n	a776 <I2C_isr+0x876>
    a750:	687b      	ldr	r3, [r7, #4]
    a752:	681b      	ldr	r3, [r3, #0]
    a754:	4618      	mov	r0, r3
    a756:	f04f 0102 	mov.w	r1, #2
    a75a:	f04f 0204 	mov.w	r2, #4
    a75e:	f04f 0301 	mov.w	r3, #1
    a762:	f7fb feab 	bl	64bc <HW_set_8bit_reg_field>
    a766:	e006      	b.n	a776 <I2C_isr+0x876>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
    a768:	687b      	ldr	r3, [r7, #4]
    a76a:	f04f 0200 	mov.w	r2, #0
    a76e:	645a      	str	r2, [r3, #68]	; 0x44
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
    a770:	6878      	ldr	r0, [r7, #4]
    a772:	f7ff fbad 	bl	9ed0 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = I2C_SUCCESS;
    a776:	687b      	ldr	r3, [r7, #4]
    a778:	f04f 0200 	mov.w	r2, #0
    a77c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    a780:	687b      	ldr	r3, [r7, #4]
    a782:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
    a786:	2b00      	cmp	r3, #0
    a788:	d00a      	beq.n	a7a0 <I2C_isr+0x8a0>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    a78a:	687b      	ldr	r3, [r7, #4]
    a78c:	681b      	ldr	r3, [r3, #0]
    a78e:	4618      	mov	r0, r3
    a790:	f04f 0105 	mov.w	r1, #5
    a794:	f04f 0220 	mov.w	r2, #32
    a798:	f04f 0301 	mov.w	r3, #1
    a79c:	f7fb fe8e 	bl	64bc <HW_set_8bit_reg_field>

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    a7a0:	687b      	ldr	r3, [r7, #4]
    a7a2:	f04f 0200 	mov.w	r2, #0
    a7a6:	731a      	strb	r2, [r3, #12]

            break;
    a7a8:	e0d9      	b.n	a95e <I2C_isr+0xa5e>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
    a7aa:	687b      	ldr	r3, [r7, #4]
    a7ac:	f04f 0200 	mov.w	r2, #0
    a7b0:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    a7b2:	687b      	ldr	r3, [r7, #4]
    a7b4:	f04f 0200 	mov.w	r2, #0
    a7b8:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->slave_status)
    a7ba:	687b      	ldr	r3, [r7, #4]
    a7bc:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    a7c0:	b2db      	uxtb	r3, r3
    a7c2:	2b01      	cmp	r3, #1
    a7c4:	d104      	bne.n	a7d0 <I2C_isr+0x8d0>
            {
                this_i2c->slave_status = I2C_FAILED;
    a7c6:	687b      	ldr	r3, [r7, #4]
    a7c8:	f04f 0202 	mov.w	r2, #2
    a7cc:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
    a7d0:	6878      	ldr	r0, [r7, #4]
    a7d2:	f7ff fb7d 	bl	9ed0 <enable_slave_if_required>

            break;
    a7d6:	e0c2      	b.n	a95e <I2C_isr+0xa5e>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:       /* Arbitration lost, and: */
        case ST_RACK:           /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
    a7d8:	7afb      	ldrb	r3, [r7, #11]
    a7da:	b2db      	uxtb	r3, r3
    a7dc:	2ba8      	cmp	r3, #168	; 0xa8
    a7de:	d128      	bne.n	a832 <I2C_isr+0x932>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
    a7e0:	687b      	ldr	r3, [r7, #4]
    a7e2:	f04f 0205 	mov.w	r2, #5
    a7e6:	731a      	strb	r2, [r3, #12]
                this_i2c->random_read_addr = 0u;
    a7e8:	687b      	ldr	r3, [r7, #4]
    a7ea:	f04f 0200 	mov.w	r2, #0
    a7ee:	611a      	str	r2, [r3, #16]
                this_i2c->slave_status = I2C_IN_PROGRESS;
    a7f0:	687b      	ldr	r3, [r7, #4]
    a7f2:	f04f 0201 	mov.w	r2, #1
    a7f6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
                /* If Start Bit is set clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
    a7fa:	687b      	ldr	r3, [r7, #4]
    a7fc:	681b      	ldr	r3, [r3, #0]
    a7fe:	4618      	mov	r0, r3
    a800:	f04f 0105 	mov.w	r1, #5
    a804:	f04f 0220 	mov.w	r2, #32
    a808:	f7fb fe66 	bl	64d8 <HW_get_8bit_reg_field>
    a80c:	4603      	mov	r3, r0
    a80e:	2b00      	cmp	r3, #0
    a810:	d00f      	beq.n	a832 <I2C_isr+0x932>
                {
                    HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
    a812:	687b      	ldr	r3, [r7, #4]
    a814:	681b      	ldr	r3, [r3, #0]
    a816:	4618      	mov	r0, r3
    a818:	f04f 0105 	mov.w	r1, #5
    a81c:	f04f 0220 	mov.w	r2, #32
    a820:	f04f 0300 	mov.w	r3, #0
    a824:	f7fb fe4a 	bl	64bc <HW_set_8bit_reg_field>
                    this_i2c->is_transaction_pending = 1u;
    a828:	687b      	ldr	r3, [r7, #4]
    a82a:	f04f 0201 	mov.w	r2, #1
    a82e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
                 }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
    a832:	687b      	ldr	r3, [r7, #4]
    a834:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    a836:	687b      	ldr	r3, [r7, #4]
    a838:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a83a:	429a      	cmp	r2, r3
    a83c:	d309      	bcc.n	a852 <I2C_isr+0x952>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, 0xFFu);
    a83e:	687b      	ldr	r3, [r7, #4]
    a840:	681b      	ldr	r3, [r3, #0]
    a842:	f103 0308 	add.w	r3, r3, #8
    a846:	4618      	mov	r0, r3
    a848:	f04f 01ff 	mov.w	r1, #255	; 0xff
    a84c:	f7fb fe32 	bl	64b4 <HW_set_8bit_reg>
    a850:	e011      	b.n	a876 <I2C_isr+0x976>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++]);
    a852:	687b      	ldr	r3, [r7, #4]
    a854:	681b      	ldr	r3, [r3, #0]
    a856:	f103 0108 	add.w	r1, r3, #8
    a85a:	687b      	ldr	r3, [r7, #4]
    a85c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    a85e:	687b      	ldr	r3, [r7, #4]
    a860:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a862:	441a      	add	r2, r3
    a864:	7812      	ldrb	r2, [r2, #0]
    a866:	f103 0001 	add.w	r0, r3, #1
    a86a:	687b      	ldr	r3, [r7, #4]
    a86c:	6458      	str	r0, [r3, #68]	; 0x44
    a86e:	4608      	mov	r0, r1
    a870:	4611      	mov	r1, r2
    a872:	f7fb fe1f 	bl	64b4 <HW_set_8bit_reg>
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
    a876:	687b      	ldr	r3, [r7, #4]
    a878:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    a87a:	687b      	ldr	r3, [r7, #4]
    a87c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a87e:	429a      	cmp	r2, r3
    a880:	d36c      	bcc.n	a95c <I2C_isr+0xa5c>
            {
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
    a882:	687b      	ldr	r3, [r7, #4]
    a884:	681b      	ldr	r3, [r3, #0]
    a886:	4618      	mov	r0, r3
    a888:	f04f 0102 	mov.w	r1, #2
    a88c:	f04f 0204 	mov.w	r2, #4
    a890:	f04f 0300 	mov.w	r3, #0
    a894:	f7fb fe12 	bl	64bc <HW_set_8bit_reg_field>
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
    a898:	687b      	ldr	r3, [r7, #4]
    a89a:	f04f 0200 	mov.w	r2, #0
    a89e:	645a      	str	r2, [r3, #68]	; 0x44
            }
            break;
    a8a0:	e05d      	b.n	a95e <I2C_isr+0xa5e>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
    a8a2:	687b      	ldr	r3, [r7, #4]
    a8a4:	f04f 0200 	mov.w	r2, #0
    a8a8:	645a      	str	r2, [r3, #68]	; 0x44
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u); 
    a8aa:	687b      	ldr	r3, [r7, #4]
    a8ac:	681b      	ldr	r3, [r3, #0]
    a8ae:	4618      	mov	r0, r3
    a8b0:	f04f 0102 	mov.w	r1, #2
    a8b4:	f04f 0204 	mov.w	r2, #4
    a8b8:	f04f 0301 	mov.w	r3, #1
    a8bc:	f7fb fdfe 	bl	64bc <HW_set_8bit_reg_field>

            /*  Mark previous state as complete */
            this_i2c->slave_status = I2C_SUCCESS;
    a8c0:	687b      	ldr	r3, [r7, #4]
    a8c2:	f04f 0200 	mov.w	r2, #0
    a8c6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
    a8ca:	687b      	ldr	r3, [r7, #4]
    a8cc:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
    a8d0:	2b00      	cmp	r3, #0
    a8d2:	d00a      	beq.n	a8ea <I2C_isr+0x9ea>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
    a8d4:	687b      	ldr	r3, [r7, #4]
    a8d6:	681b      	ldr	r3, [r3, #0]
    a8d8:	4618      	mov	r0, r3
    a8da:	f04f 0105 	mov.w	r1, #5
    a8de:	f04f 0220 	mov.w	r2, #32
    a8e2:	f04f 0301 	mov.w	r3, #1
    a8e6:	f7fb fde9 	bl	64bc <HW_set_8bit_reg_field>
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
    a8ea:	687b      	ldr	r3, [r7, #4]
    a8ec:	f04f 0200 	mov.w	r2, #0
    a8f0:	731a      	strb	r2, [r3, #12]

            break;
    a8f2:	e034      	b.n	a95e <I2C_isr+0xa5e>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
    a8f4:	687b      	ldr	r3, [r7, #4]
    a8f6:	681b      	ldr	r3, [r3, #0]
    a8f8:	4618      	mov	r0, r3
    a8fa:	f04f 0105 	mov.w	r1, #5
    a8fe:	f04f 0220 	mov.w	r2, #32
    a902:	f04f 0300 	mov.w	r3, #0
    a906:	f7fb fdd9 	bl	64bc <HW_set_8bit_reg_field>
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
    a90a:	687b      	ldr	r3, [r7, #4]
    a90c:	f04f 0200 	mov.w	r2, #0
    a910:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
    a912:	687b      	ldr	r3, [r7, #4]
    a914:	f04f 0200 	mov.w	r2, #0
    a918:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->master_status)
    a91a:	687b      	ldr	r3, [r7, #4]
    a91c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    a920:	b2db      	uxtb	r3, r3
    a922:	2b01      	cmp	r3, #1
    a924:	d104      	bne.n	a930 <I2C_isr+0xa30>
            {
                this_i2c->master_status = I2C_FAILED;
    a926:	687b      	ldr	r3, [r7, #4]
    a928:	f04f 0202 	mov.w	r2, #2
    a92c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }

            if(I2C_IN_PROGRESS == this_i2c->slave_status)
    a930:	687b      	ldr	r3, [r7, #4]
    a932:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    a936:	b2db      	uxtb	r3, r3
    a938:	2b01      	cmp	r3, #1
    a93a:	d110      	bne.n	a95e <I2C_isr+0xa5e>
            {
                this_i2c->slave_status = I2C_FAILED;
    a93c:	687b      	ldr	r3, [r7, #4]
    a93e:	f04f 0202 	mov.w	r2, #2
    a942:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
    a946:	e00a      	b.n	a95e <I2C_isr+0xa5e>
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
              break;

        case ST_STOP_TRANSMIT:
             /* Stop has been transmitted. Do nothing */
              break;
    a948:	bf00      	nop
    a94a:	e008      	b.n	a95e <I2C_isr+0xa5e>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
    a94c:	bf00      	nop
    a94e:	e006      	b.n	a95e <I2C_isr+0xa5e>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            break;
    a950:	bf00      	nop
    a952:	e004      	b.n	a95e <I2C_isr+0xa5e>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
            }
            break;
    a954:	bf00      	nop
    a956:	e002      	b.n	a95e <I2C_isr+0xa5e>
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
            }
            break;
    a958:	bf00      	nop
    a95a:	e000      	b.n	a95e <I2C_isr+0xa5e>
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
    a95c:	bf00      	nop
            }

            break;
    }
    
    if ( clear_irq )
    a95e:	7bbb      	ldrb	r3, [r7, #14]
    a960:	2b00      	cmp	r3, #0
    a962:	d00a      	beq.n	a97a <I2C_isr+0xa7a>
    {
        /* clear interrupt. */
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
    a964:	687b      	ldr	r3, [r7, #4]
    a966:	681b      	ldr	r3, [r3, #0]
    a968:	4618      	mov	r0, r3
    a96a:	f04f 0103 	mov.w	r1, #3
    a96e:	f04f 0208 	mov.w	r2, #8
    a972:	f04f 0300 	mov.w	r3, #0
    a976:	f7fb fda1 	bl	64bc <HW_set_8bit_reg_field>
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
    a97a:	687b      	ldr	r3, [r7, #4]
    a97c:	681b      	ldr	r3, [r3, #0]
    a97e:	f103 0304 	add.w	r3, r3, #4
    a982:	4618      	mov	r0, r3
    a984:	f7fb fd98 	bl	64b8 <HW_get_8bit_reg>
    a988:	4603      	mov	r3, r0
    a98a:	72fb      	strb	r3, [r7, #11]
}
    a98c:	f107 0710 	add.w	r7, r7, #16
    a990:	46bd      	mov	sp, r7
    a992:	bdb0      	pop	{r4, r5, r7, pc}

0000a994 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    a994:	b480      	push	{r7}
    a996:	b083      	sub	sp, #12
    a998:	af00      	add	r7, sp, #0
    a99a:	4603      	mov	r3, r0
    a99c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    a99e:	f24e 1300 	movw	r3, #57600	; 0xe100
    a9a2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    a9a6:	f997 2007 	ldrsb.w	r2, [r7, #7]
    a9aa:	ea4f 1252 	mov.w	r2, r2, lsr #5
    a9ae:	79f9      	ldrb	r1, [r7, #7]
    a9b0:	f001 011f 	and.w	r1, r1, #31
    a9b4:	f04f 0001 	mov.w	r0, #1
    a9b8:	fa00 f101 	lsl.w	r1, r0, r1
    a9bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a9c0:	f107 070c 	add.w	r7, r7, #12
    a9c4:	46bd      	mov	sp, r7
    a9c6:	bc80      	pop	{r7}
    a9c8:	4770      	bx	lr
    a9ca:	bf00      	nop

0000a9cc <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    a9cc:	b480      	push	{r7}
    a9ce:	b083      	sub	sp, #12
    a9d0:	af00      	add	r7, sp, #0
    a9d2:	4603      	mov	r3, r0
    a9d4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    a9d6:	f24e 1300 	movw	r3, #57600	; 0xe100
    a9da:	f2ce 0300 	movt	r3, #57344	; 0xe000
    a9de:	f997 2007 	ldrsb.w	r2, [r7, #7]
    a9e2:	ea4f 1252 	mov.w	r2, r2, lsr #5
    a9e6:	79f9      	ldrb	r1, [r7, #7]
    a9e8:	f001 011f 	and.w	r1, r1, #31
    a9ec:	f04f 0001 	mov.w	r0, #1
    a9f0:	fa00 f101 	lsl.w	r1, r0, r1
    a9f4:	f102 0220 	add.w	r2, r2, #32
    a9f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a9fc:	f107 070c 	add.w	r7, r7, #12
    aa00:	46bd      	mov	sp, r7
    aa02:	bc80      	pop	{r7}
    aa04:	4770      	bx	lr
    aa06:	bf00      	nop

0000aa08 <I2C_enable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to enable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_enable_irq( i2c_instance_t * this_i2c )
{
    aa08:	b580      	push	{r7, lr}
    aa0a:	b082      	sub	sp, #8
    aa0c:	af00      	add	r7, sp, #0
    aa0e:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
    aa10:	687a      	ldr	r2, [r7, #4]
    aa12:	f24b 4338 	movw	r3, #46136	; 0xb438
    aa16:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa1a:	429a      	cmp	r2, r3
    aa1c:	d103      	bne.n	aa26 <I2C_enable_irq+0x1e>
	{
		NVIC_EnableIRQ( FabricIrq0_IRQn );
    aa1e:	f04f 0022 	mov.w	r0, #34	; 0x22
    aa22:	f7ff ffb7 	bl	a994 <NVIC_EnableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
    aa26:	687a      	ldr	r2, [r7, #4]
    aa28:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
    aa2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa30:	429a      	cmp	r2, r3
    aa32:	d103      	bne.n	aa3c <I2C_enable_irq+0x34>
	{
		NVIC_EnableIRQ( FabricIrq1_IRQn );
    aa34:	f04f 0023 	mov.w	r0, #35	; 0x23
    aa38:	f7ff ffac 	bl	a994 <NVIC_EnableIRQ>
	}
	if(this_i2c == &counter_i2c)
    aa3c:	687a      	ldr	r2, [r7, #4]
    aa3e:	f24c 034c 	movw	r3, #49228	; 0xc04c
    aa42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa46:	429a      	cmp	r2, r3
    aa48:	d103      	bne.n	aa52 <I2C_enable_irq+0x4a>
	{
		NVIC_EnableIRQ( FabricIrq2_IRQn );
    aa4a:	f04f 0024 	mov.w	r0, #36	; 0x24
    aa4e:	f7ff ffa1 	bl	a994 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c3)
    aa52:	687a      	ldr	r2, [r7, #4]
    aa54:	f24b 53c8 	movw	r3, #46536	; 0xb5c8
    aa58:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa5c:	429a      	cmp	r2, r3
    aa5e:	d103      	bne.n	aa68 <I2C_enable_irq+0x60>
	{
		NVIC_EnableIRQ( FabricIrq3_IRQn );
    aa60:	f04f 0025 	mov.w	r0, #37	; 0x25
    aa64:	f7ff ff96 	bl	a994 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c4)
    aa68:	687a      	ldr	r2, [r7, #4]
    aa6a:	f24c 03c8 	movw	r3, #49352	; 0xc0c8
    aa6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa72:	429a      	cmp	r2, r3
    aa74:	d103      	bne.n	aa7e <I2C_enable_irq+0x76>
	{
		NVIC_EnableIRQ( FabricIrq4_IRQn );
    aa76:	f04f 0026 	mov.w	r0, #38	; 0x26
    aa7a:	f7ff ff8b 	bl	a994 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c5)
    aa7e:	687a      	ldr	r2, [r7, #4]
    aa80:	f24b 535c 	movw	r3, #46428	; 0xb55c
    aa84:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aa88:	429a      	cmp	r2, r3
    aa8a:	d103      	bne.n	aa94 <I2C_enable_irq+0x8c>
	{
		NVIC_EnableIRQ( FabricIrq5_IRQn );
    aa8c:	f04f 0027 	mov.w	r0, #39	; 0x27
    aa90:	f7ff ff80 	bl	a994 <NVIC_EnableIRQ>
	}
}
    aa94:	f107 0708 	add.w	r7, r7, #8
    aa98:	46bd      	mov	sp, r7
    aa9a:	bd80      	pop	{r7, pc}

0000aa9c <I2C_disable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to disable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_disable_irq( i2c_instance_t * this_i2c )
{
    aa9c:	b580      	push	{r7, lr}
    aa9e:	b082      	sub	sp, #8
    aaa0:	af00      	add	r7, sp, #0
    aaa2:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
    aaa4:	687a      	ldr	r2, [r7, #4]
    aaa6:	f24b 4338 	movw	r3, #46136	; 0xb438
    aaaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaae:	429a      	cmp	r2, r3
    aab0:	d103      	bne.n	aaba <I2C_disable_irq+0x1e>
	{
		NVIC_DisableIRQ( FabricIrq0_IRQn );
    aab2:	f04f 0022 	mov.w	r0, #34	; 0x22
    aab6:	f7ff ff89 	bl	a9cc <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
    aaba:	687a      	ldr	r2, [r7, #4]
    aabc:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
    aac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aac4:	429a      	cmp	r2, r3
    aac6:	d103      	bne.n	aad0 <I2C_disable_irq+0x34>
	{
		NVIC_DisableIRQ( FabricIrq1_IRQn );
    aac8:	f04f 0023 	mov.w	r0, #35	; 0x23
    aacc:	f7ff ff7e 	bl	a9cc <NVIC_DisableIRQ>
	}

	if(this_i2c == &counter_i2c)
    aad0:	687a      	ldr	r2, [r7, #4]
    aad2:	f24c 034c 	movw	r3, #49228	; 0xc04c
    aad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aada:	429a      	cmp	r2, r3
    aadc:	d103      	bne.n	aae6 <I2C_disable_irq+0x4a>
	{
		NVIC_DisableIRQ( FabricIrq2_IRQn );
    aade:	f04f 0024 	mov.w	r0, #36	; 0x24
    aae2:	f7ff ff73 	bl	a9cc <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c3)
    aae6:	687a      	ldr	r2, [r7, #4]
    aae8:	f24b 53c8 	movw	r3, #46536	; 0xb5c8
    aaec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aaf0:	429a      	cmp	r2, r3
    aaf2:	d103      	bne.n	aafc <I2C_disable_irq+0x60>
	{
		NVIC_DisableIRQ( FabricIrq3_IRQn );
    aaf4:	f04f 0025 	mov.w	r0, #37	; 0x25
    aaf8:	f7ff ff68 	bl	a9cc <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c4)
    aafc:	687a      	ldr	r2, [r7, #4]
    aafe:	f24c 03c8 	movw	r3, #49352	; 0xc0c8
    ab02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab06:	429a      	cmp	r2, r3
    ab08:	d103      	bne.n	ab12 <I2C_disable_irq+0x76>
	{
		NVIC_DisableIRQ( FabricIrq4_IRQn );
    ab0a:	f04f 0026 	mov.w	r0, #38	; 0x26
    ab0e:	f7ff ff5d 	bl	a9cc <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c5)
    ab12:	687a      	ldr	r2, [r7, #4]
    ab14:	f24b 535c 	movw	r3, #46428	; 0xb55c
    ab18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab1c:	429a      	cmp	r2, r3
    ab1e:	d103      	bne.n	ab28 <I2C_disable_irq+0x8c>
	{
		NVIC_DisableIRQ( FabricIrq5_IRQn );
    ab20:	f04f 0027 	mov.w	r0, #39	; 0x27
    ab24:	f7ff ff52 	bl	a9cc <NVIC_DisableIRQ>
	}
}
    ab28:	f107 0708 	add.w	r7, r7, #8
    ab2c:	46bd      	mov	sp, r7
    ab2e:	bd80      	pop	{r7, pc}

0000ab30 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
    ab30:	b580      	push	{r7, lr}
    ab32:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
    ab34:	f000 f936 	bl	ada4 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    ab38:	f64e 5300 	movw	r3, #60672	; 0xed00
    ab3c:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ab40:	f64e 5200 	movw	r2, #60672	; 0xed00
    ab44:	f2ce 0200 	movt	r2, #57344	; 0xe000
    ab48:	6952      	ldr	r2, [r2, #20]
    ab4a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    ab4e:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
    ab50:	f7f5 fc70 	bl	434 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
    ab54:	bd80      	pop	{r7, pc}
    ab56:	bf00      	nop

0000ab58 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
    ab58:	b580      	push	{r7, lr}
    ab5a:	b088      	sub	sp, #32
    ab5c:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
    ab5e:	f248 0300 	movw	r3, #32768	; 0x8000
    ab62:	f2c4 0303 	movt	r3, #16387	; 0x4003
    ab66:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    ab6a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    ab6e:	60fb      	str	r3, [r7, #12]

    if(0u == controller_pll_init)
    ab70:	68fb      	ldr	r3, [r7, #12]
    ab72:	2b00      	cmp	r3, #0
    ab74:	f040 808b 	bne.w	ac8e <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    ab78:	f248 0300 	movw	r3, #32768	; 0x8000
    ab7c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    ab80:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    ab84:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    ab88:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
    ab8a:	697b      	ldr	r3, [r7, #20]
    ab8c:	2b00      	cmp	r3, #0
    ab8e:	d13f      	bne.n	ac10 <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
    ab90:	f24b 332c 	movw	r3, #45868	; 0xb32c
    ab94:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ab98:	f24f 0280 	movw	r2, #61568	; 0xf080
    ab9c:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    aba0:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
    aba2:	f24b 3330 	movw	r3, #45872	; 0xb330
    aba6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abaa:	f24f 0280 	movw	r2, #61568	; 0xf080
    abae:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    abb2:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
    abb4:	f24b 3334 	movw	r3, #45876	; 0xb334
    abb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abbc:	f24f 0280 	movw	r2, #61568	; 0xf080
    abc0:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    abc4:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    abc6:	f24b 3338 	movw	r3, #45880	; 0xb338
    abca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abce:	f247 02e0 	movw	r2, #28896	; 0x70e0
    abd2:	f2c0 0272 	movt	r2, #114	; 0x72
    abd6:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
    abd8:	f24b 333c 	movw	r3, #45884	; 0xb33c
    abdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abe0:	f24f 0280 	movw	r2, #61568	; 0xf080
    abe4:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    abe8:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
    abea:	f24b 3340 	movw	r3, #45888	; 0xb340
    abee:	f2c2 0300 	movt	r3, #8192	; 0x2000
    abf2:	f24f 0280 	movw	r2, #61568	; 0xf080
    abf6:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    abfa:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
    abfc:	f24b 3344 	movw	r3, #45892	; 0xb344
    ac00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ac04:	f24f 0280 	movw	r2, #61568	; 0xf080
    ac08:	f2c0 22fa 	movt	r2, #762	; 0x2fa
    ac0c:	601a      	str	r2, [r3, #0]
                break;

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
    ac0e:	e045      	b.n	ac9c <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
    ac10:	f64b 1380 	movw	r3, #47488	; 0xb980
    ac14:	f2c0 0300 	movt	r3, #0
    ac18:	f107 0204 	add.w	r2, r7, #4
    ac1c:	e893 0003 	ldmia.w	r3, {r0, r1}
    ac20:	e882 0003 	stmia.w	r2, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
    ac24:	f248 0300 	movw	r3, #32768	; 0x8000
    ac28:	f2c4 0303 	movt	r3, #16387	; 0x4003
    ac2c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    ac30:	ea4f 1393 	mov.w	r3, r3, lsr #6
    ac34:	f003 0307 	and.w	r3, r3, #7
    ac38:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
    ac3a:	69bb      	ldr	r3, [r7, #24]
    ac3c:	f107 0220 	add.w	r2, r7, #32
    ac40:	4413      	add	r3, r2
    ac42:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    ac46:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
    ac48:	7ffb      	ldrb	r3, [r7, #31]
    ac4a:	2b01      	cmp	r3, #1
    ac4c:	d00b      	beq.n	ac66 <SystemCoreClockUpdate+0x10e>
    ac4e:	2b02      	cmp	r3, #2
    ac50:	d00e      	beq.n	ac70 <SystemCoreClockUpdate+0x118>
    ac52:	2b00      	cmp	r3, #0
    ac54:	d114      	bne.n	ac80 <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
    ac56:	f000 f825 	bl	aca4 <get_rcosc_25_50mhz_frequency>
    ac5a:	4603      	mov	r3, r0
    ac5c:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
    ac5e:	6938      	ldr	r0, [r7, #16]
    ac60:	f000 f842 	bl	ace8 <set_clock_frequency_globals>
                break;
    ac64:	e01a      	b.n	ac9c <SystemCoreClockUpdate+0x144>

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
    ac66:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    ac6a:	f000 f83d 	bl	ace8 <set_clock_frequency_globals>
                break;
    ac6e:	e015      	b.n	ac9c <SystemCoreClockUpdate+0x144>

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
    ac70:	f244 2040 	movw	r0, #16960	; 0x4240
    ac74:	f2c0 000f 	movt	r0, #15
    ac78:	f000 f836 	bl	ace8 <set_clock_frequency_globals>
                break;
    ac7c:	bf00      	nop
    ac7e:	e00d      	b.n	ac9c <SystemCoreClockUpdate+0x144>

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
    ac80:	f244 2040 	movw	r0, #16960	; 0x4240
    ac84:	f2c0 000f 	movt	r0, #15
    ac88:	f000 f82e 	bl	ace8 <set_clock_frequency_globals>
    ac8c:	e006      	b.n	ac9c <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
    ac8e:	f000 f809 	bl	aca4 <get_rcosc_25_50mhz_frequency>
    ac92:	4603      	mov	r3, r0
    ac94:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
    ac96:	6938      	ldr	r0, [r7, #16]
    ac98:	f000 f826 	bl	ace8 <set_clock_frequency_globals>
    }
}
    ac9c:	f107 0720 	add.w	r7, r7, #32
    aca0:	46bd      	mov	sp, r7
    aca2:	bd80      	pop	{r7, pc}

0000aca4 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
    aca4:	b480      	push	{r7}
    aca6:	b083      	sub	sp, #12
    aca8:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
    acaa:	f248 0300 	movw	r3, #32768	; 0x8000
    acae:	f2c4 0303 	movt	r3, #16387	; 0x4003
    acb2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
    acb6:	f003 0304 	and.w	r3, r3, #4
    acba:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
    acbc:	683b      	ldr	r3, [r7, #0]
    acbe:	2b00      	cmp	r3, #0
    acc0:	d105      	bne.n	acce <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
    acc2:	f647 0340 	movw	r3, #30784	; 0x7840
    acc6:	f2c0 137d 	movt	r3, #381	; 0x17d
    acca:	607b      	str	r3, [r7, #4]
    accc:	e004      	b.n	acd8 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
    acce:	f24f 0380 	movw	r3, #61568	; 0xf080
    acd2:	f2c0 23fa 	movt	r3, #762	; 0x2fa
    acd6:	607b      	str	r3, [r7, #4]
    }

    return rcosc_frequency;
    acd8:	687b      	ldr	r3, [r7, #4]
}
    acda:	4618      	mov	r0, r3
    acdc:	f107 070c 	add.w	r7, r7, #12
    ace0:	46bd      	mov	sp, r7
    ace2:	bc80      	pop	{r7}
    ace4:	4770      	bx	lr
    ace6:	bf00      	nop

0000ace8 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    ace8:	b480      	push	{r7}
    acea:	b083      	sub	sp, #12
    acec:	af00      	add	r7, sp, #0
    acee:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
    acf0:	f24b 332c 	movw	r3, #45868	; 0xb32c
    acf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    acf8:	687a      	ldr	r2, [r7, #4]
    acfa:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
    acfc:	f24b 3330 	movw	r3, #45872	; 0xb330
    ad00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad04:	687a      	ldr	r2, [r7, #4]
    ad06:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
    ad08:	f24b 3334 	movw	r3, #45876	; 0xb334
    ad0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad10:	687a      	ldr	r2, [r7, #4]
    ad12:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    ad14:	f24b 3338 	movw	r3, #45880	; 0xb338
    ad18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad1c:	f247 02e0 	movw	r2, #28896	; 0x70e0
    ad20:	f2c0 0272 	movt	r2, #114	; 0x72
    ad24:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
    ad26:	f24b 333c 	movw	r3, #45884	; 0xb33c
    ad2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad2e:	687a      	ldr	r2, [r7, #4]
    ad30:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
    ad32:	f24b 3340 	movw	r3, #45888	; 0xb340
    ad36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad3a:	687a      	ldr	r2, [r7, #4]
    ad3c:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
    ad3e:	f24b 3344 	movw	r3, #45892	; 0xb344
    ad42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    ad46:	687a      	ldr	r2, [r7, #4]
    ad48:	601a      	str	r2, [r3, #0]
}
    ad4a:	f107 070c 	add.w	r7, r7, #12
    ad4e:	46bd      	mov	sp, r7
    ad50:	bc80      	pop	{r7}
    ad52:	4770      	bx	lr

0000ad54 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
    ad54:	b480      	push	{r7}
    ad56:	b083      	sub	sp, #12
    ad58:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
    ad5a:	f248 0300 	movw	r3, #32768	; 0x8000
    ad5e:	f2c4 0303 	movt	r3, #16387	; 0x4003
    ad62:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    ad66:	607b      	str	r3, [r7, #4]
    switch(device_version)
    ad68:	687a      	ldr	r2, [r7, #4]
    ad6a:	f64f 0302 	movw	r3, #63490	; 0xf802
    ad6e:	429a      	cmp	r2, r3
    ad70:	d006      	beq.n	ad80 <get_silicon_revision+0x2c>
    ad72:	f64f 0302 	movw	r3, #63490	; 0xf802
    ad76:	f2c0 0301 	movt	r3, #1
    ad7a:	429a      	cmp	r2, r3
    ad7c:	d004      	beq.n	ad88 <get_silicon_revision+0x34>
    ad7e:	e007      	b.n	ad90 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
    ad80:	f04f 0301 	mov.w	r3, #1
    ad84:	603b      	str	r3, [r7, #0]
            break;
    ad86:	e006      	b.n	ad96 <get_silicon_revision+0x42>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
    ad88:	f04f 0302 	mov.w	r3, #2
    ad8c:	603b      	str	r3, [r7, #0]
            break;
    ad8e:	e002      	b.n	ad96 <get_silicon_revision+0x42>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
    ad90:	f04f 0300 	mov.w	r3, #0
    ad94:	603b      	str	r3, [r7, #0]
            break;
    }

    return silicon_revision;
    ad96:	683b      	ldr	r3, [r7, #0]
}
    ad98:	4618      	mov	r0, r3
    ad9a:	f107 070c 	add.w	r7, r7, #12
    ad9e:	46bd      	mov	sp, r7
    ada0:	bc80      	pop	{r7}
    ada2:	4770      	bx	lr

0000ada4 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
    ada4:	b580      	push	{r7, lr}
    ada6:	b082      	sub	sp, #8
    ada8:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
    adaa:	f7ff ffd3 	bl	ad54 <get_silicon_revision>
    adae:	4603      	mov	r3, r0
    adb0:	607b      	str	r3, [r7, #4]

    switch(silicon_revision)
    adb2:	687b      	ldr	r3, [r7, #4]
    adb4:	2b01      	cmp	r3, #1
    adb6:	d101      	bne.n	adbc <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
    adb8:	f000 f804 	bl	adc4 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
    adbc:	f107 0708 	add.w	r7, r7, #8
    adc0:	46bd      	mov	sp, r7
    adc2:	bd80      	pop	{r7, pc}

0000adc4 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
    adc4:	b480      	push	{r7}
    adc6:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
    adc8:	f248 0300 	movw	r3, #32768	; 0x8000
    adcc:	f2c4 0303 	movt	r3, #16387	; 0x4003
    add0:	f248 0200 	movw	r2, #32768	; 0x8000
    add4:	f2c4 0203 	movt	r2, #16387	; 0x4003
    add8:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    addc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    ade0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
    ade4:	f248 0300 	movw	r3, #32768	; 0x8000
    ade8:	f2c4 0303 	movt	r3, #16387	; 0x4003
    adec:	f248 0200 	movw	r2, #32768	; 0x8000
    adf0:	f2c4 0203 	movt	r2, #16387	; 0x4003
    adf4:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    adf8:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
    adfc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
    ae00:	46bd      	mov	sp, r7
    ae02:	bc80      	pop	{r7}
    ae04:	4770      	bx	lr
    ae06:	bf00      	nop

0000ae08 <HAL_disable_interrupts>:
    ae08:	f3ef 8010 	mrs	r0, PRIMASK
    ae0c:	b672      	cpsid	i
    ae0e:	4770      	bx	lr

0000ae10 <HAL_restore_interrupts>:
    ae10:	f380 8810 	msr	PRIMASK, r0
    ae14:	4770      	bx	lr
	...

0000ae18 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    ae18:	b480      	push	{r7}
    ae1a:	b083      	sub	sp, #12
    ae1c:	af00      	add	r7, sp, #0
    ae1e:	4603      	mov	r3, r0
    ae20:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    ae22:	f24e 1300 	movw	r3, #57600	; 0xe100
    ae26:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ae2a:	f997 2007 	ldrsb.w	r2, [r7, #7]
    ae2e:	ea4f 1252 	mov.w	r2, r2, lsr #5
    ae32:	79f9      	ldrb	r1, [r7, #7]
    ae34:	f001 011f 	and.w	r1, r1, #31
    ae38:	f04f 0001 	mov.w	r0, #1
    ae3c:	fa00 f101 	lsl.w	r1, r0, r1
    ae40:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    ae44:	f107 070c 	add.w	r7, r7, #12
    ae48:	46bd      	mov	sp, r7
    ae4a:	bc80      	pop	{r7}
    ae4c:	4770      	bx	lr
    ae4e:	bf00      	nop

0000ae50 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
    ae50:	b480      	push	{r7}
    ae52:	b083      	sub	sp, #12
    ae54:	af00      	add	r7, sp, #0
    ae56:	4603      	mov	r3, r0
    ae58:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    ae5a:	f24e 1300 	movw	r3, #57600	; 0xe100
    ae5e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ae62:	f997 2007 	ldrsb.w	r2, [r7, #7]
    ae66:	ea4f 1252 	mov.w	r2, r2, lsr #5
    ae6a:	79f9      	ldrb	r1, [r7, #7]
    ae6c:	f001 011f 	and.w	r1, r1, #31
    ae70:	f04f 0001 	mov.w	r0, #1
    ae74:	fa00 f101 	lsl.w	r1, r0, r1
    ae78:	f102 0220 	add.w	r2, r2, #32
    ae7c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    ae80:	f107 070c 	add.w	r7, r7, #12
    ae84:	46bd      	mov	sp, r7
    ae86:	bc80      	pop	{r7}
    ae88:	4770      	bx	lr
    ae8a:	bf00      	nop

0000ae8c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    ae8c:	b480      	push	{r7}
    ae8e:	b083      	sub	sp, #12
    ae90:	af00      	add	r7, sp, #0
    ae92:	4603      	mov	r3, r0
    ae94:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    ae96:	f24e 1300 	movw	r3, #57600	; 0xe100
    ae9a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    ae9e:	f997 2007 	ldrsb.w	r2, [r7, #7]
    aea2:	ea4f 1252 	mov.w	r2, r2, lsr #5
    aea6:	79f9      	ldrb	r1, [r7, #7]
    aea8:	f001 011f 	and.w	r1, r1, #31
    aeac:	f04f 0001 	mov.w	r0, #1
    aeb0:	fa00 f101 	lsl.w	r1, r0, r1
    aeb4:	f102 0260 	add.w	r2, r2, #96	; 0x60
    aeb8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    aebc:	f107 070c 	add.w	r7, r7, #12
    aec0:	46bd      	mov	sp, r7
    aec2:	bc80      	pop	{r7}
    aec4:	4770      	bx	lr
    aec6:	bf00      	nop

0000aec8 <MSS_COMBLK_init>:
void MSS_COMBLK_init
(
    comblk_async_event_handler_t async_event_handler,
    uint8_t* p_response
)
{
    aec8:	b580      	push	{r7, lr}
    aeca:	b082      	sub	sp, #8
    aecc:	af00      	add	r7, sp, #0
    aece:	6078      	str	r0, [r7, #4]
    aed0:	6039      	str	r1, [r7, #0]
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    aed2:	f04f 0013 	mov.w	r0, #19
    aed6:	f7ff ffbb 	bl	ae50 <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
    aeda:	f246 0300 	movw	r3, #24576	; 0x6000
    aede:	f2c4 0301 	movt	r3, #16385	; 0x4001
    aee2:	f04f 0200 	mov.w	r2, #0
    aee6:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    aee8:	f04f 0013 	mov.w	r0, #19
    aeec:	f7ff ffce 	bl	ae8c <NVIC_ClearPendingIRQ>
    
    g_async_event_handler = async_event_handler;
    aef0:	f24b 33c8 	movw	r3, #46024	; 0xb3c8
    aef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    aef8:	687a      	ldr	r2, [r7, #4]
    aefa:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 0u;
    aefc:	f24b 33c4 	movw	r3, #46020	; 0xb3c4
    af00:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af04:	f04f 0200 	mov.w	r2, #0
    af08:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = 0u;
    af0a:	f24b 33a0 	movw	r3, #45984	; 0xb3a0
    af0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af12:	f04f 0200 	mov.w	r2, #0
    af16:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = 0u;
    af18:	f24b 33a4 	movw	r3, #45988	; 0xb3a4
    af1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af20:	f04f 0200 	mov.w	r2, #0
    af24:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = 0u;
    af26:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    af2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af2e:	f04f 0200 	mov.w	r2, #0
    af32:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = 0u;
    af34:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    af38:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af3c:	f04f 0200 	mov.w	r2, #0
    af40:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = 0u;
    af42:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    af46:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af4a:	f04f 0200 	mov.w	r2, #0
    af4e:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
    af50:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    af54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af58:	683a      	ldr	r2, [r7, #0]
    af5a:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = 0u;
    af5c:	f24b 33b8 	movw	r3, #46008	; 0xb3b8
    af60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af64:	f04f 0200 	mov.w	r2, #0
    af68:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
    af6a:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    af6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af72:	f04f 0200 	mov.w	r2, #0
    af76:	801a      	strh	r2, [r3, #0]
    g_comblk_completion_handler = 0;
    af78:	f24b 33bc 	movw	r3, #46012	; 0xb3bc
    af7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af80:	f04f 0200 	mov.w	r2, #0
    af84:	601a      	str	r2, [r3, #0]
    
    g_comblk_state = COMBLK_IDLE;
    af86:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    af8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    af8e:	f04f 0200 	mov.w	r2, #0
    af92:	701a      	strb	r2, [r3, #0]
    /*
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controller’s COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
    af94:	f246 0300 	movw	r3, #24576	; 0x6000
    af98:	f2c4 0301 	movt	r3, #16385	; 0x4001
    af9c:	f246 0200 	movw	r2, #24576	; 0x6000
    afa0:	f2c4 0201 	movt	r2, #16385	; 0x4001
    afa4:	6812      	ldr	r2, [r2, #0]
    afa6:	f022 0220 	bic.w	r2, r2, #32
    afaa:	601a      	str	r2, [r3, #0]
    COMBLK->CONTROL |= CR_ENABLE_MASK;
    afac:	f246 0300 	movw	r3, #24576	; 0x6000
    afb0:	f2c4 0301 	movt	r3, #16385	; 0x4001
    afb4:	f246 0200 	movw	r2, #24576	; 0x6000
    afb8:	f2c4 0201 	movt	r2, #16385	; 0x4001
    afbc:	6812      	ldr	r2, [r2, #0]
    afbe:	f042 0210 	orr.w	r2, r2, #16
    afc2:	601a      	str	r2, [r3, #0]
    
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    afc4:	f246 0300 	movw	r3, #24576	; 0x6000
    afc8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    afcc:	f246 0200 	movw	r2, #24576	; 0x6000
    afd0:	f2c4 0201 	movt	r2, #16385	; 0x4001
    afd4:	6892      	ldr	r2, [r2, #8]
    afd6:	f022 0201 	bic.w	r2, r2, #1
    afda:	609a      	str	r2, [r3, #8]
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    afdc:	f246 0300 	movw	r3, #24576	; 0x6000
    afe0:	f2c4 0301 	movt	r3, #16385	; 0x4001
    afe4:	f246 0200 	movw	r2, #24576	; 0x6000
    afe8:	f2c4 0201 	movt	r2, #16385	; 0x4001
    afec:	6892      	ldr	r2, [r2, #8]
    afee:	f042 0202 	orr.w	r2, r2, #2
    aff2:	609a      	str	r2, [r3, #8]
    NVIC_EnableIRQ(ComBlk_IRQn);
    aff4:	f04f 0013 	mov.w	r0, #19
    aff8:	f7ff ff0e 	bl	ae18 <NVIC_EnableIRQ>
}
    affc:	f107 0708 	add.w	r7, r7, #8
    b000:	46bd      	mov	sp, r7
    b002:	bd80      	pop	{r7, pc}

0000b004 <ComBlk_IRQHandler>:

/*==============================================================================
 * COMBLK interrupt handler.
 */
void ComBlk_IRQHandler(void)
{
    b004:	b580      	push	{r7, lr}
    b006:	b082      	sub	sp, #8
    b008:	af00      	add	r7, sp, #0
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
    b00a:	f246 0300 	movw	r3, #24576	; 0x6000
    b00e:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b012:	685b      	ldr	r3, [r3, #4]
    b014:	717b      	strb	r3, [r7, #5]
    
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
    b016:	f246 0300 	movw	r3, #24576	; 0x6000
    b01a:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b01e:	689b      	ldr	r3, [r3, #8]
    b020:	b2da      	uxtb	r2, r3
    b022:	797b      	ldrb	r3, [r7, #5]
    b024:	ea02 0303 	and.w	r3, r2, r3
    b028:	717b      	strb	r3, [r7, #5]
    
    rcv_okay = status & RCVOKAY_MASK;
    b02a:	797b      	ldrb	r3, [r7, #5]
    b02c:	f003 0302 	and.w	r3, r3, #2
    b030:	71fb      	strb	r3, [r7, #7]
    
    if(rcv_okay)
    b032:	79fb      	ldrb	r3, [r7, #7]
    b034:	2b00      	cmp	r3, #0
    b036:	d001      	beq.n	b03c <ComBlk_IRQHandler+0x38>
    {
        handle_rx_okay_irq();
    b038:	f000 f970 	bl	b31c <handle_rx_okay_irq>
    }
        
    tx_okay = status & TXTOKAY_MASK;
    b03c:	797b      	ldrb	r3, [r7, #5]
    b03e:	f003 0301 	and.w	r3, r3, #1
    b042:	71bb      	strb	r3, [r7, #6]
    if(tx_okay)
    b044:	79bb      	ldrb	r3, [r7, #6]
    b046:	2b00      	cmp	r3, #0
    b048:	d001      	beq.n	b04e <ComBlk_IRQHandler+0x4a>
    {
        handle_tx_okay_irq();
    b04a:	f000 f805 	bl	b058 <handle_tx_okay_irq>
    }
}
    b04e:	f107 0708 	add.w	r7, r7, #8
    b052:	46bd      	mov	sp, r7
    b054:	bd80      	pop	{r7, pc}
    b056:	bf00      	nop

0000b058 <handle_tx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_tx_okay_irq(void)
{
    b058:	b580      	push	{r7, lr}
    b05a:	b084      	sub	sp, #16
    b05c:	af00      	add	r7, sp, #0
    switch(g_comblk_state)
    b05e:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b062:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b066:	781b      	ldrb	r3, [r3, #0]
    b068:	2b02      	cmp	r3, #2
    b06a:	d067      	beq.n	b13c <handle_tx_okay_irq+0xe4>
    b06c:	2b05      	cmp	r3, #5
    b06e:	f000 80b6 	beq.w	b1de <handle_tx_okay_irq+0x186>
    b072:	2b01      	cmp	r3, #1
    b074:	f040 8136 	bne.w	b2e4 <handle_tx_okay_irq+0x28c>
        /*----------------------------------------------------------------------
         * The TX_OKAY interrupt should only be enabled for states COMBLK_TX_CMD
         * and COMBLK_TX_DATA.
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
    b078:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b07c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b080:	881b      	ldrh	r3, [r3, #0]
    b082:	b29b      	uxth	r3, r3
    b084:	2b00      	cmp	r3, #0
    b086:	d055      	beq.n	b134 <handle_tx_okay_irq+0xdc>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
    b088:	f24b 33a4 	movw	r3, #45988	; 0xb3a4
    b08c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b090:	681a      	ldr	r2, [r3, #0]
    b092:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b09a:	881b      	ldrh	r3, [r3, #0]
    b09c:	b29b      	uxth	r3, r3
    b09e:	4610      	mov	r0, r2
    b0a0:	4619      	mov	r1, r3
    b0a2:	f000 fb13 	bl	b6cc <fill_tx_fifo>
    b0a6:	4603      	mov	r3, r0
    b0a8:	607b      	str	r3, [r7, #4]
                if(size_sent < g_comblk_cmd_size)
    b0aa:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b0ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0b2:	881b      	ldrh	r3, [r3, #0]
    b0b4:	b29b      	uxth	r3, r3
    b0b6:	461a      	mov	r2, r3
    b0b8:	687b      	ldr	r3, [r7, #4]
    b0ba:	429a      	cmp	r2, r3
    b0bc:	d91c      	bls.n	b0f8 <handle_tx_okay_irq+0xa0>
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    b0be:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b0c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0c6:	881b      	ldrh	r3, [r3, #0]
    b0c8:	b29a      	uxth	r2, r3
    b0ca:	687b      	ldr	r3, [r7, #4]
    b0cc:	b29b      	uxth	r3, r3
    b0ce:	ebc3 0302 	rsb	r3, r3, r2
    b0d2:	b29a      	uxth	r2, r3
    b0d4:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b0d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0dc:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    b0de:	f24b 33a4 	movw	r3, #45988	; 0xb3a4
    b0e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0e6:	681a      	ldr	r2, [r3, #0]
    b0e8:	687b      	ldr	r3, [r7, #4]
    b0ea:	441a      	add	r2, r3
    b0ec:	f24b 33a4 	movw	r3, #45988	; 0xb3a4
    b0f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b0f4:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
    b0f6:	e10c      	b.n	b312 <handle_tx_okay_irq+0x2ba>
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
                }
                else
                {
                    g_comblk_cmd_size = 0u;
    b0f8:	f24b 33a8 	movw	r3, #45992	; 0xb3a8
    b0fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b100:	f04f 0200 	mov.w	r2, #0
    b104:	801a      	strh	r2, [r3, #0]
                    if(g_comblk_data_size > 0u)
    b106:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b10a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b10e:	681b      	ldr	r3, [r3, #0]
    b110:	2b00      	cmp	r3, #0
    b112:	d007      	beq.n	b124 <handle_tx_okay_irq+0xcc>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
    b114:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b118:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b11c:	f04f 0202 	mov.w	r2, #2
    b120:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
    b122:	e0f6      	b.n	b312 <handle_tx_okay_irq+0x2ba>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
                    }
                    else
                    {
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
    b124:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b128:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b12c:	f04f 0203 	mov.w	r2, #3
    b130:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
    b132:	e0ee      	b.n	b312 <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
    b134:	be00      	bkpt	0x0000
                abort_current_cmd();
    b136:	f000 fa99 	bl	b66c <abort_current_cmd>
            }
        break;
    b13a:	e0ea      	b.n	b312 <handle_tx_okay_irq+0x2ba>
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
    b13c:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b144:	681b      	ldr	r3, [r3, #0]
    b146:	2b00      	cmp	r3, #0
    b148:	d045      	beq.n	b1d6 <handle_tx_okay_irq+0x17e>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    b14a:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b14e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b152:	681a      	ldr	r2, [r3, #0]
    b154:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b158:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b15c:	681b      	ldr	r3, [r3, #0]
    b15e:	4610      	mov	r0, r2
    b160:	4619      	mov	r1, r3
    b162:	f000 fab3 	bl	b6cc <fill_tx_fifo>
    b166:	4603      	mov	r3, r0
    b168:	60bb      	str	r3, [r7, #8]
                if(size_sent < g_comblk_data_size)
    b16a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b16e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b172:	681b      	ldr	r3, [r3, #0]
    b174:	68ba      	ldr	r2, [r7, #8]
    b176:	429a      	cmp	r2, r3
    b178:	d219      	bcs.n	b1ae <handle_tx_okay_irq+0x156>
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
    b17a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b17e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b182:	681a      	ldr	r2, [r3, #0]
    b184:	68bb      	ldr	r3, [r7, #8]
    b186:	ebc3 0202 	rsb	r2, r3, r2
    b18a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b18e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b192:	601a      	str	r2, [r3, #0]
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
    b194:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b198:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b19c:	681a      	ldr	r2, [r3, #0]
    b19e:	68bb      	ldr	r3, [r7, #8]
    b1a0:	441a      	add	r2, r3
    b1a2:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b1a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1aa:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
    b1ac:	e0b1      	b.n	b312 <handle_tx_okay_irq+0x2ba>
                    g_comblk_data_size = g_comblk_data_size - size_sent;
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
                }
                else
                {
                    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    b1ae:	f246 0300 	movw	r3, #24576	; 0x6000
    b1b2:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b1b6:	f246 0200 	movw	r2, #24576	; 0x6000
    b1ba:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b1be:	6892      	ldr	r2, [r2, #8]
    b1c0:	f022 0201 	bic.w	r2, r2, #1
    b1c4:	609a      	str	r2, [r3, #8]
                    g_comblk_state = COMBLK_WAIT_RESPONSE;
    b1c6:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b1ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1ce:	f04f 0203 	mov.w	r2, #3
    b1d2:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
    b1d4:	e09d      	b.n	b312 <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
    b1d6:	be00      	bkpt	0x0000
                abort_current_cmd();
    b1d8:	f000 fa48 	bl	b66c <abort_current_cmd>
            }
        break;
    b1dc:	e099      	b.n	b312 <handle_tx_okay_irq+0x2ba>
           
        case COMBLK_TX_PAGED_DATA:
            /*
             * Read a page of data if required.
             */
            if(0u == g_comblk_data_size)
    b1de:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b1e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1e6:	681b      	ldr	r3, [r3, #0]
    b1e8:	2b00      	cmp	r3, #0
    b1ea:	d136      	bne.n	b25a <handle_tx_okay_irq+0x202>
            {
                if(g_comblk_page_handler != 0)
    b1ec:	f24b 33c0 	movw	r3, #46016	; 0xb3c0
    b1f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b1f4:	681b      	ldr	r3, [r3, #0]
    b1f6:	2b00      	cmp	r3, #0
    b1f8:	d02a      	beq.n	b250 <handle_tx_okay_irq+0x1f8>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
    b1fa:	f24b 33c0 	movw	r3, #46016	; 0xb3c0
    b1fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b202:	681b      	ldr	r3, [r3, #0]
    b204:	f24b 30ac 	movw	r0, #45996	; 0xb3ac
    b208:	f2c2 0000 	movt	r0, #8192	; 0x2000
    b20c:	4798      	blx	r3
    b20e:	4602      	mov	r2, r0
    b210:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b214:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b218:	601a      	str	r2, [r3, #0]
                    if(0u == g_comblk_data_size)
    b21a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b21e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b222:	681b      	ldr	r3, [r3, #0]
    b224:	2b00      	cmp	r3, #0
    b226:	d117      	bne.n	b258 <handle_tx_okay_irq+0x200>
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    b228:	f246 0300 	movw	r3, #24576	; 0x6000
    b22c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b230:	f246 0200 	movw	r2, #24576	; 0x6000
    b234:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b238:	6892      	ldr	r2, [r2, #8]
    b23a:	f022 0201 	bic.w	r2, r2, #1
    b23e:	609a      	str	r2, [r3, #8]
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
    b240:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b244:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b248:	f04f 0203 	mov.w	r2, #3
    b24c:	701a      	strb	r2, [r3, #0]
    b24e:	e004      	b.n	b25a <handle_tx_okay_irq+0x202>
                    }
                }
                else
                {
                    ASSERT(0);
    b250:	be00      	bkpt	0x0000
                    abort_current_cmd();
    b252:	f000 fa0b 	bl	b66c <abort_current_cmd>
    b256:	e000      	b.n	b25a <handle_tx_okay_irq+0x202>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
                    if(0u == g_comblk_data_size)
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
    b258:	bf00      	nop
            /*
             * Transmit the page data or move to COMBLK_WAIT_RESPONSE state if
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
    b25a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b25e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b262:	681b      	ldr	r3, [r3, #0]
    b264:	2b00      	cmp	r3, #0
    b266:	d113      	bne.n	b290 <handle_tx_okay_irq+0x238>
            {
                COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    b268:	f246 0300 	movw	r3, #24576	; 0x6000
    b26c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b270:	f246 0200 	movw	r2, #24576	; 0x6000
    b274:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b278:	6892      	ldr	r2, [r2, #8]
    b27a:	f022 0201 	bic.w	r2, r2, #1
    b27e:	609a      	str	r2, [r3, #8]
                g_comblk_state = COMBLK_WAIT_RESPONSE;
    b280:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b284:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b288:	f04f 0203 	mov.w	r2, #3
    b28c:	701a      	strb	r2, [r3, #0]
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
                g_comblk_p_data = &g_comblk_p_data[size_sent];
            }
        break;
    b28e:	e040      	b.n	b312 <handle_tx_okay_irq+0x2ba>
                g_comblk_state = COMBLK_WAIT_RESPONSE;
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    b290:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b294:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b298:	681a      	ldr	r2, [r3, #0]
    b29a:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b29e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2a2:	681b      	ldr	r3, [r3, #0]
    b2a4:	4610      	mov	r0, r2
    b2a6:	4619      	mov	r1, r3
    b2a8:	f000 fa10 	bl	b6cc <fill_tx_fifo>
    b2ac:	4603      	mov	r3, r0
    b2ae:	60fb      	str	r3, [r7, #12]
                g_comblk_data_size = g_comblk_data_size - size_sent;
    b2b0:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b2b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2b8:	681a      	ldr	r2, [r3, #0]
    b2ba:	68fb      	ldr	r3, [r7, #12]
    b2bc:	ebc3 0202 	rsb	r2, r3, r2
    b2c0:	f24b 33b0 	movw	r3, #46000	; 0xb3b0
    b2c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2c8:	601a      	str	r2, [r3, #0]
                g_comblk_p_data = &g_comblk_p_data[size_sent];
    b2ca:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b2ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2d2:	681a      	ldr	r2, [r3, #0]
    b2d4:	68fb      	ldr	r3, [r7, #12]
    b2d6:	441a      	add	r2, r3
    b2d8:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
    b2dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b2e0:	601a      	str	r2, [r3, #0]
            }
        break;
    b2e2:	e016      	b.n	b312 <handle_tx_okay_irq+0x2ba>
        case COMBLK_WAIT_RESPONSE:
            /* Fall through */
        case COMBLK_RX_RESPONSE:
            /* Fall through */
        default:
            COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    b2e4:	f246 0300 	movw	r3, #24576	; 0x6000
    b2e8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b2ec:	f246 0200 	movw	r2, #24576	; 0x6000
    b2f0:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b2f4:	6892      	ldr	r2, [r2, #8]
    b2f6:	f022 0201 	bic.w	r2, r2, #1
    b2fa:	609a      	str	r2, [r3, #8]
            complete_request(0u);
    b2fc:	f04f 0000 	mov.w	r0, #0
    b300:	f000 f988 	bl	b614 <complete_request>
            g_comblk_state = COMBLK_IDLE;
    b304:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b308:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b30c:	f04f 0200 	mov.w	r2, #0
    b310:	701a      	strb	r2, [r3, #0]
        break;
    }
}
    b312:	f107 0710 	add.w	r7, r7, #16
    b316:	46bd      	mov	sp, r7
    b318:	bd80      	pop	{r7, pc}
    b31a:	bf00      	nop

0000b31c <handle_rx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_rx_okay_irq(void)
{
    b31c:	b580      	push	{r7, lr}
    b31e:	b084      	sub	sp, #16
    b320:	af00      	add	r7, sp, #0
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
    b322:	f246 0300 	movw	r3, #24576	; 0x6000
    b326:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b32a:	691b      	ldr	r3, [r3, #16]
    b32c:	80bb      	strh	r3, [r7, #4]
    is_command = data16 & DATA8_COMMAND_MASK;
    b32e:	88bb      	ldrh	r3, [r7, #4]
    b330:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
    b334:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    b338:	80fb      	strh	r3, [r7, #6]
    data8 = (uint8_t)data16;
    b33a:	88bb      	ldrh	r3, [r7, #4]
    b33c:	727b      	strb	r3, [r7, #9]
            
    switch(g_comblk_state)
    b33e:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b342:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b346:	781b      	ldrb	r3, [r3, #0]
    b348:	2b05      	cmp	r3, #5
    b34a:	f200 814b 	bhi.w	b5e4 <handle_rx_okay_irq+0x2c8>
    b34e:	a201      	add	r2, pc, #4	; (adr r2, b354 <handle_rx_okay_irq+0x38>)
    b350:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b354:	0000b36d 	.word	0x0000b36d
    b358:	0000b5d1 	.word	0x0000b5d1
    b35c:	0000b5d1 	.word	0x0000b5d1
    b360:	0000b3fd 	.word	0x0000b3fd
    b364:	0000b47b 	.word	0x0000b47b
    b368:	0000b593 	.word	0x0000b593
        * MSS_COMBLK_init() enables the RCV_OKAY interrupt for the COMBLK_IDLE
        * state to receive the asynchronous power-on-reset from the system
        * controller.
        */
        case COMBLK_IDLE:
            if(is_command)
    b36c:	88fb      	ldrh	r3, [r7, #6]
    b36e:	2b00      	cmp	r3, #0
    b370:	f000 8144 	beq.w	b5fc <handle_rx_okay_irq+0x2e0>
            {
                if(data8 != POR_DIGEST_ERROR_OPCODE)
    b374:	7a7b      	ldrb	r3, [r7, #9]
    b376:	2bf1      	cmp	r3, #241	; 0xf1
    b378:	d006      	beq.n	b388 <handle_rx_okay_irq+0x6c>
                {
                    uint8_t rxed_opcode;
                    rxed_opcode = data8;
    b37a:	7a7b      	ldrb	r3, [r7, #9]
    b37c:	72bb      	strb	r3, [r7, #10]
                    process_sys_ctrl_command(rxed_opcode);
    b37e:	7abb      	ldrb	r3, [r7, #10]
    b380:	4618      	mov	r0, r3
    b382:	f000 f9e3 	bl	b74c <process_sys_ctrl_command>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
    b386:	e140      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                    rxed_opcode = data8;
                    process_sys_ctrl_command(rxed_opcode);
                }
                else
                {  
                    g_comblk_response_idx = 0;
    b388:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b38c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b390:	f04f 0200 	mov.w	r2, #0
    b394:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = data8;
    b396:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b39a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b39e:	681a      	ldr	r2, [r3, #0]
    b3a0:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b3a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3a8:	881b      	ldrh	r3, [r3, #0]
    b3aa:	b29b      	uxth	r3, r3
    b3ac:	4413      	add	r3, r2
    b3ae:	7a7a      	ldrb	r2, [r7, #9]
    b3b0:	701a      	strb	r2, [r3, #0]
                    g_comblk_response_idx++;
    b3b2:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b3b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3ba:	881b      	ldrh	r3, [r3, #0]
    b3bc:	b29b      	uxth	r3, r3
    b3be:	f103 0301 	add.w	r3, r3, #1
    b3c2:	b29a      	uxth	r2, r3
    b3c4:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b3c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3cc:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
    b3ce:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b3d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3d6:	681a      	ldr	r2, [r3, #0]
    b3d8:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b3dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3e0:	881b      	ldrh	r3, [r3, #0]
    b3e2:	b29b      	uxth	r3, r3
    b3e4:	4413      	add	r3, r2
    b3e6:	f04f 0200 	mov.w	r2, #0
    b3ea:	701a      	strb	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
    b3ec:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b3f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b3f4:	f04f 0204 	mov.w	r2, #4
    b3f8:	701a      	strb	r2, [r3, #0]
                }
            }
        break;
    b3fa:	e106      	b.n	b60a <handle_rx_okay_irq+0x2ee>
        /*----------------------------------------------------------------------
         * The RCV_OKAY interrupt should only be enabled for states
         * COMBLK_WAIT_RESPONSE and COMBLK_RX_RESPONSE. 
         */
        case COMBLK_WAIT_RESPONSE:
            if(is_command)
    b3fc:	88fb      	ldrh	r3, [r7, #6]
    b3fe:	2b00      	cmp	r3, #0
    b400:	f000 80fe 	beq.w	b600 <handle_rx_okay_irq+0x2e4>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
    b404:	7a7b      	ldrb	r3, [r7, #9]
    b406:	72fb      	strb	r3, [r7, #11]
                if(rxed_opcode == g_comblk_cmd_opcode)
    b408:	f24b 33a0 	movw	r3, #45984	; 0xb3a0
    b40c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b410:	781b      	ldrb	r3, [r3, #0]
    b412:	b2db      	uxtb	r3, r3
    b414:	7afa      	ldrb	r2, [r7, #11]
    b416:	429a      	cmp	r2, r3
    b418:	d12a      	bne.n	b470 <handle_rx_okay_irq+0x154>
                {
                    g_comblk_response_idx = 0u;
    b41a:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b41e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b422:	f04f 0200 	mov.w	r2, #0
    b426:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
    b428:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b42c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b430:	681a      	ldr	r2, [r3, #0]
    b432:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b436:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b43a:	881b      	ldrh	r3, [r3, #0]
    b43c:	b29b      	uxth	r3, r3
    b43e:	4413      	add	r3, r2
    b440:	7afa      	ldrb	r2, [r7, #11]
    b442:	701a      	strb	r2, [r3, #0]
                    ++g_comblk_response_idx;
    b444:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b448:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b44c:	881b      	ldrh	r3, [r3, #0]
    b44e:	b29b      	uxth	r3, r3
    b450:	f103 0301 	add.w	r3, r3, #1
    b454:	b29a      	uxth	r2, r3
    b456:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b45a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b45e:	801a      	strh	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
    b460:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b464:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b468:	f04f 0204 	mov.w	r2, #4
    b46c:	701a      	strb	r2, [r3, #0]
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
    b46e:	e0cc      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                    ++g_comblk_response_idx;
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
    b470:	7afb      	ldrb	r3, [r7, #11]
    b472:	4618      	mov	r0, r3
    b474:	f000 f96a 	bl	b74c <process_sys_ctrl_command>
                }
            }
        break;
    b478:	e0c7      	b.n	b60a <handle_rx_okay_irq+0x2ee>
            
        case COMBLK_RX_RESPONSE:
            if(is_command)
    b47a:	88fb      	ldrh	r3, [r7, #6]
    b47c:	2b00      	cmp	r3, #0
    b47e:	d006      	beq.n	b48e <handle_rx_okay_irq+0x172>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
    b480:	7a7b      	ldrb	r3, [r7, #9]
    b482:	733b      	strb	r3, [r7, #12]
                process_sys_ctrl_command(rxed_opcode);
    b484:	7b3b      	ldrb	r3, [r7, #12]
    b486:	4618      	mov	r0, r3
    b488:	f000 f960 	bl	b74c <process_sys_ctrl_command>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
    b48c:	e0bd      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
            else
            {
                if( g_comblk_p_response[g_comblk_response_idx-1] == POR_DIGEST_ERROR_OPCODE)
    b48e:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b492:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b496:	681a      	ldr	r2, [r3, #0]
    b498:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b49c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4a0:	881b      	ldrh	r3, [r3, #0]
    b4a2:	b29b      	uxth	r3, r3
    b4a4:	f103 33ff 	add.w	r3, r3, #4294967295
    b4a8:	4413      	add	r3, r2
    b4aa:	781b      	ldrb	r3, [r3, #0]
    b4ac:	2bf1      	cmp	r3, #241	; 0xf1
    b4ae:	d127      	bne.n	b500 <handle_rx_okay_irq+0x1e4>
                {
                    g_comblk_p_response[g_comblk_response_idx] = data8;
    b4b0:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b4b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4b8:	681a      	ldr	r2, [r3, #0]
    b4ba:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b4be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4c2:	881b      	ldrh	r3, [r3, #0]
    b4c4:	b29b      	uxth	r3, r3
    b4c6:	4413      	add	r3, r2
    b4c8:	7a7a      	ldrb	r2, [r7, #9]
    b4ca:	701a      	strb	r2, [r3, #0]
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
    b4cc:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b4d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4d4:	681a      	ldr	r2, [r3, #0]
    b4d6:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b4da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4de:	881b      	ldrh	r3, [r3, #0]
    b4e0:	b29b      	uxth	r3, r3
    b4e2:	f103 33ff 	add.w	r3, r3, #4294967295
    b4e6:	4413      	add	r3, r2
    b4e8:	781b      	ldrb	r3, [r3, #0]
    b4ea:	4618      	mov	r0, r3
    b4ec:	f000 f92e 	bl	b74c <process_sys_ctrl_command>
                    g_comblk_state = COMBLK_IDLE;
    b4f0:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b4f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b4f8:	f04f 0200 	mov.w	r2, #0
    b4fc:	701a      	strb	r2, [r3, #0]
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
    b4fe:	e084      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
                    g_comblk_state = COMBLK_IDLE;
                }
                else
                {
                    if(g_comblk_response_idx < g_comblk_response_size)
    b500:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b504:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b508:	881b      	ldrh	r3, [r3, #0]
    b50a:	b29a      	uxth	r2, r3
    b50c:	f24b 33b8 	movw	r3, #46008	; 0xb3b8
    b510:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b514:	881b      	ldrh	r3, [r3, #0]
    b516:	429a      	cmp	r2, r3
    b518:	d21d      	bcs.n	b556 <handle_rx_okay_irq+0x23a>
                    {
                        uint8_t rxed_data;
                        
                        rxed_data = data8;
    b51a:	7a7b      	ldrb	r3, [r7, #9]
    b51c:	737b      	strb	r3, [r7, #13]
                        g_comblk_p_response[g_comblk_response_idx] = rxed_data;
    b51e:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b522:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b526:	681a      	ldr	r2, [r3, #0]
    b528:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b52c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b530:	881b      	ldrh	r3, [r3, #0]
    b532:	b29b      	uxth	r3, r3
    b534:	4413      	add	r3, r2
    b536:	7b7a      	ldrb	r2, [r7, #13]
    b538:	701a      	strb	r2, [r3, #0]
                        ++g_comblk_response_idx;
    b53a:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b53e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b542:	881b      	ldrh	r3, [r3, #0]
    b544:	b29b      	uxth	r3, r3
    b546:	f103 0301 	add.w	r3, r3, #1
    b54a:	b29a      	uxth	r2, r3
    b54c:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b550:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b554:	801a      	strh	r2, [r3, #0]
                    }
                    
                    if(g_comblk_response_idx == g_comblk_response_size)
    b556:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b55a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b55e:	881b      	ldrh	r3, [r3, #0]
    b560:	b29a      	uxth	r2, r3
    b562:	f24b 33b8 	movw	r3, #46008	; 0xb3b8
    b566:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b56a:	881b      	ldrh	r3, [r3, #0]
    b56c:	429a      	cmp	r2, r3
    b56e:	d149      	bne.n	b604 <handle_rx_okay_irq+0x2e8>
                    {
                        complete_request(g_comblk_response_idx);
    b570:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b574:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b578:	881b      	ldrh	r3, [r3, #0]
    b57a:	b29b      	uxth	r3, r3
    b57c:	4618      	mov	r0, r3
    b57e:	f000 f849 	bl	b614 <complete_request>
                        g_comblk_state = COMBLK_IDLE;
    b582:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b586:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b58a:	f04f 0200 	mov.w	r2, #0
    b58e:	701a      	strb	r2, [r3, #0]
                    }
                }
            }
        break;
    b590:	e03b      	b.n	b60a <handle_rx_okay_irq+0x2ee>
         * The RCV_OKAY interrupt should NOT be enabled for states
         * COMBLK_IDLE, COMBLK_TX_CMD and COMBLK_TX_DATA.
         */
        case COMBLK_TX_PAGED_DATA:
            /* This is needed because when there is an error, we need to terminate loading the data */
            if(!is_command)
    b592:	88fb      	ldrh	r3, [r7, #6]
    b594:	2b00      	cmp	r3, #0
    b596:	d114      	bne.n	b5c2 <handle_rx_okay_irq+0x2a6>
            {
                g_comblk_p_response[1] = data8;
    b598:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b59c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5a0:	681b      	ldr	r3, [r3, #0]
    b5a2:	f103 0301 	add.w	r3, r3, #1
    b5a6:	7a7a      	ldrb	r2, [r7, #9]
    b5a8:	701a      	strb	r2, [r3, #0]
                complete_request(2u);
    b5aa:	f04f 0002 	mov.w	r0, #2
    b5ae:	f000 f831 	bl	b614 <complete_request>
                g_comblk_state = COMBLK_IDLE;
    b5b2:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b5b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5ba:	f04f 0200 	mov.w	r2, #0
    b5be:	701a      	strb	r2, [r3, #0]
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
    b5c0:	e023      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                g_comblk_state = COMBLK_IDLE;
            }
            else
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
    b5c2:	7a7b      	ldrb	r3, [r7, #9]
    b5c4:	73bb      	strb	r3, [r7, #14]
                process_sys_ctrl_command(rxed_opcode);
    b5c6:	7bbb      	ldrb	r3, [r7, #14]
    b5c8:	4618      	mov	r0, r3
    b5ca:	f000 f8bf 	bl	b74c <process_sys_ctrl_command>
            }
        break;
    b5ce:	e01c      	b.n	b60a <handle_rx_okay_irq+0x2ee>
        
        case COMBLK_TX_CMD:
            /* Fall through */
        case COMBLK_TX_DATA:
            /* Fall through */
            if(is_command)
    b5d0:	88fb      	ldrh	r3, [r7, #6]
    b5d2:	2b00      	cmp	r3, #0
    b5d4:	d018      	beq.n	b608 <handle_rx_okay_irq+0x2ec>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
    b5d6:	7a7b      	ldrb	r3, [r7, #9]
    b5d8:	73fb      	strb	r3, [r7, #15]
                process_sys_ctrl_command(rxed_opcode);
    b5da:	7bfb      	ldrb	r3, [r7, #15]
    b5dc:	4618      	mov	r0, r3
    b5de:	f000 f8b5 	bl	b74c <process_sys_ctrl_command>
            }
        break;
    b5e2:	e012      	b.n	b60a <handle_rx_okay_irq+0x2ee>
        
        default:
            complete_request(0u);
    b5e4:	f04f 0000 	mov.w	r0, #0
    b5e8:	f000 f814 	bl	b614 <complete_request>
            g_comblk_state = COMBLK_IDLE;
    b5ec:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
    b5f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b5f4:	f04f 0200 	mov.w	r2, #0
    b5f8:	701a      	strb	r2, [r3, #0]
    b5fa:	e006      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
    b5fc:	bf00      	nop
    b5fe:	e004      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
    b600:	bf00      	nop
    b602:	e002      	b.n	b60a <handle_rx_okay_irq+0x2ee>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
    b604:	bf00      	nop
    b606:	e000      	b.n	b60a <handle_rx_okay_irq+0x2ee>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
    b608:	bf00      	nop
        default:
            complete_request(0u);
            g_comblk_state = COMBLK_IDLE;
        break;
    }
}
    b60a:	f107 0710 	add.w	r7, r7, #16
    b60e:	46bd      	mov	sp, r7
    b610:	bd80      	pop	{r7, pc}
    b612:	bf00      	nop

0000b614 <complete_request>:
 */
static void complete_request
(
    uint16_t response_length
)
{
    b614:	b580      	push	{r7, lr}
    b616:	b082      	sub	sp, #8
    b618:	af00      	add	r7, sp, #0
    b61a:	4603      	mov	r3, r0
    b61c:	80fb      	strh	r3, [r7, #6]
    if(g_comblk_completion_handler != 0)
    b61e:	f24b 33bc 	movw	r3, #46012	; 0xb3bc
    b622:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b626:	681b      	ldr	r3, [r3, #0]
    b628:	2b00      	cmp	r3, #0
    b62a:	d01b      	beq.n	b664 <complete_request+0x50>
    {
        g_comblk_completion_handler(g_comblk_p_response, response_length);
    b62c:	f24b 33bc 	movw	r3, #46012	; 0xb3bc
    b630:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b634:	681a      	ldr	r2, [r3, #0]
    b636:	f24b 33b4 	movw	r3, #46004	; 0xb3b4
    b63a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b63e:	6819      	ldr	r1, [r3, #0]
    b640:	88fb      	ldrh	r3, [r7, #6]
    b642:	4608      	mov	r0, r1
    b644:	4619      	mov	r1, r3
    b646:	4790      	blx	r2
        g_comblk_completion_handler = 0;
    b648:	f24b 33bc 	movw	r3, #46012	; 0xb3bc
    b64c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b650:	f04f 0200 	mov.w	r2, #0
    b654:	601a      	str	r2, [r3, #0]
        g_request_in_progress = 0u;
    b656:	f24b 33c4 	movw	r3, #46020	; 0xb3c4
    b65a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b65e:	f04f 0200 	mov.w	r2, #0
    b662:	701a      	strb	r2, [r3, #0]
    }
}
    b664:	f107 0708 	add.w	r7, r7, #8
    b668:	46bd      	mov	sp, r7
    b66a:	bd80      	pop	{r7, pc}

0000b66c <abort_current_cmd>:

/*==============================================================================
 *
 */
static void abort_current_cmd(void)
{
    b66c:	b580      	push	{r7, lr}
    b66e:	b082      	sub	sp, #8
    b670:	af00      	add	r7, sp, #0
    if(g_request_in_progress)
    b672:	f24b 33c4 	movw	r3, #46020	; 0xb3c4
    b676:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b67a:	781b      	ldrb	r3, [r3, #0]
    b67c:	b2db      	uxtb	r3, r3
    b67e:	2b00      	cmp	r3, #0
    b680:	d01f      	beq.n	b6c2 <abort_current_cmd+0x56>
        
        /*
         * Call completion handler just in case we are in a multi threaded system
         * to avoid a task lockup.
         */
        complete_request(g_comblk_response_idx);
    b682:	f24b 33ba 	movw	r3, #46010	; 0xb3ba
    b686:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b68a:	881b      	ldrh	r3, [r3, #0]
    b68c:	b29b      	uxth	r3, r3
    b68e:	4618      	mov	r0, r3
    b690:	f7ff ffc0 	bl	b614 <complete_request>
        
        /*
         * Flush the FIFOs
         */
        COMBLK->CONTROL |= CR_FLUSHOUT_MASK;
    b694:	f246 0300 	movw	r3, #24576	; 0x6000
    b698:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b69c:	f246 0200 	movw	r2, #24576	; 0x6000
    b6a0:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b6a4:	6812      	ldr	r2, [r2, #0]
    b6a6:	f042 0201 	orr.w	r2, r2, #1
    b6aa:	601a      	str	r2, [r3, #0]
        do {
            flush_in_progress = COMBLK->CONTROL & CR_FLUSHOUT_MASK;
    b6ac:	f246 0300 	movw	r3, #24576	; 0x6000
    b6b0:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b6b4:	681b      	ldr	r3, [r3, #0]
    b6b6:	f003 0301 	and.w	r3, r3, #1
    b6ba:	607b      	str	r3, [r7, #4]
        } while(flush_in_progress);
    b6bc:	687b      	ldr	r3, [r7, #4]
    b6be:	2b00      	cmp	r3, #0
    b6c0:	d1f4      	bne.n	b6ac <abort_current_cmd+0x40>
    }
}
    b6c2:	f107 0708 	add.w	r7, r7, #8
    b6c6:	46bd      	mov	sp, r7
    b6c8:	bd80      	pop	{r7, pc}
    b6ca:	bf00      	nop

0000b6cc <fill_tx_fifo>:
static uint32_t fill_tx_fifo
(
    const uint8_t * p_cmd,
    uint32_t cmd_size
)
{
    b6cc:	b480      	push	{r7}
    b6ce:	b085      	sub	sp, #20
    b6d0:	af00      	add	r7, sp, #0
    b6d2:	6078      	str	r0, [r7, #4]
    b6d4:	6039      	str	r1, [r7, #0]
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    b6d6:	f246 0300 	movw	r3, #24576	; 0x6000
    b6da:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b6de:	f246 0200 	movw	r2, #24576	; 0x6000
    b6e2:	f2c4 0201 	movt	r2, #16385	; 0x4001
    b6e6:	6812      	ldr	r2, [r2, #0]
    b6e8:	f022 0204 	bic.w	r2, r2, #4
    b6ec:	601a      	str	r2, [r3, #0]
    
    size_sent = 0u;
    b6ee:	f04f 0300 	mov.w	r3, #0
    b6f2:	60fb      	str	r3, [r7, #12]
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    b6f4:	f246 0300 	movw	r3, #24576	; 0x6000
    b6f8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b6fc:	685b      	ldr	r3, [r3, #4]
    b6fe:	f003 0301 	and.w	r3, r3, #1
    b702:	60bb      	str	r3, [r7, #8]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    b704:	e014      	b.n	b730 <fill_tx_fifo+0x64>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    b706:	f246 0300 	movw	r3, #24576	; 0x6000
    b70a:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b70e:	6879      	ldr	r1, [r7, #4]
    b710:	68fa      	ldr	r2, [r7, #12]
    b712:	440a      	add	r2, r1
    b714:	7812      	ldrb	r2, [r2, #0]
    b716:	611a      	str	r2, [r3, #16]
        ++size_sent;
    b718:	68fb      	ldr	r3, [r7, #12]
    b71a:	f103 0301 	add.w	r3, r3, #1
    b71e:	60fb      	str	r3, [r7, #12]
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    b720:	f246 0300 	movw	r3, #24576	; 0x6000
    b724:	f2c4 0301 	movt	r3, #16385	; 0x4001
    b728:	685b      	ldr	r3, [r3, #4]
    b72a:	f003 0301 	and.w	r3, r3, #1
    b72e:	60bb      	str	r3, [r7, #8]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    b730:	68bb      	ldr	r3, [r7, #8]
    b732:	2b00      	cmp	r3, #0
    b734:	d003      	beq.n	b73e <fill_tx_fifo+0x72>
    b736:	68fa      	ldr	r2, [r7, #12]
    b738:	683b      	ldr	r3, [r7, #0]
    b73a:	429a      	cmp	r2, r3
    b73c:	d3e3      	bcc.n	b706 <fill_tx_fifo+0x3a>
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    }
    
    return size_sent;
    b73e:	68fb      	ldr	r3, [r7, #12]
}
    b740:	4618      	mov	r0, r3
    b742:	f107 0714 	add.w	r7, r7, #20
    b746:	46bd      	mov	sp, r7
    b748:	bc80      	pop	{r7}
    b74a:	4770      	bx	lr

0000b74c <process_sys_ctrl_command>:

/*==============================================================================
 *
 */
static void process_sys_ctrl_command(uint8_t cmd_opcode)
{
    b74c:	b580      	push	{r7, lr}
    b74e:	b082      	sub	sp, #8
    b750:	af00      	add	r7, sp, #0
    b752:	4603      	mov	r3, r0
    b754:	71fb      	strb	r3, [r7, #7]
    if(g_async_event_handler != 0)
    b756:	f24b 33c8 	movw	r3, #46024	; 0xb3c8
    b75a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b75e:	681b      	ldr	r3, [r3, #0]
    b760:	2b00      	cmp	r3, #0
    b762:	d007      	beq.n	b774 <process_sys_ctrl_command+0x28>
    {
        g_async_event_handler(cmd_opcode);
    b764:	f24b 33c8 	movw	r3, #46024	; 0xb3c8
    b768:	f2c2 0300 	movt	r3, #8192	; 0x2000
    b76c:	681b      	ldr	r3, [r3, #0]
    b76e:	79fa      	ldrb	r2, [r7, #7]
    b770:	4610      	mov	r0, r2
    b772:	4798      	blx	r3
    }
}
    b774:	f107 0708 	add.w	r7, r7, #8
    b778:	46bd      	mov	sp, r7
    b77a:	bd80      	pop	{r7, pc}

0000b77c <__libc_init_array>:
    b77c:	b570      	push	{r4, r5, r6, lr}
    b77e:	f64b 16a0 	movw	r6, #47520	; 0xb9a0
    b782:	f64b 15a0 	movw	r5, #47520	; 0xb9a0
    b786:	f2c0 0600 	movt	r6, #0
    b78a:	f2c0 0500 	movt	r5, #0
    b78e:	1b76      	subs	r6, r6, r5
    b790:	10b6      	asrs	r6, r6, #2
    b792:	d006      	beq.n	b7a2 <__libc_init_array+0x26>
    b794:	2400      	movs	r4, #0
    b796:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    b79a:	3401      	adds	r4, #1
    b79c:	4798      	blx	r3
    b79e:	42a6      	cmp	r6, r4
    b7a0:	d8f9      	bhi.n	b796 <__libc_init_array+0x1a>
    b7a2:	f64b 15a0 	movw	r5, #47520	; 0xb9a0
    b7a6:	f64b 16a4 	movw	r6, #47524	; 0xb9a4
    b7aa:	f2c0 0500 	movt	r5, #0
    b7ae:	f2c0 0600 	movt	r6, #0
    b7b2:	1b76      	subs	r6, r6, r5
    b7b4:	f000 f8e8 	bl	b988 <_init>
    b7b8:	10b6      	asrs	r6, r6, #2
    b7ba:	d006      	beq.n	b7ca <__libc_init_array+0x4e>
    b7bc:	2400      	movs	r4, #0
    b7be:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    b7c2:	3401      	adds	r4, #1
    b7c4:	4798      	blx	r3
    b7c6:	42a6      	cmp	r6, r4
    b7c8:	d8f9      	bhi.n	b7be <__libc_init_array+0x42>
    b7ca:	bd70      	pop	{r4, r5, r6, pc}

0000b7cc <memset>:
    b7cc:	2a03      	cmp	r2, #3
    b7ce:	b2c9      	uxtb	r1, r1
    b7d0:	b430      	push	{r4, r5}
    b7d2:	d807      	bhi.n	b7e4 <memset+0x18>
    b7d4:	b122      	cbz	r2, b7e0 <memset+0x14>
    b7d6:	2300      	movs	r3, #0
    b7d8:	54c1      	strb	r1, [r0, r3]
    b7da:	3301      	adds	r3, #1
    b7dc:	4293      	cmp	r3, r2
    b7de:	d1fb      	bne.n	b7d8 <memset+0xc>
    b7e0:	bc30      	pop	{r4, r5}
    b7e2:	4770      	bx	lr
    b7e4:	eb00 0c02 	add.w	ip, r0, r2
    b7e8:	4603      	mov	r3, r0
    b7ea:	e001      	b.n	b7f0 <memset+0x24>
    b7ec:	f803 1c01 	strb.w	r1, [r3, #-1]
    b7f0:	f003 0403 	and.w	r4, r3, #3
    b7f4:	461a      	mov	r2, r3
    b7f6:	3301      	adds	r3, #1
    b7f8:	2c00      	cmp	r4, #0
    b7fa:	d1f7      	bne.n	b7ec <memset+0x20>
    b7fc:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
    b800:	ebc2 040c 	rsb	r4, r2, ip
    b804:	fb03 f301 	mul.w	r3, r3, r1
    b808:	e01f      	b.n	b84a <memset+0x7e>
    b80a:	f842 3c40 	str.w	r3, [r2, #-64]
    b80e:	f842 3c3c 	str.w	r3, [r2, #-60]
    b812:	f842 3c38 	str.w	r3, [r2, #-56]
    b816:	f842 3c34 	str.w	r3, [r2, #-52]
    b81a:	f842 3c30 	str.w	r3, [r2, #-48]
    b81e:	f842 3c2c 	str.w	r3, [r2, #-44]
    b822:	f842 3c28 	str.w	r3, [r2, #-40]
    b826:	f842 3c24 	str.w	r3, [r2, #-36]
    b82a:	f842 3c20 	str.w	r3, [r2, #-32]
    b82e:	f842 3c1c 	str.w	r3, [r2, #-28]
    b832:	f842 3c18 	str.w	r3, [r2, #-24]
    b836:	f842 3c14 	str.w	r3, [r2, #-20]
    b83a:	f842 3c10 	str.w	r3, [r2, #-16]
    b83e:	f842 3c0c 	str.w	r3, [r2, #-12]
    b842:	f842 3c08 	str.w	r3, [r2, #-8]
    b846:	f842 3c04 	str.w	r3, [r2, #-4]
    b84a:	4615      	mov	r5, r2
    b84c:	3240      	adds	r2, #64	; 0x40
    b84e:	2c3f      	cmp	r4, #63	; 0x3f
    b850:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
    b854:	dcd9      	bgt.n	b80a <memset+0x3e>
    b856:	462a      	mov	r2, r5
    b858:	ebc5 040c 	rsb	r4, r5, ip
    b85c:	e007      	b.n	b86e <memset+0xa2>
    b85e:	f842 3c10 	str.w	r3, [r2, #-16]
    b862:	f842 3c0c 	str.w	r3, [r2, #-12]
    b866:	f842 3c08 	str.w	r3, [r2, #-8]
    b86a:	f842 3c04 	str.w	r3, [r2, #-4]
    b86e:	4615      	mov	r5, r2
    b870:	3210      	adds	r2, #16
    b872:	2c0f      	cmp	r4, #15
    b874:	f1a4 0410 	sub.w	r4, r4, #16
    b878:	dcf1      	bgt.n	b85e <memset+0x92>
    b87a:	462a      	mov	r2, r5
    b87c:	ebc5 050c 	rsb	r5, r5, ip
    b880:	e001      	b.n	b886 <memset+0xba>
    b882:	f842 3c04 	str.w	r3, [r2, #-4]
    b886:	4614      	mov	r4, r2
    b888:	3204      	adds	r2, #4
    b88a:	2d03      	cmp	r5, #3
    b88c:	f1a5 0504 	sub.w	r5, r5, #4
    b890:	dcf7      	bgt.n	b882 <memset+0xb6>
    b892:	e001      	b.n	b898 <memset+0xcc>
    b894:	f804 1b01 	strb.w	r1, [r4], #1
    b898:	4564      	cmp	r4, ip
    b89a:	d3fb      	bcc.n	b894 <memset+0xc8>
    b89c:	e7a0      	b.n	b7e0 <memset+0x14>
    b89e:	bf00      	nop
    b8a0:	6f470d0a 	.word	0x6f470d0a
    b8a4:	4b482074 	.word	0x4b482074
    b8a8:	61655220 	.word	0x61655220
    b8ac:	676e6964 	.word	0x676e6964
    b8b0:	00000073 	.word	0x00000073

0000b8b4 <C.0.1475>:
    b8b4:	00fc0f05                                ....

0000b8b8 <C.8.2448>:
    b8b8:	00006a10                                .j..

0000b8bc <C.0.2383>:
    b8bc:	00006020                                 `..

0000b8c0 <C.57.5243>:
    b8c0:	71290020                                 .)q

0000b8c4 <C.58.5244>:
    b8c4:	20002971                                q). 

0000b8c8 <C.59.5245>:
    b8c8:	212a0020                                 .*!

0000b8cc <C.60.5246>:
    b8cc:	20002a21                                !*. 

0000b8d0 <g_nvm>:
    b8d0:	60080000 600c0000                       ...`...`

0000b8d8 <g_nvm32>:
    b8d8:	60080000 600c0000                       ...`...`

0000b8e0 <g_config_reg_lut>:
    b8e0:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
    b8f0:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
    b900:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
    b910:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
    b920:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
    b930:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
    b940:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
    b950:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

0000b960 <g_gpio_irqn_lut>:
    b960:	35343332 39383736 3d3c3b3a 41403f3e     23456789:;<=>?@A
    b970:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ

0000b980 <C.18.3527>:
    b980:	01000100 03030202                       ........

0000b988 <_init>:
    b988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b98a:	bf00      	nop
    b98c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b98e:	bc08      	pop	{r3}
    b990:	469e      	mov	lr, r3
    b992:	4770      	bx	lr

0000b994 <_fini>:
    b994:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b996:	bf00      	nop
    b998:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b99a:	bc08      	pop	{r3}
    b99c:	469e      	mov	lr, r3
    b99e:	4770      	bx	lr

0000b9a0 <__frame_dummy_init_array_entry>:
    b9a0:	04d5 0000                                   ....

0000b9a4 <__do_global_dtors_aux_fini_array_entry>:
    b9a4:	04c1 0000 0000 0000 0000 0000               ............
