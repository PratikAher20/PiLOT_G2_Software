
PiLOT_sb_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  20000190  20000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000bac0  200004c0  200004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000350  2000bf80  2000bf80  00013f80  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000012c0  2000c2d0  2000c2d0  000142d0  2**4
                  ALLOC
  5 .heap         00001a70  2000d590  2000d590  000142d0  2**4
                  ALLOC
  6 .stack        00001000  2000f000  2000f000  000142d0  2**4
                  ALLOC
  7 .comment      00000433  00000000  00000000  000142d0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000dc8  00000000  00000000  00014703  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000261d  00000000  00000000  000154cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00015924  00000000  00000000  00017ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000274a  00000000  00000000  0002d40c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed29  00000000  00000000  0002fb56  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002e7c  00000000  00000000  0003e880  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000056f4  00000000  00000000  000416fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00004db0  00000000  00000000  00046df0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 000bba6c  00000000  00000000  0004bba0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  0010760c  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00000db8  00000000  00000000  00107631  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

20000000 <__vector_table_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000191 	.word	0x20000191
20000008:	2000037f 	.word	0x2000037f
2000000c:	20000381 	.word	0x20000381
20000010:	20000383 	.word	0x20000383
20000014:	20000385 	.word	0x20000385
20000018:	20000387 	.word	0x20000387
	...
2000002c:	20000389 	.word	0x20000389
20000030:	2000038b 	.word	0x2000038b
20000034:	00000000 	.word	0x00000000
20000038:	2000038d 	.word	0x2000038d
2000003c:	2000038f 	.word	0x2000038f
20000040:	20000391 	.word	0x20000391
20000044:	20000393 	.word	0x20000393
20000048:	20008499 	.word	0x20008499
2000004c:	200084bd 	.word	0x200084bd
20000050:	20000399 	.word	0x20000399
20000054:	2000039b 	.word	0x2000039b
20000058:	2000039d 	.word	0x2000039d
2000005c:	2000039f 	.word	0x2000039f
20000060:	200003a1 	.word	0x200003a1
20000064:	200003a3 	.word	0x200003a3
20000068:	20006449 	.word	0x20006449
2000006c:	2000646d 	.word	0x2000646d
20000070:	200003a9 	.word	0x200003a9
20000074:	200003ab 	.word	0x200003ab
20000078:	200003ad 	.word	0x200003ad
2000007c:	200003af 	.word	0x200003af
20000080:	200003b1 	.word	0x200003b1
20000084:	200003b3 	.word	0x200003b3
20000088:	200003b5 	.word	0x200003b5
2000008c:	2000b581 	.word	0x2000b581
20000090:	200003b9 	.word	0x200003b9
20000094:	200003bb 	.word	0x200003bb
20000098:	200003bd 	.word	0x200003bd
2000009c:	200003bf 	.word	0x200003bf
200000a0:	200003c1 	.word	0x200003c1
200000a4:	200003c3 	.word	0x200003c3
200000a8:	200003c5 	.word	0x200003c5
200000ac:	200003c7 	.word	0x200003c7
200000b0:	200003c9 	.word	0x200003c9
200000b4:	200003cb 	.word	0x200003cb
200000b8:	200003cd 	.word	0x200003cd
200000bc:	200003cf 	.word	0x200003cf
200000c0:	200003d1 	.word	0x200003d1
200000c4:	200003d3 	.word	0x200003d3
200000c8:	20003431 	.word	0x20003431
200000cc:	20003445 	.word	0x20003445
200000d0:	20003459 	.word	0x20003459
200000d4:	2000346d 	.word	0x2000346d
200000d8:	20003481 	.word	0x20003481
200000dc:	2000348d 	.word	0x2000348d
200000e0:	20003499 	.word	0x20003499
200000e4:	200034a5 	.word	0x200034a5
200000e8:	200034b1 	.word	0x200034b1
200000ec:	200003e7 	.word	0x200003e7
200000f0:	200003e9 	.word	0x200003e9
200000f4:	200003eb 	.word	0x200003eb
200000f8:	200003ed 	.word	0x200003ed
200000fc:	200003ef 	.word	0x200003ef
20000100:	200003f1 	.word	0x200003f1
20000104:	200003f3 	.word	0x200003f3
20000108:	200003f5 	.word	0x200003f5
2000010c:	20003bc9 	.word	0x20003bc9
20000110:	200003f9 	.word	0x200003f9
20000114:	20003c21 	.word	0x20003c21
20000118:	200003fd 	.word	0x200003fd
2000011c:	200003ff 	.word	0x200003ff
20000120:	20000401 	.word	0x20000401
20000124:	20000403 	.word	0x20000403
20000128:	20000405 	.word	0x20000405
2000012c:	20000407 	.word	0x20000407
20000130:	20000409 	.word	0x20000409
20000134:	2000040b 	.word	0x2000040b
20000138:	2000040d 	.word	0x2000040d
2000013c:	2000040f 	.word	0x2000040f
20000140:	20000411 	.word	0x20000411
20000144:	20000413 	.word	0x20000413
20000148:	20000415 	.word	0x20000415
2000014c:	20000417 	.word	0x20000417
20000150:	20000419 	.word	0x20000419
20000154:	2000041b 	.word	0x2000041b
20000158:	2000041d 	.word	0x2000041d
2000015c:	2000041f 	.word	0x2000041f
20000160:	20000421 	.word	0x20000421
20000164:	20000423 	.word	0x20000423
20000168:	20000425 	.word	0x20000425
2000016c:	20000427 	.word	0x20000427
20000170:	20000429 	.word	0x20000429
20000174:	2000042b 	.word	0x2000042b
20000178:	2000042d 	.word	0x2000042d
2000017c:	2000042f 	.word	0x2000042f
20000180:	20000431 	.word	0x20000431
20000184:	20000433 	.word	0x20000433
	...

Disassembly of section .boot_code:

20000190 <Reset_Handler>:
20000190:	f04f 0b00 	mov.w	fp, #0
20000194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 20000456 <SF2_MDDR_MODE_CR>
20000198:	6800      	ldr	r0, [r0, #0]
2000019a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 20000452 <SF2_EDAC_CR>
2000019e:	6809      	ldr	r1, [r1, #0]
200001a0:	f001 0103 	and.w	r1, r1, #3
200001a4:	f000 001c 	and.w	r0, r0, #28
200001a8:	2814      	cmp	r0, #20
200001aa:	d101      	bne.n	200001b0 <check_esram_edac>
200001ac:	f04b 0b02 	orr.w	fp, fp, #2

200001b0 <check_esram_edac>:
200001b0:	2900      	cmp	r1, #0
200001b2:	d001      	beq.n	200001b8 <check_stack_init>
200001b4:	f04b 0b01 	orr.w	fp, fp, #1

200001b8 <check_stack_init>:
200001b8:	f1bb 0f00 	cmp.w	fp, #0
200001bc:	d005      	beq.n	200001ca <system_init>

200001be <clear_stack>:
200001be:	48a7      	ldr	r0, [pc, #668]	; (2000045c <SF2_MDDR_MODE_CR+0x6>)
200001c0:	49a7      	ldr	r1, [pc, #668]	; (20000460 <SF2_MDDR_MODE_CR+0xa>)
200001c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 20000436 <RAM_INIT_PATTERN>
200001c6:	f000 f89f 	bl	20000308 <fill_memory>

200001ca <system_init>:
200001ca:	48a6      	ldr	r0, [pc, #664]	; (20000464 <SF2_MDDR_MODE_CR+0xe>)
200001cc:	4780      	blx	r0
200001ce:	f00b 0a02 	and.w	sl, fp, #2
200001d2:	f1ba 0f00 	cmp.w	sl, #0
200001d6:	d00c      	beq.n	200001f2 <remap_memory>
200001d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 2000044a <SF2_DDRB_NB_SIZE>
200001dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 2000044e <SF2_DDRB_CR>
200001e0:	6802      	ldr	r2, [r0, #0]
200001e2:	680b      	ldr	r3, [r1, #0]
200001e4:	b40f      	push	{r0, r1, r2, r3}
200001e6:	f04f 0200 	mov.w	r2, #0
200001ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
200001ee:	6002      	str	r2, [r0, #0]
200001f0:	600b      	str	r3, [r1, #0]

200001f2 <remap_memory>:
200001f2:	489d      	ldr	r0, [pc, #628]	; (20000468 <SF2_MDDR_MODE_CR+0x12>)
200001f4:	4a9d      	ldr	r2, [pc, #628]	; (2000046c <SF2_MDDR_MODE_CR+0x16>)
200001f6:	4b9e      	ldr	r3, [pc, #632]	; (20000470 <SF2_MDDR_MODE_CR+0x1a>)
200001f8:	2802      	cmp	r0, #2
200001fa:	d108      	bne.n	2000020e <check_esram_remap>
200001fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 2000043e <SF2_ESRAM_CR>
20000200:	600a      	str	r2, [r1, #0]
20000202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 20000446 <SF2_ENVM_REMAP_CR>
20000206:	600a      	str	r2, [r1, #0]
20000208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 20000442 <SF2_DDR_CR>
2000020c:	600b      	str	r3, [r1, #0]

2000020e <check_esram_remap>:
2000020e:	2801      	cmp	r0, #1
20000210:	d108      	bne.n	20000224 <check_mirrored_nvm>
20000212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 20000442 <SF2_DDR_CR>
20000216:	600a      	str	r2, [r1, #0]
20000218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 20000446 <SF2_ENVM_REMAP_CR>
2000021c:	600a      	str	r2, [r1, #0]
2000021e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 2000043e <SF2_ESRAM_CR>
20000222:	600b      	str	r3, [r1, #0]

20000224 <check_mirrored_nvm>:
20000224:	4893      	ldr	r0, [pc, #588]	; (20000474 <SF2_MDDR_MODE_CR+0x1e>)
20000226:	2800      	cmp	r0, #0
20000228:	d109      	bne.n	2000023e <copy_data>
2000022a:	4893      	ldr	r0, [pc, #588]	; (20000478 <SF2_MDDR_MODE_CR+0x22>)
2000022c:	4993      	ldr	r1, [pc, #588]	; (2000047c <SF2_MDDR_MODE_CR+0x26>)
2000022e:	4a94      	ldr	r2, [pc, #592]	; (20000480 <SF2_MDDR_MODE_CR+0x2a>)
20000230:	f000 f832 	bl	20000298 <block_copy>

20000234 <copy_text>:
20000234:	4893      	ldr	r0, [pc, #588]	; (20000484 <SF2_MDDR_MODE_CR+0x2e>)
20000236:	4994      	ldr	r1, [pc, #592]	; (20000488 <SF2_MDDR_MODE_CR+0x32>)
20000238:	4a94      	ldr	r2, [pc, #592]	; (2000048c <SF2_MDDR_MODE_CR+0x36>)
2000023a:	f000 f82d 	bl	20000298 <block_copy>

2000023e <copy_data>:
2000023e:	4894      	ldr	r0, [pc, #592]	; (20000490 <SF2_MDDR_MODE_CR+0x3a>)
20000240:	4994      	ldr	r1, [pc, #592]	; (20000494 <SF2_MDDR_MODE_CR+0x3e>)
20000242:	4a95      	ldr	r2, [pc, #596]	; (20000498 <SF2_MDDR_MODE_CR+0x42>)
20000244:	f000 f828 	bl	20000298 <block_copy>

20000248 <clear_bss>:
20000248:	4894      	ldr	r0, [pc, #592]	; (2000049c <SF2_MDDR_MODE_CR+0x46>)
2000024a:	4995      	ldr	r1, [pc, #596]	; (200004a0 <SF2_MDDR_MODE_CR+0x4a>)
2000024c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 20000436 <RAM_INIT_PATTERN>
20000250:	f000 f85a 	bl	20000308 <fill_memory>

20000254 <clear_heap>:
20000254:	f1bb 0f00 	cmp.w	fp, #0
20000258:	d012      	beq.n	20000280 <call_glob_ctor>
2000025a:	4892      	ldr	r0, [pc, #584]	; (200004a4 <SF2_MDDR_MODE_CR+0x4e>)
2000025c:	4992      	ldr	r1, [pc, #584]	; (200004a8 <SF2_MDDR_MODE_CR+0x52>)
2000025e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 2000043a <HEAP_INIT_PATTERN>
20000262:	f000 f851 	bl	20000308 <fill_memory>
20000266:	f00b 0a02 	and.w	sl, fp, #2
2000026a:	f1ba 0f00 	cmp.w	sl, #0
2000026e:	d007      	beq.n	20000280 <call_glob_ctor>
20000270:	bc0f      	pop	{r0, r1, r2, r3}
20000272:	6002      	str	r2, [r0, #0]
20000274:	600b      	str	r3, [r1, #0]
20000276:	bf00      	nop
20000278:	f3af 8000 	nop.w
2000027c:	f3af 8000 	nop.w

20000280 <call_glob_ctor>:
20000280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 200004ac <SF2_MDDR_MODE_CR+0x56>
20000284:	f20f 0e03 	addw	lr, pc, #3
20000288:	4700      	bx	r0

2000028a <branch_to_main>:
2000028a:	f04f 0000 	mov.w	r0, #0
2000028e:	f04f 0100 	mov.w	r1, #0
20000292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 200004b0 <SF2_MDDR_MODE_CR+0x5a>

20000296 <ExitLoop>:
20000296:	e7fe      	b.n	20000296 <ExitLoop>

20000298 <block_copy>:
20000298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
2000029c:	4288      	cmp	r0, r1
2000029e:	d025      	beq.n	200002ec <block_copy_exit>
200002a0:	ebb2 0201 	subs.w	r2, r2, r1
200002a4:	d500      	bpl.n	200002a8 <block_copy_address_ok>
200002a6:	e7fe      	b.n	200002a6 <block_copy+0xe>

200002a8 <block_copy_address_ok>:
200002a8:	ea40 0301 	orr.w	r3, r0, r1
200002ac:	f013 0303 	ands.w	r3, r3, #3
200002b0:	d002      	beq.n	200002b8 <block_copy_continue>

200002b2 <block_copy_byte_copy>:
200002b2:	f000 f81d 	bl	200002f0 <block_copy_byte>
200002b6:	e019      	b.n	200002ec <block_copy_exit>

200002b8 <block_copy_continue>:
200002b8:	f04f 0300 	mov.w	r3, #0
200002bc:	4690      	mov	r8, r2
200002be:	1112      	asrs	r2, r2, #4
200002c0:	d0f7      	beq.n	200002b2 <block_copy_byte_copy>

200002c2 <block_copy_loop>:
200002c2:	429a      	cmp	r2, r3
200002c4:	bf1c      	itt	ne
200002c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
200002c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
200002ca:	f103 0301 	add.w	r3, r3, #1
200002ce:	d1f8      	bne.n	200002c2 <block_copy_loop>
200002d0:	f008 080f 	and.w	r8, r8, #15
200002d4:	f1b8 0f00 	cmp.w	r8, #0
200002d8:	d008      	beq.n	200002ec <block_copy_exit>

200002da <copy_spare_bytes>:
200002da:	7804      	ldrb	r4, [r0, #0]
200002dc:	700c      	strb	r4, [r1, #0]
200002de:	f100 0001 	add.w	r0, r0, #1
200002e2:	f101 0101 	add.w	r1, r1, #1
200002e6:	f1b8 0801 	subs.w	r8, r8, #1
200002ea:	d1f6      	bne.n	200002da <copy_spare_bytes>

200002ec <block_copy_exit>:
200002ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

200002f0 <block_copy_byte>:
200002f0:	b508      	push	{r3, lr}
200002f2:	f04f 0300 	mov.w	r3, #0

200002f6 <block_copy_byte_loop>:
200002f6:	7803      	ldrb	r3, [r0, #0]
200002f8:	700b      	strb	r3, [r1, #0]
200002fa:	f100 0001 	add.w	r0, r0, #1
200002fe:	f101 0101 	add.w	r1, r1, #1
20000302:	3a01      	subs	r2, #1
20000304:	d1f7      	bne.n	200002f6 <block_copy_byte_loop>
20000306:	bd08      	pop	{r3, pc}

20000308 <fill_memory>:
20000308:	4288      	cmp	r0, r1
2000030a:	d037      	beq.n	2000037c <fill_memory_exit>
2000030c:	f000 0603 	and.w	r6, r0, #3
20000310:	2e00      	cmp	r6, #0
20000312:	d014      	beq.n	2000033e <fill_memory_end_start>
20000314:	f04f 0504 	mov.w	r5, #4
20000318:	eba5 0406 	sub.w	r4, r5, r6
2000031c:	f04f 0708 	mov.w	r7, #8
20000320:	fb07 f806 	mul.w	r8, r7, r6
20000324:	4691      	mov	r9, r2
20000326:	fa69 f908 	ror.w	r9, r9, r8

2000032a <fill_memory_spare_bytes_start>:
2000032a:	2c00      	cmp	r4, #0
2000032c:	d007      	beq.n	2000033e <fill_memory_end_start>
2000032e:	f880 9000 	strb.w	r9, [r0]
20000332:	fa69 f907 	ror.w	r9, r9, r7
20000336:	f100 0001 	add.w	r0, r0, #1
2000033a:	3c01      	subs	r4, #1
2000033c:	e7f5      	b.n	2000032a <fill_memory_spare_bytes_start>

2000033e <fill_memory_end_start>:
2000033e:	f04f 0600 	mov.w	r6, #0
20000342:	460f      	mov	r7, r1
20000344:	1a09      	subs	r1, r1, r0
20000346:	4688      	mov	r8, r1
20000348:	1109      	asrs	r1, r1, #4
2000034a:	4691      	mov	r9, r2
2000034c:	4614      	mov	r4, r2
2000034e:	4615      	mov	r5, r2
20000350:	42b1      	cmp	r1, r6
20000352:	d006      	beq.n	20000362 <fill_memory_spare_bytes_end>

20000354 <fill_memory_loop>:
20000354:	bf18      	it	ne
20000356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
2000035a:	f106 0601 	add.w	r6, r6, #1
2000035e:	42b1      	cmp	r1, r6
20000360:	d1f8      	bne.n	20000354 <fill_memory_loop>

20000362 <fill_memory_spare_bytes_end>:
20000362:	f008 080f 	and.w	r8, r8, #15

20000366 <fill_memory_spare_end_loop>:
20000366:	f1b8 0f00 	cmp.w	r8, #0
2000036a:	d007      	beq.n	2000037c <fill_memory_exit>
2000036c:	7002      	strb	r2, [r0, #0]
2000036e:	ea4f 2232 	mov.w	r2, r2, ror #8
20000372:	f100 0001 	add.w	r0, r0, #1
20000376:	f1b8 0801 	subs.w	r8, r8, #1
2000037a:	e7f4      	b.n	20000366 <fill_memory_spare_end_loop>

2000037c <fill_memory_exit>:
2000037c:	4770      	bx	lr

2000037e <NMI_Handler>:
2000037e:	e7fe      	b.n	2000037e <NMI_Handler>

20000380 <HardFault_Handler>:
20000380:	e7fe      	b.n	20000380 <HardFault_Handler>

20000382 <MemManage_Handler>:
20000382:	e7fe      	b.n	20000382 <MemManage_Handler>

20000384 <BusFault_Handler>:
20000384:	e7fe      	b.n	20000384 <BusFault_Handler>

20000386 <UsageFault_Handler>:
20000386:	e7fe      	b.n	20000386 <UsageFault_Handler>

20000388 <SVC_Handler>:
20000388:	e7fe      	b.n	20000388 <SVC_Handler>

2000038a <DebugMon_Handler>:
2000038a:	e7fe      	b.n	2000038a <DebugMon_Handler>

2000038c <PendSV_Handler>:
2000038c:	e7fe      	b.n	2000038c <PendSV_Handler>

2000038e <SysTick_Handler>:
2000038e:	e7fe      	b.n	2000038e <SysTick_Handler>

20000390 <WdogWakeup_IRQHandler>:
20000390:	e7fe      	b.n	20000390 <WdogWakeup_IRQHandler>

20000392 <RTC_Wakeup_IRQHandler>:
20000392:	e7fe      	b.n	20000392 <RTC_Wakeup_IRQHandler>
20000394:	e7fe      	b.n	20000394 <RTC_Wakeup_IRQHandler+0x2>
20000396:	e7fe      	b.n	20000396 <RTC_Wakeup_IRQHandler+0x4>

20000398 <I2C0_IRQHandler>:
20000398:	e7fe      	b.n	20000398 <I2C0_IRQHandler>

2000039a <I2C0_SMBAlert_IRQHandler>:
2000039a:	e7fe      	b.n	2000039a <I2C0_SMBAlert_IRQHandler>

2000039c <I2C0_SMBus_IRQHandler>:
2000039c:	e7fe      	b.n	2000039c <I2C0_SMBus_IRQHandler>

2000039e <I2C1_IRQHandler>:
2000039e:	e7fe      	b.n	2000039e <I2C1_IRQHandler>

200003a0 <I2C1_SMBAlert_IRQHandler>:
200003a0:	e7fe      	b.n	200003a0 <I2C1_SMBAlert_IRQHandler>

200003a2 <I2C1_SMBus_IRQHandler>:
200003a2:	e7fe      	b.n	200003a2 <I2C1_SMBus_IRQHandler>
200003a4:	e7fe      	b.n	200003a4 <I2C1_SMBus_IRQHandler+0x2>
200003a6:	e7fe      	b.n	200003a6 <I2C1_SMBus_IRQHandler+0x4>

200003a8 <EthernetMAC_IRQHandler>:
200003a8:	e7fe      	b.n	200003a8 <EthernetMAC_IRQHandler>

200003aa <DMA_IRQHandler>:
200003aa:	e7fe      	b.n	200003aa <DMA_IRQHandler>

200003ac <Timer1_IRQHandler>:
200003ac:	e7fe      	b.n	200003ac <Timer1_IRQHandler>

200003ae <Timer2_IRQHandler>:
200003ae:	e7fe      	b.n	200003ae <Timer2_IRQHandler>

200003b0 <CAN_IRQHandler>:
200003b0:	e7fe      	b.n	200003b0 <CAN_IRQHandler>

200003b2 <ENVM0_IRQHandler>:
200003b2:	e7fe      	b.n	200003b2 <ENVM0_IRQHandler>

200003b4 <ENVM1_IRQHandler>:
200003b4:	e7fe      	b.n	200003b4 <ENVM1_IRQHandler>
200003b6:	e7fe      	b.n	200003b6 <ENVM1_IRQHandler+0x2>

200003b8 <USB_IRQHandler>:
200003b8:	e7fe      	b.n	200003b8 <USB_IRQHandler>

200003ba <USB_DMA_IRQHandler>:
200003ba:	e7fe      	b.n	200003ba <USB_DMA_IRQHandler>

200003bc <PLL_Lock_IRQHandler>:
200003bc:	e7fe      	b.n	200003bc <PLL_Lock_IRQHandler>

200003be <PLL_LockLost_IRQHandler>:
200003be:	e7fe      	b.n	200003be <PLL_LockLost_IRQHandler>

200003c0 <CommSwitchError_IRQHandler>:
200003c0:	e7fe      	b.n	200003c0 <CommSwitchError_IRQHandler>

200003c2 <CacheError_IRQHandler>:
200003c2:	e7fe      	b.n	200003c2 <CacheError_IRQHandler>

200003c4 <DDR_IRQHandler>:
200003c4:	e7fe      	b.n	200003c4 <DDR_IRQHandler>

200003c6 <HPDMA_Complete_IRQHandler>:
200003c6:	e7fe      	b.n	200003c6 <HPDMA_Complete_IRQHandler>

200003c8 <HPDMA_Error_IRQHandler>:
200003c8:	e7fe      	b.n	200003c8 <HPDMA_Error_IRQHandler>

200003ca <ECC_Error_IRQHandler>:
200003ca:	e7fe      	b.n	200003ca <ECC_Error_IRQHandler>

200003cc <MDDR_IOCalib_IRQHandler>:
200003cc:	e7fe      	b.n	200003cc <MDDR_IOCalib_IRQHandler>

200003ce <FAB_PLL_Lock_IRQHandler>:
200003ce:	e7fe      	b.n	200003ce <FAB_PLL_Lock_IRQHandler>

200003d0 <FAB_PLL_LockLost_IRQHandler>:
200003d0:	e7fe      	b.n	200003d0 <FAB_PLL_LockLost_IRQHandler>

200003d2 <FIC64_IRQHandler>:
200003d2:	e7fe      	b.n	200003d2 <FIC64_IRQHandler>
200003d4:	e7fe      	b.n	200003d4 <FIC64_IRQHandler+0x2>
200003d6:	e7fe      	b.n	200003d6 <FIC64_IRQHandler+0x4>
200003d8:	e7fe      	b.n	200003d8 <FIC64_IRQHandler+0x6>
200003da:	e7fe      	b.n	200003da <FIC64_IRQHandler+0x8>
200003dc:	e7fe      	b.n	200003dc <FIC64_IRQHandler+0xa>
200003de:	e7fe      	b.n	200003de <FIC64_IRQHandler+0xc>
200003e0:	e7fe      	b.n	200003e0 <FIC64_IRQHandler+0xe>
200003e2:	e7fe      	b.n	200003e2 <FIC64_IRQHandler+0x10>
200003e4:	e7fe      	b.n	200003e4 <FIC64_IRQHandler+0x12>

200003e6 <FabricIrq9_IRQHandler>:
200003e6:	e7fe      	b.n	200003e6 <FabricIrq9_IRQHandler>

200003e8 <FabricIrq10_IRQHandler>:
200003e8:	e7fe      	b.n	200003e8 <FabricIrq10_IRQHandler>

200003ea <FabricIrq11_IRQHandler>:
200003ea:	e7fe      	b.n	200003ea <FabricIrq11_IRQHandler>

200003ec <FabricIrq12_IRQHandler>:
200003ec:	e7fe      	b.n	200003ec <FabricIrq12_IRQHandler>

200003ee <FabricIrq13_IRQHandler>:
200003ee:	e7fe      	b.n	200003ee <FabricIrq13_IRQHandler>

200003f0 <FabricIrq14_IRQHandler>:
200003f0:	e7fe      	b.n	200003f0 <FabricIrq14_IRQHandler>

200003f2 <FabricIrq15_IRQHandler>:
200003f2:	e7fe      	b.n	200003f2 <FabricIrq15_IRQHandler>

200003f4 <GPIO0_IRQHandler>:
200003f4:	e7fe      	b.n	200003f4 <GPIO0_IRQHandler>
200003f6:	e7fe      	b.n	200003f6 <GPIO0_IRQHandler+0x2>

200003f8 <GPIO2_IRQHandler>:
200003f8:	e7fe      	b.n	200003f8 <GPIO2_IRQHandler>
200003fa:	e7fe      	b.n	200003fa <GPIO2_IRQHandler+0x2>

200003fc <GPIO4_IRQHandler>:
200003fc:	e7fe      	b.n	200003fc <GPIO4_IRQHandler>

200003fe <GPIO5_IRQHandler>:
200003fe:	e7fe      	b.n	200003fe <GPIO5_IRQHandler>

20000400 <GPIO6_IRQHandler>:
20000400:	e7fe      	b.n	20000400 <GPIO6_IRQHandler>

20000402 <GPIO7_IRQHandler>:
20000402:	e7fe      	b.n	20000402 <GPIO7_IRQHandler>

20000404 <GPIO8_IRQHandler>:
20000404:	e7fe      	b.n	20000404 <GPIO8_IRQHandler>

20000406 <GPIO9_IRQHandler>:
20000406:	e7fe      	b.n	20000406 <GPIO9_IRQHandler>

20000408 <GPIO10_IRQHandler>:
20000408:	e7fe      	b.n	20000408 <GPIO10_IRQHandler>

2000040a <GPIO11_IRQHandler>:
2000040a:	e7fe      	b.n	2000040a <GPIO11_IRQHandler>

2000040c <GPIO12_IRQHandler>:
2000040c:	e7fe      	b.n	2000040c <GPIO12_IRQHandler>

2000040e <GPIO13_IRQHandler>:
2000040e:	e7fe      	b.n	2000040e <GPIO13_IRQHandler>

20000410 <GPIO14_IRQHandler>:
20000410:	e7fe      	b.n	20000410 <GPIO14_IRQHandler>

20000412 <GPIO15_IRQHandler>:
20000412:	e7fe      	b.n	20000412 <GPIO15_IRQHandler>

20000414 <GPIO16_IRQHandler>:
20000414:	e7fe      	b.n	20000414 <GPIO16_IRQHandler>

20000416 <GPIO17_IRQHandler>:
20000416:	e7fe      	b.n	20000416 <GPIO17_IRQHandler>

20000418 <GPIO18_IRQHandler>:
20000418:	e7fe      	b.n	20000418 <GPIO18_IRQHandler>

2000041a <GPIO19_IRQHandler>:
2000041a:	e7fe      	b.n	2000041a <GPIO19_IRQHandler>

2000041c <GPIO20_IRQHandler>:
2000041c:	e7fe      	b.n	2000041c <GPIO20_IRQHandler>

2000041e <GPIO21_IRQHandler>:
2000041e:	e7fe      	b.n	2000041e <GPIO21_IRQHandler>

20000420 <GPIO22_IRQHandler>:
20000420:	e7fe      	b.n	20000420 <GPIO22_IRQHandler>

20000422 <GPIO23_IRQHandler>:
20000422:	e7fe      	b.n	20000422 <GPIO23_IRQHandler>

20000424 <GPIO24_IRQHandler>:
20000424:	e7fe      	b.n	20000424 <GPIO24_IRQHandler>

20000426 <GPIO25_IRQHandler>:
20000426:	e7fe      	b.n	20000426 <GPIO25_IRQHandler>

20000428 <GPIO26_IRQHandler>:
20000428:	e7fe      	b.n	20000428 <GPIO26_IRQHandler>

2000042a <GPIO27_IRQHandler>:
2000042a:	e7fe      	b.n	2000042a <GPIO27_IRQHandler>

2000042c <GPIO28_IRQHandler>:
2000042c:	e7fe      	b.n	2000042c <GPIO28_IRQHandler>

2000042e <GPIO29_IRQHandler>:
2000042e:	e7fe      	b.n	2000042e <GPIO29_IRQHandler>

20000430 <GPIO30_IRQHandler>:
20000430:	e7fe      	b.n	20000430 <GPIO30_IRQHandler>

20000432 <GPIO31_IRQHandler>:
20000432:	e7fe      	b.n	20000432 <GPIO31_IRQHandler>

20000434 <mscc_post_hw_cfg_init>:
20000434:	4770      	bx	lr

20000436 <RAM_INIT_PATTERN>:
20000436:	0000      	.short	0x0000
	...

2000043a <HEAP_INIT_PATTERN>:
2000043a:	a2a2      	.short	0xa2a2
2000043c:	a2a2      	.short	0xa2a2

2000043e <SF2_ESRAM_CR>:
2000043e:	8000      	.short	0x8000
20000440:	4003      	.short	0x4003

20000442 <SF2_DDR_CR>:
20000442:	8008      	.short	0x8008
20000444:	4003      	.short	0x4003

20000446 <SF2_ENVM_REMAP_CR>:
20000446:	8010      	.short	0x8010
20000448:	4003      	.short	0x4003

2000044a <SF2_DDRB_NB_SIZE>:
2000044a:	8030      	.short	0x8030
2000044c:	4003      	.short	0x4003

2000044e <SF2_DDRB_CR>:
2000044e:	8034      	.short	0x8034
20000450:	4003      	.short	0x4003

20000452 <SF2_EDAC_CR>:
20000452:	8038      	.short	0x8038
20000454:	4003      	.short	0x4003

20000456 <SF2_MDDR_MODE_CR>:
20000456:	0818      	.short	0x0818
20000458:	00004002 	.word	0x00004002
2000045c:	2000f000 	.word	0x2000f000
20000460:	20010000 	.word	0x20010000
20000464:	2000af01 	.word	0x2000af01
	...
20000470:	00000001 	.word	0x00000001
20000474:	00000000 	.word	0x00000000
20000478:	20000000 	.word	0x20000000
2000047c:	20000000 	.word	0x20000000
20000480:	20000190 	.word	0x20000190
20000484:	200004c0 	.word	0x200004c0
20000488:	200004c0 	.word	0x200004c0
2000048c:	2000bf80 	.word	0x2000bf80
20000490:	2000bf80 	.word	0x2000bf80
20000494:	2000bf80 	.word	0x2000bf80
20000498:	2000c2d0 	.word	0x2000c2d0
2000049c:	2000c2d0 	.word	0x2000c2d0
200004a0:	2000d590 	.word	0x2000d590
200004a4:	2000d590 	.word	0x2000d590
200004a8:	2000f000 	.word	0x2000f000
200004ac:	2000bd49 	.word	0x2000bd49
200004b0:	2000305d 	.word	0x2000305d
200004b4:	f3af 8000 	nop.w
200004b8:	f3af 8000 	nop.w
200004bc:	f3af 8000 	nop.w

Disassembly of section .text:

200004c0 <__do_global_dtors_aux>:
200004c0:	f24c 23d0 	movw	r3, #49872	; 0xc2d0
200004c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004c8:	781a      	ldrb	r2, [r3, #0]
200004ca:	b90a      	cbnz	r2, 200004d0 <__do_global_dtors_aux+0x10>
200004cc:	2001      	movs	r0, #1
200004ce:	7018      	strb	r0, [r3, #0]
200004d0:	4770      	bx	lr
200004d2:	bf00      	nop

200004d4 <frame_dummy>:
200004d4:	f64b 7080 	movw	r0, #49024	; 0xbf80
200004d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200004dc:	b508      	push	{r3, lr}
200004de:	6803      	ldr	r3, [r0, #0]
200004e0:	b12b      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004e2:	f240 0300 	movw	r3, #0
200004e6:	f2c0 0300 	movt	r3, #0
200004ea:	b103      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004ec:	4798      	blx	r3
200004ee:	bd08      	pop	{r3, pc}

200004f0 <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
200004f0:	b480      	push	{r7}
200004f2:	b083      	sub	sp, #12
200004f4:	af00      	add	r7, sp, #0
200004f6:	6078      	str	r0, [r7, #4]
200004f8:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
200004fa:	f244 0300 	movw	r3, #16384	; 0x4000
200004fe:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000502:	6b5a      	ldr	r2, [r3, #52]	; 0x34
20000504:	683b      	ldr	r3, [r7, #0]
20000506:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
20000508:	f244 0300 	movw	r3, #16384	; 0x4000
2000050c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000510:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20000512:	687b      	ldr	r3, [r7, #4]
20000514:	601a      	str	r2, [r3, #0]
}
20000516:	f107 070c 	add.w	r7, r7, #12
2000051a:	46bd      	mov	sp, r7
2000051c:	bc80      	pop	{r7}
2000051e:	4770      	bx	lr

20000520 <MSS_WD_current_value>:
  @return
    This function returns the current value of the watchdog’s down-counter as
    a 32-bit unsigned integer.
 */
static __INLINE uint32_t MSS_WD_current_value(void)
{
20000520:	b480      	push	{r7}
20000522:	af00      	add	r7, sp, #0
    return WATCHDOG->WDOGVALUE;
20000524:	f245 0300 	movw	r3, #20480	; 0x5000
20000528:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000052c:	681b      	ldr	r3, [r3, #0]
}
2000052e:	4618      	mov	r0, r3
20000530:	46bd      	mov	sp, r7
20000532:	bc80      	pop	{r7}
20000534:	4770      	bx	lr
20000536:	bf00      	nop

20000538 <store_pkt>:

void timer_intr_en(){
	NVIC_EnableIRQ(FabricIrq4_IRQn);
}

void store_pkt(){
20000538:	b580      	push	{r7, lr}
2000053a:	b082      	sub	sp, #8
2000053c:	af00      	add	r7, sp, #0
	uint16_t i = 0;
2000053e:	f04f 0300 	mov.w	r3, #0
20000542:	80fb      	strh	r3, [r7, #6]


		for(;i<256;i++){
20000544:	e01e      	b.n	20000584 <store_pkt+0x4c>

			HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) blck_pkt[active_blck - 1][i]);
20000546:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
2000054a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000054e:	781b      	ldrb	r3, [r3, #0]
20000550:	f103 31ff 	add.w	r1, r3, #4294967295
20000554:	88fa      	ldrh	r2, [r7, #6]
20000556:	f24c 73cc 	movw	r3, #51148	; 0xc7cc
2000055a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000055e:	ea4f 2101 	mov.w	r1, r1, lsl #8
20000562:	440a      	add	r2, r1
20000564:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
20000568:	f245 0000 	movw	r0, #20480	; 0x5000
2000056c:	f2c5 0000 	movt	r0, #20480	; 0x5000
20000570:	4619      	mov	r1, r3
20000572:	f005 fe07 	bl	20006184 <HW_set_16bit_reg>

			if(i == 255){
20000576:	88fb      	ldrh	r3, [r7, #6]
20000578:	2bff      	cmp	r3, #255	; 0xff
2000057a:	d007      	beq.n	2000058c <store_pkt+0x54>

void store_pkt(){
	uint16_t i = 0;


		for(;i<256;i++){
2000057c:	88fb      	ldrh	r3, [r7, #6]
2000057e:	f103 0301 	add.w	r3, r3, #1
20000582:	80fb      	strh	r3, [r7, #6]
20000584:	88fb      	ldrh	r3, [r7, #6]
20000586:	2bff      	cmp	r3, #255	; 0xff
20000588:	d9dd      	bls.n	20000546 <store_pkt+0xe>
2000058a:	e000      	b.n	2000058e <store_pkt+0x56>

			HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) blck_pkt[active_blck - 1][i]);

			if(i == 255){
				return;
2000058c:	bf00      	nop
			}
		}


}
2000058e:	f107 0708 	add.w	r7, r7, #8
20000592:	46bd      	mov	sp, r7
20000594:	bd80      	pop	{r7, pc}
20000596:	bf00      	nop

20000598 <p1_init>:


void p1_init(){
20000598:	b580      	push	{r7, lr}
2000059a:	af00      	add	r7, sp, #0
	I2C_init(VC_SENSOR_I2C, COREI2C_0_0, VC1, I2C_PCLK_DIV_256);	//VC_Sensor
2000059c:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
200005a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005a4:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
200005a8:	f04f 0240 	mov.w	r2, #64	; 0x40
200005ac:	f04f 0300 	mov.w	r3, #0
200005b0:	f009 fc68 	bl	20009e84 <I2C_init>
	I2C_init(IMU_CORE_I2C, COREI2C_3_0, IMU_ADDR, I2C_PCLK_DIV_256);	//IMU_Sensor
200005b4:	f24c 5048 	movw	r0, #50504	; 0xc548
200005b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005bc:	f243 0100 	movw	r1, #12288	; 0x3000
200005c0:	f2c5 0100 	movt	r1, #20480	; 0x5000
200005c4:	f04f 026a 	mov.w	r2, #106	; 0x6a
200005c8:	f04f 0300 	mov.w	r3, #0
200005cc:	f009 fc5a 	bl	20009e84 <I2C_init>
	I2C_init(TEMP_ADC_CORE_I2C, COREI2C_1_0, ADC_ADDR, I2C_PCLK_DIV_256);	//Temp_ADC_Sensor
200005d0:	f24c 4024 	movw	r0, #50212	; 0xc424
200005d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005d8:	f241 0100 	movw	r1, #4096	; 0x1000
200005dc:	f2c5 0100 	movt	r1, #20480	; 0x5000
200005e0:	f04f 0221 	mov.w	r2, #33	; 0x21
200005e4:	f04f 0300 	mov.w	r3, #0
200005e8:	f009 fc4c 	bl	20009e84 <I2C_init>
}
200005ec:	bd80      	pop	{r7, pc}
200005ee:	bf00      	nop

200005f0 <vGetPktStruct>:


void vGetPktStruct(pkt_name_t pktname, void* pktdata, uint8_t pktsize){
200005f0:	b580      	push	{r7, lr}
200005f2:	b086      	sub	sp, #24
200005f4:	af00      	add	r7, sp, #0
200005f6:	60b9      	str	r1, [r7, #8]
200005f8:	4613      	mov	r3, r2
200005fa:	4602      	mov	r2, r0
200005fc:	73fa      	strb	r2, [r7, #15]
200005fe:	71fb      	strb	r3, [r7, #7]

	uint8_t i =0;
20000600:	f04f 0300 	mov.w	r3, #0
20000604:	74fb      	strb	r3, [r7, #19]
	uint8_t* pkt_data;
	pkt_data = (uint8_t* )pktdata;
20000606:	68bb      	ldr	r3, [r7, #8]
20000608:	617b      	str	r3, [r7, #20]

//	xQueueSend(Data_PKT_Queue, &pkt, 0);
	if(pktsize + wri_ptr >= 255){
2000060a:	79fa      	ldrb	r2, [r7, #7]
2000060c:	f24c 23d8 	movw	r3, #49880	; 0xc2d8
20000610:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000614:	781b      	ldrb	r3, [r3, #0]
20000616:	4413      	add	r3, r2
20000618:	2bfe      	cmp	r3, #254	; 0xfe
2000061a:	dd50      	ble.n	200006be <vGetPktStruct+0xce>
//		send_pkt_flg = 1;
		active_blck += 1;
2000061c:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
20000620:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000624:	781b      	ldrb	r3, [r3, #0]
20000626:	f103 0301 	add.w	r3, r3, #1
2000062a:	b2da      	uxtb	r2, r3
2000062c:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
20000630:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000634:	701a      	strb	r2, [r3, #0]
		store_pkt();
20000636:	f7ff ff7f 	bl	20000538 <store_pkt>
//		MSS_GPIO_set_output(MSS_GPIO_8, 1);
		wri_ptr = 0;
2000063a:	f24c 23d8 	movw	r3, #49880	; 0xc2d8
2000063e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000642:	f04f 0200 	mov.w	r2, #0
20000646:	701a      	strb	r2, [r3, #0]
		if(active_blck == 4){
20000648:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
2000064c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000650:	781b      	ldrb	r3, [r3, #0]
20000652:	2b04      	cmp	r3, #4
20000654:	d133      	bne.n	200006be <vGetPktStruct+0xce>
			active_blck = 0;
20000656:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
2000065a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000065e:	f04f 0200 	mov.w	r2, #0
20000662:	701a      	strb	r2, [r3, #0]
		}
	}

	// Storing the packets

	for(;i<pktsize;i++){
20000664:	e02b      	b.n	200006be <vGetPktStruct+0xce>
		blck_pkt[active_blck][wri_ptr + i] = pkt_data[i] | (pkt_data[i] << 8);
20000666:	f24c 23d7 	movw	r3, #49879	; 0xc2d7
2000066a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000066e:	781b      	ldrb	r3, [r3, #0]
20000670:	4618      	mov	r0, r3
20000672:	f24c 23d8 	movw	r3, #49880	; 0xc2d8
20000676:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000067a:	781b      	ldrb	r3, [r3, #0]
2000067c:	461a      	mov	r2, r3
2000067e:	7cfb      	ldrb	r3, [r7, #19]
20000680:	441a      	add	r2, r3
20000682:	7cf9      	ldrb	r1, [r7, #19]
20000684:	697b      	ldr	r3, [r7, #20]
20000686:	440b      	add	r3, r1
20000688:	781b      	ldrb	r3, [r3, #0]
2000068a:	4619      	mov	r1, r3
2000068c:	f897 c013 	ldrb.w	ip, [r7, #19]
20000690:	697b      	ldr	r3, [r7, #20]
20000692:	4463      	add	r3, ip
20000694:	781b      	ldrb	r3, [r3, #0]
20000696:	ea4f 2303 	mov.w	r3, r3, lsl #8
2000069a:	b29b      	uxth	r3, r3
2000069c:	ea41 0303 	orr.w	r3, r1, r3
200006a0:	b29b      	uxth	r3, r3
200006a2:	b299      	uxth	r1, r3
200006a4:	f24c 73cc 	movw	r3, #51148	; 0xc7cc
200006a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006ac:	ea4f 2000 	mov.w	r0, r0, lsl #8
200006b0:	4402      	add	r2, r0
200006b2:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
		}
	}

	// Storing the packets

	for(;i<pktsize;i++){
200006b6:	7cfb      	ldrb	r3, [r7, #19]
200006b8:	f103 0301 	add.w	r3, r3, #1
200006bc:	74fb      	strb	r3, [r7, #19]
200006be:	7cfa      	ldrb	r2, [r7, #19]
200006c0:	79fb      	ldrb	r3, [r7, #7]
200006c2:	429a      	cmp	r2, r3
200006c4:	d3cf      	bcc.n	20000666 <vGetPktStruct+0x76>
		blck_pkt[active_blck][wri_ptr + i] = pkt_data[i] | (pkt_data[i] << 8);
	}
	wri_ptr += pktsize;
200006c6:	f24c 23d8 	movw	r3, #49880	; 0xc2d8
200006ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006ce:	781a      	ldrb	r2, [r3, #0]
200006d0:	79fb      	ldrb	r3, [r7, #7]
200006d2:	4413      	add	r3, r2
200006d4:	b2da      	uxtb	r2, r3
200006d6:	f24c 23d8 	movw	r3, #49880	; 0xc2d8
200006da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006de:	701a      	strb	r2, [r3, #0]

}
200006e0:	f107 0718 	add.w	r7, r7, #24
200006e4:	46bd      	mov	sp, r7
200006e6:	bd80      	pop	{r7, pc}

200006e8 <make_FLetcher>:
//
//	vGetPktStruct(pld, (void*) data_test, sizeof(data_test));
//}


uint16_t make_FLetcher(uint8_t *data,uint16_t len) {
200006e8:	b480      	push	{r7}
200006ea:	b085      	sub	sp, #20
200006ec:	af00      	add	r7, sp, #0
200006ee:	6078      	str	r0, [r7, #4]
200006f0:	460b      	mov	r3, r1
200006f2:	807b      	strh	r3, [r7, #2]
	uint8_t sumA = 0,sumB = 0,temp = 0;
200006f4:	f04f 0300 	mov.w	r3, #0
200006f8:	733b      	strb	r3, [r7, #12]
200006fa:	f04f 0300 	mov.w	r3, #0
200006fe:	737b      	strb	r3, [r7, #13]
20000700:	f04f 0300 	mov.w	r3, #0
20000704:	73bb      	strb	r3, [r7, #14]
	uint8_t i = 0;
20000706:	f04f 0300 	mov.w	r3, #0
2000070a:	73fb      	strb	r3, [r7, #15]
	for(i = 0;i<len;i++) {
2000070c:	f04f 0300 	mov.w	r3, #0
20000710:	73fb      	strb	r3, [r7, #15]
20000712:	e03a      	b.n	2000078a <make_FLetcher+0xa2>
		sumA = (sumA + data[i]) % 255;
20000714:	7b3a      	ldrb	r2, [r7, #12]
20000716:	7bf9      	ldrb	r1, [r7, #15]
20000718:	687b      	ldr	r3, [r7, #4]
2000071a:	440b      	add	r3, r1
2000071c:	781b      	ldrb	r3, [r3, #0]
2000071e:	eb02 0103 	add.w	r1, r2, r3
20000722:	f248 0381 	movw	r3, #32897	; 0x8081
20000726:	f2c8 0380 	movt	r3, #32896	; 0x8080
2000072a:	fb83 2301 	smull	r2, r3, r3, r1
2000072e:	440b      	add	r3, r1
20000730:	ea4f 12e3 	mov.w	r2, r3, asr #7
20000734:	ea4f 73e1 	mov.w	r3, r1, asr #31
20000738:	ebc3 0202 	rsb	r2, r3, r2
2000073c:	4613      	mov	r3, r2
2000073e:	ea4f 2303 	mov.w	r3, r3, lsl #8
20000742:	ebc2 0303 	rsb	r3, r2, r3
20000746:	ebc3 0201 	rsb	r2, r3, r1
2000074a:	4613      	mov	r3, r2
2000074c:	733b      	strb	r3, [r7, #12]
		sumB = (sumB + sumA) % 255;
2000074e:	7b7a      	ldrb	r2, [r7, #13]
20000750:	7b3b      	ldrb	r3, [r7, #12]
20000752:	eb02 0103 	add.w	r1, r2, r3
20000756:	f248 0381 	movw	r3, #32897	; 0x8081
2000075a:	f2c8 0380 	movt	r3, #32896	; 0x8080
2000075e:	fb83 2301 	smull	r2, r3, r3, r1
20000762:	440b      	add	r3, r1
20000764:	ea4f 12e3 	mov.w	r2, r3, asr #7
20000768:	ea4f 73e1 	mov.w	r3, r1, asr #31
2000076c:	ebc3 0202 	rsb	r2, r3, r2
20000770:	4613      	mov	r3, r2
20000772:	ea4f 2303 	mov.w	r3, r3, lsl #8
20000776:	ebc2 0303 	rsb	r3, r2, r3
2000077a:	ebc3 0201 	rsb	r2, r3, r1
2000077e:	4613      	mov	r3, r2
20000780:	737b      	strb	r3, [r7, #13]


uint16_t make_FLetcher(uint8_t *data,uint16_t len) {
	uint8_t sumA = 0,sumB = 0,temp = 0;
	uint8_t i = 0;
	for(i = 0;i<len;i++) {
20000782:	7bfb      	ldrb	r3, [r7, #15]
20000784:	f103 0301 	add.w	r3, r3, #1
20000788:	73fb      	strb	r3, [r7, #15]
2000078a:	7bfb      	ldrb	r3, [r7, #15]
2000078c:	887a      	ldrh	r2, [r7, #2]
2000078e:	429a      	cmp	r2, r3
20000790:	d8c0      	bhi.n	20000714 <make_FLetcher+0x2c>
		sumA = (sumA + data[i]) % 255;
		sumB = (sumB + sumA) % 255;
	}
	temp = 255 - ((sumA + sumB) % 255);
20000792:	7b3a      	ldrb	r2, [r7, #12]
20000794:	7b7b      	ldrb	r3, [r7, #13]
20000796:	eb02 0103 	add.w	r1, r2, r3
2000079a:	f248 0381 	movw	r3, #32897	; 0x8081
2000079e:	f2c8 0380 	movt	r3, #32896	; 0x8080
200007a2:	fb83 2301 	smull	r2, r3, r3, r1
200007a6:	440b      	add	r3, r1
200007a8:	ea4f 12e3 	mov.w	r2, r3, asr #7
200007ac:	ea4f 73e1 	mov.w	r3, r1, asr #31
200007b0:	ebc3 0202 	rsb	r2, r3, r2
200007b4:	4613      	mov	r3, r2
200007b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
200007ba:	ebc2 0303 	rsb	r3, r2, r3
200007be:	ebc3 0201 	rsb	r2, r3, r1
200007c2:	b2d3      	uxtb	r3, r2
200007c4:	ea6f 0303 	mvn.w	r3, r3
200007c8:	73bb      	strb	r3, [r7, #14]
	sumB = 255 - ((sumA + temp) % 255);
200007ca:	7b3a      	ldrb	r2, [r7, #12]
200007cc:	7bbb      	ldrb	r3, [r7, #14]
200007ce:	eb02 0103 	add.w	r1, r2, r3
200007d2:	f248 0381 	movw	r3, #32897	; 0x8081
200007d6:	f2c8 0380 	movt	r3, #32896	; 0x8080
200007da:	fb83 2301 	smull	r2, r3, r3, r1
200007de:	440b      	add	r3, r1
200007e0:	ea4f 12e3 	mov.w	r2, r3, asr #7
200007e4:	ea4f 73e1 	mov.w	r3, r1, asr #31
200007e8:	ebc3 0202 	rsb	r2, r3, r2
200007ec:	4613      	mov	r3, r2
200007ee:	ea4f 2303 	mov.w	r3, r3, lsl #8
200007f2:	ebc2 0303 	rsb	r3, r2, r3
200007f6:	ebc3 0201 	rsb	r2, r3, r1
200007fa:	b2d3      	uxtb	r3, r2
200007fc:	ea6f 0303 	mvn.w	r3, r3
20000800:	737b      	strb	r3, [r7, #13]

	return ((sumB << 8) | temp);
20000802:	7b7b      	ldrb	r3, [r7, #13]
20000804:	ea4f 2303 	mov.w	r3, r3, lsl #8
20000808:	b29a      	uxth	r2, r3
2000080a:	7bbb      	ldrb	r3, [r7, #14]
2000080c:	ea42 0303 	orr.w	r3, r2, r3
20000810:	b29b      	uxth	r3, r3
20000812:	b29b      	uxth	r3, r3

}
20000814:	4618      	mov	r0, r3
20000816:	f107 0714 	add.w	r7, r7, #20
2000081a:	46bd      	mov	sp, r7
2000081c:	bc80      	pop	{r7}
2000081e:	4770      	bx	lr

20000820 <get_hk>:

uint16_t get_hk(){
20000820:	b590      	push	{r4, r7, lr}
20000822:	b08f      	sub	sp, #60	; 0x3c
20000824:	af00      	add	r7, sp, #0
	hk_pkt = (hk_pkt_t* )data;
20000826:	f24c 52b8 	movw	r2, #50616	; 0xc5b8
2000082a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000082e:	f24c 4390 	movw	r3, #50320	; 0xc490
20000832:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000836:	601a      	str	r2, [r3, #0]
	uint16_t ax, ay, az;
	uint16_t roll_rate, pitch_rate, yaw_rate;
	uint16_t CDH_VC[2];
	uint16_t PIS_VC[2];
	uint16_t imu_temp;
	uint16_t result=0;
20000838:	f04f 0300 	mov.w	r3, #0
2000083c:	867b      	strh	r3, [r7, #50]	; 0x32
	uint8_t flag;
	uint8_t i = 0 ;
2000083e:	f04f 0300 	mov.w	r3, #0
20000842:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	uint8_t msg[18] = "\n\rGot HK Readings\0";
20000846:	f64b 636c 	movw	r3, #48748	; 0xbe6c
2000084a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000084e:	f107 0c04 	add.w	ip, r7, #4
20000852:	469e      	mov	lr, r3
20000854:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000858:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
2000085c:	f8de 3000 	ldr.w	r3, [lr]
20000860:	f8ac 3000 	strh.w	r3, [ip]
	uint16_t hk_status;

	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
20000864:	f24d 3258 	movw	r2, #54104	; 0xd358
20000868:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000086c:	f24d 3348 	movw	r3, #54088	; 0xd348
20000870:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000874:	4610      	mov	r0, r2
20000876:	4619      	mov	r1, r3
20000878:	f7ff fe3a 	bl	200004f0 <MSS_TIM64_get_current_value>

	result = (get_IMU_acc(&ax, &ay, &az) == 0 ? 0 : 1);
2000087c:	f107 0130 	add.w	r1, r7, #48	; 0x30
20000880:	f107 022e 	add.w	r2, r7, #46	; 0x2e
20000884:	f107 032c 	add.w	r3, r7, #44	; 0x2c
20000888:	4608      	mov	r0, r1
2000088a:	4611      	mov	r1, r2
2000088c:	461a      	mov	r2, r3
2000088e:	f003 fdb1 	bl	200043f4 <get_IMU_acc>
20000892:	4603      	mov	r3, r0
20000894:	2b00      	cmp	r3, #0
20000896:	bf0c      	ite	eq
20000898:	2300      	moveq	r3, #0
2000089a:	2301      	movne	r3, #1
2000089c:	867b      	strh	r3, [r7, #50]	; 0x32
	result |= ((get_IMU_gyro(&roll_rate, &pitch_rate, &yaw_rate) == 0 ? 0 : 1) << 1);
2000089e:	f107 012a 	add.w	r1, r7, #42	; 0x2a
200008a2:	f107 0228 	add.w	r2, r7, #40	; 0x28
200008a6:	f107 0326 	add.w	r3, r7, #38	; 0x26
200008aa:	4608      	mov	r0, r1
200008ac:	4611      	mov	r1, r2
200008ae:	461a      	mov	r2, r3
200008b0:	f003 ff2c 	bl	2000470c <get_IMU_gyro>
200008b4:	4603      	mov	r3, r0
200008b6:	2b00      	cmp	r3, #0
200008b8:	d002      	beq.n	200008c0 <get_hk+0xa0>
200008ba:	f04f 0302 	mov.w	r3, #2
200008be:	e001      	b.n	200008c4 <get_hk+0xa4>
200008c0:	f04f 0300 	mov.w	r3, #0
200008c4:	8e79      	ldrh	r1, [r7, #50]	; 0x32
200008c6:	461a      	mov	r2, r3
200008c8:	460b      	mov	r3, r1
200008ca:	ea42 0303 	orr.w	r3, r2, r3
200008ce:	b29b      	uxth	r3, r3
200008d0:	867b      	strh	r3, [r7, #50]	; 0x32
	result |= ((get_IMU_temp(&imu_temp) == 0 ? : 1) << 2);
200008d2:	f107 031a 	add.w	r3, r7, #26
200008d6:	4618      	mov	r0, r3
200008d8:	f004 f88a 	bl	200049f0 <get_IMU_temp>
200008dc:	4603      	mov	r3, r0
200008de:	2b00      	cmp	r3, #0
200008e0:	bf14      	ite	ne
200008e2:	2300      	movne	r3, #0
200008e4:	2301      	moveq	r3, #1
200008e6:	2b00      	cmp	r3, #0
200008e8:	d003      	beq.n	200008f2 <get_hk+0xd2>
200008ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
200008ee:	b29b      	uxth	r3, r3
200008f0:	e001      	b.n	200008f6 <get_hk+0xd6>
200008f2:	f04f 0304 	mov.w	r3, #4
200008f6:	8e79      	ldrh	r1, [r7, #50]	; 0x32
200008f8:	461a      	mov	r2, r3
200008fa:	460b      	mov	r3, r1
200008fc:	ea42 0303 	orr.w	r3, r2, r3
20000900:	b29b      	uxth	r3, r3
20000902:	867b      	strh	r3, [r7, #50]	; 0x32
//	CDH_VC[0] = read_bus_voltage( VC1,  2, &flag);
//	PIS_VC[0] = read_bus_voltage(VC1, 3, &flag);
//	CDH_VC[1] = read_shunt_voltage(VC1, 2, &flag);
//	PIS_VC[1] = read_shunt_voltage(VC1, 3, &flag);

	hk_pkt->IMG_ID = IMG_ID;
20000904:	f24c 4390 	movw	r3, #50320	; 0xc490
20000908:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000090c:	681a      	ldr	r2, [r3, #0]
2000090e:	f64b 7384 	movw	r3, #49028	; 0xbf84
20000912:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000916:	781b      	ldrb	r3, [r3, #0]
20000918:	7453      	strb	r3, [r2, #17]
	hk_pkt->CLK_RATE = MSS_SYS_M3_CLK_FREQ / 1000;
2000091a:	f24c 4390 	movw	r3, #50320	; 0xc490
2000091e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000922:	681a      	ldr	r2, [r3, #0]
20000924:	f04f 0300 	mov.w	r3, #0
20000928:	f043 0350 	orr.w	r3, r3, #80	; 0x50
2000092c:	7493      	strb	r3, [r2, #18]
2000092e:	f04f 0300 	mov.w	r3, #0
20000932:	ea6f 0303 	mvn.w	r3, r3
20000936:	f003 033c 	and.w	r3, r3, #60	; 0x3c
2000093a:	ea6f 0303 	mvn.w	r3, r3
2000093e:	74d3      	strb	r3, [r2, #19]
	hk_pkt->Command_Loss_Timer = MSS_WD_current_value();
20000940:	f24c 4390 	movw	r3, #50320	; 0xc490
20000944:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000948:	681c      	ldr	r4, [r3, #0]
2000094a:	f7ff fde9 	bl	20000520 <MSS_WD_current_value>
2000094e:	4603      	mov	r3, r0
20000950:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20000954:	f04f 0100 	mov.w	r1, #0
20000958:	ea41 0202 	orr.w	r2, r1, r2
2000095c:	7522      	strb	r2, [r4, #20]
2000095e:	ea4f 2213 	mov.w	r2, r3, lsr #8
20000962:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20000966:	f04f 0100 	mov.w	r1, #0
2000096a:	ea41 0202 	orr.w	r2, r1, r2
2000096e:	7562      	strb	r2, [r4, #21]
20000970:	ea4f 4213 	mov.w	r2, r3, lsr #16
20000974:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20000978:	f04f 0100 	mov.w	r1, #0
2000097c:	ea41 0202 	orr.w	r2, r1, r2
20000980:	75a2      	strb	r2, [r4, #22]
20000982:	ea4f 6313 	mov.w	r3, r3, lsr #24
20000986:	f04f 0200 	mov.w	r2, #0
2000098a:	ea42 0303 	orr.w	r3, r2, r3
2000098e:	75e3      	strb	r3, [r4, #23]
	hk_pkt->Reset_Counts = reset_counts[0];
20000990:	f24c 4390 	movw	r3, #50320	; 0xc490
20000994:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000998:	681a      	ldr	r2, [r3, #0]
2000099a:	f24c 23ec 	movw	r3, #49900	; 0xc2ec
2000099e:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009a2:	781b      	ldrb	r3, [r3, #0]
200009a4:	7693      	strb	r3, [r2, #26]
	hk_pkt->PREV_CMD_RX = rx_cmd_pkt->cmd_id;
200009a6:	f24c 4390 	movw	r3, #50320	; 0xc490
200009aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009ae:	681a      	ldr	r2, [r3, #0]
200009b0:	f24d 3360 	movw	r3, #54112	; 0xd360
200009b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009b8:	681b      	ldr	r3, [r3, #0]
200009ba:	781b      	ldrb	r3, [r3, #0]
200009bc:	7613      	strb	r3, [r2, #24]
	hk_pkt->Cmd_ADF_counts = cmd_rx_count;
200009be:	f24c 4390 	movw	r3, #50320	; 0xc490
200009c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009c6:	681a      	ldr	r2, [r3, #0]
200009c8:	f24c 23e6 	movw	r3, #49894	; 0xc2e6
200009cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009d0:	781b      	ldrb	r3, [r3, #0]
200009d2:	7393      	strb	r3, [r2, #14]

	for(;i<16;i++){
200009d4:	e016      	b.n	20000a04 <get_hk+0x1e4>
		hk_pkt->RTM[i] = RTM[i];
200009d6:	f24c 4390 	movw	r3, #50320	; 0xc490
200009da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009de:	6819      	ldr	r1, [r3, #0]
200009e0:	f897 0035 	ldrb.w	r0, [r7, #53]	; 0x35
200009e4:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
200009e8:	f24d 0338 	movw	r3, #53304	; 0xd038
200009ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009f0:	5c9a      	ldrb	r2, [r3, r2]
200009f2:	eb00 0301 	add.w	r3, r0, r1
200009f6:	76da      	strb	r2, [r3, #27]
	hk_pkt->Command_Loss_Timer = MSS_WD_current_value();
	hk_pkt->Reset_Counts = reset_counts[0];
	hk_pkt->PREV_CMD_RX = rx_cmd_pkt->cmd_id;
	hk_pkt->Cmd_ADF_counts = cmd_rx_count;

	for(;i<16;i++){
200009f8:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
200009fc:	f103 0301 	add.w	r3, r3, #1
20000a00:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
20000a04:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
20000a08:	2b0f      	cmp	r3, #15
20000a0a:	d9e4      	bls.n	200009d6 <get_hk+0x1b6>
		hk_pkt->RTM[i] = RTM[i];
	}

	hk_pkt->Cmd_RS485_Succ_counts = cmd_rs485_succ_count;
20000a0c:	f24c 4390 	movw	r3, #50320	; 0xc490
20000a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a14:	681a      	ldr	r2, [r3, #0]
20000a16:	f24c 23e9 	movw	r3, #49897	; 0xc2e9
20000a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a1e:	781b      	ldrb	r3, [r3, #0]
20000a20:	73d3      	strb	r3, [r2, #15]
	hk_pkt->Cmd_RS485_Fail_counts = cmd_rs485_fail_count;
20000a22:	f24c 4390 	movw	r3, #50320	; 0xc490
20000a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a2a:	681a      	ldr	r2, [r3, #0]
20000a2c:	f24c 23ea 	movw	r3, #49898	; 0xc2ea
20000a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a34:	781b      	ldrb	r3, [r3, #0]
20000a36:	7413      	strb	r3, [r2, #16]
	hk_pkt->Acc[0] = ((ax));
20000a38:	f24c 4390 	movw	r3, #50320	; 0xc490
20000a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a40:	681b      	ldr	r3, [r3, #0]
20000a42:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
20000a44:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000a48:	f04f 0000 	mov.w	r0, #0
20000a4c:	ea40 0101 	orr.w	r1, r0, r1
20000a50:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
20000a54:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000a58:	b292      	uxth	r2, r2
20000a5a:	f04f 0100 	mov.w	r1, #0
20000a5e:	ea41 0202 	orr.w	r2, r1, r2
20000a62:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
	hk_pkt->Acc[1] = ((ay));
20000a66:	f24c 4390 	movw	r3, #50320	; 0xc490
20000a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a6e:	681b      	ldr	r3, [r3, #0]
20000a70:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
20000a72:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000a76:	f04f 0000 	mov.w	r0, #0
20000a7a:	ea40 0101 	orr.w	r1, r0, r1
20000a7e:	f883 102d 	strb.w	r1, [r3, #45]	; 0x2d
20000a82:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000a86:	b292      	uxth	r2, r2
20000a88:	f04f 0100 	mov.w	r1, #0
20000a8c:	ea41 0202 	orr.w	r2, r1, r2
20000a90:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
	hk_pkt->Acc[2] = ((az));
20000a94:	f24c 4390 	movw	r3, #50320	; 0xc490
20000a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a9c:	681b      	ldr	r3, [r3, #0]
20000a9e:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
20000aa0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000aa4:	f04f 0000 	mov.w	r0, #0
20000aa8:	ea40 0101 	orr.w	r1, r0, r1
20000aac:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
20000ab0:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000ab4:	b292      	uxth	r2, r2
20000ab6:	f04f 0100 	mov.w	r1, #0
20000aba:	ea41 0202 	orr.w	r2, r1, r2
20000abe:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	hk_pkt->Angular_Rate[0] = roll_rate;
20000ac2:	f24c 4390 	movw	r3, #50320	; 0xc490
20000ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000aca:	681b      	ldr	r3, [r3, #0]
20000acc:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
20000ace:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000ad2:	f04f 0000 	mov.w	r0, #0
20000ad6:	ea40 0101 	orr.w	r1, r0, r1
20000ada:	f883 1031 	strb.w	r1, [r3, #49]	; 0x31
20000ade:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000ae2:	b292      	uxth	r2, r2
20000ae4:	f04f 0100 	mov.w	r1, #0
20000ae8:	ea41 0202 	orr.w	r2, r1, r2
20000aec:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	hk_pkt->Angular_Rate[1] = pitch_rate;
20000af0:	f24c 4390 	movw	r3, #50320	; 0xc490
20000af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000af8:	681b      	ldr	r3, [r3, #0]
20000afa:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
20000afc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000b00:	f04f 0000 	mov.w	r0, #0
20000b04:	ea40 0101 	orr.w	r1, r0, r1
20000b08:	f883 1033 	strb.w	r1, [r3, #51]	; 0x33
20000b0c:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000b10:	b292      	uxth	r2, r2
20000b12:	f04f 0100 	mov.w	r1, #0
20000b16:	ea41 0202 	orr.w	r2, r1, r2
20000b1a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	hk_pkt->Angular_Rate[2] = yaw_rate;
20000b1e:	f24c 4390 	movw	r3, #50320	; 0xc490
20000b22:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b26:	681b      	ldr	r3, [r3, #0]
20000b28:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
20000b2a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000b2e:	f04f 0000 	mov.w	r0, #0
20000b32:	ea40 0101 	orr.w	r1, r0, r1
20000b36:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
20000b3a:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000b3e:	b292      	uxth	r2, r2
20000b40:	f04f 0100 	mov.w	r1, #0
20000b44:	ea41 0202 	orr.w	r2, r1, r2
20000b48:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	hk_pkt->imu_temp = imu_temp;
20000b4c:	f24c 4390 	movw	r3, #50320	; 0xc490
20000b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b54:	681b      	ldr	r3, [r3, #0]
20000b56:	8b7a      	ldrh	r2, [r7, #26]
20000b58:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000b5c:	f04f 0000 	mov.w	r0, #0
20000b60:	ea40 0101 	orr.w	r1, r0, r1
20000b64:	f883 1037 	strb.w	r1, [r3, #55]	; 0x37
20000b68:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000b6c:	b292      	uxth	r2, r2
20000b6e:	f04f 0100 	mov.w	r1, #0
20000b72:	ea41 0202 	orr.w	r2, r1, r2
20000b76:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

//	hk_pkt->Sensor_Board_VC[0] = read_bus_voltage(VC1, 1, &flag);
//	hk_pkt->CDH_VC[0] = read_bus_voltage( VC1,  2, &flag);
//	hk_pkt->PIS_VC[0] = read_bus_voltage( VC1,  3, &flag);
	hk_pkt->Voltages[0] = read_bus_voltage(VC1, 2, &flag);
20000b7a:	f24c 4390 	movw	r3, #50320	; 0xc490
20000b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b82:	681c      	ldr	r4, [r3, #0]
20000b84:	f107 0319 	add.w	r3, r7, #25
20000b88:	f04f 0040 	mov.w	r0, #64	; 0x40
20000b8c:	f04f 0102 	mov.w	r1, #2
20000b90:	461a      	mov	r2, r3
20000b92:	f003 faa9 	bl	200040e8 <read_bus_voltage>
20000b96:	4603      	mov	r3, r0
20000b98:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20000b9c:	f04f 0100 	mov.w	r1, #0
20000ba0:	ea41 0202 	orr.w	r2, r1, r2
20000ba4:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
20000ba8:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000bac:	b29b      	uxth	r3, r3
20000bae:	f04f 0200 	mov.w	r2, #0
20000bb2:	ea42 0303 	orr.w	r3, r2, r3
20000bb6:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
	result |= flag << 3;
20000bba:	7e7b      	ldrb	r3, [r7, #25]
20000bbc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20000bc0:	b29a      	uxth	r2, r3
20000bc2:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
20000bc4:	ea42 0303 	orr.w	r3, r2, r3
20000bc8:	b29b      	uxth	r3, r3
20000bca:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Voltages[1] = read_bus_voltage(VC1, 3, &flag);
20000bcc:	f24c 4390 	movw	r3, #50320	; 0xc490
20000bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000bd4:	681c      	ldr	r4, [r3, #0]
20000bd6:	f107 0319 	add.w	r3, r7, #25
20000bda:	f04f 0040 	mov.w	r0, #64	; 0x40
20000bde:	f04f 0103 	mov.w	r1, #3
20000be2:	461a      	mov	r2, r3
20000be4:	f003 fa80 	bl	200040e8 <read_bus_voltage>
20000be8:	4603      	mov	r3, r0
20000bea:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20000bee:	f04f 0100 	mov.w	r1, #0
20000bf2:	ea41 0202 	orr.w	r2, r1, r2
20000bf6:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
20000bfa:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000bfe:	b29b      	uxth	r3, r3
20000c00:	f04f 0200 	mov.w	r2, #0
20000c04:	ea42 0303 	orr.w	r3, r2, r3
20000c08:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	result |= flag << 4;
20000c0c:	7e7b      	ldrb	r3, [r7, #25]
20000c0e:	ea4f 1303 	mov.w	r3, r3, lsl #4
20000c12:	b29a      	uxth	r2, r3
20000c14:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
20000c16:	ea42 0303 	orr.w	r3, r2, r3
20000c1a:	b29b      	uxth	r3, r3
20000c1c:	867b      	strh	r3, [r7, #50]	; 0x32
//	hk_pkt->Sensor_Board_VC[1] = read_shunt_voltage(VC1, 1, &flag);
//	hk_pkt->CDH_VC[1] = read_shunt_voltage( VC1,  2, &flag);
//	hk_pkt->PIS_VC[1] = read_shunt_voltage( VC1,  3, &flag);

	hk_pkt->HK_Write_Pointer = hk_partition.write_pointer;
20000c1e:	f24c 4390 	movw	r3, #50320	; 0xc490
20000c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c26:	681b      	ldr	r3, [r3, #0]
20000c28:	f24d 328c 	movw	r2, #54156	; 0xd38c
20000c2c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000c30:	68d2      	ldr	r2, [r2, #12]
20000c32:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000c36:	f04f 0000 	mov.w	r0, #0
20000c3a:	ea40 0101 	orr.w	r1, r0, r1
20000c3e:	f883 1045 	strb.w	r1, [r3, #69]	; 0x45
20000c42:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000c46:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000c4a:	f04f 0000 	mov.w	r0, #0
20000c4e:	ea40 0101 	orr.w	r1, r0, r1
20000c52:	f883 1046 	strb.w	r1, [r3, #70]	; 0x46
20000c56:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000c5a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000c5e:	f04f 0000 	mov.w	r0, #0
20000c62:	ea40 0101 	orr.w	r1, r0, r1
20000c66:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
20000c6a:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000c6e:	f04f 0100 	mov.w	r1, #0
20000c72:	ea41 0202 	orr.w	r2, r1, r2
20000c76:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
	hk_pkt->HK_Read_Pointer = hk_partition.read_pointer;
20000c7a:	f24c 4390 	movw	r3, #50320	; 0xc490
20000c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c82:	681b      	ldr	r3, [r3, #0]
20000c84:	f24d 328c 	movw	r2, #54156	; 0xd38c
20000c88:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000c8c:	6892      	ldr	r2, [r2, #8]
20000c8e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000c92:	f04f 0000 	mov.w	r0, #0
20000c96:	ea40 0101 	orr.w	r1, r0, r1
20000c9a:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
20000c9e:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000ca2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000ca6:	f04f 0000 	mov.w	r0, #0
20000caa:	ea40 0101 	orr.w	r1, r0, r1
20000cae:	f883 1042 	strb.w	r1, [r3, #66]	; 0x42
20000cb2:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000cb6:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000cba:	f04f 0000 	mov.w	r0, #0
20000cbe:	ea40 0101 	orr.w	r1, r0, r1
20000cc2:	f883 1043 	strb.w	r1, [r3, #67]	; 0x43
20000cc6:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000cca:	f04f 0100 	mov.w	r1, #0
20000cce:	ea41 0202 	orr.w	r2, r1, r2
20000cd2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	hk_pkt->COMMS_Write_Pointer = comms_partition.write_pointer;
20000cd6:	f24c 4390 	movw	r3, #50320	; 0xc490
20000cda:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cde:	681b      	ldr	r3, [r3, #0]
20000ce0:	f24d 327c 	movw	r2, #54140	; 0xd37c
20000ce4:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000ce8:	68d2      	ldr	r2, [r2, #12]
20000cea:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000cee:	f04f 0000 	mov.w	r0, #0
20000cf2:	ea40 0101 	orr.w	r1, r0, r1
20000cf6:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
20000cfa:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000cfe:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000d02:	f04f 0000 	mov.w	r0, #0
20000d06:	ea40 0101 	orr.w	r1, r0, r1
20000d0a:	f883 1056 	strb.w	r1, [r3, #86]	; 0x56
20000d0e:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000d12:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000d16:	f04f 0000 	mov.w	r0, #0
20000d1a:	ea40 0101 	orr.w	r1, r0, r1
20000d1e:	f883 1057 	strb.w	r1, [r3, #87]	; 0x57
20000d22:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000d26:	f04f 0100 	mov.w	r1, #0
20000d2a:	ea41 0202 	orr.w	r2, r1, r2
20000d2e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	hk_pkt->COMMS_Read_Pointer = comms_partition.read_pointer;
20000d32:	f24c 4390 	movw	r3, #50320	; 0xc490
20000d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d3a:	681b      	ldr	r3, [r3, #0]
20000d3c:	f24d 327c 	movw	r2, #54140	; 0xd37c
20000d40:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000d44:	6892      	ldr	r2, [r2, #8]
20000d46:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000d4a:	f04f 0000 	mov.w	r0, #0
20000d4e:	ea40 0101 	orr.w	r1, r0, r1
20000d52:	f883 1051 	strb.w	r1, [r3, #81]	; 0x51
20000d56:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000d5a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000d5e:	f04f 0000 	mov.w	r0, #0
20000d62:	ea40 0101 	orr.w	r1, r0, r1
20000d66:	f883 1052 	strb.w	r1, [r3, #82]	; 0x52
20000d6a:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000d6e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000d72:	f04f 0000 	mov.w	r0, #0
20000d76:	ea40 0101 	orr.w	r1, r0, r1
20000d7a:	f883 1053 	strb.w	r1, [r3, #83]	; 0x53
20000d7e:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000d82:	f04f 0100 	mov.w	r1, #0
20000d86:	ea41 0202 	orr.w	r2, r1, r2
20000d8a:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	hk_pkt->Thermistor_Write_Pointer = thermistor_partition.write_pointer;
20000d8e:	f24c 4390 	movw	r3, #50320	; 0xc490
20000d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d96:	681b      	ldr	r3, [r3, #0]
20000d98:	f24d 3268 	movw	r2, #54120	; 0xd368
20000d9c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000da0:	68d2      	ldr	r2, [r2, #12]
20000da2:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000da6:	f04f 0000 	mov.w	r0, #0
20000daa:	ea40 0101 	orr.w	r1, r0, r1
20000dae:	f883 104d 	strb.w	r1, [r3, #77]	; 0x4d
20000db2:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000db6:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000dba:	f04f 0000 	mov.w	r0, #0
20000dbe:	ea40 0101 	orr.w	r1, r0, r1
20000dc2:	f883 104e 	strb.w	r1, [r3, #78]	; 0x4e
20000dc6:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000dca:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000dce:	f04f 0000 	mov.w	r0, #0
20000dd2:	ea40 0101 	orr.w	r1, r0, r1
20000dd6:	f883 104f 	strb.w	r1, [r3, #79]	; 0x4f
20000dda:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000dde:	f04f 0100 	mov.w	r1, #0
20000de2:	ea41 0202 	orr.w	r2, r1, r2
20000de6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	hk_pkt->Thermistor_Read_Pointer = thermistor_partition.read_pointer;
20000dea:	f24c 4390 	movw	r3, #50320	; 0xc490
20000dee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000df2:	681b      	ldr	r3, [r3, #0]
20000df4:	f24d 3268 	movw	r2, #54120	; 0xd368
20000df8:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000dfc:	6892      	ldr	r2, [r2, #8]
20000dfe:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20000e02:	f04f 0000 	mov.w	r0, #0
20000e06:	ea40 0101 	orr.w	r1, r0, r1
20000e0a:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
20000e0e:	ea4f 2112 	mov.w	r1, r2, lsr #8
20000e12:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000e16:	f04f 0000 	mov.w	r0, #0
20000e1a:	ea40 0101 	orr.w	r1, r0, r1
20000e1e:	f883 104a 	strb.w	r1, [r3, #74]	; 0x4a
20000e22:	ea4f 4112 	mov.w	r1, r2, lsr #16
20000e26:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20000e2a:	f04f 0000 	mov.w	r0, #0
20000e2e:	ea40 0101 	orr.w	r1, r0, r1
20000e32:	f883 104b 	strb.w	r1, [r3, #75]	; 0x4b
20000e36:	ea4f 6212 	mov.w	r2, r2, lsr #24
20000e3a:	f04f 0100 	mov.w	r1, #0
20000e3e:	ea41 0202 	orr.w	r2, r1, r2
20000e42:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

	hk_pkt->Currents[0] = read_shunt_voltage( VC1,  2, &flag);
20000e46:	f24c 4390 	movw	r3, #50320	; 0xc490
20000e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e4e:	681c      	ldr	r4, [r3, #0]
20000e50:	f107 0319 	add.w	r3, r7, #25
20000e54:	f04f 0040 	mov.w	r0, #64	; 0x40
20000e58:	f04f 0102 	mov.w	r1, #2
20000e5c:	461a      	mov	r2, r3
20000e5e:	f003 f9a1 	bl	200041a4 <read_shunt_voltage>
20000e62:	4603      	mov	r3, r0
20000e64:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20000e68:	f04f 0100 	mov.w	r1, #0
20000e6c:	ea41 0202 	orr.w	r2, r1, r2
20000e70:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
20000e74:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000e78:	b29b      	uxth	r3, r3
20000e7a:	f04f 0200 	mov.w	r2, #0
20000e7e:	ea42 0303 	orr.w	r3, r2, r3
20000e82:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	result |= flag << 5;
20000e86:	7e7b      	ldrb	r3, [r7, #25]
20000e88:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000e8c:	b29a      	uxth	r2, r3
20000e8e:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
20000e90:	ea42 0303 	orr.w	r3, r2, r3
20000e94:	b29b      	uxth	r3, r3
20000e96:	867b      	strh	r3, [r7, #50]	; 0x32
	hk_pkt->Currents[1] = read_shunt_voltage( VC1,  3, &flag);
20000e98:	f24c 4390 	movw	r3, #50320	; 0xc490
20000e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ea0:	681c      	ldr	r4, [r3, #0]
20000ea2:	f107 0319 	add.w	r3, r7, #25
20000ea6:	f04f 0040 	mov.w	r0, #64	; 0x40
20000eaa:	f04f 0103 	mov.w	r1, #3
20000eae:	461a      	mov	r2, r3
20000eb0:	f003 f978 	bl	200041a4 <read_shunt_voltage>
20000eb4:	4603      	mov	r3, r0
20000eb6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20000eba:	f04f 0100 	mov.w	r1, #0
20000ebe:	ea41 0202 	orr.w	r2, r1, r2
20000ec2:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
20000ec6:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000eca:	b29b      	uxth	r3, r3
20000ecc:	f04f 0200 	mov.w	r2, #0
20000ed0:	ea42 0303 	orr.w	r3, r2, r3
20000ed4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
	result |= flag << 6;
20000ed8:	7e7b      	ldrb	r3, [r7, #25]
20000eda:	ea4f 1383 	mov.w	r3, r3, lsl #6
20000ede:	b29a      	uxth	r2, r3
20000ee0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
20000ee2:	ea42 0303 	orr.w	r3, r2, r3
20000ee6:	b29b      	uxth	r3, r3
20000ee8:	867b      	strh	r3, [r7, #50]	; 0x32

	hk_pkt->latest_codeword_rx = latest_codeword;
20000eea:	f24c 4390 	movw	r3, #50320	; 0xc490
20000eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ef2:	681a      	ldr	r2, [r3, #0]
20000ef4:	f24c 23d6 	movw	r3, #49878	; 0xc2d6
20000ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000efc:	781b      	ldrb	r3, [r3, #0]
20000efe:	7653      	strb	r3, [r2, #25]

	get_time_vector(Time_Vector);
20000f00:	f24d 30a0 	movw	r0, #54176	; 0xd3a0
20000f04:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f08:	f002 fed6 	bl	20003cb8 <get_time_vector>
	for(;i<32;i++){
20000f0c:	e017      	b.n	20000f3e <get_hk+0x71e>
		hk_pkt->GTime_SVector[i] = Time_Vector[i];
20000f0e:	f24c 4390 	movw	r3, #50320	; 0xc490
20000f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f16:	6819      	ldr	r1, [r3, #0]
20000f18:	f897 0035 	ldrb.w	r0, [r7, #53]	; 0x35
20000f1c:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
20000f20:	f24d 33a0 	movw	r3, #54176	; 0xd3a0
20000f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f28:	5c9a      	ldrb	r2, [r3, r2]
20000f2a:	eb00 0301 	add.w	r3, r0, r1
20000f2e:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
	result |= flag << 6;

	hk_pkt->latest_codeword_rx = latest_codeword;

	get_time_vector(Time_Vector);
	for(;i<32;i++){
20000f32:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
20000f36:	f103 0301 	add.w	r3, r3, #1
20000f3a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
20000f3e:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
20000f42:	2b1f      	cmp	r3, #31
20000f44:	d9e3      	bls.n	20000f0e <get_hk+0x6ee>
		hk_pkt->GTime_SVector[i] = Time_Vector[i];
	}

	hk_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, HK_API_ID))));
20000f46:	f24c 4390 	movw	r3, #50320	; 0xc490
20000f4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f4e:	681b      	ldr	r3, [r3, #0]
20000f50:	f04f 0200 	mov.w	r2, #0
20000f54:	f042 0208 	orr.w	r2, r2, #8
20000f58:	701a      	strb	r2, [r3, #0]
20000f5a:	f04f 0200 	mov.w	r2, #0
20000f5e:	f042 0201 	orr.w	r2, r2, #1
20000f62:	705a      	strb	r2, [r3, #1]
	hk_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((hk_seq_num++)))));
20000f64:	f24c 4390 	movw	r3, #50320	; 0xc490
20000f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f6c:	6818      	ldr	r0, [r3, #0]
20000f6e:	f24c 23d2 	movw	r3, #49874	; 0xc2d2
20000f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f76:	8819      	ldrh	r1, [r3, #0]
20000f78:	460b      	mov	r3, r1
20000f7a:	ea6f 4383 	mvn.w	r3, r3, lsl #18
20000f7e:	ea6f 4393 	mvn.w	r3, r3, lsr #18
20000f82:	b29b      	uxth	r3, r3
20000f84:	b29b      	uxth	r3, r3
20000f86:	ea4f 2303 	mov.w	r3, r3, lsl #8
20000f8a:	fa1f fc83 	uxth.w	ip, r3
20000f8e:	f24c 23d2 	movw	r3, #49874	; 0xc2d2
20000f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f96:	881a      	ldrh	r2, [r3, #0]
20000f98:	4613      	mov	r3, r2
20000f9a:	ea6f 4383 	mvn.w	r3, r3, lsl #18
20000f9e:	ea6f 4393 	mvn.w	r3, r3, lsr #18
20000fa2:	b29b      	uxth	r3, r3
20000fa4:	b29b      	uxth	r3, r3
20000fa6:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000faa:	b29b      	uxth	r3, r3
20000fac:	ea4c 0303 	orr.w	r3, ip, r3
20000fb0:	b29b      	uxth	r3, r3
20000fb2:	b29b      	uxth	r3, r3
20000fb4:	f003 0cff 	and.w	ip, r3, #255	; 0xff
20000fb8:	f04f 0e00 	mov.w	lr, #0
20000fbc:	ea4e 0c0c 	orr.w	ip, lr, ip
20000fc0:	f880 c002 	strb.w	ip, [r0, #2]
20000fc4:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000fc8:	b29b      	uxth	r3, r3
20000fca:	f04f 0c00 	mov.w	ip, #0
20000fce:	ea4c 0303 	orr.w	r3, ip, r3
20000fd2:	70c3      	strb	r3, [r0, #3]
20000fd4:	f101 0301 	add.w	r3, r1, #1
20000fd8:	b299      	uxth	r1, r3
20000fda:	f24c 23d2 	movw	r3, #49874	; 0xc2d2
20000fde:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fe2:	8019      	strh	r1, [r3, #0]
20000fe4:	f102 0301 	add.w	r3, r2, #1
20000fe8:	b29a      	uxth	r2, r3
20000fea:	f24c 23d2 	movw	r3, #49874	; 0xc2d2
20000fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ff2:	801a      	strh	r2, [r3, #0]
	hk_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(HK_PKT_LENGTH))));
20000ff4:	f24c 4390 	movw	r3, #50320	; 0xc490
20000ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ffc:	681b      	ldr	r3, [r3, #0]
20000ffe:	f04f 0200 	mov.w	r2, #0
20001002:	711a      	strb	r2, [r3, #4]
20001004:	f04f 0200 	mov.w	r2, #0
20001008:	f042 027c 	orr.w	r2, r2, #124	; 0x7c
2000100c:	715a      	strb	r2, [r3, #5]
	hk_pkt->ccsds_s2 = current_time_lower;
2000100e:	f24c 4390 	movw	r3, #50320	; 0xc490
20001012:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001016:	681b      	ldr	r3, [r3, #0]
20001018:	f24d 3248 	movw	r2, #54088	; 0xd348
2000101c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001020:	e9d2 0100 	ldrd	r0, r1, [r2]
20001024:	4602      	mov	r2, r0
20001026:	f002 01ff 	and.w	r1, r2, #255	; 0xff
2000102a:	f04f 0000 	mov.w	r0, #0
2000102e:	ea40 0101 	orr.w	r1, r0, r1
20001032:	7299      	strb	r1, [r3, #10]
20001034:	ea4f 2112 	mov.w	r1, r2, lsr #8
20001038:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000103c:	f04f 0000 	mov.w	r0, #0
20001040:	ea40 0101 	orr.w	r1, r0, r1
20001044:	72d9      	strb	r1, [r3, #11]
20001046:	ea4f 4112 	mov.w	r1, r2, lsr #16
2000104a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000104e:	f04f 0000 	mov.w	r0, #0
20001052:	ea40 0101 	orr.w	r1, r0, r1
20001056:	7319      	strb	r1, [r3, #12]
20001058:	ea4f 6212 	mov.w	r2, r2, lsr #24
2000105c:	f04f 0100 	mov.w	r1, #0
20001060:	ea41 0202 	orr.w	r2, r1, r2
20001064:	735a      	strb	r2, [r3, #13]
	hk_pkt->ccsds_s1 = current_time_upper;
20001066:	f24c 4390 	movw	r3, #50320	; 0xc490
2000106a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000106e:	681b      	ldr	r3, [r3, #0]
20001070:	f24d 3258 	movw	r2, #54104	; 0xd358
20001074:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001078:	e9d2 0100 	ldrd	r0, r1, [r2]
2000107c:	4602      	mov	r2, r0
2000107e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20001082:	f04f 0000 	mov.w	r0, #0
20001086:	ea40 0101 	orr.w	r1, r0, r1
2000108a:	7199      	strb	r1, [r3, #6]
2000108c:	ea4f 2112 	mov.w	r1, r2, lsr #8
20001090:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001094:	f04f 0000 	mov.w	r0, #0
20001098:	ea40 0101 	orr.w	r1, r0, r1
2000109c:	71d9      	strb	r1, [r3, #7]
2000109e:	ea4f 4112 	mov.w	r1, r2, lsr #16
200010a2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200010a6:	f04f 0000 	mov.w	r0, #0
200010aa:	ea40 0101 	orr.w	r1, r0, r1
200010ae:	7219      	strb	r1, [r3, #8]
200010b0:	ea4f 6212 	mov.w	r2, r2, lsr #24
200010b4:	f04f 0100 	mov.w	r1, #0
200010b8:	ea41 0202 	orr.w	r2, r1, r2
200010bc:	725a      	strb	r2, [r3, #9]

	if(store_in_sd_card){
200010be:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
200010c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010c6:	781b      	ldrb	r3, [r3, #0]
200010c8:	2b00      	cmp	r3, #0
200010ca:	d055      	beq.n	20001178 <get_hk+0x958>
		sd_dump = 1;
200010cc:	f24c 23eb 	movw	r3, #49899	; 0xc2eb
200010d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010d4:	f04f 0201 	mov.w	r2, #1
200010d8:	701a      	strb	r2, [r3, #0]
		hk_pkt->sd_dump = sd_dump;
200010da:	f24c 4390 	movw	r3, #50320	; 0xc490
200010de:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010e2:	681a      	ldr	r2, [r3, #0]
200010e4:	f24c 23eb 	movw	r3, #49899	; 0xc2eb
200010e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010ec:	781b      	ldrb	r3, [r3, #0]
200010ee:	f882 3059 	strb.w	r3, [r2, #89]	; 0x59
		hk_pkt->Fletcher_Code = make_FLetcher(data, sizeof(hk_pkt_t) - 2);
200010f2:	f24c 4390 	movw	r3, #50320	; 0xc490
200010f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010fa:	681c      	ldr	r4, [r3, #0]
200010fc:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
20001100:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001104:	f04f 017a 	mov.w	r1, #122	; 0x7a
20001108:	f7ff faee 	bl	200006e8 <make_FLetcher>
2000110c:	4603      	mov	r3, r0
2000110e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001112:	f04f 0100 	mov.w	r1, #0
20001116:	ea41 0202 	orr.w	r2, r1, r2
2000111a:	f884 207a 	strb.w	r2, [r4, #122]	; 0x7a
2000111e:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001122:	b29b      	uxth	r3, r3
20001124:	f04f 0200 	mov.w	r2, #0
20001128:	ea42 0303 	orr.w	r3, r2, r3
2000112c:	f884 307b 	strb.w	r3, [r4, #123]	; 0x7b
		result |= ((store_data(&hk_partition, data) == 0 ? 0 : 1) << 7);
20001130:	f24d 308c 	movw	r0, #54156	; 0xd38c
20001134:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001138:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
2000113c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001140:	f004 f908 	bl	20005354 <store_data>
20001144:	4603      	mov	r3, r0
20001146:	2b00      	cmp	r3, #0
20001148:	d002      	beq.n	20001150 <get_hk+0x930>
2000114a:	f04f 0380 	mov.w	r3, #128	; 0x80
2000114e:	e001      	b.n	20001154 <get_hk+0x934>
20001150:	f04f 0300 	mov.w	r3, #0
20001154:	8e79      	ldrh	r1, [r7, #50]	; 0x32
20001156:	461a      	mov	r2, r3
20001158:	460b      	mov	r3, r1
2000115a:	ea42 0303 	orr.w	r3, r2, r3
2000115e:	b29b      	uxth	r3, r3
20001160:	867b      	strh	r3, [r7, #50]	; 0x32
		store_data(&hk_partition, data);
20001162:	f24d 308c 	movw	r0, #54156	; 0xd38c
20001166:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000116a:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
2000116e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001172:	f004 f8ef 	bl	20005354 <store_data>
20001176:	e03d      	b.n	200011f4 <get_hk+0x9d4>
	}
	else{
		sd_dump = 0;
20001178:	f24c 23eb 	movw	r3, #49899	; 0xc2eb
2000117c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001180:	f04f 0200 	mov.w	r2, #0
20001184:	701a      	strb	r2, [r3, #0]
		hk_pkt->sd_dump = sd_dump;
20001186:	f24c 4390 	movw	r3, #50320	; 0xc490
2000118a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000118e:	681a      	ldr	r2, [r3, #0]
20001190:	f24c 23eb 	movw	r3, #49899	; 0xc2eb
20001194:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001198:	781b      	ldrb	r3, [r3, #0]
2000119a:	f882 3059 	strb.w	r3, [r2, #89]	; 0x59
		hk_pkt->Fletcher_Code = make_FLetcher(data, sizeof(hk_pkt_t) - 2);
2000119e:	f24c 4390 	movw	r3, #50320	; 0xc490
200011a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011a6:	681c      	ldr	r4, [r3, #0]
200011a8:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
200011ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011b0:	f04f 017a 	mov.w	r1, #122	; 0x7a
200011b4:	f7ff fa98 	bl	200006e8 <make_FLetcher>
200011b8:	4603      	mov	r3, r0
200011ba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
200011be:	f04f 0100 	mov.w	r1, #0
200011c2:	ea41 0202 	orr.w	r2, r1, r2
200011c6:	f884 207a 	strb.w	r2, [r4, #122]	; 0x7a
200011ca:	ea4f 2313 	mov.w	r3, r3, lsr #8
200011ce:	b29b      	uxth	r3, r3
200011d0:	f04f 0200 	mov.w	r2, #0
200011d4:	ea42 0303 	orr.w	r3, r2, r3
200011d8:	f884 307b 	strb.w	r3, [r4, #123]	; 0x7b
//		vGetPktStruct(hk, (void*) hk_pkt, sizeof(hk_pkt_t));
		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
200011dc:	f24d 4040 	movw	r0, #54336	; 0xd440
200011e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011e4:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
200011e8:	f2c2 0100 	movt	r1, #8192	; 0x2000
200011ec:	f04f 027c 	mov.w	r2, #124	; 0x7c
200011f0:	f005 f8b8 	bl	20006364 <MSS_UART_polled_tx>
	}

	return result;
200011f4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32


//	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
//	MSS_UART_polled_tx_string(&g_mss_uart0, msg);
}
200011f6:	4618      	mov	r0, r3
200011f8:	f107 073c 	add.w	r7, r7, #60	; 0x3c
200011fc:	46bd      	mov	sp, r7
200011fe:	bd90      	pop	{r4, r7, pc}

20001200 <get_temp>:


uint16_t get_temp(){
20001200:	b5b0      	push	{r4, r5, r7, lr}
20001202:	b082      	sub	sp, #8
20001204:	af00      	add	r7, sp, #0
	uint8_t i = 0;
20001206:	f04f 0300 	mov.w	r3, #0
2000120a:	713b      	strb	r3, [r7, #4]
	uint8_t flag;
	uint8_t sd_dump_thermistor = 0;
2000120c:	f04f 0300 	mov.w	r3, #0
20001210:	717b      	strb	r3, [r7, #5]
	uint16_t res = 0;
20001212:	f04f 0300 	mov.w	r3, #0
20001216:	80fb      	strh	r3, [r7, #6]
	thermistor_pkt = (thermistor_pkt_t*) data;
20001218:	f24c 52b8 	movw	r2, #50616	; 0xc5b8
2000121c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001220:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001224:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001228:	601a      	str	r2, [r3, #0]

	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
2000122a:	f24d 3258 	movw	r2, #54104	; 0xd358
2000122e:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001232:	f24d 3348 	movw	r3, #54088	; 0xd348
20001236:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000123a:	4610      	mov	r0, r2
2000123c:	4619      	mov	r1, r3
2000123e:	f7ff f957 	bl	200004f0 <MSS_TIM64_get_current_value>

	thermistor_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, THERMISTOR_API_ID))));
20001242:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001246:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000124a:	681b      	ldr	r3, [r3, #0]
2000124c:	f04f 0200 	mov.w	r2, #0
20001250:	f042 0208 	orr.w	r2, r2, #8
20001254:	701a      	strb	r2, [r3, #0]
20001256:	f04f 0200 	mov.w	r2, #0
2000125a:	f042 0204 	orr.w	r2, r2, #4
2000125e:	705a      	strb	r2, [r3, #1]
	thermistor_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((temp_seq_num++)))));
20001260:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001264:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001268:	6818      	ldr	r0, [r3, #0]
2000126a:	f24c 23d4 	movw	r3, #49876	; 0xc2d4
2000126e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001272:	8819      	ldrh	r1, [r3, #0]
20001274:	460b      	mov	r3, r1
20001276:	ea6f 4383 	mvn.w	r3, r3, lsl #18
2000127a:	ea6f 4393 	mvn.w	r3, r3, lsr #18
2000127e:	b29b      	uxth	r3, r3
20001280:	b29b      	uxth	r3, r3
20001282:	ea4f 2303 	mov.w	r3, r3, lsl #8
20001286:	fa1f fc83 	uxth.w	ip, r3
2000128a:	f24c 23d4 	movw	r3, #49876	; 0xc2d4
2000128e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001292:	881a      	ldrh	r2, [r3, #0]
20001294:	4613      	mov	r3, r2
20001296:	ea6f 4383 	mvn.w	r3, r3, lsl #18
2000129a:	ea6f 4393 	mvn.w	r3, r3, lsr #18
2000129e:	b29b      	uxth	r3, r3
200012a0:	b29b      	uxth	r3, r3
200012a2:	ea4f 2313 	mov.w	r3, r3, lsr #8
200012a6:	b29b      	uxth	r3, r3
200012a8:	ea4c 0303 	orr.w	r3, ip, r3
200012ac:	b29b      	uxth	r3, r3
200012ae:	b29b      	uxth	r3, r3
200012b0:	f003 0cff 	and.w	ip, r3, #255	; 0xff
200012b4:	f04f 0e00 	mov.w	lr, #0
200012b8:	ea4e 0c0c 	orr.w	ip, lr, ip
200012bc:	f880 c002 	strb.w	ip, [r0, #2]
200012c0:	ea4f 2313 	mov.w	r3, r3, lsr #8
200012c4:	b29b      	uxth	r3, r3
200012c6:	f04f 0c00 	mov.w	ip, #0
200012ca:	ea4c 0303 	orr.w	r3, ip, r3
200012ce:	70c3      	strb	r3, [r0, #3]
200012d0:	f101 0301 	add.w	r3, r1, #1
200012d4:	b299      	uxth	r1, r3
200012d6:	f24c 23d4 	movw	r3, #49876	; 0xc2d4
200012da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012de:	8019      	strh	r1, [r3, #0]
200012e0:	f102 0301 	add.w	r3, r2, #1
200012e4:	b29a      	uxth	r2, r3
200012e6:	f24c 23d4 	movw	r3, #49876	; 0xc2d4
200012ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012ee:	801a      	strh	r2, [r3, #0]
	thermistor_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(THERMISTOR_PKT_LENGTH))));
200012f0:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
200012f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012f8:	681b      	ldr	r3, [r3, #0]
200012fa:	f04f 0200 	mov.w	r2, #0
200012fe:	711a      	strb	r2, [r3, #4]
20001300:	f04f 0200 	mov.w	r2, #0
20001304:	f042 0241 	orr.w	r2, r2, #65	; 0x41
20001308:	715a      	strb	r2, [r3, #5]
	thermistor_pkt->ccsds_s2 = current_time_lower;
2000130a:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
2000130e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001312:	681b      	ldr	r3, [r3, #0]
20001314:	f24d 3248 	movw	r2, #54088	; 0xd348
20001318:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000131c:	e9d2 0100 	ldrd	r0, r1, [r2]
20001320:	4602      	mov	r2, r0
20001322:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20001326:	f04f 0000 	mov.w	r0, #0
2000132a:	ea40 0101 	orr.w	r1, r0, r1
2000132e:	7299      	strb	r1, [r3, #10]
20001330:	ea4f 2112 	mov.w	r1, r2, lsr #8
20001334:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001338:	f04f 0000 	mov.w	r0, #0
2000133c:	ea40 0101 	orr.w	r1, r0, r1
20001340:	72d9      	strb	r1, [r3, #11]
20001342:	ea4f 4112 	mov.w	r1, r2, lsr #16
20001346:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000134a:	f04f 0000 	mov.w	r0, #0
2000134e:	ea40 0101 	orr.w	r1, r0, r1
20001352:	7319      	strb	r1, [r3, #12]
20001354:	ea4f 6212 	mov.w	r2, r2, lsr #24
20001358:	f04f 0100 	mov.w	r1, #0
2000135c:	ea41 0202 	orr.w	r2, r1, r2
20001360:	735a      	strb	r2, [r3, #13]
	thermistor_pkt->ccsds_s1 = current_time_upper;
20001362:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001366:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000136a:	681b      	ldr	r3, [r3, #0]
2000136c:	f24d 3258 	movw	r2, #54104	; 0xd358
20001370:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001374:	e9d2 0100 	ldrd	r0, r1, [r2]
20001378:	4602      	mov	r2, r0
2000137a:	f002 01ff 	and.w	r1, r2, #255	; 0xff
2000137e:	f04f 0000 	mov.w	r0, #0
20001382:	ea40 0101 	orr.w	r1, r0, r1
20001386:	7199      	strb	r1, [r3, #6]
20001388:	ea4f 2112 	mov.w	r1, r2, lsr #8
2000138c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001390:	f04f 0000 	mov.w	r0, #0
20001394:	ea40 0101 	orr.w	r1, r0, r1
20001398:	71d9      	strb	r1, [r3, #7]
2000139a:	ea4f 4112 	mov.w	r1, r2, lsr #16
2000139e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200013a2:	f04f 0000 	mov.w	r0, #0
200013a6:	ea40 0101 	orr.w	r1, r0, r1
200013aa:	7219      	strb	r1, [r3, #8]
200013ac:	ea4f 6212 	mov.w	r2, r2, lsr #24
200013b0:	f04f 0100 	mov.w	r1, #0
200013b4:	ea41 0202 	orr.w	r2, r1, r2
200013b8:	725a      	strb	r2, [r3, #9]

	for(;i<8;i++){
200013ba:	e03a      	b.n	20001432 <get_temp+0x232>
		thermistor_pkt->Temperature_Values[i] = get_ADC_value(TEMP_ADC_CORE_I2C, ADC_ADDR, i, &flag);
200013bc:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
200013c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200013c4:	681c      	ldr	r4, [r3, #0]
200013c6:	793d      	ldrb	r5, [r7, #4]
200013c8:	793a      	ldrb	r2, [r7, #4]
200013ca:	f107 0303 	add.w	r3, r7, #3
200013ce:	f24c 4024 	movw	r0, #50212	; 0xc424
200013d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200013d6:	f04f 0121 	mov.w	r1, #33	; 0x21
200013da:	f002 ffbb 	bl	20004354 <get_ADC_value>
200013de:	4603      	mov	r3, r0
200013e0:	4619      	mov	r1, r3
200013e2:	f105 0204 	add.w	r2, r5, #4
200013e6:	f001 00ff 	and.w	r0, r1, #255	; 0xff
200013ea:	ea4f 0342 	mov.w	r3, r2, lsl #1
200013ee:	4423      	add	r3, r4
200013f0:	f04f 0c00 	mov.w	ip, #0
200013f4:	ea4c 0000 	orr.w	r0, ip, r0
200013f8:	7198      	strb	r0, [r3, #6]
200013fa:	ea4f 2311 	mov.w	r3, r1, lsr #8
200013fe:	b298      	uxth	r0, r3
20001400:	ea4f 0342 	mov.w	r3, r2, lsl #1
20001404:	4423      	add	r3, r4
20001406:	f04f 0200 	mov.w	r2, #0
2000140a:	4611      	mov	r1, r2
2000140c:	4602      	mov	r2, r0
2000140e:	ea41 0202 	orr.w	r2, r1, r2
20001412:	71da      	strb	r2, [r3, #7]
		res |= (flag << i);
20001414:	78fb      	ldrb	r3, [r7, #3]
20001416:	461a      	mov	r2, r3
20001418:	793b      	ldrb	r3, [r7, #4]
2000141a:	fa02 f303 	lsl.w	r3, r2, r3
2000141e:	b29a      	uxth	r2, r3
20001420:	88fb      	ldrh	r3, [r7, #6]
20001422:	ea42 0303 	orr.w	r3, r2, r3
20001426:	b29b      	uxth	r3, r3
20001428:	80fb      	strh	r3, [r7, #6]
	thermistor_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((temp_seq_num++)))));
	thermistor_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(THERMISTOR_PKT_LENGTH))));
	thermistor_pkt->ccsds_s2 = current_time_lower;
	thermistor_pkt->ccsds_s1 = current_time_upper;

	for(;i<8;i++){
2000142a:	793b      	ldrb	r3, [r7, #4]
2000142c:	f103 0301 	add.w	r3, r3, #1
20001430:	713b      	strb	r3, [r7, #4]
20001432:	793b      	ldrb	r3, [r7, #4]
20001434:	2b07      	cmp	r3, #7
20001436:	d9c1      	bls.n	200013bc <get_temp+0x1bc>
		thermistor_pkt->Temperature_Values[i] = get_ADC_value(TEMP_ADC_CORE_I2C, ADC_ADDR, i, &flag);
		res |= (flag << i);
	}

	get_time_vector(Time_Vector);
20001438:	f24d 30a0 	movw	r0, #54176	; 0xd3a0
2000143c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001440:	f002 fc3a 	bl	20003cb8 <get_time_vector>
	for(;i<32;i++){
20001444:	e012      	b.n	2000146c <get_temp+0x26c>
		thermistor_pkt->GTime_SVector[i] = Time_Vector[i];
20001446:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
2000144a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000144e:	6819      	ldr	r1, [r3, #0]
20001450:	7938      	ldrb	r0, [r7, #4]
20001452:	793a      	ldrb	r2, [r7, #4]
20001454:	f24d 33a0 	movw	r3, #54176	; 0xd3a0
20001458:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000145c:	5c9a      	ldrb	r2, [r3, r2]
2000145e:	eb00 0301 	add.w	r3, r0, r1
20001462:	77da      	strb	r2, [r3, #31]
		thermistor_pkt->Temperature_Values[i] = get_ADC_value(TEMP_ADC_CORE_I2C, ADC_ADDR, i, &flag);
		res |= (flag << i);
	}

	get_time_vector(Time_Vector);
	for(;i<32;i++){
20001464:	793b      	ldrb	r3, [r7, #4]
20001466:	f103 0301 	add.w	r3, r3, #1
2000146a:	713b      	strb	r3, [r7, #4]
2000146c:	793b      	ldrb	r3, [r7, #4]
2000146e:	2b1f      	cmp	r3, #31
20001470:	d9e9      	bls.n	20001446 <get_temp+0x246>
		thermistor_pkt->GTime_SVector[i] = Time_Vector[i];
	}


	if(store_in_sd_card){
20001472:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20001476:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000147a:	781b      	ldrb	r3, [r3, #0]
2000147c:	2b00      	cmp	r3, #0
2000147e:	d033      	beq.n	200014e8 <get_temp+0x2e8>
		sd_dump_thermistor = 1;
20001480:	f04f 0301 	mov.w	r3, #1
20001484:	717b      	strb	r3, [r7, #5]
		thermistor_pkt->sd_dump = sd_dump_thermistor;
20001486:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
2000148a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000148e:	681b      	ldr	r3, [r3, #0]
20001490:	797a      	ldrb	r2, [r7, #5]
20001492:	779a      	strb	r2, [r3, #30]
		thermistor_pkt->Fletcher_Code = make_FLetcher(data, sizeof(thermistor_pkt_t) - 2);
20001494:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001498:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000149c:	681c      	ldr	r4, [r3, #0]
2000149e:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
200014a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200014a6:	f04f 013f 	mov.w	r1, #63	; 0x3f
200014aa:	f7ff f91d 	bl	200006e8 <make_FLetcher>
200014ae:	4603      	mov	r3, r0
200014b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
200014b4:	f04f 0100 	mov.w	r1, #0
200014b8:	ea41 0202 	orr.w	r2, r1, r2
200014bc:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
200014c0:	ea4f 2313 	mov.w	r3, r3, lsr #8
200014c4:	b29b      	uxth	r3, r3
200014c6:	f04f 0200 	mov.w	r2, #0
200014ca:	ea42 0303 	orr.w	r3, r2, r3
200014ce:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		store_data(&thermistor_partition, data);
200014d2:	f24d 3068 	movw	r0, #54120	; 0xd368
200014d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200014da:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
200014de:	f2c2 0100 	movt	r1, #8192	; 0x2000
200014e2:	f003 ff37 	bl	20005354 <store_data>
200014e6:	e034      	b.n	20001552 <get_temp+0x352>
	}
	else{
		sd_dump_thermistor = 0;
200014e8:	f04f 0300 	mov.w	r3, #0
200014ec:	717b      	strb	r3, [r7, #5]
		thermistor_pkt->sd_dump = sd_dump_thermistor;
200014ee:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
200014f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014f6:	681b      	ldr	r3, [r3, #0]
200014f8:	797a      	ldrb	r2, [r7, #5]
200014fa:	779a      	strb	r2, [r3, #30]
		thermistor_pkt->Fletcher_Code = make_FLetcher(data, sizeof(thermistor_pkt_t) - 2);
200014fc:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
20001500:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001504:	681c      	ldr	r4, [r3, #0]
20001506:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
2000150a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000150e:	f04f 013f 	mov.w	r1, #63	; 0x3f
20001512:	f7ff f8e9 	bl	200006e8 <make_FLetcher>
20001516:	4603      	mov	r3, r0
20001518:	f003 02ff 	and.w	r2, r3, #255	; 0xff
2000151c:	f04f 0100 	mov.w	r1, #0
20001520:	ea41 0202 	orr.w	r2, r1, r2
20001524:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
20001528:	ea4f 2313 	mov.w	r3, r3, lsr #8
2000152c:	b29b      	uxth	r3, r3
2000152e:	f04f 0200 	mov.w	r2, #0
20001532:	ea42 0303 	orr.w	r3, r2, r3
20001536:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		vGetPktStruct(thermistor, (void*) thermistor_pkt, sizeof(thermistor_pkt_t));
2000153a:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
2000153e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001542:	681b      	ldr	r3, [r3, #0]
20001544:	f04f 0002 	mov.w	r0, #2
20001548:	4619      	mov	r1, r3
2000154a:	f04f 0241 	mov.w	r2, #65	; 0x41
2000154e:	f7ff f84f 	bl	200005f0 <vGetPktStruct>
//		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(thermistor_pkt_t));
	}

	return res;
20001552:	88fb      	ldrh	r3, [r7, #6]
}
20001554:	4618      	mov	r0, r3
20001556:	f107 0708 	add.w	r7, r7, #8
2000155a:	46bd      	mov	sp, r7
2000155c:	bdb0      	pop	{r4, r5, r7, pc}
2000155e:	bf00      	nop

20001560 <get_sd_data>:

void get_sd_data(){
20001560:	b580      	push	{r7, lr}
20001562:	af00      	add	r7, sp, #0
	read_data(&hk_partition, data);
20001564:	f24d 308c 	movw	r0, #54156	; 0xd38c
20001568:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000156c:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001570:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001574:	f003 ff1c 	bl	200053b0 <read_data>
	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(hk_pkt_t));
20001578:	f24d 4040 	movw	r0, #54336	; 0xd440
2000157c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001580:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001584:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001588:	f04f 027c 	mov.w	r2, #124	; 0x7c
2000158c:	f004 feea 	bl	20006364 <MSS_UART_polled_tx>
}
20001590:	bd80      	pop	{r7, pc}
20001592:	bf00      	nop

20001594 <get_gmc>:

uint8_t status;
uint16_t ADC_voltages[8];


uint8_t get_gmc(){
20001594:	b590      	push	{r4, r7, lr}
20001596:	b083      	sub	sp, #12
20001598:	af00      	add	r7, sp, #0
	uint16_t i = 0;
2000159a:	f04f 0300 	mov.w	r3, #0
2000159e:	80fb      	strh	r3, [r7, #6]
	gmc_pkt = (gmc_pkt_t*) data;
200015a0:	f24c 52b8 	movw	r2, #50616	; 0xc5b8
200015a4:	f2c2 0200 	movt	r2, #8192	; 0x2000
200015a8:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
200015ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015b0:	601a      	str	r2, [r3, #0]
	status = get_count(&counter_i2c, count_val);
200015b2:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
200015b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200015ba:	f24d 01d0 	movw	r1, #53456	; 0xd0d0
200015be:	f2c2 0100 	movt	r1, #8192	; 0x2000
200015c2:	f003 ff55 	bl	20005470 <get_count>
200015c6:	4603      	mov	r3, r0
200015c8:	461a      	mov	r2, r3
200015ca:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200015ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015d2:	701a      	strb	r2, [r3, #0]
	status = status << 1;
200015d4:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200015d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015dc:	781b      	ldrb	r3, [r3, #0]
200015de:	ea4f 0343 	mov.w	r3, r3, lsl #1
200015e2:	b2da      	uxtb	r2, r3
200015e4:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200015e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015ec:	701a      	strb	r2, [r3, #0]
	gmc_radiation_count = count_val[0];
200015ee:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
200015f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015f6:	781b      	ldrb	r3, [r3, #0]
200015f8:	461a      	mov	r2, r3
200015fa:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
200015fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001602:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count << 8;
20001604:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001608:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000160c:	681b      	ldr	r3, [r3, #0]
2000160e:	ea4f 2203 	mov.w	r2, r3, lsl #8
20001612:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001616:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000161a:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count | count_val[1];
2000161c:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
20001620:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001624:	785b      	ldrb	r3, [r3, #1]
20001626:	461a      	mov	r2, r3
20001628:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
2000162c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001630:	681b      	ldr	r3, [r3, #0]
20001632:	ea42 0203 	orr.w	r2, r2, r3
20001636:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
2000163a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000163e:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count << 8;
20001640:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001644:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001648:	681b      	ldr	r3, [r3, #0]
2000164a:	ea4f 2203 	mov.w	r2, r3, lsl #8
2000164e:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001652:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001656:	601a      	str	r2, [r3, #0]
	gmc_radiation_count = gmc_radiation_count | count_val[2];
20001658:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
2000165c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001660:	789b      	ldrb	r3, [r3, #2]
20001662:	461a      	mov	r2, r3
20001664:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001668:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000166c:	681b      	ldr	r3, [r3, #0]
2000166e:	ea42 0203 	orr.w	r2, r2, r3
20001672:	f24d 03cc 	movw	r3, #53452	; 0xd0cc
20001676:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000167a:	601a      	str	r2, [r3, #0]



	status = get_free_res(&counter_i2c, free_res);
2000167c:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20001680:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001684:	f24d 01d4 	movw	r1, #53460	; 0xd0d4
20001688:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000168c:	f003 ff1a 	bl	200054c4 <get_free_res>
20001690:	4603      	mov	r3, r0
20001692:	461a      	mov	r2, r3
20001694:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20001698:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000169c:	701a      	strb	r2, [r3, #0]
	status = status << 1;
2000169e:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200016a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016a6:	781b      	ldrb	r3, [r3, #0]
200016a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
200016ac:	b2da      	uxtb	r2, r3
200016ae:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200016b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016b6:	701a      	strb	r2, [r3, #0]
	gmc_free_res_value = count_val[0];
200016b8:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
200016bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016c0:	781b      	ldrb	r3, [r3, #0]
200016c2:	461a      	mov	r2, r3
200016c4:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
200016c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016cc:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value << 8;
200016ce:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
200016d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016d6:	681b      	ldr	r3, [r3, #0]
200016d8:	ea4f 2203 	mov.w	r2, r3, lsl #8
200016dc:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
200016e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016e4:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value | count_val[1];
200016e6:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
200016ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016ee:	785b      	ldrb	r3, [r3, #1]
200016f0:	461a      	mov	r2, r3
200016f2:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
200016f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016fa:	681b      	ldr	r3, [r3, #0]
200016fc:	ea42 0203 	orr.w	r2, r2, r3
20001700:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
20001704:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001708:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value << 8;
2000170a:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
2000170e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001712:	681b      	ldr	r3, [r3, #0]
20001714:	ea4f 2203 	mov.w	r2, r3, lsl #8
20001718:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
2000171c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001720:	601a      	str	r2, [r3, #0]
	gmc_free_res_value = gmc_free_res_value | count_val[2];
20001722:	f24d 03d0 	movw	r3, #53456	; 0xd0d0
20001726:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000172a:	789b      	ldrb	r3, [r3, #2]
2000172c:	461a      	mov	r2, r3
2000172e:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
20001732:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001736:	681b      	ldr	r3, [r3, #0]
20001738:	ea42 0203 	orr.w	r2, r2, r3
2000173c:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
20001740:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001744:	601a      	str	r2, [r3, #0]

	get_gmc_voltages(&counter_i2c, ADC_voltages);
20001746:	f24d 03b8 	movw	r3, #53432	; 0xd0b8
2000174a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000174e:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20001752:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001756:	4619      	mov	r1, r3
20001758:	f003 fefa 	bl	20005550 <get_gmc_voltages>

	gmc_pkt->IMG_ID = IMG_ID;
2000175c:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001760:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001764:	681a      	ldr	r2, [r3, #0]
20001766:	f64b 7384 	movw	r3, #49028	; 0xbf84
2000176a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000176e:	781b      	ldrb	r3, [r3, #0]
20001770:	7393      	strb	r3, [r2, #14]
	gmc_pkt->Radiation_Counts = gmc_radiation_count;
20001772:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001776:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000177a:	681b      	ldr	r3, [r3, #0]
2000177c:	f24d 02cc 	movw	r2, #53452	; 0xd0cc
20001780:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001784:	6812      	ldr	r2, [r2, #0]
20001786:	f002 01ff 	and.w	r1, r2, #255	; 0xff
2000178a:	f04f 0000 	mov.w	r0, #0
2000178e:	ea40 0101 	orr.w	r1, r0, r1
20001792:	73d9      	strb	r1, [r3, #15]
20001794:	ea4f 2112 	mov.w	r1, r2, lsr #8
20001798:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000179c:	f04f 0000 	mov.w	r0, #0
200017a0:	ea40 0101 	orr.w	r1, r0, r1
200017a4:	7419      	strb	r1, [r3, #16]
200017a6:	ea4f 4112 	mov.w	r1, r2, lsr #16
200017aa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200017ae:	f04f 0000 	mov.w	r0, #0
200017b2:	ea40 0101 	orr.w	r1, r0, r1
200017b6:	7459      	strb	r1, [r3, #17]
200017b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
200017bc:	f04f 0100 	mov.w	r1, #0
200017c0:	ea41 0202 	orr.w	r2, r1, r2
200017c4:	749a      	strb	r2, [r3, #18]
	gmc_pkt->Counter_Free_Register = gmc_free_res_value;
200017c6:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
200017ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200017ce:	681b      	ldr	r3, [r3, #0]
200017d0:	f24d 02f8 	movw	r2, #53496	; 0xd0f8
200017d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
200017d8:	6812      	ldr	r2, [r2, #0]
200017da:	f002 01ff 	and.w	r1, r2, #255	; 0xff
200017de:	f04f 0000 	mov.w	r0, #0
200017e2:	ea40 0101 	orr.w	r1, r0, r1
200017e6:	74d9      	strb	r1, [r3, #19]
200017e8:	ea4f 2112 	mov.w	r1, r2, lsr #8
200017ec:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200017f0:	f04f 0000 	mov.w	r0, #0
200017f4:	ea40 0101 	orr.w	r1, r0, r1
200017f8:	7519      	strb	r1, [r3, #20]
200017fa:	ea4f 4112 	mov.w	r1, r2, lsr #16
200017fe:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001802:	f04f 0000 	mov.w	r0, #0
20001806:	ea40 0101 	orr.w	r1, r0, r1
2000180a:	7559      	strb	r1, [r3, #21]
2000180c:	ea4f 6212 	mov.w	r2, r2, lsr #24
20001810:	f04f 0100 	mov.w	r1, #0
20001814:	ea41 0202 	orr.w	r2, r1, r2
20001818:	759a      	strb	r2, [r3, #22]
	for (i=0; i<8; i++){
2000181a:	f04f 0300 	mov.w	r3, #0
2000181e:	80fb      	strh	r3, [r7, #6]
20001820:	e02a      	b.n	20001878 <get_gmc+0x2e4>
	gmc_pkt->GMC_Voltage_ADC[i] = ADC_voltages[i];
20001822:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001826:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000182a:	681a      	ldr	r2, [r3, #0]
2000182c:	88f9      	ldrh	r1, [r7, #6]
2000182e:	88f8      	ldrh	r0, [r7, #6]
20001830:	f24d 03b8 	movw	r3, #53432	; 0xd0b8
20001834:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001838:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
2000183c:	f101 0108 	add.w	r1, r1, #8
20001840:	f000 0cff 	and.w	ip, r0, #255	; 0xff
20001844:	ea4f 0341 	mov.w	r3, r1, lsl #1
20001848:	4413      	add	r3, r2
2000184a:	f04f 0e00 	mov.w	lr, #0
2000184e:	ea4e 0c0c 	orr.w	ip, lr, ip
20001852:	f883 c007 	strb.w	ip, [r3, #7]
20001856:	ea4f 2310 	mov.w	r3, r0, lsr #8
2000185a:	b298      	uxth	r0, r3
2000185c:	ea4f 0341 	mov.w	r3, r1, lsl #1
20001860:	4413      	add	r3, r2
20001862:	f04f 0200 	mov.w	r2, #0
20001866:	4611      	mov	r1, r2
20001868:	4602      	mov	r2, r0
2000186a:	ea41 0202 	orr.w	r2, r1, r2
2000186e:	721a      	strb	r2, [r3, #8]
	get_gmc_voltages(&counter_i2c, ADC_voltages);

	gmc_pkt->IMG_ID = IMG_ID;
	gmc_pkt->Radiation_Counts = gmc_radiation_count;
	gmc_pkt->Counter_Free_Register = gmc_free_res_value;
	for (i=0; i<8; i++){
20001870:	88fb      	ldrh	r3, [r7, #6]
20001872:	f103 0301 	add.w	r3, r3, #1
20001876:	80fb      	strh	r3, [r7, #6]
20001878:	88fb      	ldrh	r3, [r7, #6]
2000187a:	2b07      	cmp	r3, #7
2000187c:	d9d1      	bls.n	20001822 <get_gmc+0x28e>
	gmc_pkt->GMC_Voltage_ADC[i] = ADC_voltages[i];
	}

//	get_time_vector(Time_Vector);

	i = 0;
2000187e:	f04f 0300 	mov.w	r3, #0
20001882:	80fb      	strh	r3, [r7, #6]
//	for(;i<32;i++){
//		gmc_pkt->GMC_GTime_SVector[i] = Time_Vector[i];
//	}

	gmc_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, GMC_API_ID))));
20001884:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001888:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000188c:	681b      	ldr	r3, [r3, #0]
2000188e:	f04f 0200 	mov.w	r2, #0
20001892:	f042 0208 	orr.w	r2, r2, #8
20001896:	701a      	strb	r2, [r3, #0]
20001898:	f04f 0200 	mov.w	r2, #0
2000189c:	f042 0202 	orr.w	r2, r2, #2
200018a0:	705a      	strb	r2, [r3, #1]
	gmc_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((gmc_seq_num++)))));
200018a2:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
200018a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018aa:	6818      	ldr	r0, [r3, #0]
200018ac:	f24c 23de 	movw	r3, #49886	; 0xc2de
200018b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018b4:	8819      	ldrh	r1, [r3, #0]
200018b6:	460b      	mov	r3, r1
200018b8:	ea6f 4383 	mvn.w	r3, r3, lsl #18
200018bc:	ea6f 4393 	mvn.w	r3, r3, lsr #18
200018c0:	b29b      	uxth	r3, r3
200018c2:	b29b      	uxth	r3, r3
200018c4:	ea4f 2303 	mov.w	r3, r3, lsl #8
200018c8:	fa1f fc83 	uxth.w	ip, r3
200018cc:	f24c 23de 	movw	r3, #49886	; 0xc2de
200018d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018d4:	881a      	ldrh	r2, [r3, #0]
200018d6:	4613      	mov	r3, r2
200018d8:	ea6f 4383 	mvn.w	r3, r3, lsl #18
200018dc:	ea6f 4393 	mvn.w	r3, r3, lsr #18
200018e0:	b29b      	uxth	r3, r3
200018e2:	b29b      	uxth	r3, r3
200018e4:	ea4f 2313 	mov.w	r3, r3, lsr #8
200018e8:	b29b      	uxth	r3, r3
200018ea:	ea4c 0303 	orr.w	r3, ip, r3
200018ee:	b29b      	uxth	r3, r3
200018f0:	b29b      	uxth	r3, r3
200018f2:	f003 0cff 	and.w	ip, r3, #255	; 0xff
200018f6:	f04f 0e00 	mov.w	lr, #0
200018fa:	ea4e 0c0c 	orr.w	ip, lr, ip
200018fe:	f880 c002 	strb.w	ip, [r0, #2]
20001902:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001906:	b29b      	uxth	r3, r3
20001908:	f04f 0c00 	mov.w	ip, #0
2000190c:	ea4c 0303 	orr.w	r3, ip, r3
20001910:	70c3      	strb	r3, [r0, #3]
20001912:	f101 0301 	add.w	r3, r1, #1
20001916:	b299      	uxth	r1, r3
20001918:	f24c 23de 	movw	r3, #49886	; 0xc2de
2000191c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001920:	8019      	strh	r1, [r3, #0]
20001922:	f102 0301 	add.w	r3, r2, #1
20001926:	b29a      	uxth	r2, r3
20001928:	f24c 23de 	movw	r3, #49886	; 0xc2de
2000192c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001930:	801a      	strh	r2, [r3, #0]
	gmc_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(GMC_PKT_LENGTH))));
20001932:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001936:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000193a:	681b      	ldr	r3, [r3, #0]
2000193c:	f04f 0200 	mov.w	r2, #0
20001940:	711a      	strb	r2, [r3, #4]
20001942:	f04f 0200 	mov.w	r2, #0
20001946:	f042 024a 	orr.w	r2, r2, #74	; 0x4a
2000194a:	715a      	strb	r2, [r3, #5]
	gmc_pkt->ccsds_s1 = 0;
2000194c:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001950:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001954:	681b      	ldr	r3, [r3, #0]
20001956:	f04f 0200 	mov.w	r2, #0
2000195a:	719a      	strb	r2, [r3, #6]
2000195c:	f04f 0200 	mov.w	r2, #0
20001960:	71da      	strb	r2, [r3, #7]
20001962:	f04f 0200 	mov.w	r2, #0
20001966:	721a      	strb	r2, [r3, #8]
20001968:	f04f 0200 	mov.w	r2, #0
2000196c:	725a      	strb	r2, [r3, #9]

	gmc_pkt->ccsds_s2 = 0;
2000196e:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001972:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001976:	681b      	ldr	r3, [r3, #0]
20001978:	f04f 0200 	mov.w	r2, #0
2000197c:	729a      	strb	r2, [r3, #10]
2000197e:	f04f 0200 	mov.w	r2, #0
20001982:	72da      	strb	r2, [r3, #11]
20001984:	f04f 0200 	mov.w	r2, #0
20001988:	731a      	strb	r2, [r3, #12]
2000198a:	f04f 0200 	mov.w	r2, #0
2000198e:	735a      	strb	r2, [r3, #13]

	if(store_in_sd_card){
20001990:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20001994:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001998:	781b      	ldrb	r3, [r3, #0]
2000199a:	2b00      	cmp	r3, #0
2000199c:	d03c      	beq.n	20001a18 <get_gmc+0x484>
			sd_dump_gmc = 1;
2000199e:	f24c 23db 	movw	r3, #49883	; 0xc2db
200019a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019a6:	f04f 0201 	mov.w	r2, #1
200019aa:	701a      	strb	r2, [r3, #0]
			gmc_pkt->GMC_sd_dump = sd_dump_gmc;
200019ac:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
200019b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019b4:	681a      	ldr	r2, [r3, #0]
200019b6:	f24c 23db 	movw	r3, #49883	; 0xc2db
200019ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019be:	781b      	ldrb	r3, [r3, #0]
200019c0:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
			gmc_pkt->Fletcher_Code = make_FLetcher(data, sizeof(gmc_pkt_t) - 2);
200019c4:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
200019c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019cc:	681c      	ldr	r4, [r3, #0]
200019ce:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
200019d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200019d6:	f04f 0148 	mov.w	r1, #72	; 0x48
200019da:	f7fe fe85 	bl	200006e8 <make_FLetcher>
200019de:	4603      	mov	r3, r0
200019e0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
200019e4:	f04f 0100 	mov.w	r1, #0
200019e8:	ea41 0202 	orr.w	r2, r1, r2
200019ec:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
200019f0:	ea4f 2313 	mov.w	r3, r3, lsr #8
200019f4:	b29b      	uxth	r3, r3
200019f6:	f04f 0200 	mov.w	r2, #0
200019fa:	ea42 0303 	orr.w	r3, r2, r3
200019fe:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
			store_data(&gmc_partition, data);
20001a02:	f24d 1020 	movw	r0, #53536	; 0xd120
20001a06:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001a0a:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001a0e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001a12:	f003 fc9f 	bl	20005354 <store_data>
20001a16:	e03d      	b.n	20001a94 <get_gmc+0x500>
		}
		else{
			sd_dump_gmc = 0;
20001a18:	f24c 23db 	movw	r3, #49883	; 0xc2db
20001a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a20:	f04f 0200 	mov.w	r2, #0
20001a24:	701a      	strb	r2, [r3, #0]
			gmc_pkt->GMC_sd_dump = sd_dump_gmc;
20001a26:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a2e:	681a      	ldr	r2, [r3, #0]
20001a30:	f24c 23db 	movw	r3, #49883	; 0xc2db
20001a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a38:	781b      	ldrb	r3, [r3, #0]
20001a3a:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
			gmc_pkt->Fletcher_Code = make_FLetcher(data, sizeof(gmc_pkt_t) - 2);
20001a3e:	f24d 03b4 	movw	r3, #53428	; 0xd0b4
20001a42:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a46:	681c      	ldr	r4, [r3, #0]
20001a48:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
20001a4c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001a50:	f04f 0148 	mov.w	r1, #72	; 0x48
20001a54:	f7fe fe48 	bl	200006e8 <make_FLetcher>
20001a58:	4603      	mov	r3, r0
20001a5a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001a5e:	f04f 0100 	mov.w	r1, #0
20001a62:	ea41 0202 	orr.w	r2, r1, r2
20001a66:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
20001a6a:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001a6e:	b29b      	uxth	r3, r3
20001a70:	f04f 0200 	mov.w	r2, #0
20001a74:	ea42 0303 	orr.w	r3, r2, r3
20001a78:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	//		vGetPktStruct(comms, (void*) comms_pkt, sizeof(comms_pkt_t));
			MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(gmc_pkt_t));
20001a7c:	f24d 4040 	movw	r0, #54336	; 0xd440
20001a80:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001a84:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001a88:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001a8c:	f04f 024a 	mov.w	r2, #74	; 0x4a
20001a90:	f004 fc68 	bl	20006364 <MSS_UART_polled_tx>
		}


	return status;
20001a94:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20001a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a9c:	781b      	ldrb	r3, [r3, #0]
}
20001a9e:	4618      	mov	r0, r3
20001aa0:	f107 070c 	add.w	r7, r7, #12
20001aa4:	46bd      	mov	sp, r7
20001aa6:	bd90      	pop	{r4, r7, pc}

20001aa8 <get_comms>:

uint16_t get_comms(){
20001aa8:	b590      	push	{r4, r7, lr}
20001aaa:	b083      	sub	sp, #12
20001aac:	af00      	add	r7, sp, #0
	uint16_t i = 0;
20001aae:	f04f 0300 	mov.w	r3, #0
20001ab2:	80fb      	strh	r3, [r7, #6]
	comms_pkt = (comms_pkt_t*) data;
20001ab4:	f24c 52b8 	movw	r2, #50616	; 0xc5b8
20001ab8:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001abc:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001ac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ac4:	601a      	str	r2, [r3, #0]
//	data_test[0]++;
	for(;i<8;i++){
20001ac6:	e00c      	b.n	20001ae2 <get_comms+0x3a>
		cmd_adf_data[i] = 0;
20001ac8:	88fa      	ldrh	r2, [r7, #6]
20001aca:	f24d 03d8 	movw	r3, #53464	; 0xd0d8
20001ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ad2:	f04f 0100 	mov.w	r1, #0
20001ad6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

uint16_t get_comms(){
	uint16_t i = 0;
	comms_pkt = (comms_pkt_t*) data;
//	data_test[0]++;
	for(;i<8;i++){
20001ada:	88fb      	ldrh	r3, [r7, #6]
20001adc:	f103 0301 	add.w	r3, r3, #1
20001ae0:	80fb      	strh	r3, [r7, #6]
20001ae2:	88fb      	ldrh	r3, [r7, #6]
20001ae4:	2b07      	cmp	r3, #7
20001ae6:	d9ef      	bls.n	20001ac8 <get_comms+0x20>
		cmd_adf_data[i] = 0;
	}
	i = 0;
20001ae8:	f04f 0300 	mov.w	r3, #0
20001aec:	80fb      	strh	r3, [r7, #6]
	get_rssi_data(&rssi);
20001aee:	f24d 3078 	movw	r0, #54136	; 0xd378
20001af2:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001af6:	f004 fa21 	bl	20005f3c <get_rssi_data>
	comms_pkt->IMG_ID = IMG_ID;
20001afa:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001afe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b02:	681a      	ldr	r2, [r3, #0]
20001b04:	f64b 7384 	movw	r3, #49028	; 0xbf84
20001b08:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b0c:	781b      	ldrb	r3, [r3, #0]
20001b0e:	7393      	strb	r3, [r2, #14]
	comms_pkt->comms_adf_rssi = rssi;
20001b10:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001b14:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b18:	681a      	ldr	r2, [r3, #0]
20001b1a:	f24d 3378 	movw	r3, #54136	; 0xd378
20001b1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b22:	881b      	ldrh	r3, [r3, #0]
20001b24:	f003 01ff 	and.w	r1, r3, #255	; 0xff
20001b28:	f04f 0000 	mov.w	r0, #0
20001b2c:	ea40 0101 	orr.w	r1, r0, r1
20001b30:	7511      	strb	r1, [r2, #20]
20001b32:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001b36:	b29b      	uxth	r3, r3
20001b38:	f04f 0100 	mov.w	r1, #0
20001b3c:	ea41 0303 	orr.w	r3, r1, r3
20001b40:	7553      	strb	r3, [r2, #21]
	comms_pkt->comms_adf_cmd_rx = cmd_rx_count;
20001b42:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001b46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b4a:	681a      	ldr	r2, [r3, #0]
20001b4c:	f24c 23e6 	movw	r3, #49894	; 0xc2e6
20001b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b54:	781b      	ldrb	r3, [r3, #0]
20001b56:	73d3      	strb	r3, [r2, #15]
	comms_pkt->comms_adf_cmd_succ = cmd_succ_count;
20001b58:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001b5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b60:	681a      	ldr	r2, [r3, #0]
20001b62:	f24c 23e7 	movw	r3, #49895	; 0xc2e7
20001b66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b6a:	781b      	ldrb	r3, [r3, #0]
20001b6c:	7413      	strb	r3, [r2, #16]
	comms_pkt->comms_adf_cmd_reject = cmd_reject_count;
20001b6e:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001b72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b76:	681a      	ldr	r2, [r3, #0]
20001b78:	f24c 23e8 	movw	r3, #49896	; 0xc2e8
20001b7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b80:	781b      	ldrb	r3, [r3, #0]
20001b82:	7453      	strb	r3, [r2, #17]
	comms_pkt->comms_adf_rssi_cca = rssi_cca;
20001b84:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001b88:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b8c:	681a      	ldr	r2, [r3, #0]
20001b8e:	f24d 3364 	movw	r3, #54116	; 0xd364
20001b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b96:	881b      	ldrh	r3, [r3, #0]
20001b98:	f003 01ff 	and.w	r1, r3, #255	; 0xff
20001b9c:	f04f 0000 	mov.w	r0, #0
20001ba0:	ea40 0101 	orr.w	r1, r0, r1
20001ba4:	7491      	strb	r1, [r2, #18]
20001ba6:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001baa:	b29b      	uxth	r3, r3
20001bac:	f04f 0100 	mov.w	r1, #0
20001bb0:	ea41 0303 	orr.w	r3, r1, r3
20001bb4:	74d3      	strb	r3, [r2, #19]
	comms_pkt->comms_adf_preamble_patt = get_preamble_pkt();
20001bb6:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bbe:	681c      	ldr	r4, [r3, #0]
20001bc0:	f004 fa60 	bl	20006084 <get_preamble_pkt>
20001bc4:	4603      	mov	r3, r0
20001bc6:	75a3      	strb	r3, [r4, #22]
	comms_pkt->comms_adf_sync_word = get_sync_word();
20001bc8:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bd0:	681c      	ldr	r4, [r3, #0]
20001bd2:	f004 fa6f 	bl	200060b4 <get_sync_word>
20001bd6:	4603      	mov	r3, r0
20001bd8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001bdc:	f04f 0100 	mov.w	r1, #0
20001be0:	ea41 0202 	orr.w	r2, r1, r2
20001be4:	75e2      	strb	r2, [r4, #23]
20001be6:	ea4f 2213 	mov.w	r2, r3, lsr #8
20001bea:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20001bee:	f04f 0100 	mov.w	r1, #0
20001bf2:	ea41 0202 	orr.w	r2, r1, r2
20001bf6:	7622      	strb	r2, [r4, #24]
20001bf8:	ea4f 4213 	mov.w	r2, r3, lsr #16
20001bfc:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20001c00:	f04f 0100 	mov.w	r1, #0
20001c04:	ea41 0202 	orr.w	r2, r1, r2
20001c08:	7662      	strb	r2, [r4, #25]
20001c0a:	ea4f 6313 	mov.w	r3, r3, lsr #24
20001c0e:	f04f 0200 	mov.w	r2, #0
20001c12:	ea42 0303 	orr.w	r3, r2, r3
20001c16:	76a3      	strb	r3, [r4, #26]
	comms_pkt->comms_adf_freq = get_freq();
20001c18:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001c1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c20:	681c      	ldr	r4, [r3, #0]
20001c22:	f004 fa6f 	bl	20006104 <get_freq>
20001c26:	4603      	mov	r3, r0
20001c28:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001c2c:	f04f 0100 	mov.w	r1, #0
20001c30:	ea41 0202 	orr.w	r2, r1, r2
20001c34:	76e2      	strb	r2, [r4, #27]
20001c36:	ea4f 2213 	mov.w	r2, r3, lsr #8
20001c3a:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20001c3e:	f04f 0100 	mov.w	r1, #0
20001c42:	ea41 0202 	orr.w	r2, r1, r2
20001c46:	7722      	strb	r2, [r4, #28]
20001c48:	ea4f 4213 	mov.w	r2, r3, lsr #16
20001c4c:	f002 02ff 	and.w	r2, r2, #255	; 0xff
20001c50:	f04f 0100 	mov.w	r1, #0
20001c54:	ea41 0202 	orr.w	r2, r1, r2
20001c58:	7762      	strb	r2, [r4, #29]
20001c5a:	ea4f 6313 	mov.w	r3, r3, lsr #24
20001c5e:	f04f 0200 	mov.w	r2, #0
20001c62:	ea42 0303 	orr.w	r3, r2, r3
20001c66:	77a3      	strb	r3, [r4, #30]
	comms_pkt->comms_adf_read_reg_addr = cmd_adf_read_addr;
20001c68:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c70:	681b      	ldr	r3, [r3, #0]
20001c72:	f24c 22e0 	movw	r2, #49888	; 0xc2e0
20001c76:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001c7a:	6812      	ldr	r2, [r2, #0]
20001c7c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20001c80:	f04f 0000 	mov.w	r0, #0
20001c84:	ea40 0101 	orr.w	r1, r0, r1
20001c88:	77d9      	strb	r1, [r3, #31]
20001c8a:	ea4f 2112 	mov.w	r1, r2, lsr #8
20001c8e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001c92:	f04f 0000 	mov.w	r0, #0
20001c96:	ea40 0101 	orr.w	r1, r0, r1
20001c9a:	f883 1020 	strb.w	r1, [r3, #32]
20001c9e:	ea4f 4112 	mov.w	r1, r2, lsr #16
20001ca2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20001ca6:	f04f 0000 	mov.w	r0, #0
20001caa:	ea40 0101 	orr.w	r1, r0, r1
20001cae:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
20001cb2:	ea4f 6212 	mov.w	r2, r2, lsr #24
20001cb6:	f04f 0100 	mov.w	r1, #0
20001cba:	ea41 0202 	orr.w	r2, r1, r2
20001cbe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	comms_pkt->comms_adf_read_No_double_words = cmd_adf_read_No_double_words;
20001cc2:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001cc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001cca:	681a      	ldr	r2, [r3, #0]
20001ccc:	f24c 23e4 	movw	r3, #49892	; 0xc2e4
20001cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001cd4:	781b      	ldrb	r3, [r3, #0]
20001cd6:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
	comms_pkt->comms_adf_state = adf_get_state();
20001cda:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ce2:	681c      	ldr	r4, [r3, #0]
20001ce4:	f004 f8dc 	bl	20005ea0 <adf_get_state>
20001ce8:	4603      	mov	r3, r0
20001cea:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44

	for(;i<cmd_adf_read_No_double_words;i++){
20001cee:	e043      	b.n	20001d78 <get_comms+0x2d0>
		comms_pkt->comms_adf_data[i] =	cmd_adf_data[i];
20001cf0:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001cf8:	681b      	ldr	r3, [r3, #0]
20001cfa:	88f8      	ldrh	r0, [r7, #6]
20001cfc:	88f9      	ldrh	r1, [r7, #6]
20001cfe:	f24d 02d8 	movw	r2, #53464	; 0xd0d8
20001d02:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001d06:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
20001d0a:	f100 0208 	add.w	r2, r0, #8
20001d0e:	f001 0cff 	and.w	ip, r1, #255	; 0xff
20001d12:	ea4f 0082 	mov.w	r0, r2, lsl #2
20001d16:	4418      	add	r0, r3
20001d18:	f04f 0e00 	mov.w	lr, #0
20001d1c:	ea4e 0c0c 	orr.w	ip, lr, ip
20001d20:	f880 c004 	strb.w	ip, [r0, #4]
20001d24:	ea4f 2011 	mov.w	r0, r1, lsr #8
20001d28:	f000 0cff 	and.w	ip, r0, #255	; 0xff
20001d2c:	ea4f 0082 	mov.w	r0, r2, lsl #2
20001d30:	4418      	add	r0, r3
20001d32:	f04f 0e00 	mov.w	lr, #0
20001d36:	ea4e 0c0c 	orr.w	ip, lr, ip
20001d3a:	f880 c005 	strb.w	ip, [r0, #5]
20001d3e:	ea4f 4011 	mov.w	r0, r1, lsr #16
20001d42:	f000 0cff 	and.w	ip, r0, #255	; 0xff
20001d46:	ea4f 0082 	mov.w	r0, r2, lsl #2
20001d4a:	4418      	add	r0, r3
20001d4c:	f04f 0e00 	mov.w	lr, #0
20001d50:	ea4e 0c0c 	orr.w	ip, lr, ip
20001d54:	f880 c006 	strb.w	ip, [r0, #6]
20001d58:	ea4f 6011 	mov.w	r0, r1, lsr #24
20001d5c:	ea4f 0282 	mov.w	r2, r2, lsl #2
20001d60:	441a      	add	r2, r3
20001d62:	f04f 0300 	mov.w	r3, #0
20001d66:	4619      	mov	r1, r3
20001d68:	4603      	mov	r3, r0
20001d6a:	ea41 0303 	orr.w	r3, r1, r3
20001d6e:	71d3      	strb	r3, [r2, #7]
	comms_pkt->comms_adf_freq = get_freq();
	comms_pkt->comms_adf_read_reg_addr = cmd_adf_read_addr;
	comms_pkt->comms_adf_read_No_double_words = cmd_adf_read_No_double_words;
	comms_pkt->comms_adf_state = adf_get_state();

	for(;i<cmd_adf_read_No_double_words;i++){
20001d70:	88fb      	ldrh	r3, [r7, #6]
20001d72:	f103 0301 	add.w	r3, r3, #1
20001d76:	80fb      	strh	r3, [r7, #6]
20001d78:	f24c 23e4 	movw	r3, #49892	; 0xc2e4
20001d7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d80:	781b      	ldrb	r3, [r3, #0]
20001d82:	88fa      	ldrh	r2, [r7, #6]
20001d84:	429a      	cmp	r2, r3
20001d86:	d3b3      	bcc.n	20001cf0 <get_comms+0x248>



//	comms_pkt->comms_adf_state = adf_get_state();

	comms_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, COMMS_API_ID))));
20001d88:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001d8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d90:	681b      	ldr	r3, [r3, #0]
20001d92:	f04f 0200 	mov.w	r2, #0
20001d96:	f042 0208 	orr.w	r2, r2, #8
20001d9a:	701a      	strb	r2, [r3, #0]
20001d9c:	f04f 0200 	mov.w	r2, #0
20001da0:	f042 0203 	orr.w	r2, r2, #3
20001da4:	705a      	strb	r2, [r3, #1]
	comms_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((comms_seq_num++)))));
20001da6:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001dae:	6818      	ldr	r0, [r3, #0]
20001db0:	f24c 23dc 	movw	r3, #49884	; 0xc2dc
20001db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001db8:	8819      	ldrh	r1, [r3, #0]
20001dba:	460b      	mov	r3, r1
20001dbc:	ea6f 4383 	mvn.w	r3, r3, lsl #18
20001dc0:	ea6f 4393 	mvn.w	r3, r3, lsr #18
20001dc4:	b29b      	uxth	r3, r3
20001dc6:	b29b      	uxth	r3, r3
20001dc8:	ea4f 2303 	mov.w	r3, r3, lsl #8
20001dcc:	fa1f fc83 	uxth.w	ip, r3
20001dd0:	f24c 23dc 	movw	r3, #49884	; 0xc2dc
20001dd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001dd8:	881a      	ldrh	r2, [r3, #0]
20001dda:	4613      	mov	r3, r2
20001ddc:	ea6f 4383 	mvn.w	r3, r3, lsl #18
20001de0:	ea6f 4393 	mvn.w	r3, r3, lsr #18
20001de4:	b29b      	uxth	r3, r3
20001de6:	b29b      	uxth	r3, r3
20001de8:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001dec:	b29b      	uxth	r3, r3
20001dee:	ea4c 0303 	orr.w	r3, ip, r3
20001df2:	b29b      	uxth	r3, r3
20001df4:	b29b      	uxth	r3, r3
20001df6:	f003 0cff 	and.w	ip, r3, #255	; 0xff
20001dfa:	f04f 0e00 	mov.w	lr, #0
20001dfe:	ea4e 0c0c 	orr.w	ip, lr, ip
20001e02:	f880 c002 	strb.w	ip, [r0, #2]
20001e06:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001e0a:	b29b      	uxth	r3, r3
20001e0c:	f04f 0c00 	mov.w	ip, #0
20001e10:	ea4c 0303 	orr.w	r3, ip, r3
20001e14:	70c3      	strb	r3, [r0, #3]
20001e16:	f101 0301 	add.w	r3, r1, #1
20001e1a:	b299      	uxth	r1, r3
20001e1c:	f24c 23dc 	movw	r3, #49884	; 0xc2dc
20001e20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e24:	8019      	strh	r1, [r3, #0]
20001e26:	f102 0301 	add.w	r3, r2, #1
20001e2a:	b29a      	uxth	r2, r3
20001e2c:	f24c 23dc 	movw	r3, #49884	; 0xc2dc
20001e30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e34:	801a      	strh	r2, [r3, #0]
	comms_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(COMMS_PKT_LENGTH))));
20001e36:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e3e:	681b      	ldr	r3, [r3, #0]
20001e40:	f04f 0200 	mov.w	r2, #0
20001e44:	711a      	strb	r2, [r3, #4]
20001e46:	f04f 0200 	mov.w	r2, #0
20001e4a:	f042 0268 	orr.w	r2, r2, #104	; 0x68
20001e4e:	715a      	strb	r2, [r3, #5]
	comms_pkt->ccsds_s1 = 0;
20001e50:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001e54:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e58:	681b      	ldr	r3, [r3, #0]
20001e5a:	f04f 0200 	mov.w	r2, #0
20001e5e:	719a      	strb	r2, [r3, #6]
20001e60:	f04f 0200 	mov.w	r2, #0
20001e64:	71da      	strb	r2, [r3, #7]
20001e66:	f04f 0200 	mov.w	r2, #0
20001e6a:	721a      	strb	r2, [r3, #8]
20001e6c:	f04f 0200 	mov.w	r2, #0
20001e70:	725a      	strb	r2, [r3, #9]

	comms_pkt->ccsds_s2 = 0;
20001e72:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001e76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e7a:	681b      	ldr	r3, [r3, #0]
20001e7c:	f04f 0200 	mov.w	r2, #0
20001e80:	729a      	strb	r2, [r3, #10]
20001e82:	f04f 0200 	mov.w	r2, #0
20001e86:	72da      	strb	r2, [r3, #11]
20001e88:	f04f 0200 	mov.w	r2, #0
20001e8c:	731a      	strb	r2, [r3, #12]
20001e8e:	f04f 0200 	mov.w	r2, #0
20001e92:	735a      	strb	r2, [r3, #13]

	if(store_in_sd_card){
20001e94:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20001e98:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e9c:	781b      	ldrb	r3, [r3, #0]
20001e9e:	2b00      	cmp	r3, #0
20001ea0:	d03c      	beq.n	20001f1c <get_comms+0x474>
		sd_dump_comms = 1;
20001ea2:	f24c 23da 	movw	r3, #49882	; 0xc2da
20001ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001eaa:	f04f 0201 	mov.w	r2, #1
20001eae:	701a      	strb	r2, [r3, #0]
		comms_pkt->comms_sd_dump = sd_dump_comms;
20001eb0:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001eb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001eb8:	681a      	ldr	r2, [r3, #0]
20001eba:	f24c 23da 	movw	r3, #49882	; 0xc2da
20001ebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ec2:	781b      	ldrb	r3, [r3, #0]
20001ec4:	f882 3045 	strb.w	r3, [r2, #69]	; 0x45
		comms_pkt->Fletcher_Code = make_FLetcher(data, sizeof(comms_pkt_t) - 2);
20001ec8:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ed0:	681c      	ldr	r4, [r3, #0]
20001ed2:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
20001ed6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001eda:	f04f 0166 	mov.w	r1, #102	; 0x66
20001ede:	f7fe fc03 	bl	200006e8 <make_FLetcher>
20001ee2:	4603      	mov	r3, r0
20001ee4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001ee8:	f04f 0100 	mov.w	r1, #0
20001eec:	ea41 0202 	orr.w	r2, r1, r2
20001ef0:	f884 2066 	strb.w	r2, [r4, #102]	; 0x66
20001ef4:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001ef8:	b29b      	uxth	r3, r3
20001efa:	f04f 0200 	mov.w	r2, #0
20001efe:	ea42 0303 	orr.w	r3, r2, r3
20001f02:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
		store_data(&comms_partition, data);
20001f06:	f24d 307c 	movw	r0, #54140	; 0xd37c
20001f0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001f0e:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001f12:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001f16:	f003 fa1d 	bl	20005354 <store_data>
20001f1a:	e03d      	b.n	20001f98 <get_comms+0x4f0>
	}
	else{
		sd_dump_comms = 0;
20001f1c:	f24c 23da 	movw	r3, #49882	; 0xc2da
20001f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f24:	f04f 0200 	mov.w	r2, #0
20001f28:	701a      	strb	r2, [r3, #0]
		comms_pkt->comms_sd_dump = sd_dump_comms;
20001f2a:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001f2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f32:	681a      	ldr	r2, [r3, #0]
20001f34:	f24c 23da 	movw	r3, #49882	; 0xc2da
20001f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f3c:	781b      	ldrb	r3, [r3, #0]
20001f3e:	f882 3045 	strb.w	r3, [r2, #69]	; 0x45
		comms_pkt->Fletcher_Code = make_FLetcher(data, sizeof(comms_pkt_t) - 2);
20001f42:	f24d 03c8 	movw	r3, #53448	; 0xd0c8
20001f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f4a:	681c      	ldr	r4, [r3, #0]
20001f4c:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
20001f50:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001f54:	f04f 0166 	mov.w	r1, #102	; 0x66
20001f58:	f7fe fbc6 	bl	200006e8 <make_FLetcher>
20001f5c:	4603      	mov	r3, r0
20001f5e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
20001f62:	f04f 0100 	mov.w	r1, #0
20001f66:	ea41 0202 	orr.w	r2, r1, r2
20001f6a:	f884 2066 	strb.w	r2, [r4, #102]	; 0x66
20001f6e:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001f72:	b29b      	uxth	r3, r3
20001f74:	f04f 0200 	mov.w	r2, #0
20001f78:	ea42 0303 	orr.w	r3, r2, r3
20001f7c:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
//		vGetPktStruct(comms, (void*) comms_pkt, sizeof(comms_pkt_t));
		MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(comms_pkt_t));
20001f80:	f24d 4040 	movw	r0, #54336	; 0xd440
20001f84:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001f88:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20001f8c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001f90:	f04f 0268 	mov.w	r2, #104	; 0x68
20001f94:	f004 f9e6 	bl	20006364 <MSS_UART_polled_tx>
	}

//	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(comms_pkt_t));
//	vGetPktStruct(comms, (void*) data_test, sizeof(data_test));
}
20001f98:	f107 070c 	add.w	r7, r7, #12
20001f9c:	46bd      	mov	sp, r7
20001f9e:	bd90      	pop	{r4, r7, pc}

20001fa0 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20001fa0:	b480      	push	{r7}
20001fa2:	b083      	sub	sp, #12
20001fa4:	af00      	add	r7, sp, #0
20001fa6:	4603      	mov	r3, r0
20001fa8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20001faa:	f24e 1300 	movw	r3, #57600	; 0xe100
20001fae:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001fb2:	f997 2007 	ldrsb.w	r2, [r7, #7]
20001fb6:	ea4f 1252 	mov.w	r2, r2, lsr #5
20001fba:	79f9      	ldrb	r1, [r7, #7]
20001fbc:	f001 011f 	and.w	r1, r1, #31
20001fc0:	f04f 0001 	mov.w	r0, #1
20001fc4:	fa00 f101 	lsl.w	r1, r0, r1
20001fc8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20001fcc:	f107 070c 	add.w	r7, r7, #12
20001fd0:	46bd      	mov	sp, r7
20001fd2:	bc80      	pop	{r7}
20001fd4:	4770      	bx	lr
20001fd6:	bf00      	nop

20001fd8 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20001fd8:	b480      	push	{r7}
20001fda:	b083      	sub	sp, #12
20001fdc:	af00      	add	r7, sp, #0
20001fde:	4603      	mov	r3, r0
20001fe0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20001fe2:	f24e 1300 	movw	r3, #57600	; 0xe100
20001fe6:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001fea:	f997 2007 	ldrsb.w	r2, [r7, #7]
20001fee:	ea4f 1252 	mov.w	r2, r2, lsr #5
20001ff2:	79f9      	ldrb	r1, [r7, #7]
20001ff4:	f001 011f 	and.w	r1, r1, #31
20001ff8:	f04f 0001 	mov.w	r0, #1
20001ffc:	fa00 f101 	lsl.w	r1, r0, r1
20002000:	f102 0220 	add.w	r2, r2, #32
20002004:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002008:	f107 070c 	add.w	r7, r7, #12
2000200c:	46bd      	mov	sp, r7
2000200e:	bc80      	pop	{r7}
20002010:	4770      	bx	lr
20002012:	bf00      	nop

20002014 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002014:	b480      	push	{r7}
20002016:	b083      	sub	sp, #12
20002018:	af00      	add	r7, sp, #0
2000201a:	4603      	mov	r3, r0
2000201c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
2000201e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002022:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002026:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000202a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000202e:	79f9      	ldrb	r1, [r7, #7]
20002030:	f001 011f 	and.w	r1, r1, #31
20002034:	f04f 0001 	mov.w	r0, #1
20002038:	fa00 f101 	lsl.w	r1, r0, r1
2000203c:	f102 0260 	add.w	r2, r2, #96	; 0x60
20002040:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002044:	f107 070c 	add.w	r7, r7, #12
20002048:	46bd      	mov	sp, r7
2000204a:	bc80      	pop	{r7}
2000204c:	4770      	bx	lr
2000204e:	bf00      	nop

20002050 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number. 
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
20002050:	b480      	push	{r7}
20002052:	b083      	sub	sp, #12
20002054:	af00      	add	r7, sp, #0
20002056:	4603      	mov	r3, r0
20002058:	6039      	str	r1, [r7, #0]
2000205a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
2000205c:	f997 3007 	ldrsb.w	r3, [r7, #7]
20002060:	2b00      	cmp	r3, #0
20002062:	da10      	bge.n	20002086 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
20002064:	f64e 5300 	movw	r3, #60672	; 0xed00
20002068:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000206c:	79fa      	ldrb	r2, [r7, #7]
2000206e:	f002 020f 	and.w	r2, r2, #15
20002072:	f1a2 0104 	sub.w	r1, r2, #4
20002076:	683a      	ldr	r2, [r7, #0]
20002078:	b2d2      	uxtb	r2, r2
2000207a:	ea4f 1202 	mov.w	r2, r2, lsl #4
2000207e:	b2d2      	uxtb	r2, r2
20002080:	440b      	add	r3, r1
20002082:	761a      	strb	r2, [r3, #24]
20002084:	e00d      	b.n	200020a2 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
20002086:	f24e 1300 	movw	r3, #57600	; 0xe100
2000208a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000208e:	f997 1007 	ldrsb.w	r1, [r7, #7]
20002092:	683a      	ldr	r2, [r7, #0]
20002094:	b2d2      	uxtb	r2, r2
20002096:	ea4f 1202 	mov.w	r2, r2, lsl #4
2000209a:	b2d2      	uxtb	r2, r2
2000209c:	440b      	add	r3, r1
2000209e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
200020a2:	f107 070c 	add.w	r7, r7, #12
200020a6:	46bd      	mov	sp, r7
200020a8:	bc80      	pop	{r7}
200020aa:	4770      	bx	lr

200020ac <MSS_TIM64_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE 
 */
static __INLINE void MSS_TIM64_init(mss_timer_mode_t mode)
{
200020ac:	b580      	push	{r7, lr}
200020ae:	b082      	sub	sp, #8
200020b0:	af00      	add	r7, sp, #0
200020b2:	4603      	mov	r3, r0
200020b4:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ(Timer1_IRQn);         /* disable timer 1 interrupt within NVIC */
200020b6:	f04f 000e 	mov.w	r0, #14
200020ba:	f7ff ff8d 	bl	20001fd8 <NVIC_DisableIRQ>
    NVIC_DisableIRQ(Timer2_IRQn);         /* disable timer 2 interrupt within NVIC */
200020be:	f04f 000f 	mov.w	r0, #15
200020c2:	f7ff ff89 	bl	20001fd8 <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
200020c6:	f248 0300 	movw	r3, #32768	; 0x8000
200020ca:	f2c4 0303 	movt	r3, #16387	; 0x4003
200020ce:	f248 0200 	movw	r2, #32768	; 0x8000
200020d2:	f2c4 0203 	movt	r2, #16387	; 0x4003
200020d6:	6c92      	ldr	r2, [r2, #72]	; 0x48
200020d8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
200020dc:	649a      	str	r2, [r3, #72]	; 0x48
    
    TIMER->TIM64_MODE = 1u;                     /* switch to 64 bits mode */
200020de:	f244 0300 	movw	r3, #16384	; 0x4000
200020e2:	f2c4 0300 	movt	r3, #16384	; 0x4000
200020e6:	f04f 0201 	mov.w	r2, #1
200020ea:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM64ENABLE = 0u;            /* disable timer */
200020ec:	f240 0300 	movw	r3, #0
200020f0:	f2c4 2308 	movt	r3, #16904	; 0x4208
200020f4:	f04f 0200 	mov.w	r2, #0
200020f8:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    TIMER_BITBAND->TIM64INTEN = 0u;             /* disable interrupt */
200020fc:	f240 0300 	movw	r3, #0
20002100:	f2c4 2308 	movt	r3, #16904	; 0x4208
20002104:	f04f 0200 	mov.w	r2, #0
20002108:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    TIMER_BITBAND->TIM64MODE = (uint32_t)mode;  /* set mode (continuous/one-shot) */
2000210c:	f240 0300 	movw	r3, #0
20002110:	f2c4 2308 	movt	r3, #16904	; 0x4208
20002114:	79fa      	ldrb	r2, [r7, #7]
20002116:	f8c3 2904 	str.w	r2, [r3, #2308]	; 0x904
    
    TIMER->TIM1_RIS = 1u;                   /* clear timer 1 interrupt */
2000211a:	f244 0300 	movw	r3, #16384	; 0x4000
2000211e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002122:	f04f 0201 	mov.w	r2, #1
20002126:	611a      	str	r2, [r3, #16]
    TIMER->TIM2_RIS = 1u;                   /* clear timer 2 interrupt */
20002128:	f244 0300 	movw	r3, #16384	; 0x4000
2000212c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002130:	f04f 0201 	mov.w	r2, #1
20002134:	629a      	str	r2, [r3, #40]	; 0x28
    NVIC_ClearPendingIRQ(Timer1_IRQn);    /* clear timer 1 interrupt within NVIC */
20002136:	f04f 000e 	mov.w	r0, #14
2000213a:	f7ff ff6b 	bl	20002014 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ(Timer2_IRQn);    /* clear timer 2 interrupt within NVIC */
2000213e:	f04f 000f 	mov.w	r0, #15
20002142:	f7ff ff67 	bl	20002014 <NVIC_ClearPendingIRQ>
}
20002146:	f107 0708 	add.w	r7, r7, #8
2000214a:	46bd      	mov	sp, r7
2000214c:	bd80      	pop	{r7, pc}
2000214e:	bf00      	nop

20002150 <MSS_TIM64_start>:
  the MSS_TIM64_load_immediate() or MSS_TIM64_load_background() functions.
  Note: The MSS_TIM64_start() function is also used to resume the down-counter
        if previously stopped using the MSS_TIM64_stop() function.
 */
static __INLINE void MSS_TIM64_start(void)
{
20002150:	b480      	push	{r7}
20002152:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM64ENABLE = 1u;    /* enable timer */
20002154:	f240 0300 	movw	r3, #0
20002158:	f2c4 2308 	movt	r3, #16904	; 0x4208
2000215c:	f04f 0201 	mov.w	r2, #1
20002160:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
20002164:	46bd      	mov	sp, r7
20002166:	bc80      	pop	{r7}
20002168:	4770      	bx	lr
2000216a:	bf00      	nop

2000216c <MSS_TIM64_get_current_value>:
static __INLINE void MSS_TIM64_get_current_value
(
    uint32_t * load_value_u,
    uint32_t * load_value_l
)
{
2000216c:	b480      	push	{r7}
2000216e:	b083      	sub	sp, #12
20002170:	af00      	add	r7, sp, #0
20002172:	6078      	str	r0, [r7, #4]
20002174:	6039      	str	r1, [r7, #0]
    *load_value_l = TIMER->TIM64_VAL_L;
20002176:	f244 0300 	movw	r3, #16384	; 0x4000
2000217a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000217e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
20002180:	683b      	ldr	r3, [r7, #0]
20002182:	601a      	str	r2, [r3, #0]
    *load_value_u = TIMER->TIM64_VAL_U;
20002184:	f244 0300 	movw	r3, #16384	; 0x4000
20002188:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000218c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
2000218e:	687b      	ldr	r3, [r7, #4]
20002190:	601a      	str	r2, [r3, #0]
}
20002192:	f107 070c 	add.w	r7, r7, #12
20002196:	46bd      	mov	sp, r7
20002198:	bc80      	pop	{r7}
2000219a:	4770      	bx	lr

2000219c <MSS_TIM64_load_immediate>:
static __INLINE void MSS_TIM64_load_immediate
(
    uint32_t load_value_u,
    uint32_t load_value_l
)
{
2000219c:	b480      	push	{r7}
2000219e:	b083      	sub	sp, #12
200021a0:	af00      	add	r7, sp, #0
200021a2:	6078      	str	r0, [r7, #4]
200021a4:	6039      	str	r1, [r7, #0]
    TIMER->TIM64_LOADVAL_U = load_value_u;
200021a6:	f244 0300 	movw	r3, #16384	; 0x4000
200021aa:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021ae:	687a      	ldr	r2, [r7, #4]
200021b0:	639a      	str	r2, [r3, #56]	; 0x38
    TIMER->TIM64_LOADVAL_L = load_value_l;
200021b2:	f244 0300 	movw	r3, #16384	; 0x4000
200021b6:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021ba:	683a      	ldr	r2, [r7, #0]
200021bc:	63da      	str	r2, [r3, #60]	; 0x3c
}
200021be:	f107 070c 	add.w	r7, r7, #12
200021c2:	46bd      	mov	sp, r7
200021c4:	bc80      	pop	{r7}
200021c6:	4770      	bx	lr

200021c8 <MSS_WD_init>:
        
  @return
    This function does not return a value.
 */
static __INLINE void MSS_WD_init(void)
{
200021c8:	b580      	push	{r7, lr}
200021ca:	b082      	sub	sp, #8
200021cc:	af00      	add	r7, sp, #0
    uint32_t wdg_value;
    
    /* Disable interrupts. */
    WATCHDOG->WDOGCONTROL &= ~(MSS_WDOG_TIMEOUT_IRQ_ENABLE_BIT_MASK | MSS_WDOG_WAKEUP_IRQ_CLEAR_BIT_MASK);
200021ce:	f245 0300 	movw	r3, #20480	; 0x5000
200021d2:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021d6:	f245 0200 	movw	r2, #20480	; 0x5000
200021da:	f2c4 0200 	movt	r2, #16384	; 0x4000
200021de:	6952      	ldr	r2, [r2, #20]
200021e0:	f022 0203 	bic.w	r2, r2, #3
200021e4:	615a      	str	r2, [r3, #20]
    
    /* Clear any existing interrupts. */
    WATCHDOG->WDOGRIS = MSS_WDOG_TIMEOUT_IRQ_CLEAR_BIT_MASK | MSS_WDOG_WAKEUP_IRQ_CLEAR_BIT_MASK;
200021e6:	f245 0300 	movw	r3, #20480	; 0x5000
200021ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
200021ee:	f04f 0203 	mov.w	r2, #3
200021f2:	61da      	str	r2, [r3, #28]
    
    /* Clear any pending wakeup interrupt from Cortex-M3 NVIC */
    NVIC_ClearPendingIRQ(WdogWakeup_IRQn);
200021f4:	f04f 0000 	mov.w	r0, #0
200021f8:	f7ff ff0c 	bl	20002014 <NVIC_ClearPendingIRQ>
    
    /* Reload watchdog with new load value if in allowed window. */
    wdg_value = WATCHDOG->WDOGVALUE;
200021fc:	f245 0300 	movw	r3, #20480	; 0x5000
20002200:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002204:	681b      	ldr	r3, [r3, #0]
20002206:	607b      	str	r3, [r7, #4]
    if(wdg_value < WATCHDOG->WDOGMVRP)
20002208:	f245 0300 	movw	r3, #20480	; 0x5000
2000220c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002210:	689a      	ldr	r2, [r3, #8]
20002212:	687b      	ldr	r3, [r7, #4]
20002214:	429a      	cmp	r2, r3
20002216:	d908      	bls.n	2000222a <MSS_WD_init+0x62>
    {
        WATCHDOG->WDOGREFRESH = MSS_WDOG_REFRESH_KEY;
20002218:	f245 0300 	movw	r3, #20480	; 0x5000
2000221c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002220:	f64d 6242 	movw	r2, #56898	; 0xde42
20002224:	f6ca 4215 	movt	r2, #44053	; 0xac15
20002228:	60da      	str	r2, [r3, #12]
    }
}
2000222a:	f107 0708 	add.w	r7, r7, #8
2000222e:	46bd      	mov	sp, r7
20002230:	bd80      	pop	{r7, pc}
20002232:	bf00      	nop

20002234 <MSS_WD_reload>:
 
  @return
    This function does not return a value.
 */
static __INLINE void MSS_WD_reload(void)
{
20002234:	b480      	push	{r7}
20002236:	af00      	add	r7, sp, #0
    WATCHDOG->WDOGREFRESH = MSS_WDOG_REFRESH_KEY;
20002238:	f245 0300 	movw	r3, #20480	; 0x5000
2000223c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002240:	f64d 6242 	movw	r2, #56898	; 0xde42
20002244:	f6ca 4215 	movt	r2, #44053	; 0xac15
20002248:	60da      	str	r2, [r3, #12]
}
2000224a:	46bd      	mov	sp, r7
2000224c:	bc80      	pop	{r7}
2000224e:	4770      	bx	lr

20002250 <form_log_packet>:

//Declare variable for status for each packet
uint16_t hk_status,gmc_status,comms_status,therm_status;

//Function to form Log packet
void form_log_packet() {
20002250:	b598      	push	{r3, r4, r7, lr}
20002252:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
20002254:	f24d 3258 	movw	r2, #54104	; 0xd358
20002258:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000225c:	f24d 3348 	movw	r3, #54088	; 0xd348
20002260:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002264:	4610      	mov	r0, r2
20002266:	4619      	mov	r1, r3
20002268:	f7ff ff80 	bl	2000216c <MSS_TIM64_get_current_value>
	log_packet_ptr->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(ccsds_p1(tlm_pkt_type,LOGS_API_ID));
2000226c:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002270:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002274:	681b      	ldr	r3, [r3, #0]
20002276:	f04f 0200 	mov.w	r2, #0
2000227a:	f042 0208 	orr.w	r2, r2, #8
2000227e:	701a      	strb	r2, [r3, #0]
20002280:	f04f 0200 	mov.w	r2, #0
20002284:	f042 0206 	orr.w	r2, r2, #6
20002288:	705a      	strb	r2, [r3, #1]
	log_packet_ptr->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(ccsds_p2((logs_seq_no)));
2000228a:	f24d 131c 	movw	r3, #53532	; 0xd11c
2000228e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002292:	681a      	ldr	r2, [r3, #0]
20002294:	f24d 333c 	movw	r3, #54076	; 0xd33c
20002298:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000229c:	881b      	ldrh	r3, [r3, #0]
2000229e:	ea6f 4383 	mvn.w	r3, r3, lsl #18
200022a2:	ea6f 4393 	mvn.w	r3, r3, lsr #18
200022a6:	b29b      	uxth	r3, r3
200022a8:	b29b      	uxth	r3, r3
200022aa:	ea4f 2303 	mov.w	r3, r3, lsl #8
200022ae:	b299      	uxth	r1, r3
200022b0:	f24d 333c 	movw	r3, #54076	; 0xd33c
200022b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200022b8:	881b      	ldrh	r3, [r3, #0]
200022ba:	ea6f 4383 	mvn.w	r3, r3, lsl #18
200022be:	ea6f 4393 	mvn.w	r3, r3, lsr #18
200022c2:	b29b      	uxth	r3, r3
200022c4:	b29b      	uxth	r3, r3
200022c6:	ea4f 2313 	mov.w	r3, r3, lsr #8
200022ca:	b29b      	uxth	r3, r3
200022cc:	ea41 0303 	orr.w	r3, r1, r3
200022d0:	b29b      	uxth	r3, r3
200022d2:	b29b      	uxth	r3, r3
200022d4:	f003 01ff 	and.w	r1, r3, #255	; 0xff
200022d8:	f04f 0000 	mov.w	r0, #0
200022dc:	ea40 0101 	orr.w	r1, r0, r1
200022e0:	7091      	strb	r1, [r2, #2]
200022e2:	ea4f 2313 	mov.w	r3, r3, lsr #8
200022e6:	b29b      	uxth	r3, r3
200022e8:	f04f 0100 	mov.w	r1, #0
200022ec:	ea41 0303 	orr.w	r3, r1, r3
200022f0:	70d3      	strb	r3, [r2, #3]
	log_packet_ptr->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(ccsds_p3(LOGS_PKT_LENGTH));
200022f2:	f24d 131c 	movw	r3, #53532	; 0xd11c
200022f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200022fa:	681b      	ldr	r3, [r3, #0]
200022fc:	f04f 0200 	mov.w	r2, #0
20002300:	711a      	strb	r2, [r3, #4]
20002302:	f04f 0200 	mov.w	r2, #0
20002306:	f042 027e 	orr.w	r2, r2, #126	; 0x7e
2000230a:	715a      	strb	r2, [r3, #5]
	log_packet_ptr->ccsds_s2 = current_time_lower;
2000230c:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002310:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002314:	681b      	ldr	r3, [r3, #0]
20002316:	f24d 3248 	movw	r2, #54088	; 0xd348
2000231a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000231e:	e9d2 0100 	ldrd	r0, r1, [r2]
20002322:	4602      	mov	r2, r0
20002324:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002328:	f04f 0000 	mov.w	r0, #0
2000232c:	ea40 0101 	orr.w	r1, r0, r1
20002330:	7299      	strb	r1, [r3, #10]
20002332:	ea4f 2112 	mov.w	r1, r2, lsr #8
20002336:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000233a:	f04f 0000 	mov.w	r0, #0
2000233e:	ea40 0101 	orr.w	r1, r0, r1
20002342:	72d9      	strb	r1, [r3, #11]
20002344:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002348:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000234c:	f04f 0000 	mov.w	r0, #0
20002350:	ea40 0101 	orr.w	r1, r0, r1
20002354:	7319      	strb	r1, [r3, #12]
20002356:	ea4f 6212 	mov.w	r2, r2, lsr #24
2000235a:	f04f 0100 	mov.w	r1, #0
2000235e:	ea41 0202 	orr.w	r2, r1, r2
20002362:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->ccsds_s1 = current_time_upper;
20002364:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002368:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000236c:	681b      	ldr	r3, [r3, #0]
2000236e:	f24d 3258 	movw	r2, #54104	; 0xd358
20002372:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002376:	e9d2 0100 	ldrd	r0, r1, [r2]
2000237a:	4602      	mov	r2, r0
2000237c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002380:	f04f 0000 	mov.w	r0, #0
20002384:	ea40 0101 	orr.w	r1, r0, r1
20002388:	7199      	strb	r1, [r3, #6]
2000238a:	ea4f 2112 	mov.w	r1, r2, lsr #8
2000238e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002392:	f04f 0000 	mov.w	r0, #0
20002396:	ea40 0101 	orr.w	r1, r0, r1
2000239a:	71d9      	strb	r1, [r3, #7]
2000239c:	ea4f 4112 	mov.w	r1, r2, lsr #16
200023a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200023a4:	f04f 0000 	mov.w	r0, #0
200023a8:	ea40 0101 	orr.w	r1, r0, r1
200023ac:	7219      	strb	r1, [r3, #8]
200023ae:	ea4f 6212 	mov.w	r2, r2, lsr #24
200023b2:	f04f 0100 	mov.w	r1, #0
200023b6:	ea41 0202 	orr.w	r2, r1, r2
200023ba:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->Fletcher_Code = make_FLetcher(log_data,LOGS_PKT_LENGTH-2);
200023bc:	f24d 131c 	movw	r3, #53532	; 0xd11c
200023c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200023c4:	681c      	ldr	r4, [r3, #0]
200023c6:	f24d 1038 	movw	r0, #53560	; 0xd138
200023ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
200023ce:	f04f 017c 	mov.w	r1, #124	; 0x7c
200023d2:	f7fe f989 	bl	200006e8 <make_FLetcher>
200023d6:	4603      	mov	r3, r0
200023d8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
200023dc:	f04f 0100 	mov.w	r1, #0
200023e0:	ea41 0202 	orr.w	r2, r1, r2
200023e4:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
200023e8:	ea4f 2313 	mov.w	r3, r3, lsr #8
200023ec:	b29b      	uxth	r3, r3
200023ee:	f04f 0200 	mov.w	r2, #0
200023f2:	ea42 0303 	orr.w	r3, r2, r3
200023f6:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
	//Need to replace the below l
	// add_to_queue(LOGS_PKT_LENGTH,&log_p,log_data,&logs_miss,LOGS_TASK_ID);
	if(store_in_sd_card){
200023fa:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
200023fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002402:	781b      	ldrb	r3, [r3, #0]
20002404:	2b00      	cmp	r3, #0
20002406:	d00a      	beq.n	2000241e <form_log_packet+0x1ce>
		store_data(&log_partiton, log_data);
20002408:	f24d 1004 	movw	r0, #53508	; 0xd104
2000240c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002410:	f24d 1138 	movw	r1, #53560	; 0xd138
20002414:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002418:	f002 ff9c 	bl	20005354 <store_data>
2000241c:	e00b      	b.n	20002436 <form_log_packet+0x1e6>
	}
	else{
//		vGetPktStruct(logs, (void*) log_packet_ptr, sizeof(log_packet_t));
		MSS_UART_polled_tx(&g_mss_uart0, log_data, sizeof(log_packet_t));
2000241e:	f24d 4040 	movw	r0, #54336	; 0xd440
20002422:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002426:	f24d 1138 	movw	r1, #53560	; 0xd138
2000242a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000242e:	f04f 027e 	mov.w	r2, #126	; 0x7e
20002432:	f003 ff97 	bl	20006364 <MSS_UART_polled_tx>
	}
	log_counter = 0;
20002436:	f24d 1300 	movw	r3, #53504	; 0xd100
2000243a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000243e:	f04f 0200 	mov.w	r2, #0
20002442:	701a      	strb	r2, [r3, #0]
	logs_seq_no++;
20002444:	f24d 333c 	movw	r3, #54076	; 0xd33c
20002448:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000244c:	881b      	ldrh	r3, [r3, #0]
2000244e:	f103 0301 	add.w	r3, r3, #1
20002452:	b29a      	uxth	r2, r3
20002454:	f24d 333c 	movw	r3, #54076	; 0xd33c
20002458:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000245c:	801a      	strh	r2, [r3, #0]
}
2000245e:	bd98      	pop	{r3, r4, r7, pc}

20002460 <HK_ISR>:
void HK_ISR(){
20002460:	b580      	push	{r7, lr}
20002462:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
20002464:	f24d 3258 	movw	r2, #54104	; 0xd358
20002468:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000246c:	f24d 3348 	movw	r3, #54088	; 0xd348
20002470:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002474:	4610      	mov	r0, r2
20002476:	4619      	mov	r1, r3
20002478:	f7ff fe78 	bl	2000216c <MSS_TIM64_get_current_value>

	hk_status = get_hk();
2000247c:	f7fe f9d0 	bl	20000820 <get_hk>
20002480:	4603      	mov	r3, r0
20002482:	461a      	mov	r2, r3
20002484:	f24d 3354 	movw	r3, #54100	; 0xd354
20002488:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000248c:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
2000248e:	f24d 1300 	movw	r3, #53504	; 0xd100
20002492:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002496:	781b      	ldrb	r3, [r3, #0]
20002498:	2b09      	cmp	r3, #9
2000249a:	d901      	bls.n	200024a0 <HK_ISR+0x40>
		form_log_packet();
2000249c:	f7ff fed8 	bl	20002250 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = HK_TASK_ID;
200024a0:	f24d 131c 	movw	r3, #53532	; 0xd11c
200024a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024a8:	6819      	ldr	r1, [r3, #0]
200024aa:	f24d 1300 	movw	r3, #53504	; 0xd100
200024ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024b2:	781b      	ldrb	r3, [r3, #0]
200024b4:	461a      	mov	r2, r3
200024b6:	4613      	mov	r3, r2
200024b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
200024bc:	4413      	add	r3, r2
200024be:	ea4f 0343 	mov.w	r3, r3, lsl #1
200024c2:	4413      	add	r3, r2
200024c4:	440b      	add	r3, r1
200024c6:	f103 0316 	add.w	r3, r3, #22
200024ca:	f04f 0202 	mov.w	r2, #2
200024ce:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
200024d0:	f24d 131c 	movw	r3, #53532	; 0xd11c
200024d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024d8:	6818      	ldr	r0, [r3, #0]
200024da:	f24d 1300 	movw	r3, #53504	; 0xd100
200024de:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024e2:	781b      	ldrb	r3, [r3, #0]
200024e4:	4619      	mov	r1, r3
200024e6:	f24d 3358 	movw	r3, #54104	; 0xd358
200024ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024ee:	e9d3 2300 	ldrd	r2, r3, [r3]
200024f2:	460b      	mov	r3, r1
200024f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200024f8:	440b      	add	r3, r1
200024fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
200024fe:	440b      	add	r3, r1
20002500:	4403      	add	r3, r0
20002502:	f103 0308 	add.w	r3, r3, #8
20002506:	f002 01ff 	and.w	r1, r2, #255	; 0xff
2000250a:	f04f 0000 	mov.w	r0, #0
2000250e:	ea40 0101 	orr.w	r1, r0, r1
20002512:	7299      	strb	r1, [r3, #10]
20002514:	ea4f 2112 	mov.w	r1, r2, lsr #8
20002518:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000251c:	f04f 0000 	mov.w	r0, #0
20002520:	ea40 0101 	orr.w	r1, r0, r1
20002524:	72d9      	strb	r1, [r3, #11]
20002526:	ea4f 4112 	mov.w	r1, r2, lsr #16
2000252a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000252e:	f04f 0000 	mov.w	r0, #0
20002532:	ea40 0101 	orr.w	r1, r0, r1
20002536:	7319      	strb	r1, [r3, #12]
20002538:	ea4f 6212 	mov.w	r2, r2, lsr #24
2000253c:	f04f 0100 	mov.w	r1, #0
20002540:	ea41 0202 	orr.w	r2, r1, r2
20002544:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
20002546:	f24d 131c 	movw	r3, #53532	; 0xd11c
2000254a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000254e:	6818      	ldr	r0, [r3, #0]
20002550:	f24d 1300 	movw	r3, #53504	; 0xd100
20002554:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002558:	781b      	ldrb	r3, [r3, #0]
2000255a:	4619      	mov	r1, r3
2000255c:	f24d 3348 	movw	r3, #54088	; 0xd348
20002560:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002564:	e9d3 2300 	ldrd	r2, r3, [r3]
20002568:	460b      	mov	r3, r1
2000256a:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000256e:	440b      	add	r3, r1
20002570:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002574:	440b      	add	r3, r1
20002576:	4403      	add	r3, r0
20002578:	f103 0308 	add.w	r3, r3, #8
2000257c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002580:	f04f 0000 	mov.w	r0, #0
20002584:	ea40 0101 	orr.w	r1, r0, r1
20002588:	7199      	strb	r1, [r3, #6]
2000258a:	ea4f 2112 	mov.w	r1, r2, lsr #8
2000258e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002592:	f04f 0000 	mov.w	r0, #0
20002596:	ea40 0101 	orr.w	r1, r0, r1
2000259a:	71d9      	strb	r1, [r3, #7]
2000259c:	ea4f 4112 	mov.w	r1, r2, lsr #16
200025a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200025a4:	f04f 0000 	mov.w	r0, #0
200025a8:	ea40 0101 	orr.w	r1, r0, r1
200025ac:	7219      	strb	r1, [r3, #8]
200025ae:	ea4f 6212 	mov.w	r2, r2, lsr #24
200025b2:	f04f 0100 	mov.w	r1, #0
200025b6:	ea41 0202 	orr.w	r2, r1, r2
200025ba:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = hk_status;
200025bc:	f24d 131c 	movw	r3, #53532	; 0xd11c
200025c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200025c4:	6818      	ldr	r0, [r3, #0]
200025c6:	f24d 1300 	movw	r3, #53504	; 0xd100
200025ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200025ce:	781b      	ldrb	r3, [r3, #0]
200025d0:	461a      	mov	r2, r3
200025d2:	f24d 3354 	movw	r3, #54100	; 0xd354
200025d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200025da:	8819      	ldrh	r1, [r3, #0]
200025dc:	4613      	mov	r3, r2
200025de:	ea4f 0383 	mov.w	r3, r3, lsl #2
200025e2:	4413      	add	r3, r2
200025e4:	ea4f 0343 	mov.w	r3, r3, lsl #1
200025e8:	4413      	add	r3, r2
200025ea:	4403      	add	r3, r0
200025ec:	f103 0310 	add.w	r3, r3, #16
200025f0:	f001 02ff 	and.w	r2, r1, #255	; 0xff
200025f4:	f04f 0000 	mov.w	r0, #0
200025f8:	ea40 0202 	orr.w	r2, r0, r2
200025fc:	71da      	strb	r2, [r3, #7]
200025fe:	ea4f 2211 	mov.w	r2, r1, lsr #8
20002602:	b292      	uxth	r2, r2
20002604:	f04f 0100 	mov.w	r1, #0
20002608:	ea41 0202 	orr.w	r2, r1, r2
2000260c:	721a      	strb	r2, [r3, #8]
	log_counter++;
2000260e:	f24d 1300 	movw	r3, #53504	; 0xd100
20002612:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002616:	781b      	ldrb	r3, [r3, #0]
20002618:	f103 0301 	add.w	r3, r3, #1
2000261c:	b2da      	uxtb	r2, r3
2000261e:	f24d 1300 	movw	r3, #53504	; 0xd100
20002622:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002626:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&hk_timer);
20002628:	f24d 309c 	movw	r0, #54172	; 0xd39c
2000262c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002630:	f007 f880 	bl	20009734 <TMR_clear_int>
}
20002634:	bd80      	pop	{r7, pc}
20002636:	bf00      	nop

20002638 <GMC_ISR>:

void GMC_ISR(){
20002638:	b580      	push	{r7, lr}
2000263a:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
2000263c:	f24d 3258 	movw	r2, #54104	; 0xd358
20002640:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002644:	f24d 3348 	movw	r3, #54088	; 0xd348
20002648:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000264c:	4610      	mov	r0, r2
2000264e:	4619      	mov	r1, r3
20002650:	f7ff fd8c 	bl	2000216c <MSS_TIM64_get_current_value>
	gmc_status = get_gmc();
20002654:	f7fe ff9e 	bl	20001594 <get_gmc>
20002658:	4603      	mov	r3, r0
2000265a:	461a      	mov	r2, r3
2000265c:	f24d 1332 	movw	r3, #53554	; 0xd132
20002660:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002664:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
20002666:	f24d 1300 	movw	r3, #53504	; 0xd100
2000266a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000266e:	781b      	ldrb	r3, [r3, #0]
20002670:	2b09      	cmp	r3, #9
20002672:	d901      	bls.n	20002678 <GMC_ISR+0x40>
		form_log_packet();
20002674:	f7ff fdec 	bl	20002250 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = GMC_TASK_ID;
20002678:	f24d 131c 	movw	r3, #53532	; 0xd11c
2000267c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002680:	6819      	ldr	r1, [r3, #0]
20002682:	f24d 1300 	movw	r3, #53504	; 0xd100
20002686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000268a:	781b      	ldrb	r3, [r3, #0]
2000268c:	461a      	mov	r2, r3
2000268e:	4613      	mov	r3, r2
20002690:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002694:	4413      	add	r3, r2
20002696:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000269a:	4413      	add	r3, r2
2000269c:	440b      	add	r3, r1
2000269e:	f103 0316 	add.w	r3, r3, #22
200026a2:	f04f 0206 	mov.w	r2, #6
200026a6:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
200026a8:	f24d 131c 	movw	r3, #53532	; 0xd11c
200026ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026b0:	6818      	ldr	r0, [r3, #0]
200026b2:	f24d 1300 	movw	r3, #53504	; 0xd100
200026b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026ba:	781b      	ldrb	r3, [r3, #0]
200026bc:	4619      	mov	r1, r3
200026be:	f24d 3358 	movw	r3, #54104	; 0xd358
200026c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026c6:	e9d3 2300 	ldrd	r2, r3, [r3]
200026ca:	460b      	mov	r3, r1
200026cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
200026d0:	440b      	add	r3, r1
200026d2:	ea4f 0343 	mov.w	r3, r3, lsl #1
200026d6:	440b      	add	r3, r1
200026d8:	4403      	add	r3, r0
200026da:	f103 0308 	add.w	r3, r3, #8
200026de:	f002 01ff 	and.w	r1, r2, #255	; 0xff
200026e2:	f04f 0000 	mov.w	r0, #0
200026e6:	ea40 0101 	orr.w	r1, r0, r1
200026ea:	7299      	strb	r1, [r3, #10]
200026ec:	ea4f 2112 	mov.w	r1, r2, lsr #8
200026f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200026f4:	f04f 0000 	mov.w	r0, #0
200026f8:	ea40 0101 	orr.w	r1, r0, r1
200026fc:	72d9      	strb	r1, [r3, #11]
200026fe:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002702:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002706:	f04f 0000 	mov.w	r0, #0
2000270a:	ea40 0101 	orr.w	r1, r0, r1
2000270e:	7319      	strb	r1, [r3, #12]
20002710:	ea4f 6212 	mov.w	r2, r2, lsr #24
20002714:	f04f 0100 	mov.w	r1, #0
20002718:	ea41 0202 	orr.w	r2, r1, r2
2000271c:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
2000271e:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002722:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002726:	6818      	ldr	r0, [r3, #0]
20002728:	f24d 1300 	movw	r3, #53504	; 0xd100
2000272c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002730:	781b      	ldrb	r3, [r3, #0]
20002732:	4619      	mov	r1, r3
20002734:	f24d 3348 	movw	r3, #54088	; 0xd348
20002738:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000273c:	e9d3 2300 	ldrd	r2, r3, [r3]
20002740:	460b      	mov	r3, r1
20002742:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002746:	440b      	add	r3, r1
20002748:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000274c:	440b      	add	r3, r1
2000274e:	4403      	add	r3, r0
20002750:	f103 0308 	add.w	r3, r3, #8
20002754:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002758:	f04f 0000 	mov.w	r0, #0
2000275c:	ea40 0101 	orr.w	r1, r0, r1
20002760:	7199      	strb	r1, [r3, #6]
20002762:	ea4f 2112 	mov.w	r1, r2, lsr #8
20002766:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000276a:	f04f 0000 	mov.w	r0, #0
2000276e:	ea40 0101 	orr.w	r1, r0, r1
20002772:	71d9      	strb	r1, [r3, #7]
20002774:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002778:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000277c:	f04f 0000 	mov.w	r0, #0
20002780:	ea40 0101 	orr.w	r1, r0, r1
20002784:	7219      	strb	r1, [r3, #8]
20002786:	ea4f 6212 	mov.w	r2, r2, lsr #24
2000278a:	f04f 0100 	mov.w	r1, #0
2000278e:	ea41 0202 	orr.w	r2, r1, r2
20002792:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = gmc_status;
20002794:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002798:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000279c:	6818      	ldr	r0, [r3, #0]
2000279e:	f24d 1300 	movw	r3, #53504	; 0xd100
200027a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027a6:	781b      	ldrb	r3, [r3, #0]
200027a8:	461a      	mov	r2, r3
200027aa:	f24d 1332 	movw	r3, #53554	; 0xd132
200027ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027b2:	8819      	ldrh	r1, [r3, #0]
200027b4:	4613      	mov	r3, r2
200027b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
200027ba:	4413      	add	r3, r2
200027bc:	ea4f 0343 	mov.w	r3, r3, lsl #1
200027c0:	4413      	add	r3, r2
200027c2:	4403      	add	r3, r0
200027c4:	f103 0310 	add.w	r3, r3, #16
200027c8:	f001 02ff 	and.w	r2, r1, #255	; 0xff
200027cc:	f04f 0000 	mov.w	r0, #0
200027d0:	ea40 0202 	orr.w	r2, r0, r2
200027d4:	71da      	strb	r2, [r3, #7]
200027d6:	ea4f 2211 	mov.w	r2, r1, lsr #8
200027da:	b292      	uxth	r2, r2
200027dc:	f04f 0100 	mov.w	r1, #0
200027e0:	ea41 0202 	orr.w	r2, r1, r2
200027e4:	721a      	strb	r2, [r3, #8]
	log_counter++;
200027e6:	f24d 1300 	movw	r3, #53504	; 0xd100
200027ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027ee:	781b      	ldrb	r3, [r3, #0]
200027f0:	f103 0301 	add.w	r3, r3, #1
200027f4:	b2da      	uxtb	r2, r3
200027f6:	f24d 1300 	movw	r3, #53504	; 0xd100
200027fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027fe:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&gmc_timer);
20002800:	f24d 3038 	movw	r0, #54072	; 0xd338
20002804:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002808:	f006 ff94 	bl	20009734 <TMR_clear_int>
}
2000280c:	bd80      	pop	{r7, pc}
2000280e:	bf00      	nop

20002810 <COMMS_ISR>:

void COMMS_ISR(){
20002810:	b580      	push	{r7, lr}
20002812:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
20002814:	f24d 3258 	movw	r2, #54104	; 0xd358
20002818:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000281c:	f24d 3348 	movw	r3, #54088	; 0xd348
20002820:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002824:	4610      	mov	r0, r2
20002826:	4619      	mov	r1, r3
20002828:	f7ff fca0 	bl	2000216c <MSS_TIM64_get_current_value>
	comms_status = get_comms();
2000282c:	f7ff f93c 	bl	20001aa8 <get_comms>
20002830:	4603      	mov	r3, r0
20002832:	461a      	mov	r2, r3
20002834:	f24d 33c0 	movw	r3, #54208	; 0xd3c0
20002838:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000283c:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
2000283e:	f24d 1300 	movw	r3, #53504	; 0xd100
20002842:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002846:	781b      	ldrb	r3, [r3, #0]
20002848:	2b09      	cmp	r3, #9
2000284a:	d901      	bls.n	20002850 <COMMS_ISR+0x40>
		form_log_packet();
2000284c:	f7ff fd00 	bl	20002250 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = COMMS_TASK_ID;
20002850:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002854:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002858:	6819      	ldr	r1, [r3, #0]
2000285a:	f24d 1300 	movw	r3, #53504	; 0xd100
2000285e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002862:	781b      	ldrb	r3, [r3, #0]
20002864:	461a      	mov	r2, r3
20002866:	4613      	mov	r3, r2
20002868:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000286c:	4413      	add	r3, r2
2000286e:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002872:	4413      	add	r3, r2
20002874:	440b      	add	r3, r1
20002876:	f103 0316 	add.w	r3, r3, #22
2000287a:	f04f 0204 	mov.w	r2, #4
2000287e:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
20002880:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002884:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002888:	6818      	ldr	r0, [r3, #0]
2000288a:	f24d 1300 	movw	r3, #53504	; 0xd100
2000288e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002892:	781b      	ldrb	r3, [r3, #0]
20002894:	4619      	mov	r1, r3
20002896:	f24d 3358 	movw	r3, #54104	; 0xd358
2000289a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000289e:	e9d3 2300 	ldrd	r2, r3, [r3]
200028a2:	460b      	mov	r3, r1
200028a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200028a8:	440b      	add	r3, r1
200028aa:	ea4f 0343 	mov.w	r3, r3, lsl #1
200028ae:	440b      	add	r3, r1
200028b0:	4403      	add	r3, r0
200028b2:	f103 0308 	add.w	r3, r3, #8
200028b6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
200028ba:	f04f 0000 	mov.w	r0, #0
200028be:	ea40 0101 	orr.w	r1, r0, r1
200028c2:	7299      	strb	r1, [r3, #10]
200028c4:	ea4f 2112 	mov.w	r1, r2, lsr #8
200028c8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200028cc:	f04f 0000 	mov.w	r0, #0
200028d0:	ea40 0101 	orr.w	r1, r0, r1
200028d4:	72d9      	strb	r1, [r3, #11]
200028d6:	ea4f 4112 	mov.w	r1, r2, lsr #16
200028da:	f001 01ff 	and.w	r1, r1, #255	; 0xff
200028de:	f04f 0000 	mov.w	r0, #0
200028e2:	ea40 0101 	orr.w	r1, r0, r1
200028e6:	7319      	strb	r1, [r3, #12]
200028e8:	ea4f 6212 	mov.w	r2, r2, lsr #24
200028ec:	f04f 0100 	mov.w	r1, #0
200028f0:	ea41 0202 	orr.w	r2, r1, r2
200028f4:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
200028f6:	f24d 131c 	movw	r3, #53532	; 0xd11c
200028fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200028fe:	6818      	ldr	r0, [r3, #0]
20002900:	f24d 1300 	movw	r3, #53504	; 0xd100
20002904:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002908:	781b      	ldrb	r3, [r3, #0]
2000290a:	4619      	mov	r1, r3
2000290c:	f24d 3348 	movw	r3, #54088	; 0xd348
20002910:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002914:	e9d3 2300 	ldrd	r2, r3, [r3]
20002918:	460b      	mov	r3, r1
2000291a:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000291e:	440b      	add	r3, r1
20002920:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002924:	440b      	add	r3, r1
20002926:	4403      	add	r3, r0
20002928:	f103 0308 	add.w	r3, r3, #8
2000292c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002930:	f04f 0000 	mov.w	r0, #0
20002934:	ea40 0101 	orr.w	r1, r0, r1
20002938:	7199      	strb	r1, [r3, #6]
2000293a:	ea4f 2112 	mov.w	r1, r2, lsr #8
2000293e:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002942:	f04f 0000 	mov.w	r0, #0
20002946:	ea40 0101 	orr.w	r1, r0, r1
2000294a:	71d9      	strb	r1, [r3, #7]
2000294c:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002950:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002954:	f04f 0000 	mov.w	r0, #0
20002958:	ea40 0101 	orr.w	r1, r0, r1
2000295c:	7219      	strb	r1, [r3, #8]
2000295e:	ea4f 6212 	mov.w	r2, r2, lsr #24
20002962:	f04f 0100 	mov.w	r1, #0
20002966:	ea41 0202 	orr.w	r2, r1, r2
2000296a:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = comms_status;
2000296c:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002970:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002974:	6818      	ldr	r0, [r3, #0]
20002976:	f24d 1300 	movw	r3, #53504	; 0xd100
2000297a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000297e:	781b      	ldrb	r3, [r3, #0]
20002980:	461a      	mov	r2, r3
20002982:	f24d 33c0 	movw	r3, #54208	; 0xd3c0
20002986:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000298a:	8819      	ldrh	r1, [r3, #0]
2000298c:	4613      	mov	r3, r2
2000298e:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002992:	4413      	add	r3, r2
20002994:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002998:	4413      	add	r3, r2
2000299a:	4403      	add	r3, r0
2000299c:	f103 0310 	add.w	r3, r3, #16
200029a0:	f001 02ff 	and.w	r2, r1, #255	; 0xff
200029a4:	f04f 0000 	mov.w	r0, #0
200029a8:	ea40 0202 	orr.w	r2, r0, r2
200029ac:	71da      	strb	r2, [r3, #7]
200029ae:	ea4f 2211 	mov.w	r2, r1, lsr #8
200029b2:	b292      	uxth	r2, r2
200029b4:	f04f 0100 	mov.w	r1, #0
200029b8:	ea41 0202 	orr.w	r2, r1, r2
200029bc:	721a      	strb	r2, [r3, #8]
	log_counter++;
200029be:	f24d 1300 	movw	r3, #53504	; 0xd100
200029c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029c6:	781b      	ldrb	r3, [r3, #0]
200029c8:	f103 0301 	add.w	r3, r3, #1
200029cc:	b2da      	uxtb	r2, r3
200029ce:	f24d 1300 	movw	r3, #53504	; 0xd100
200029d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029d6:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&comms_timer);
200029d8:	f24d 1014 	movw	r0, #53524	; 0xd114
200029dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200029e0:	f006 fea8 	bl	20009734 <TMR_clear_int>
}
200029e4:	bd80      	pop	{r7, pc}
200029e6:	bf00      	nop

200029e8 <THER_ISR>:

void THER_ISR(){
200029e8:	b580      	push	{r7, lr}
200029ea:	af00      	add	r7, sp, #0
	MSS_TIM64_get_current_value(&current_time_upper,&current_time_lower);
200029ec:	f24d 3258 	movw	r2, #54104	; 0xd358
200029f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
200029f4:	f24d 3348 	movw	r3, #54088	; 0xd348
200029f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029fc:	4610      	mov	r0, r2
200029fe:	4619      	mov	r1, r3
20002a00:	f7ff fbb4 	bl	2000216c <MSS_TIM64_get_current_value>
	therm_status =  get_temp();
20002a04:	f7fe fbfc 	bl	20001200 <get_temp>
20002a08:	4603      	mov	r3, r0
20002a0a:	461a      	mov	r2, r3
20002a0c:	f24d 1318 	movw	r3, #53528	; 0xd118
20002a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a14:	801a      	strh	r2, [r3, #0]
	if(log_counter >= 10) {
20002a16:	f24d 1300 	movw	r3, #53504	; 0xd100
20002a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a1e:	781b      	ldrb	r3, [r3, #0]
20002a20:	2b09      	cmp	r3, #9
20002a22:	d901      	bls.n	20002a28 <THER_ISR+0x40>
		form_log_packet();
20002a24:	f7ff fc14 	bl	20002250 <form_log_packet>
	}
	log_packet_ptr->logs[log_counter].task_id = THERMISTOR_TASK_ID;
20002a28:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002a2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a30:	6819      	ldr	r1, [r3, #0]
20002a32:	f24d 1300 	movw	r3, #53504	; 0xd100
20002a36:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a3a:	781b      	ldrb	r3, [r3, #0]
20002a3c:	461a      	mov	r2, r3
20002a3e:	4613      	mov	r3, r2
20002a40:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002a44:	4413      	add	r3, r2
20002a46:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002a4a:	4413      	add	r3, r2
20002a4c:	440b      	add	r3, r1
20002a4e:	f103 0316 	add.w	r3, r3, #22
20002a52:	f04f 0201 	mov.w	r2, #1
20002a56:	701a      	strb	r2, [r3, #0]
	log_packet_ptr->logs[log_counter].time_H = current_time_upper;
20002a58:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002a5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a60:	6818      	ldr	r0, [r3, #0]
20002a62:	f24d 1300 	movw	r3, #53504	; 0xd100
20002a66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a6a:	781b      	ldrb	r3, [r3, #0]
20002a6c:	4619      	mov	r1, r3
20002a6e:	f24d 3358 	movw	r3, #54104	; 0xd358
20002a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a76:	e9d3 2300 	ldrd	r2, r3, [r3]
20002a7a:	460b      	mov	r3, r1
20002a7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002a80:	440b      	add	r3, r1
20002a82:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002a86:	440b      	add	r3, r1
20002a88:	4403      	add	r3, r0
20002a8a:	f103 0308 	add.w	r3, r3, #8
20002a8e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002a92:	f04f 0000 	mov.w	r0, #0
20002a96:	ea40 0101 	orr.w	r1, r0, r1
20002a9a:	7299      	strb	r1, [r3, #10]
20002a9c:	ea4f 2112 	mov.w	r1, r2, lsr #8
20002aa0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002aa4:	f04f 0000 	mov.w	r0, #0
20002aa8:	ea40 0101 	orr.w	r1, r0, r1
20002aac:	72d9      	strb	r1, [r3, #11]
20002aae:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002ab2:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002ab6:	f04f 0000 	mov.w	r0, #0
20002aba:	ea40 0101 	orr.w	r1, r0, r1
20002abe:	7319      	strb	r1, [r3, #12]
20002ac0:	ea4f 6212 	mov.w	r2, r2, lsr #24
20002ac4:	f04f 0100 	mov.w	r1, #0
20002ac8:	ea41 0202 	orr.w	r2, r1, r2
20002acc:	735a      	strb	r2, [r3, #13]
	log_packet_ptr->logs[log_counter].time_L = current_time_lower;
20002ace:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ad6:	6818      	ldr	r0, [r3, #0]
20002ad8:	f24d 1300 	movw	r3, #53504	; 0xd100
20002adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ae0:	781b      	ldrb	r3, [r3, #0]
20002ae2:	4619      	mov	r1, r3
20002ae4:	f24d 3348 	movw	r3, #54088	; 0xd348
20002ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002aec:	e9d3 2300 	ldrd	r2, r3, [r3]
20002af0:	460b      	mov	r3, r1
20002af2:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002af6:	440b      	add	r3, r1
20002af8:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002afc:	440b      	add	r3, r1
20002afe:	4403      	add	r3, r0
20002b00:	f103 0308 	add.w	r3, r3, #8
20002b04:	f002 01ff 	and.w	r1, r2, #255	; 0xff
20002b08:	f04f 0000 	mov.w	r0, #0
20002b0c:	ea40 0101 	orr.w	r1, r0, r1
20002b10:	7199      	strb	r1, [r3, #6]
20002b12:	ea4f 2112 	mov.w	r1, r2, lsr #8
20002b16:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002b1a:	f04f 0000 	mov.w	r0, #0
20002b1e:	ea40 0101 	orr.w	r1, r0, r1
20002b22:	71d9      	strb	r1, [r3, #7]
20002b24:	ea4f 4112 	mov.w	r1, r2, lsr #16
20002b28:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20002b2c:	f04f 0000 	mov.w	r0, #0
20002b30:	ea40 0101 	orr.w	r1, r0, r1
20002b34:	7219      	strb	r1, [r3, #8]
20002b36:	ea4f 6212 	mov.w	r2, r2, lsr #24
20002b3a:	f04f 0100 	mov.w	r1, #0
20002b3e:	ea41 0202 	orr.w	r2, r1, r2
20002b42:	725a      	strb	r2, [r3, #9]
	log_packet_ptr->logs[log_counter].task_status = therm_status;
20002b44:	f24d 131c 	movw	r3, #53532	; 0xd11c
20002b48:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b4c:	6818      	ldr	r0, [r3, #0]
20002b4e:	f24d 1300 	movw	r3, #53504	; 0xd100
20002b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b56:	781b      	ldrb	r3, [r3, #0]
20002b58:	461a      	mov	r2, r3
20002b5a:	f24d 1318 	movw	r3, #53528	; 0xd118
20002b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b62:	8819      	ldrh	r1, [r3, #0]
20002b64:	4613      	mov	r3, r2
20002b66:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002b6a:	4413      	add	r3, r2
20002b6c:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002b70:	4413      	add	r3, r2
20002b72:	4403      	add	r3, r0
20002b74:	f103 0310 	add.w	r3, r3, #16
20002b78:	f001 02ff 	and.w	r2, r1, #255	; 0xff
20002b7c:	f04f 0000 	mov.w	r0, #0
20002b80:	ea40 0202 	orr.w	r2, r0, r2
20002b84:	71da      	strb	r2, [r3, #7]
20002b86:	ea4f 2211 	mov.w	r2, r1, lsr #8
20002b8a:	b292      	uxth	r2, r2
20002b8c:	f04f 0100 	mov.w	r1, #0
20002b90:	ea41 0202 	orr.w	r2, r1, r2
20002b94:	721a      	strb	r2, [r3, #8]
	log_counter++;
20002b96:	f24d 1300 	movw	r3, #53504	; 0xd100
20002b9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b9e:	781b      	ldrb	r3, [r3, #0]
20002ba0:	f103 0301 	add.w	r3, r3, #1
20002ba4:	b2da      	uxtb	r2, r3
20002ba6:	f24d 1300 	movw	r3, #53504	; 0xd100
20002baa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002bae:	701a      	strb	r2, [r3, #0]
	TMR_clear_int(&temp_timer);
20002bb0:	f24d 3040 	movw	r0, #54080	; 0xd340
20002bb4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002bb8:	f006 fdbc 	bl	20009734 <TMR_clear_int>
}
20002bbc:	bd80      	pop	{r7, pc}
20002bbe:	bf00      	nop

20002bc0 <SD_ISR>:

void SD_ISR(){
20002bc0:	b580      	push	{r7, lr}
20002bc2:	af00      	add	r7, sp, #0
	get_sd_data();
20002bc4:	f7fe fccc 	bl	20001560 <get_sd_data>
	if(hk_partition.read_pointer < hk_partition.write_pointer && store_in_sd_card == 0){
20002bc8:	f24d 338c 	movw	r3, #54156	; 0xd38c
20002bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002bd0:	689a      	ldr	r2, [r3, #8]
20002bd2:	f24d 338c 	movw	r3, #54156	; 0xd38c
20002bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002bda:	68db      	ldr	r3, [r3, #12]
20002bdc:	429a      	cmp	r2, r3
20002bde:	d208      	bcs.n	20002bf2 <SD_ISR+0x32>
20002be0:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20002be4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002be8:	781b      	ldrb	r3, [r3, #0]
20002bea:	2b00      	cmp	r3, #0
20002bec:	d101      	bne.n	20002bf2 <SD_ISR+0x32>
		get_sd_data();
20002bee:	f7fe fcb7 	bl	20001560 <get_sd_data>
	}

	TMR_clear_int(&sd_timer);
20002bf2:	f24d 3050 	movw	r0, #54096	; 0xd350
20002bf6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002bfa:	f006 fd9b 	bl	20009734 <TMR_clear_int>
}
20002bfe:	bd80      	pop	{r7, pc}

20002c00 <timer_intr_set>:

void timer_intr_set(){
20002c00:	b580      	push	{r7, lr}
20002c02:	b082      	sub	sp, #8
20002c04:	af02      	add	r7, sp, #8
	TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, HK_PKT_PERIOD);
20002c06:	f645 735e 	movw	r3, #24414	; 0x5f5e
20002c0a:	9300      	str	r3, [sp, #0]
20002c0c:	f24d 309c 	movw	r0, #54172	; 0xd39c
20002c10:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c14:	f246 0100 	movw	r1, #24576	; 0x6000
20002c18:	f2c5 0100 	movt	r1, #20480	; 0x5000
20002c1c:	f04f 0200 	mov.w	r2, #0
20002c20:	f04f 0309 	mov.w	r3, #9
20002c24:	f006 fcc4 	bl	200095b0 <TMR_init>
	TMR_enable_int(&hk_timer);
20002c28:	f24d 309c 	movw	r0, #54172	; 0xd39c
20002c2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c30:	f006 fd62 	bl	200096f8 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq4_IRQn);
20002c34:	f04f 0026 	mov.w	r0, #38	; 0x26
20002c38:	f7ff f9b2 	bl	20001fa0 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq4_IRQn, 254);
20002c3c:	f04f 0026 	mov.w	r0, #38	; 0x26
20002c40:	f04f 01fe 	mov.w	r1, #254	; 0xfe
20002c44:	f7ff fa04 	bl	20002050 <NVIC_SetPriority>

	TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, COMMS_PKT_PERIOD);
20002c48:	f649 0396 	movw	r3, #39062	; 0x9896
20002c4c:	9300      	str	r3, [sp, #0]
20002c4e:	f24d 1014 	movw	r0, #53524	; 0xd114
20002c52:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c56:	f247 0100 	movw	r1, #28672	; 0x7000
20002c5a:	f2c5 0100 	movt	r1, #20480	; 0x5000
20002c5e:	f04f 0200 	mov.w	r2, #0
20002c62:	f04f 0309 	mov.w	r3, #9
20002c66:	f006 fca3 	bl	200095b0 <TMR_init>
	TMR_enable_int(&comms_timer);
20002c6a:	f24d 1014 	movw	r0, #53524	; 0xd114
20002c6e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c72:	f006 fd41 	bl	200096f8 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq5_IRQn);
20002c76:	f04f 0027 	mov.w	r0, #39	; 0x27
20002c7a:	f7ff f991 	bl	20001fa0 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq5_IRQn, 254);
20002c7e:	f04f 0027 	mov.w	r0, #39	; 0x27
20002c82:	f04f 01fe 	mov.w	r1, #254	; 0xfe
20002c86:	f7ff f9e3 	bl	20002050 <NVIC_SetPriority>


	TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, TEMP_PKT_PERIOD);
20002c8a:	f64b 63bc 	movw	r3, #48828	; 0xbebc
20002c8e:	9300      	str	r3, [sp, #0]
20002c90:	f24d 3040 	movw	r0, #54080	; 0xd340
20002c94:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c98:	f248 0100 	movw	r1, #32768	; 0x8000
20002c9c:	f2c5 0100 	movt	r1, #20480	; 0x5000
20002ca0:	f04f 0200 	mov.w	r2, #0
20002ca4:	f04f 0309 	mov.w	r3, #9
20002ca8:	f006 fc82 	bl	200095b0 <TMR_init>
	TMR_enable_int(&temp_timer);
20002cac:	f24d 3040 	movw	r0, #54080	; 0xd340
20002cb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002cb4:	f006 fd20 	bl	200096f8 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq6_IRQn);
20002cb8:	f04f 0028 	mov.w	r0, #40	; 0x28
20002cbc:	f7ff f970 	bl	20001fa0 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq6_IRQn, 254);
20002cc0:	f04f 0028 	mov.w	r0, #40	; 0x28
20002cc4:	f04f 01fe 	mov.w	r1, #254	; 0xfe
20002cc8:	f7ff f9c2 	bl	20002050 <NVIC_SetPriority>

	TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, SD_PKT_PERIOD);
20002ccc:	f247 3358 	movw	r3, #29528	; 0x7358
20002cd0:	f2c0 0307 	movt	r3, #7
20002cd4:	9300      	str	r3, [sp, #0]
20002cd6:	f24d 3050 	movw	r0, #54096	; 0xd350
20002cda:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002cde:	f249 0100 	movw	r1, #36864	; 0x9000
20002ce2:	f2c5 0100 	movt	r1, #20480	; 0x5000
20002ce6:	f04f 0200 	mov.w	r2, #0
20002cea:	f04f 0309 	mov.w	r3, #9
20002cee:	f006 fc5f 	bl	200095b0 <TMR_init>
	TMR_enable_int(&sd_timer);
20002cf2:	f24d 3050 	movw	r0, #54096	; 0xd350
20002cf6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002cfa:	f006 fcfd 	bl	200096f8 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq7_IRQn);
20002cfe:	f04f 0029 	mov.w	r0, #41	; 0x29
20002d02:	f7ff f94d 	bl	20001fa0 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq7_IRQn, 254);
20002d06:	f04f 0029 	mov.w	r0, #41	; 0x29
20002d0a:	f04f 01fe 	mov.w	r1, #254	; 0xfe
20002d0e:	f7ff f99f 	bl	20002050 <NVIC_SetPriority>

	TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, GMC_PKT_PERIOD);
20002d12:	f645 735e 	movw	r3, #24414	; 0x5f5e
20002d16:	9300      	str	r3, [sp, #0]
20002d18:	f24d 3038 	movw	r0, #54072	; 0xd338
20002d1c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002d20:	f24a 0100 	movw	r1, #40960	; 0xa000
20002d24:	f2c5 0100 	movt	r1, #20480	; 0x5000
20002d28:	f04f 0200 	mov.w	r2, #0
20002d2c:	f04f 0309 	mov.w	r3, #9
20002d30:	f006 fc3e 	bl	200095b0 <TMR_init>
	TMR_enable_int(&gmc_timer);
20002d34:	f24d 3038 	movw	r0, #54072	; 0xd338
20002d38:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002d3c:	f006 fcdc 	bl	200096f8 <TMR_enable_int>
	NVIC_EnableIRQ( FabricIrq8_IRQn);
20002d40:	f04f 002a 	mov.w	r0, #42	; 0x2a
20002d44:	f7ff f92c 	bl	20001fa0 <NVIC_EnableIRQ>
	NVIC_SetPriority(FabricIrq8_IRQn, 254);
20002d48:	f04f 002a 	mov.w	r0, #42	; 0x2a
20002d4c:	f04f 01fe 	mov.w	r1, #254	; 0xfe
20002d50:	f7ff f97e 	bl	20002050 <NVIC_SetPriority>

	TMR_start(&hk_timer);
20002d54:	f24d 309c 	movw	r0, #54172	; 0xd39c
20002d58:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002d5c:	f006 fc90 	bl	20009680 <TMR_start>
	TMR_start(&comms_timer);
20002d60:	f24d 1014 	movw	r0, #53524	; 0xd114
20002d64:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002d68:	f006 fc8a 	bl	20009680 <TMR_start>
//	TMR_start(&temp_timer);
//	TMR_start(&sd_timer);
//	TMR_start(&gmc_timer);
}
20002d6c:	46bd      	mov	sp, r7
20002d6e:	bd80      	pop	{r7, pc}

20002d70 <get_cmd>:
void timer_ena(){
//	NVIC_EnableIRQ(FabricIrq4_IRQn);
	NVIC_EnableIRQ(FabricIrq5_IRQn);
}

void get_cmd(uint8_t* cmd, uint8_t src){
20002d70:	b580      	push	{r7, lr}
20002d72:	b082      	sub	sp, #8
20002d74:	af00      	add	r7, sp, #0
20002d76:	6078      	str	r0, [r7, #4]
20002d78:	460b      	mov	r3, r1
20002d7a:	70fb      	strb	r3, [r7, #3]

	rx_cmd_pkt = (rx_cmd_t*) cmd;
20002d7c:	687a      	ldr	r2, [r7, #4]
20002d7e:	f24d 3360 	movw	r3, #54112	; 0xd360
20002d82:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d86:	601a      	str	r2, [r3, #0]

	if(cmd_valid(rx_cmd_pkt, src)){
20002d88:	f24d 3360 	movw	r3, #54112	; 0xd360
20002d8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d90:	681a      	ldr	r2, [r3, #0]
20002d92:	78fb      	ldrb	r3, [r7, #3]
20002d94:	4610      	mov	r0, r2
20002d96:	4619      	mov	r1, r3
20002d98:	f000 fb90 	bl	200034bc <cmd_valid>
20002d9c:	4603      	mov	r3, r0
20002d9e:	2b00      	cmp	r3, #0
20002da0:	d026      	beq.n	20002df0 <get_cmd+0x80>
		cmd_engine(rx_cmd_pkt);
20002da2:	f24d 3360 	movw	r3, #54112	; 0xd360
20002da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002daa:	681b      	ldr	r3, [r3, #0]
20002dac:	4618      	mov	r0, r3
20002dae:	f000 fc01 	bl	200035b4 <cmd_engine>
		if(src == 0){
20002db2:	78fb      	ldrb	r3, [r7, #3]
20002db4:	2b00      	cmp	r3, #0
20002db6:	d10d      	bne.n	20002dd4 <get_cmd+0x64>
			cmd_rs485_succ_count++;
20002db8:	f24c 23e9 	movw	r3, #49897	; 0xc2e9
20002dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002dc0:	781b      	ldrb	r3, [r3, #0]
20002dc2:	f103 0301 	add.w	r3, r3, #1
20002dc6:	b2da      	uxtb	r2, r3
20002dc8:	f24c 23e9 	movw	r3, #49897	; 0xc2e9
20002dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002dd0:	701a      	strb	r2, [r3, #0]
		}
		else{
			cmd_succ_count++;
20002dd2:	e02b      	b.n	20002e2c <get_cmd+0xbc>
20002dd4:	f24c 23e7 	movw	r3, #49895	; 0xc2e7
20002dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ddc:	781b      	ldrb	r3, [r3, #0]
20002dde:	f103 0301 	add.w	r3, r3, #1
20002de2:	b2da      	uxtb	r2, r3
20002de4:	f24c 23e7 	movw	r3, #49895	; 0xc2e7
20002de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002dec:	701a      	strb	r2, [r3, #0]
20002dee:	e01d      	b.n	20002e2c <get_cmd+0xbc>
		}


	}
	else{
		if(src == 0){
20002df0:	78fb      	ldrb	r3, [r7, #3]
20002df2:	2b00      	cmp	r3, #0
20002df4:	d10d      	bne.n	20002e12 <get_cmd+0xa2>
			cmd_rs485_fail_count++;
20002df6:	f24c 23ea 	movw	r3, #49898	; 0xc2ea
20002dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002dfe:	781b      	ldrb	r3, [r3, #0]
20002e00:	f103 0301 	add.w	r3, r3, #1
20002e04:	b2da      	uxtb	r2, r3
20002e06:	f24c 23ea 	movw	r3, #49898	; 0xc2ea
20002e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e0e:	701a      	strb	r2, [r3, #0]
20002e10:	e00c      	b.n	20002e2c <get_cmd+0xbc>
		}
		else{
			cmd_reject_count++;
20002e12:	f24c 23e8 	movw	r3, #49896	; 0xc2e8
20002e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e1a:	781b      	ldrb	r3, [r3, #0]
20002e1c:	f103 0301 	add.w	r3, r3, #1
20002e20:	b2da      	uxtb	r2, r3
20002e22:	f24c 23e8 	movw	r3, #49896	; 0xc2e8
20002e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e2a:	701a      	strb	r2, [r3, #0]
		}

	}
}
20002e2c:	f107 0708 	add.w	r7, r7, #8
20002e30:	46bd      	mov	sp, r7
20002e32:	bd80      	pop	{r7, pc}

20002e34 <init_cmd_engine>:

void init_cmd_engine(){
20002e34:	b580      	push	{r7, lr}
20002e36:	af00      	add	r7, sp, #0
	add_cmd(0, 2, cmd_noop);
20002e38:	f243 6305 	movw	r3, #13829	; 0x3605
20002e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e40:	f04f 0000 	mov.w	r0, #0
20002e44:	f04f 0102 	mov.w	r1, #2
20002e48:	461a      	mov	r2, r3
20002e4a:	f000 fb55 	bl	200034f8 <add_cmd>
	add_cmd(1, 3, set_pkt_rate);
20002e4e:	f243 6319 	movw	r3, #13849	; 0x3619
20002e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e56:	f04f 0001 	mov.w	r0, #1
20002e5a:	f04f 0103 	mov.w	r1, #3
20002e5e:	461a      	mov	r2, r3
20002e60:	f000 fb4a 	bl	200034f8 <add_cmd>
	add_cmd(2, 3, exe_iap);
20002e64:	f643 0331 	movw	r3, #14385	; 0x3831
20002e68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e6c:	f04f 0002 	mov.w	r0, #2
20002e70:	f04f 0103 	mov.w	r1, #3
20002e74:	461a      	mov	r2, r3
20002e76:	f000 fb3f 	bl	200034f8 <add_cmd>
	add_cmd(3, 6, read_adf_reg);
20002e7a:	f643 13f9 	movw	r3, #14841	; 0x39f9
20002e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e82:	f04f 0003 	mov.w	r0, #3
20002e86:	f04f 0106 	mov.w	r1, #6
20002e8a:	461a      	mov	r2, r3
20002e8c:	f000 fb34 	bl	200034f8 <add_cmd>
	add_cmd(4, 16, exe_rtm);
20002e90:	f643 23f9 	movw	r3, #15097	; 0x3af9
20002e94:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e98:	f04f 0004 	mov.w	r0, #4
20002e9c:	f04f 0110 	mov.w	r1, #16
20002ea0:	461a      	mov	r2, r3
20002ea2:	f000 fb29 	bl	200034f8 <add_cmd>
}
20002ea6:	bd80      	pop	{r7, pc}

20002ea8 <Tim64_init>:

//Function to initialise 64 bit timer
void Tim64_init() {
20002ea8:	b580      	push	{r7, lr}
20002eaa:	af00      	add	r7, sp, #0
	MSS_TIM64_init(MSS_TIMER_ONE_SHOT_MODE);
20002eac:	f04f 0001 	mov.w	r0, #1
20002eb0:	f7ff f8fc 	bl	200020ac <MSS_TIM64_init>
	MSS_TIM64_load_immediate(0xFFFFFFFF,0xFFFFFFFF);
20002eb4:	f04f 30ff 	mov.w	r0, #4294967295
20002eb8:	f04f 31ff 	mov.w	r1, #4294967295
20002ebc:	f7ff f96e 	bl	2000219c <MSS_TIM64_load_immediate>
	MSS_TIM64_start();
20002ec0:	f7ff f946 	bl	20002150 <MSS_TIM64_start>
}
20002ec4:	bd80      	pop	{r7, pc}
20002ec6:	bf00      	nop

20002ec8 <get_init>:

void get_init(){
20002ec8:	b590      	push	{r4, r7, lr}
20002eca:	b083      	sub	sp, #12
20002ecc:	af00      	add	r7, sp, #0
	init_pkt = (init_packet_t* )data;
20002ece:	f24c 52b8 	movw	r2, #50616	; 0xc5b8
20002ed2:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002ed6:	f24d 1334 	movw	r3, #53556	; 0xd134
20002eda:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ede:	601a      	str	r2, [r3, #0]
	init_pkt->Status_1 = stat1;
20002ee0:	f24d 1334 	movw	r3, #53556	; 0xd134
20002ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ee8:	681a      	ldr	r2, [r3, #0]
20002eea:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
20002eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ef2:	781b      	ldrb	r3, [r3, #0]
20002ef4:	73d3      	strb	r3, [r2, #15]
	init_pkt->Adf_init_status = adf_status;
20002ef6:	f24d 1334 	movw	r3, #53556	; 0xd134
20002efa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002efe:	681a      	ldr	r2, [r3, #0]
20002f00:	f24c 23f2 	movw	r3, #49906	; 0xc2f2
20002f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f08:	781b      	ldrb	r3, [r3, #0]
20002f0a:	7413      	strb	r3, [r2, #16]
	init_pkt->status_2 = stat2;
20002f0c:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f14:	681a      	ldr	r2, [r3, #0]
20002f16:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20002f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f1e:	781b      	ldrb	r3, [r3, #0]
20002f20:	7453      	strb	r3, [r2, #17]
	init_pkt->ccsds_p1 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p1(tlm_pkt_type, INIT_API_ID))));
20002f22:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f2a:	681b      	ldr	r3, [r3, #0]
20002f2c:	f04f 0200 	mov.w	r2, #0
20002f30:	f042 0208 	orr.w	r2, r2, #8
20002f34:	701a      	strb	r2, [r3, #0]
20002f36:	f04f 0200 	mov.w	r2, #0
20002f3a:	f042 0205 	orr.w	r2, r2, #5
20002f3e:	705a      	strb	r2, [r3, #1]
	init_pkt->ccsds_p2 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p2((0)))));
20002f40:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f44:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f48:	681a      	ldr	r2, [r3, #0]
20002f4a:	f04f 0300 	mov.w	r3, #0
20002f4e:	ea6f 6383 	mvn.w	r3, r3, lsl #26
20002f52:	ea6f 6393 	mvn.w	r3, r3, lsr #26
20002f56:	7093      	strb	r3, [r2, #2]
20002f58:	f04f 0300 	mov.w	r3, #0
20002f5c:	70d3      	strb	r3, [r2, #3]
	init_pkt->ccsds_p3 = PILOT_REVERSE_BYTE_ORDER(((ccsds_p3(INIT_PKT_LENGTH))));
20002f5e:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f62:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f66:	681b      	ldr	r3, [r3, #0]
20002f68:	f04f 0200 	mov.w	r2, #0
20002f6c:	711a      	strb	r2, [r3, #4]
20002f6e:	f04f 0200 	mov.w	r2, #0
20002f72:	f042 0234 	orr.w	r2, r2, #52	; 0x34
20002f76:	715a      	strb	r2, [r3, #5]
	init_pkt->ccsds_s1 = 0;
20002f78:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f80:	681b      	ldr	r3, [r3, #0]
20002f82:	f04f 0200 	mov.w	r2, #0
20002f86:	719a      	strb	r2, [r3, #6]
20002f88:	f04f 0200 	mov.w	r2, #0
20002f8c:	71da      	strb	r2, [r3, #7]
20002f8e:	f04f 0200 	mov.w	r2, #0
20002f92:	721a      	strb	r2, [r3, #8]
20002f94:	f04f 0200 	mov.w	r2, #0
20002f98:	725a      	strb	r2, [r3, #9]
	init_pkt->ccsds_s2 = 0;
20002f9a:	f24d 1334 	movw	r3, #53556	; 0xd134
20002f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fa2:	681b      	ldr	r3, [r3, #0]
20002fa4:	f04f 0200 	mov.w	r2, #0
20002fa8:	729a      	strb	r2, [r3, #10]
20002faa:	f04f 0200 	mov.w	r2, #0
20002fae:	72da      	strb	r2, [r3, #11]
20002fb0:	f04f 0200 	mov.w	r2, #0
20002fb4:	731a      	strb	r2, [r3, #12]
20002fb6:	f04f 0200 	mov.w	r2, #0
20002fba:	735a      	strb	r2, [r3, #13]

	uint8_t i = 0;
20002fbc:	f04f 0300 	mov.w	r3, #0
20002fc0:	71fb      	strb	r3, [r7, #7]

	get_time_vector(Time_Vector);
20002fc2:	f24d 30a0 	movw	r0, #54176	; 0xd3a0
20002fc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002fca:	f000 fe75 	bl	20003cb8 <get_time_vector>
	for(;i<32;i++){
20002fce:	e012      	b.n	20002ff6 <get_init+0x12e>
		init_pkt->GTime_SVector[i] = Time_Vector[i];
20002fd0:	f24d 1334 	movw	r3, #53556	; 0xd134
20002fd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fd8:	6819      	ldr	r1, [r3, #0]
20002fda:	79f8      	ldrb	r0, [r7, #7]
20002fdc:	79fa      	ldrb	r2, [r7, #7]
20002fde:	f24d 33a0 	movw	r3, #54176	; 0xd3a0
20002fe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fe6:	5c9a      	ldrb	r2, [r3, r2]
20002fe8:	eb00 0301 	add.w	r3, r0, r1
20002fec:	749a      	strb	r2, [r3, #18]
	init_pkt->ccsds_s2 = 0;

	uint8_t i = 0;

	get_time_vector(Time_Vector);
	for(;i<32;i++){
20002fee:	79fb      	ldrb	r3, [r7, #7]
20002ff0:	f103 0301 	add.w	r3, r3, #1
20002ff4:	71fb      	strb	r3, [r7, #7]
20002ff6:	79fb      	ldrb	r3, [r7, #7]
20002ff8:	2b1f      	cmp	r3, #31
20002ffa:	d9e9      	bls.n	20002fd0 <get_init+0x108>
		init_pkt->GTime_SVector[i] = Time_Vector[i];
	}
	init_pkt->Fletcher_Code = make_FLetcher(data, sizeof(init_packet_t) - 2);
20002ffc:	f24d 1334 	movw	r3, #53556	; 0xd134
20003000:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003004:	681c      	ldr	r4, [r3, #0]
20003006:	f24c 50b8 	movw	r0, #50616	; 0xc5b8
2000300a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000300e:	f04f 0132 	mov.w	r1, #50	; 0x32
20003012:	f7fd fb69 	bl	200006e8 <make_FLetcher>
20003016:	4603      	mov	r3, r0
20003018:	f003 02ff 	and.w	r2, r3, #255	; 0xff
2000301c:	f04f 0100 	mov.w	r1, #0
20003020:	ea41 0202 	orr.w	r2, r1, r2
20003024:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
20003028:	ea4f 2313 	mov.w	r3, r3, lsr #8
2000302c:	b29b      	uxth	r3, r3
2000302e:	f04f 0200 	mov.w	r2, #0
20003032:	ea42 0303 	orr.w	r3, r2, r3
20003036:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33


//	vGetPktStruct(init, (void*) init_pkt, sizeof(init_packet_t));
	MSS_UART_polled_tx(&g_mss_uart0, data, sizeof(init_packet_t));
2000303a:	f24d 4040 	movw	r0, #54336	; 0xd440
2000303e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003042:	f24c 51b8 	movw	r1, #50616	; 0xc5b8
20003046:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000304a:	f04f 0234 	mov.w	r2, #52	; 0x34
2000304e:	f003 f989 	bl	20006364 <MSS_UART_polled_tx>

}
20003052:	f107 070c 	add.w	r7, r7, #12
20003056:	46bd      	mov	sp, r7
20003058:	bd90      	pop	{r4, r7, pc}
2000305a:	bf00      	nop

2000305c <main>:

int main(){
2000305c:	b580      	push	{r7, lr}
2000305e:	b08c      	sub	sp, #48	; 0x30
20003060:	af02      	add	r7, sp, #8
//adf_init
	//gmc_init
	//sd_init
	//pslv_interface_init
	//interface_init
	MSS_WD_init();
20003062:	f7ff f8b1 	bl	200021c8 <MSS_WD_init>
	MSS_WD_reload();
20003066:	f7ff f8e5 	bl	20002234 <MSS_WD_reload>
	p1_init();
2000306a:	f7fd fa95 	bl	20000598 <p1_init>
	MSS_GPIO_init();
2000306e:	f006 f9a3 	bl	200093b8 <MSS_GPIO_init>
	MSS_GPIO_config(MSS_GPIO_0, MSS_GPIO_OUTPUT_MODE);
20003072:	f04f 0000 	mov.w	r0, #0
20003076:	f04f 0105 	mov.w	r1, #5
2000307a:	f006 f9f3 	bl	20009464 <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_2, MSS_GPIO_OUTPUT_MODE);
2000307e:	f04f 0002 	mov.w	r0, #2
20003082:	f04f 0105 	mov.w	r1, #5
20003086:	f006 f9ed 	bl	20009464 <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_6, MSS_GPIO_OUTPUT_MODE);
2000308a:	f04f 0006 	mov.w	r0, #6
2000308e:	f04f 0105 	mov.w	r1, #5
20003092:	f006 f9e7 	bl	20009464 <MSS_GPIO_config>

	MSS_GPIO_set_output(MSS_GPIO_0, 1);	//Control_Interface ON
20003096:	f04f 0000 	mov.w	r0, #0
2000309a:	f04f 0101 	mov.w	r1, #1
2000309e:	f006 f9ff 	bl	200094a0 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_2, 1);	//COmms_ON
200030a2:	f04f 0002 	mov.w	r0, #2
200030a6:	f04f 0101 	mov.w	r1, #1
200030aa:	f006 f9f9 	bl	200094a0 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_6, 1);	//GMC_on
200030ae:	f04f 0006 	mov.w	r0, #6
200030b2:	f04f 0101 	mov.w	r1, #1
200030b6:	f006 f9f3 	bl	200094a0 <MSS_GPIO_set_output>

	MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
200030ba:	f04f 0000 	mov.w	r0, #0
200030be:	f003 fd85 	bl	20006bcc <MSS_SYS_init>
	MSS_SPI_init( &g_mss_spi0 );
200030c2:	f24d 5004 	movw	r0, #54532	; 0xd504
200030c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200030ca:	f004 fb95 	bl	200077f8 <MSS_SPI_init>
	MSS_SPI_configure_master_mode(&g_mss_spi0, MSS_SPI_SLAVE_0, MSS_SPI_MODE0, 8u, 8);
200030ce:	f04f 0308 	mov.w	r3, #8
200030d2:	9300      	str	r3, [sp, #0]
200030d4:	f24d 5004 	movw	r0, #54532	; 0xd504
200030d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200030dc:	f04f 0100 	mov.w	r1, #0
200030e0:	f04f 0200 	mov.w	r2, #0
200030e4:	f04f 0308 	mov.w	r3, #8
200030e8:	f004 fcd0 	bl	20007a8c <MSS_SPI_configure_master_mode>

	MSS_SPI_init(&g_mss_spi1);
200030ec:	f24d 4080 	movw	r0, #54400	; 0xd480
200030f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200030f4:	f004 fb80 	bl	200077f8 <MSS_SPI_init>
	MSS_SPI_configure_master_mode(&g_mss_spi1, MSS_SPI_SLAVE_0, MSS_SPI_MODE0, 512, 8);
200030f8:	f04f 0308 	mov.w	r3, #8
200030fc:	9300      	str	r3, [sp, #0]
200030fe:	f24d 4080 	movw	r0, #54400	; 0xd480
20003102:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003106:	f04f 0100 	mov.w	r1, #0
2000310a:	f04f 0200 	mov.w	r2, #0
2000310e:	f44f 7300 	mov.w	r3, #512	; 0x200
20003112:	f004 fcbb 	bl	20007a8c <MSS_SPI_configure_master_mode>

	initialise_partition(&hk_partition, HK_BLOCK_INIT, HK_BLOCK_END);
20003116:	f24d 308c 	movw	r0, #54156	; 0xd38c
2000311a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000311e:	f04f 010a 	mov.w	r1, #10
20003122:	f641 220a 	movw	r2, #6666	; 0x1a0a
20003126:	f2c0 024f 	movt	r2, #79	; 0x4f
2000312a:	f002 f8fb 	bl	20005324 <initialise_partition>
	initialise_partition(&comms_partition, COMMS_BLOCK_INIT, COMMS_BLOCK_END);
2000312e:	f24d 307c 	movw	r0, #54140	; 0xd37c
20003132:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003136:	f240 31d2 	movw	r1, #978	; 0x3d2
2000313a:	f2c0 0157 	movt	r1, #87	; 0x57
2000313e:	f64c 6252 	movw	r2, #52818	; 0xce52
20003142:	f2c0 0257 	movt	r2, #87	; 0x57
20003146:	f002 f8ed 	bl	20005324 <initialise_partition>
	initialise_partition(&thermistor_partition, THERMISTOR_BLOCK_INIT, THERMISTOR_BLOCK_END);
2000314a:	f24d 3068 	movw	r0, #54120	; 0xd368
2000314e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003152:	f246 417e 	movw	r1, #25726	; 0x647e
20003156:	f2c0 0159 	movt	r1, #89	; 0x59
2000315a:	f645 12fe 	movw	r2, #23038	; 0x59fe
2000315e:	f2c0 027a 	movt	r2, #122	; 0x7a
20003162:	f002 f8df 	bl	20005324 <initialise_partition>
	initialise_partition(&gmc_partition, GMC_BLOCK_INIT, GMC_BLOCK_END);
20003166:	f24d 1020 	movw	r0, #53536	; 0xd120
2000316a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000316e:	f44f 712f 	mov.w	r1, #700	; 0x2bc
20003172:	f44f 7248 	mov.w	r2, #800	; 0x320
20003176:	f002 f8d5 	bl	20005324 <initialise_partition>
	initialise_partition(&log_partiton, LOGS_BLOCK_INIT, LOGS_BLOCK_END);
2000317a:	f24d 1004 	movw	r0, #53508	; 0xd104
2000317e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003182:	f641 216e 	movw	r1, #6766	; 0x1a6e
20003186:	f2c0 014f 	movt	r1, #79	; 0x4f
2000318a:	f240 326e 	movw	r2, #878	; 0x36e
2000318e:	f2c0 0257 	movt	r2, #87	; 0x57
20003192:	f002 f8c7 	bl	20005324 <initialise_partition>

	uint8_t init_envm[3];
	init_envm[0] = 0x00;
20003196:	f04f 0300 	mov.w	r3, #0
2000319a:	733b      	strb	r3, [r7, #12]
	init_envm[1] = 0x00;
2000319c:	f04f 0300 	mov.w	r3, #0
200031a0:	737b      	strb	r3, [r7, #13]
	init_envm[2] = 0x00;
200031a2:	f04f 0300 	mov.w	r3, #0
200031a6:	73bb      	strb	r3, [r7, #14]
	NVM_write(REPRO_CODE_WORD_ADDR, init_envm, 3, NVM_DO_NOT_LOCK_PAGE);
200031a8:	f64b 7388 	movw	r3, #49032	; 0xbf88
200031ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031b0:	681a      	ldr	r2, [r3, #0]
200031b2:	f107 030c 	add.w	r3, r7, #12
200031b6:	4610      	mov	r0, r2
200031b8:	4619      	mov	r1, r3
200031ba:	f04f 0203 	mov.w	r2, #3
200031be:	f04f 0300 	mov.w	r3, #0
200031c2:	f005 f98d 	bl	200084e0 <NVM_write>

	//Assign log packet pointer to log data buffer
	log_packet_ptr = (log_packet_t*)log_data;
200031c6:	f24d 1238 	movw	r2, #53560	; 0xd138
200031ca:	f2c2 0200 	movt	r2, #8192	; 0x2000
200031ce:	f24d 131c 	movw	r3, #53532	; 0xd11c
200031d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031d6:	601a      	str	r2, [r3, #0]

	//Initialise log counter to zero
	log_counter = 0;
200031d8:	f24d 1300 	movw	r3, #53504	; 0xd100
200031dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031e0:	f04f 0200 	mov.w	r2, #0
200031e4:	701a      	strb	r2, [r3, #0]

	//Initailise the log sequence number
	logs_seq_no = 1;
200031e6:	f24d 333c 	movw	r3, #54076	; 0xd33c
200031ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031ee:	f04f 0201 	mov.w	r2, #1
200031f2:	801a      	strh	r2, [r3, #0]

	//Function to initialise 64 bit timer
	Tim64_init();
200031f4:	f7ff fe58 	bl	20002ea8 <Tim64_init>

	uint8_t mode = 0;
200031f8:	f04f 0300 	mov.w	r3, #0
200031fc:	747b      	strb	r3, [r7, #17]
	counter_init(&counter_i2c);
200031fe:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20003202:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003206:	f002 f901 	bl	2000540c <counter_init>

	stat1 |= ADC_Init(TEMP_ADC_CORE_I2C, ADC_ADDR);
2000320a:	f24c 4024 	movw	r0, #50212	; 0xc424
2000320e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003212:	f04f 0121 	mov.w	r1, #33	; 0x21
20003216:	f001 f825 	bl	20004264 <ADC_Init>
2000321a:	4603      	mov	r3, r0
2000321c:	461a      	mov	r2, r3
2000321e:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
20003222:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003226:	781b      	ldrb	r3, [r3, #0]
20003228:	ea42 0303 	orr.w	r3, r2, r3
2000322c:	b2da      	uxtb	r2, r3
2000322e:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
20003232:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003236:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 1);
20003238:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
2000323c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003240:	781b      	ldrb	r3, [r3, #0]
20003242:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003246:	b2da      	uxtb	r2, r3
20003248:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
2000324c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003250:	701a      	strb	r2, [r3, #0]
	stat1 |= ADC_Init(&counter_i2c, ADC_ADDR);
20003252:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20003256:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000325a:	f04f 0121 	mov.w	r1, #33	; 0x21
2000325e:	f001 f801 	bl	20004264 <ADC_Init>
20003262:	4603      	mov	r3, r0
20003264:	461a      	mov	r2, r3
20003266:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
2000326a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000326e:	781b      	ldrb	r3, [r3, #0]
20003270:	ea42 0303 	orr.w	r3, r2, r3
20003274:	b2da      	uxtb	r2, r3
20003276:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
2000327a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000327e:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 1);
20003280:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
20003284:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003288:	781b      	ldrb	r3, [r3, #0]
2000328a:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000328e:	b2da      	uxtb	r2, r3
20003290:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
20003294:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003298:	701a      	strb	r2, [r3, #0]
	stat1 |= SD_Init();
2000329a:	f001 fc09 	bl	20004ab0 <SD_Init>
2000329e:	4603      	mov	r3, r0
200032a0:	461a      	mov	r2, r3
200032a2:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032aa:	781b      	ldrb	r3, [r3, #0]
200032ac:	ea42 0303 	orr.w	r3, r2, r3
200032b0:	b2da      	uxtb	r2, r3
200032b2:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032ba:	701a      	strb	r2, [r3, #0]
	stat1 = (stat1 << 5);
200032bc:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032c4:	781b      	ldrb	r3, [r3, #0]
200032c6:	ea4f 1343 	mov.w	r3, r3, lsl #5
200032ca:	b2da      	uxtb	r2, r3
200032cc:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032d4:	701a      	strb	r2, [r3, #0]
	stat1 |= init_RS485_Controller();
200032d6:	f000 fd25 	bl	20003d24 <init_RS485_Controller>
200032da:	4603      	mov	r3, r0
200032dc:	461a      	mov	r2, r3
200032de:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032e6:	781b      	ldrb	r3, [r3, #0]
200032e8:	ea42 0303 	orr.w	r3, r2, r3
200032ec:	b2da      	uxtb	r2, r3
200032ee:	f24c 23f0 	movw	r3, #49904	; 0xc2f0
200032f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032f6:	701a      	strb	r2, [r3, #0]

	adf_status = adf_init();
200032f8:	f002 f97a 	bl	200055f0 <adf_init>
200032fc:	4603      	mov	r3, r0
200032fe:	461a      	mov	r2, r3
20003300:	f24c 23f2 	movw	r3, #49906	; 0xc2f2
20003304:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003308:	701a      	strb	r2, [r3, #0]
	mode = adf_get_state();
2000330a:	f002 fdc9 	bl	20005ea0 <adf_get_state>
2000330e:	4603      	mov	r3, r0
20003310:	747b      	strb	r3, [r7, #17]

	stat2 |= mode;
20003312:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003316:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000331a:	781a      	ldrb	r2, [r3, #0]
2000331c:	7c7b      	ldrb	r3, [r7, #17]
2000331e:	ea42 0303 	orr.w	r3, r2, r3
20003322:	b2da      	uxtb	r2, r3
20003324:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003328:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000332c:	701a      	strb	r2, [r3, #0]
	stat2 = (stat2 << 1);
2000332e:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003332:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003336:	781b      	ldrb	r3, [r3, #0]
20003338:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000333c:	b2da      	uxtb	r2, r3
2000333e:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003342:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003346:	701a      	strb	r2, [r3, #0]
	stat2 |= vc_init(VC1);
20003348:	f04f 0040 	mov.w	r0, #64	; 0x40
2000334c:	f000 fe90 	bl	20004070 <vc_init>
20003350:	4603      	mov	r3, r0
20003352:	461a      	mov	r2, r3
20003354:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003358:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000335c:	781b      	ldrb	r3, [r3, #0]
2000335e:	ea42 0303 	orr.w	r3, r2, r3
20003362:	b2da      	uxtb	r2, r3
20003364:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003368:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000336c:	701a      	strb	r2, [r3, #0]
	stat2 = (stat2 << 1);
2000336e:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003372:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003376:	781b      	ldrb	r3, [r3, #0]
20003378:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000337c:	b2da      	uxtb	r2, r3
2000337e:	f24c 23f1 	movw	r3, #49905	; 0xc2f1
20003382:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003386:	701a      	strb	r2, [r3, #0]


	uint16_t curr_tpsram_read_addr;
	uint16_t rssi;
	uint8_t cmd[8];
	uint8_t cmd_rx_flag = 0;
20003388:	f04f 0300 	mov.w	r3, #0
2000338c:	75fb      	strb	r3, [r7, #23]


	uint32_t wd_reset;

	init_cmd_engine();
2000338e:	f7ff fd51 	bl	20002e34 <init_cmd_engine>

	 MSS_UART_init(&g_mss_uart0,
20003392:	f24d 4040 	movw	r0, #54336	; 0xd440
20003396:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000339a:	f44f 5116 	mov.w	r1, #9600	; 0x2580
2000339e:	f04f 0203 	mov.w	r2, #3
200033a2:	f002 ff9d 	bl	200062e0 <MSS_UART_init>
	                   MSS_UART_9600_BAUD,
	                   MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);


	NVIC_ClearPendingIRQ(FabricIrq4_IRQn);
200033a6:	f04f 0026 	mov.w	r0, #38	; 0x26
200033aa:	f7fe fe33 	bl	20002014 <NVIC_ClearPendingIRQ>
	NVIC_ClearPendingIRQ(FabricIrq5_IRQn);
200033ae:	f04f 0027 	mov.w	r0, #39	; 0x27
200033b2:	f7fe fe2f 	bl	20002014 <NVIC_ClearPendingIRQ>

	timer_intr_set();
200033b6:	f7ff fc23 	bl	20002c00 <timer_intr_set>

	uint32_t timer_count = 0xFFFFFFFF;
200033ba:	f04f 33ff 	mov.w	r3, #4294967295
200033be:	61fb      	str	r3, [r7, #28]
	uint32_t CMD_CHK_TIMER = 0xFFFFFFFF - (MSS_SYS_M3_CLK_FREQ* (10));
200033c0:	f649 23ff 	movw	r3, #39679	; 0x9aff
200033c4:	f2ce 2332 	movt	r3, #57906	; 0xe232
200033c8:	623b      	str	r3, [r7, #32]
	uint32_t curr_value = 0x0;
200033ca:	f04f 0300 	mov.w	r3, #0
200033ce:	627b      	str	r3, [r7, #36]	; 0x24

	get_init();
200033d0:	f7ff fd7a 	bl	20002ec8 <get_init>
200033d4:	e002      	b.n	200033dc <main+0x380>
			curr_tpsram_read_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_RADDR);
			if(curr_tpsram_read_addr > Read_TPSRAM_addr){
				store_in_sd_card = 0;
			}
		}
	}
200033d6:	bf00      	nop
200033d8:	e000      	b.n	200033dc <main+0x380>
200033da:	bf00      	nop

	get_init();

	while(1){

		adf_send_cmd(CMD_PHY_CCA);
200033dc:	f04f 0086 	mov.w	r0, #134	; 0x86
200033e0:	f002 fbce 	bl	20005b80 <adf_send_cmd>

		get_rssi_cca_data(&rssi_cca);
200033e4:	f24d 3064 	movw	r0, #54116	; 0xd364
200033e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200033ec:	f002 fdf0 	bl	20005fd0 <get_rssi_cca_data>

		if(store_in_sd_card == 1){
200033f0:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
200033f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200033f8:	781b      	ldrb	r3, [r3, #0]
200033fa:	2b01      	cmp	r3, #1
200033fc:	d1eb      	bne.n	200033d6 <main+0x37a>
			curr_tpsram_read_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_RADDR);
200033fe:	f245 000c 	movw	r0, #20492	; 0x500c
20003402:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003406:	f002 febf 	bl	20006188 <HW_get_16bit_reg>
2000340a:	4603      	mov	r3, r0
2000340c:	827b      	strh	r3, [r7, #18]
			if(curr_tpsram_read_addr > Read_TPSRAM_addr){
2000340e:	f24d 1330 	movw	r3, #53552	; 0xd130
20003412:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003416:	881b      	ldrh	r3, [r3, #0]
20003418:	8a7a      	ldrh	r2, [r7, #18]
2000341a:	429a      	cmp	r2, r3
2000341c:	d9dd      	bls.n	200033da <main+0x37e>
				store_in_sd_card = 0;
2000341e:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20003422:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003426:	f04f 0200 	mov.w	r2, #0
2000342a:	701a      	strb	r2, [r3, #0]
			}
		}
	}
2000342c:	e7d6      	b.n	200033dc <main+0x380>
2000342e:	bf00      	nop

20003430 <FabricIrq0_IRQHandler>:
    return 0;

}

void FabricIrq0_IRQHandler(void)
{
20003430:	b580      	push	{r7, lr}
20003432:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c0);
20003434:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
20003438:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000343c:	f006 ff48 	bl	2000a2d0 <I2C_isr>
}
20003440:	bd80      	pop	{r7, pc}
20003442:	bf00      	nop

20003444 <FabricIrq1_IRQHandler>:

void FabricIrq1_IRQHandler(void)
{
20003444:	b580      	push	{r7, lr}
20003446:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c1);
20003448:	f24c 4024 	movw	r0, #50212	; 0xc424
2000344c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003450:	f006 ff3e 	bl	2000a2d0 <I2C_isr>
}
20003454:	bd80      	pop	{r7, pc}
20003456:	bf00      	nop

20003458 <FabricIrq2_IRQHandler>:

void FabricIrq2_IRQHandler(void)
{
20003458:	b580      	push	{r7, lr}
2000345a:	af00      	add	r7, sp, #0
    I2C_isr(&counter_i2c);
2000345c:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20003460:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003464:	f006 ff34 	bl	2000a2d0 <I2C_isr>
}
20003468:	bd80      	pop	{r7, pc}
2000346a:	bf00      	nop

2000346c <FabricIrq3_IRQHandler>:

void FabricIrq3_IRQHandler(void)
{
2000346c:	b580      	push	{r7, lr}
2000346e:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c3);
20003470:	f24c 5048 	movw	r0, #50504	; 0xc548
20003474:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003478:	f006 ff2a 	bl	2000a2d0 <I2C_isr>
}
2000347c:	bd80      	pop	{r7, pc}
2000347e:	bf00      	nop

20003480 <FabricIrq4_IRQHandler>:

void FabricIrq4_IRQHandler(void)
{
20003480:	b580      	push	{r7, lr}
20003482:	af00      	add	r7, sp, #0
    HK_ISR();
20003484:	f7fe ffec 	bl	20002460 <HK_ISR>

}
20003488:	bd80      	pop	{r7, pc}
2000348a:	bf00      	nop

2000348c <FabricIrq5_IRQHandler>:

void FabricIrq5_IRQHandler(void)
{
2000348c:	b580      	push	{r7, lr}
2000348e:	af00      	add	r7, sp, #0
    COMMS_ISR();
20003490:	f7ff f9be 	bl	20002810 <COMMS_ISR>
}
20003494:	bd80      	pop	{r7, pc}
20003496:	bf00      	nop

20003498 <FabricIrq6_IRQHandler>:

void FabricIrq6_IRQHandler(void)
{
20003498:	b580      	push	{r7, lr}
2000349a:	af00      	add	r7, sp, #0
    THER_ISR();
2000349c:	f7ff faa4 	bl	200029e8 <THER_ISR>
}
200034a0:	bd80      	pop	{r7, pc}
200034a2:	bf00      	nop

200034a4 <FabricIrq7_IRQHandler>:

void FabricIrq7_IRQHandler(void)
{
200034a4:	b580      	push	{r7, lr}
200034a6:	af00      	add	r7, sp, #0
    SD_ISR();
200034a8:	f7ff fb8a 	bl	20002bc0 <SD_ISR>
}
200034ac:	bd80      	pop	{r7, pc}
200034ae:	bf00      	nop

200034b0 <FabricIrq8_IRQHandler>:

void FabricIrq8_IRQHandler(void)
{
200034b0:	b580      	push	{r7, lr}
200034b2:	af00      	add	r7, sp, #0
    GMC_ISR();
200034b4:	f7ff f8c0 	bl	20002638 <GMC_ISR>
}
200034b8:	bd80      	pop	{r7, pc}
200034ba:	bf00      	nop

200034bc <cmd_valid>:
extern uint8_t IMG_ID;

uint32_t REPRO_CODE_WORD_ADDR = 0x60033000;
uint8_t* code_word = (uint8_t*) 0x60033000;

uint8_t cmd_valid(rx_cmd_t* rx_cmd, uint8_t src){
200034bc:	b480      	push	{r7}
200034be:	b083      	sub	sp, #12
200034c0:	af00      	add	r7, sp, #0
200034c2:	6078      	str	r0, [r7, #4]
200034c4:	460b      	mov	r3, r1
200034c6:	70fb      	strb	r3, [r7, #3]
	//Logic to check validity of the command ID within limits along with the params limits.

	if(rx_cmd->cmd_id - 1 >= 0x00 && rx_cmd->cmd_id - 1 <= NUM_CMDS){
200034c8:	687b      	ldr	r3, [r7, #4]
200034ca:	781b      	ldrb	r3, [r3, #0]
200034cc:	f103 33ff 	add.w	r3, r3, #4294967295
200034d0:	2b00      	cmp	r3, #0
200034d2:	db08      	blt.n	200034e6 <cmd_valid+0x2a>
200034d4:	687b      	ldr	r3, [r7, #4]
200034d6:	781b      	ldrb	r3, [r3, #0]
200034d8:	f103 33ff 	add.w	r3, r3, #4294967295
200034dc:	2b05      	cmp	r3, #5
200034de:	dc02      	bgt.n	200034e6 <cmd_valid+0x2a>
		return 1;  //Will be checking the validated of the checksum.
200034e0:	f04f 0301 	mov.w	r3, #1
200034e4:	e001      	b.n	200034ea <cmd_valid+0x2e>
	}
	else{
		return 0;
200034e6:	f04f 0300 	mov.w	r3, #0
	}

}
200034ea:	4618      	mov	r0, r3
200034ec:	f107 070c 	add.w	r7, r7, #12
200034f0:	46bd      	mov	sp, r7
200034f2:	bc80      	pop	{r7}
200034f4:	4770      	bx	lr
200034f6:	bf00      	nop

200034f8 <add_cmd>:


void add_cmd(uint8_t id, uint16_t length, void (*ex_func)(uint8_t id, rx_cmd_t* rcv_cmd)){
200034f8:	b480      	push	{r7}
200034fa:	b083      	sub	sp, #12
200034fc:	af00      	add	r7, sp, #0
200034fe:	460b      	mov	r3, r1
20003500:	603a      	str	r2, [r7, #0]
20003502:	4602      	mov	r2, r0
20003504:	71fa      	strb	r2, [r7, #7]
20003506:	80bb      	strh	r3, [r7, #4]

	cmd_list[id].id = id;
20003508:	79f9      	ldrb	r1, [r7, #7]
2000350a:	f24d 32c4 	movw	r2, #54212	; 0xd3c4
2000350e:	f2c2 0200 	movt	r2, #8192	; 0x2000
20003512:	460b      	mov	r3, r1
20003514:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20003518:	ebc1 0303 	rsb	r3, r1, r3
2000351c:	4413      	add	r3, r2
2000351e:	79fa      	ldrb	r2, [r7, #7]
20003520:	701a      	strb	r2, [r3, #0]
	cmd_list[id].length = length;
20003522:	79f9      	ldrb	r1, [r7, #7]
20003524:	f24d 32c4 	movw	r2, #54212	; 0xd3c4
20003528:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000352c:	460b      	mov	r3, r1
2000352e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20003532:	ebc1 0303 	rsb	r3, r1, r3
20003536:	4413      	add	r3, r2
20003538:	793a      	ldrb	r2, [r7, #4]
2000353a:	f04f 0100 	mov.w	r1, #0
2000353e:	ea41 0202 	orr.w	r2, r1, r2
20003542:	705a      	strb	r2, [r3, #1]
20003544:	797a      	ldrb	r2, [r7, #5]
20003546:	f04f 0100 	mov.w	r1, #0
2000354a:	ea41 0202 	orr.w	r2, r1, r2
2000354e:	709a      	strb	r2, [r3, #2]
	cmd_list[id].ex_func = ex_func;
20003550:	79f8      	ldrb	r0, [r7, #7]
20003552:	683a      	ldr	r2, [r7, #0]
20003554:	f24d 31c4 	movw	r1, #54212	; 0xd3c4
20003558:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000355c:	4603      	mov	r3, r0
2000355e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20003562:	ebc0 0303 	rsb	r3, r0, r3
20003566:	440b      	add	r3, r1
20003568:	f002 01ff 	and.w	r1, r2, #255	; 0xff
2000356c:	f04f 0000 	mov.w	r0, #0
20003570:	ea40 0101 	orr.w	r1, r0, r1
20003574:	70d9      	strb	r1, [r3, #3]
20003576:	ea4f 2112 	mov.w	r1, r2, lsr #8
2000357a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
2000357e:	f04f 0000 	mov.w	r0, #0
20003582:	ea40 0101 	orr.w	r1, r0, r1
20003586:	7119      	strb	r1, [r3, #4]
20003588:	ea4f 4112 	mov.w	r1, r2, lsr #16
2000358c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
20003590:	f04f 0000 	mov.w	r0, #0
20003594:	ea40 0101 	orr.w	r1, r0, r1
20003598:	7159      	strb	r1, [r3, #5]
2000359a:	ea4f 6212 	mov.w	r2, r2, lsr #24
2000359e:	f04f 0100 	mov.w	r1, #0
200035a2:	ea41 0202 	orr.w	r2, r1, r2
200035a6:	719a      	strb	r2, [r3, #6]

}
200035a8:	f107 070c 	add.w	r7, r7, #12
200035ac:	46bd      	mov	sp, r7
200035ae:	bc80      	pop	{r7}
200035b0:	4770      	bx	lr
200035b2:	bf00      	nop

200035b4 <cmd_engine>:

void cmd_engine(rx_cmd_t* rx_cmd){
200035b4:	b580      	push	{r7, lr}
200035b6:	b082      	sub	sp, #8
200035b8:	af00      	add	r7, sp, #0
200035ba:	6078      	str	r0, [r7, #4]

	   //the actual command apid's is one greater than this.
//	add_cmd(2, 2, cmd_sc_reset);

	cmd_list[rx_cmd->cmd_id - 1].ex_func(rx_cmd);
200035bc:	687b      	ldr	r3, [r7, #4]
200035be:	781b      	ldrb	r3, [r3, #0]
200035c0:	f103 31ff 	add.w	r1, r3, #4294967295
200035c4:	f24d 32c4 	movw	r2, #54212	; 0xd3c4
200035c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
200035cc:	460b      	mov	r3, r1
200035ce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200035d2:	ebc1 0303 	rsb	r3, r1, r3
200035d6:	4413      	add	r3, r2
200035d8:	78da      	ldrb	r2, [r3, #3]
200035da:	7919      	ldrb	r1, [r3, #4]
200035dc:	ea4f 2101 	mov.w	r1, r1, lsl #8
200035e0:	ea41 0202 	orr.w	r2, r1, r2
200035e4:	7959      	ldrb	r1, [r3, #5]
200035e6:	ea4f 4101 	mov.w	r1, r1, lsl #16
200035ea:	ea41 0202 	orr.w	r2, r1, r2
200035ee:	799b      	ldrb	r3, [r3, #6]
200035f0:	ea4f 6303 	mov.w	r3, r3, lsl #24
200035f4:	ea43 0302 	orr.w	r3, r3, r2
200035f8:	6878      	ldr	r0, [r7, #4]
200035fa:	4798      	blx	r3

}
200035fc:	f107 0708 	add.w	r7, r7, #8
20003600:	46bd      	mov	sp, r7
20003602:	bd80      	pop	{r7, pc}

20003604 <cmd_noop>:

// Commands Definition

void cmd_noop(rx_cmd_t* rcv_cmd){
20003604:	b480      	push	{r7}
20003606:	b085      	sub	sp, #20
20003608:	af00      	add	r7, sp, #0
2000360a:	6078      	str	r0, [r7, #4]

	uint8_t a;

}
2000360c:	f107 0714 	add.w	r7, r7, #20
20003610:	46bd      	mov	sp, r7
20003612:	bc80      	pop	{r7}
20003614:	4770      	bx	lr
20003616:	bf00      	nop

20003618 <set_pkt_rate>:

void set_pkt_rate(rx_cmd_t* rcv_cmd){
20003618:	b580      	push	{r7, lr}
2000361a:	b086      	sub	sp, #24
2000361c:	af02      	add	r7, sp, #8
2000361e:	6078      	str	r0, [r7, #4]

	uint32_t new_time_period = MSS_SYS_M3_CLK_FREQ/1024 * (rcv_cmd->parameters[1] / 10);
20003620:	687b      	ldr	r3, [r7, #4]
20003622:	789a      	ldrb	r2, [r3, #2]
20003624:	f64c 43cd 	movw	r3, #52429	; 0xcccd
20003628:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
2000362c:	fba3 1302 	umull	r1, r3, r3, r2
20003630:	ea4f 03d3 	mov.w	r3, r3, lsr #3
20003634:	b2db      	uxtb	r3, r3
20003636:	f64b 62bc 	movw	r2, #48828	; 0xbebc
2000363a:	fb02 f303 	mul.w	r3, r2, r3
2000363e:	60fb      	str	r3, [r7, #12]

	if(rcv_cmd->parameters[1] != 0){
20003640:	687b      	ldr	r3, [r7, #4]
20003642:	789b      	ldrb	r3, [r3, #2]
20003644:	2b00      	cmp	r3, #0
20003646:	f000 80a5 	beq.w	20003794 <set_pkt_rate+0x17c>
		if(rcv_cmd->parameters[0] == hk){
2000364a:	687b      	ldr	r3, [r7, #4]
2000364c:	785b      	ldrb	r3, [r3, #1]
2000364e:	2b00      	cmp	r3, #0
20003650:	d11c      	bne.n	2000368c <set_pkt_rate+0x74>
			TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
20003652:	68fb      	ldr	r3, [r7, #12]
20003654:	9300      	str	r3, [sp, #0]
20003656:	f24d 309c 	movw	r0, #54172	; 0xd39c
2000365a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000365e:	f246 0100 	movw	r1, #24576	; 0x6000
20003662:	f2c5 0100 	movt	r1, #20480	; 0x5000
20003666:	f04f 0200 	mov.w	r2, #0
2000366a:	f04f 0309 	mov.w	r3, #9
2000366e:	f005 ff9f 	bl	200095b0 <TMR_init>
			TMR_enable_int(&hk_timer);
20003672:	f24d 309c 	movw	r0, #54172	; 0xd39c
20003676:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000367a:	f006 f83d 	bl	200096f8 <TMR_enable_int>
			TMR_start(&hk_timer);
2000367e:	f24d 309c 	movw	r0, #54172	; 0xd39c
20003682:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003686:	f005 fffb 	bl	20009680 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
2000368a:	e0bb      	b.n	20003804 <set_pkt_rate+0x1ec>
		if(rcv_cmd->parameters[0] == hk){
			TMR_init(&hk_timer, CORETIMER_C0_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&hk_timer);
			TMR_start(&hk_timer);
		}
		else if(rcv_cmd->parameters[0] == comms){
2000368c:	687b      	ldr	r3, [r7, #4]
2000368e:	785b      	ldrb	r3, [r3, #1]
20003690:	2b01      	cmp	r3, #1
20003692:	d11c      	bne.n	200036ce <set_pkt_rate+0xb6>
			TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
20003694:	68fb      	ldr	r3, [r7, #12]
20003696:	9300      	str	r3, [sp, #0]
20003698:	f24d 1014 	movw	r0, #53524	; 0xd114
2000369c:	f2c2 0000 	movt	r0, #8192	; 0x2000
200036a0:	f247 0100 	movw	r1, #28672	; 0x7000
200036a4:	f2c5 0100 	movt	r1, #20480	; 0x5000
200036a8:	f04f 0200 	mov.w	r2, #0
200036ac:	f04f 0309 	mov.w	r3, #9
200036b0:	f005 ff7e 	bl	200095b0 <TMR_init>
			TMR_enable_int(&comms_timer);
200036b4:	f24d 1014 	movw	r0, #53524	; 0xd114
200036b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200036bc:	f006 f81c 	bl	200096f8 <TMR_enable_int>
			TMR_start(&comms_timer);
200036c0:	f24d 1014 	movw	r0, #53524	; 0xd114
200036c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200036c8:	f005 ffda 	bl	20009680 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
200036cc:	e09a      	b.n	20003804 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == comms){
			TMR_init(&comms_timer, CORETIMER_C1_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&comms_timer);
			TMR_start(&comms_timer);
		}
		else if(rcv_cmd->parameters[0] == thermistor){
200036ce:	687b      	ldr	r3, [r7, #4]
200036d0:	785b      	ldrb	r3, [r3, #1]
200036d2:	2b02      	cmp	r3, #2
200036d4:	d11c      	bne.n	20003710 <set_pkt_rate+0xf8>
			TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
200036d6:	68fb      	ldr	r3, [r7, #12]
200036d8:	9300      	str	r3, [sp, #0]
200036da:	f24d 3040 	movw	r0, #54080	; 0xd340
200036de:	f2c2 0000 	movt	r0, #8192	; 0x2000
200036e2:	f248 0100 	movw	r1, #32768	; 0x8000
200036e6:	f2c5 0100 	movt	r1, #20480	; 0x5000
200036ea:	f04f 0200 	mov.w	r2, #0
200036ee:	f04f 0309 	mov.w	r3, #9
200036f2:	f005 ff5d 	bl	200095b0 <TMR_init>
			TMR_enable_int(&temp_timer);
200036f6:	f24d 3040 	movw	r0, #54080	; 0xd340
200036fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200036fe:	f005 fffb 	bl	200096f8 <TMR_enable_int>
			TMR_start(&temp_timer);
20003702:	f24d 3040 	movw	r0, #54080	; 0xd340
20003706:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000370a:	f005 ffb9 	bl	20009680 <TMR_start>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
2000370e:	e079      	b.n	20003804 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == thermistor){
			TMR_init(&temp_timer, CORETIMER_C2_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&temp_timer);
			TMR_start(&temp_timer);
		}
		else if(rcv_cmd->parameters[0] == sd){
20003710:	687b      	ldr	r3, [r7, #4]
20003712:	785b      	ldrb	r3, [r3, #1]
20003714:	2b05      	cmp	r3, #5
20003716:	d11c      	bne.n	20003752 <set_pkt_rate+0x13a>
			TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
20003718:	68fb      	ldr	r3, [r7, #12]
2000371a:	9300      	str	r3, [sp, #0]
2000371c:	f24d 3050 	movw	r0, #54096	; 0xd350
20003720:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003724:	f249 0100 	movw	r1, #36864	; 0x9000
20003728:	f2c5 0100 	movt	r1, #20480	; 0x5000
2000372c:	f04f 0200 	mov.w	r2, #0
20003730:	f04f 0309 	mov.w	r3, #9
20003734:	f005 ff3c 	bl	200095b0 <TMR_init>
			TMR_enable_int(&sd_timer);
20003738:	f24d 3050 	movw	r0, #54096	; 0xd350
2000373c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003740:	f005 ffda 	bl	200096f8 <TMR_enable_int>
			TMR_start(&sd_timer);
20003744:	f24d 3050 	movw	r0, #54096	; 0xd350
20003748:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000374c:	f005 ff98 	bl	20009680 <TMR_start>
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
20003750:	e058      	b.n	20003804 <set_pkt_rate+0x1ec>
		else if(rcv_cmd->parameters[0] == sd){
			TMR_init(&sd_timer, CORETIMER_C3_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&sd_timer);
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
20003752:	687b      	ldr	r3, [r7, #4]
20003754:	785b      	ldrb	r3, [r3, #1]
20003756:	2b03      	cmp	r3, #3
20003758:	d153      	bne.n	20003802 <set_pkt_rate+0x1ea>
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
2000375a:	68fb      	ldr	r3, [r7, #12]
2000375c:	9300      	str	r3, [sp, #0]
2000375e:	f24d 3038 	movw	r0, #54072	; 0xd338
20003762:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003766:	f24a 0100 	movw	r1, #40960	; 0xa000
2000376a:	f2c5 0100 	movt	r1, #20480	; 0x5000
2000376e:	f04f 0200 	mov.w	r2, #0
20003772:	f04f 0309 	mov.w	r3, #9
20003776:	f005 ff1b 	bl	200095b0 <TMR_init>
			TMR_enable_int(&gmc_timer);
2000377a:	f24d 3038 	movw	r0, #54072	; 0xd338
2000377e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003782:	f005 ffb9 	bl	200096f8 <TMR_enable_int>
			TMR_start(&gmc_timer);
20003786:	f24d 3038 	movw	r0, #54072	; 0xd338
2000378a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000378e:	f005 ff77 	bl	20009680 <TMR_start>
20003792:	e037      	b.n	20003804 <set_pkt_rate+0x1ec>
		}
	}
	else{
		//Here, instead of disabling the NVIC interrupts, we can stop the timer, so that the packetisation can again be restarted with another command
		if(rcv_cmd->parameters[0] == hk){
20003794:	687b      	ldr	r3, [r7, #4]
20003796:	785b      	ldrb	r3, [r3, #1]
20003798:	2b00      	cmp	r3, #0
2000379a:	d106      	bne.n	200037aa <set_pkt_rate+0x192>
			TMR_stop(&hk_timer);
2000379c:	f24d 309c 	movw	r0, #54172	; 0xd39c
200037a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200037a4:	f005 ff8a 	bl	200096bc <TMR_stop>
200037a8:	e02c      	b.n	20003804 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq4_IRQn);
		}
		else if(rcv_cmd->parameters[0] == comms){
200037aa:	687b      	ldr	r3, [r7, #4]
200037ac:	785b      	ldrb	r3, [r3, #1]
200037ae:	2b01      	cmp	r3, #1
200037b0:	d106      	bne.n	200037c0 <set_pkt_rate+0x1a8>
			TMR_stop(&comms_timer);
200037b2:	f24d 1014 	movw	r0, #53524	; 0xd114
200037b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200037ba:	f005 ff7f 	bl	200096bc <TMR_stop>
200037be:	e021      	b.n	20003804 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq5_IRQn);
		}
		else if(rcv_cmd->parameters[0] == thermistor){
200037c0:	687b      	ldr	r3, [r7, #4]
200037c2:	785b      	ldrb	r3, [r3, #1]
200037c4:	2b02      	cmp	r3, #2
200037c6:	d106      	bne.n	200037d6 <set_pkt_rate+0x1be>
			TMR_stop(&temp_timer);
200037c8:	f24d 3040 	movw	r0, #54080	; 0xd340
200037cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200037d0:	f005 ff74 	bl	200096bc <TMR_stop>
200037d4:	e016      	b.n	20003804 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq6_IRQn);
		}
		else if(rcv_cmd->parameters[0] == sd){
200037d6:	687b      	ldr	r3, [r7, #4]
200037d8:	785b      	ldrb	r3, [r3, #1]
200037da:	2b05      	cmp	r3, #5
200037dc:	d106      	bne.n	200037ec <set_pkt_rate+0x1d4>
			TMR_stop(&sd_timer);
200037de:	f24d 3050 	movw	r0, #54096	; 0xd350
200037e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200037e6:	f005 ff69 	bl	200096bc <TMR_stop>
200037ea:	e00b      	b.n	20003804 <set_pkt_rate+0x1ec>
//			NVIC_DisableIRQ(FabricIrq7_IRQn);
		}
		else if(rcv_cmd->parameters[0] == gmc){
200037ec:	687b      	ldr	r3, [r7, #4]
200037ee:	785b      	ldrb	r3, [r3, #1]
200037f0:	2b03      	cmp	r3, #3
200037f2:	d107      	bne.n	20003804 <set_pkt_rate+0x1ec>
			TMR_stop(&gmc_timer);
200037f4:	f24d 3038 	movw	r0, #54072	; 0xd338
200037f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200037fc:	f005 ff5e 	bl	200096bc <TMR_stop>
20003800:	e000      	b.n	20003804 <set_pkt_rate+0x1ec>
			TMR_start(&sd_timer);
		}
		else if(rcv_cmd->parameters[0] == gmc){
			TMR_init(&gmc_timer, CORETIMER_C4_0, TMR_CONTINUOUS_MODE, PRESCALER_DIV_1024, new_time_period);
			TMR_enable_int(&gmc_timer);
			TMR_start(&gmc_timer);
20003802:	bf00      	nop
			TMR_stop(&gmc_timer);
//			NVIC_DisableIRQ(FabricIrq8_IRQn);
		}
	}

}
20003804:	f107 0710 	add.w	r7, r7, #16
20003808:	46bd      	mov	sp, r7
2000380a:	bd80      	pop	{r7, pc}

2000380c <delay>:

void delay ( volatile unsigned int n)
{
2000380c:	b480      	push	{r7}
2000380e:	b083      	sub	sp, #12
20003810:	af00      	add	r7, sp, #0
20003812:	6078      	str	r0, [r7, #4]
	while(n!=0)
20003814:	e003      	b.n	2000381e <delay+0x12>
	{
		n--;
20003816:	687b      	ldr	r3, [r7, #4]
20003818:	f103 33ff 	add.w	r3, r3, #4294967295
2000381c:	607b      	str	r3, [r7, #4]

}

void delay ( volatile unsigned int n)
{
	while(n!=0)
2000381e:	687b      	ldr	r3, [r7, #4]
20003820:	2b00      	cmp	r3, #0
20003822:	d1f8      	bne.n	20003816 <delay+0xa>
	{
		n--;
	}
}
20003824:	f107 070c 	add.w	r7, r7, #12
20003828:	46bd      	mov	sp, r7
2000382a:	bc80      	pop	{r7}
2000382c:	4770      	bx	lr
2000382e:	bf00      	nop

20003830 <exe_iap>:

void exe_iap(rx_cmd_t* rcv_cmd){
20003830:	b580      	push	{r7, lr}
20003832:	b084      	sub	sp, #16
20003834:	af00      	add	r7, sp, #0
20003836:	6078      	str	r0, [r7, #4]


	uint8_t prog_status, auth_status;

	if(rcv_cmd->parameters[0] == 0x07 || rcv_cmd->parameters[0] == 0x14 || rcv_cmd->parameters[0] == 0x21){
20003838:	687b      	ldr	r3, [r7, #4]
2000383a:	785b      	ldrb	r3, [r3, #1]
2000383c:	2b07      	cmp	r3, #7
2000383e:	d007      	beq.n	20003850 <exe_iap+0x20>
20003840:	687b      	ldr	r3, [r7, #4]
20003842:	785b      	ldrb	r3, [r3, #1]
20003844:	2b14      	cmp	r3, #20
20003846:	d003      	beq.n	20003850 <exe_iap+0x20>
20003848:	687b      	ldr	r3, [r7, #4]
2000384a:	785b      	ldrb	r3, [r3, #1]
2000384c:	2b21      	cmp	r3, #33	; 0x21
2000384e:	d122      	bne.n	20003896 <exe_iap+0x66>
		NVM_write(REPRO_CODE_WORD_ADDR, &(rcv_cmd->parameters[0]), 1, NVM_DO_NOT_LOCK_PAGE);
20003850:	f64b 7388 	movw	r3, #49032	; 0xbf88
20003854:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003858:	681a      	ldr	r2, [r3, #0]
2000385a:	687b      	ldr	r3, [r7, #4]
2000385c:	f103 0301 	add.w	r3, r3, #1
20003860:	4610      	mov	r0, r2
20003862:	4619      	mov	r1, r3
20003864:	f04f 0201 	mov.w	r2, #1
20003868:	f04f 0300 	mov.w	r3, #0
2000386c:	f004 fe38 	bl	200084e0 <NVM_write>
		latest_codeword = rcv_cmd->parameters[0];
20003870:	687b      	ldr	r3, [r7, #4]
20003872:	785a      	ldrb	r2, [r3, #1]
20003874:	f24c 23d6 	movw	r3, #49878	; 0xc2d6
20003878:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000387c:	701a      	strb	r2, [r3, #0]
		REPRO_CODE_WORD_ADDR += 0x01;
2000387e:	f64b 7388 	movw	r3, #49032	; 0xbf88
20003882:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003886:	681b      	ldr	r3, [r3, #0]
20003888:	f103 0201 	add.w	r2, r3, #1
2000388c:	f64b 7388 	movw	r3, #49032	; 0xbf88
20003890:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003894:	601a      	str	r2, [r3, #0]
	}


	if(code_word[0] == 0x07 && code_word[1] == 0x14 && code_word[2] == 0x21){
20003896:	f64b 738c 	movw	r3, #49036	; 0xbf8c
2000389a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000389e:	681b      	ldr	r3, [r3, #0]
200038a0:	781b      	ldrb	r3, [r3, #0]
200038a2:	2b07      	cmp	r3, #7
200038a4:	f040 80a4 	bne.w	200039f0 <exe_iap+0x1c0>
200038a8:	f64b 738c 	movw	r3, #49036	; 0xbf8c
200038ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200038b0:	681b      	ldr	r3, [r3, #0]
200038b2:	f103 0301 	add.w	r3, r3, #1
200038b6:	781b      	ldrb	r3, [r3, #0]
200038b8:	2b14      	cmp	r3, #20
200038ba:	f040 8099 	bne.w	200039f0 <exe_iap+0x1c0>
200038be:	f64b 738c 	movw	r3, #49036	; 0xbf8c
200038c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200038c6:	681b      	ldr	r3, [r3, #0]
200038c8:	f103 0302 	add.w	r3, r3, #2
200038cc:	781b      	ldrb	r3, [r3, #0]
200038ce:	2b21      	cmp	r3, #33	; 0x21
200038d0:	f040 808e 	bne.w	200039f0 <exe_iap+0x1c0>
		if(IMG_ID == 0){
200038d4:	f64b 7384 	movw	r3, #49028	; 0xbf84
200038d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200038dc:	781b      	ldrb	r3, [r3, #0]
200038de:	2b00      	cmp	r3, #0
200038e0:	d143      	bne.n	2000396a <exe_iap+0x13a>
			MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
200038e2:	f24d 5004 	movw	r0, #54532	; 0xd504
200038e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200038ea:	f04f 0100 	mov.w	r1, #0
200038ee:	f004 f975 	bl	20007bdc <MSS_SPI_set_slave_select>

			g_mss_spi0.hw_reg->CONTROL |= (0x04000000);
200038f2:	f24d 5304 	movw	r3, #54532	; 0xd504
200038f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200038fa:	681a      	ldr	r2, [r3, #0]
200038fc:	f24d 5304 	movw	r3, #54532	; 0xd504
20003900:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003904:	681b      	ldr	r3, [r3, #0]
20003906:	681b      	ldr	r3, [r3, #0]
20003908:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
2000390c:	6013      	str	r3, [r2, #0]
			delay(80000);
2000390e:	f643 0080 	movw	r0, #14464	; 0x3880
20003912:	f2c0 0001 	movt	r0, #1
20003916:	f7ff ff79 	bl	2000380c <delay>

			auth_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_AUTHENTICATE, 0x001000);
2000391a:	f04f 0000 	mov.w	r0, #0
2000391e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
20003922:	f003 fd79 	bl	20007418 <MSS_SYS_initiate_iap>
20003926:	4603      	mov	r3, r0
20003928:	73fb      	strb	r3, [r7, #15]

			delay(80000);
2000392a:	f643 0080 	movw	r0, #14464	; 0x3880
2000392e:	f2c0 0001 	movt	r0, #1
20003932:	f7ff ff6b 	bl	2000380c <delay>

			if(auth_status){
20003936:	7bfb      	ldrb	r3, [r7, #15]
20003938:	2b00      	cmp	r3, #0
2000393a:	d00d      	beq.n	20003958 <exe_iap+0x128>
				ERR_LOG = ERR_LOG | 0x01;
2000393c:	f24c 23e5 	movw	r3, #49893	; 0xc2e5
20003940:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003944:	781b      	ldrb	r3, [r3, #0]
20003946:	f043 0301 	orr.w	r3, r3, #1
2000394a:	b2da      	uxtb	r2, r3
2000394c:	f24c 23e5 	movw	r3, #49893	; 0xc2e5
20003950:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003954:	701a      	strb	r2, [r3, #0]
			}
			else{
				prog_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_PROGRAM, 0x001000);
20003956:	e04b      	b.n	200039f0 <exe_iap+0x1c0>
20003958:	f04f 0001 	mov.w	r0, #1
2000395c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
20003960:	f003 fd5a 	bl	20007418 <MSS_SYS_initiate_iap>
20003964:	4603      	mov	r3, r0
20003966:	73bb      	strb	r3, [r7, #14]
20003968:	e042      	b.n	200039f0 <exe_iap+0x1c0>
			}
		}
		else{
			MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
2000396a:	f24d 5004 	movw	r0, #54532	; 0xd504
2000396e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003972:	f04f 0100 	mov.w	r1, #0
20003976:	f004 f931 	bl	20007bdc <MSS_SPI_set_slave_select>

			g_mss_spi0.hw_reg->CONTROL |= (0x04000000);
2000397a:	f24d 5304 	movw	r3, #54532	; 0xd504
2000397e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003982:	681a      	ldr	r2, [r3, #0]
20003984:	f24d 5304 	movw	r3, #54532	; 0xd504
20003988:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000398c:	681b      	ldr	r3, [r3, #0]
2000398e:	681b      	ldr	r3, [r3, #0]
20003990:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
20003994:	6013      	str	r3, [r2, #0]
			delay(80000);
20003996:	f643 0080 	movw	r0, #14464	; 0x3880
2000399a:	f2c0 0001 	movt	r0, #1
2000399e:	f7ff ff35 	bl	2000380c <delay>

			auth_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_AUTHENTICATE, 0x001000);
200039a2:	f04f 0000 	mov.w	r0, #0
200039a6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
200039aa:	f003 fd35 	bl	20007418 <MSS_SYS_initiate_iap>
200039ae:	4603      	mov	r3, r0
200039b0:	73fb      	strb	r3, [r7, #15]

			delay(80000);
200039b2:	f643 0080 	movw	r0, #14464	; 0x3880
200039b6:	f2c0 0001 	movt	r0, #1
200039ba:	f7ff ff27 	bl	2000380c <delay>

			if(auth_status){
200039be:	7bfb      	ldrb	r3, [r7, #15]
200039c0:	2b00      	cmp	r3, #0
200039c2:	d00d      	beq.n	200039e0 <exe_iap+0x1b0>
				ERR_LOG = ERR_LOG | 0x01;
200039c4:	f24c 23e5 	movw	r3, #49893	; 0xc2e5
200039c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200039cc:	781b      	ldrb	r3, [r3, #0]
200039ce:	f043 0301 	orr.w	r3, r3, #1
200039d2:	b2da      	uxtb	r2, r3
200039d4:	f24c 23e5 	movw	r3, #49893	; 0xc2e5
200039d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200039dc:	701a      	strb	r2, [r3, #0]
200039de:	e007      	b.n	200039f0 <exe_iap+0x1c0>
			}
			else{
				prog_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_PROGRAM, 0x001000);
200039e0:	f04f 0001 	mov.w	r0, #1
200039e4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
200039e8:	f003 fd16 	bl	20007418 <MSS_SYS_initiate_iap>
200039ec:	4603      	mov	r3, r0
200039ee:	73bb      	strb	r3, [r7, #14]
			}
		}

	}

}
200039f0:	f107 0710 	add.w	r7, r7, #16
200039f4:	46bd      	mov	sp, r7
200039f6:	bd80      	pop	{r7, pc}

200039f8 <read_adf_reg>:

void read_adf_reg(rx_cmd_t* rcv_cmd){
200039f8:	b580      	push	{r7, lr}
200039fa:	b084      	sub	sp, #16
200039fc:	af00      	add	r7, sp, #0
200039fe:	6078      	str	r0, [r7, #4]

	uint8_t data_read[6];
	uint8_t j;

	cmd_adf_read_addr = (rcv_cmd->parameters[1] << 24) | (rcv_cmd->parameters[2] << 16) | (rcv_cmd->parameters[3] << 8) | rcv_cmd->parameters[4];
20003a00:	687b      	ldr	r3, [r7, #4]
20003a02:	789b      	ldrb	r3, [r3, #2]
20003a04:	ea4f 6203 	mov.w	r2, r3, lsl #24
20003a08:	687b      	ldr	r3, [r7, #4]
20003a0a:	78db      	ldrb	r3, [r3, #3]
20003a0c:	ea4f 4303 	mov.w	r3, r3, lsl #16
20003a10:	ea42 0203 	orr.w	r2, r2, r3
20003a14:	687b      	ldr	r3, [r7, #4]
20003a16:	791b      	ldrb	r3, [r3, #4]
20003a18:	ea4f 2303 	mov.w	r3, r3, lsl #8
20003a1c:	ea42 0203 	orr.w	r2, r2, r3
20003a20:	687b      	ldr	r3, [r7, #4]
20003a22:	795b      	ldrb	r3, [r3, #5]
20003a24:	ea42 0303 	orr.w	r3, r2, r3
20003a28:	461a      	mov	r2, r3
20003a2a:	f24c 23e0 	movw	r3, #49888	; 0xc2e0
20003a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a32:	601a      	str	r2, [r3, #0]
	cmd_adf_read_No_double_words = rcv_cmd->parameters[0];
20003a34:	687b      	ldr	r3, [r7, #4]
20003a36:	785a      	ldrb	r2, [r3, #1]
20003a38:	f24c 23e4 	movw	r3, #49892	; 0xc2e4
20003a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a40:	701a      	strb	r2, [r3, #0]

	adf_read_from_memory(RMODE_1, cmd_adf_read_addr, data_read, 6);
20003a42:	f24c 23e0 	movw	r3, #49888	; 0xc2e0
20003a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a4a:	681a      	ldr	r2, [r3, #0]
20003a4c:	f107 0308 	add.w	r3, r7, #8
20003a50:	f04f 0078 	mov.w	r0, #120	; 0x78
20003a54:	4611      	mov	r1, r2
20003a56:	461a      	mov	r2, r3
20003a58:	f04f 0306 	mov.w	r3, #6
20003a5c:	f002 f844 	bl	20005ae8 <adf_read_from_memory>

	cmd_adf_data[0] = (data_read[2] << 24) | (data_read[3] << 16) | (data_read[4] << 8) | (data_read[5]);
20003a60:	7abb      	ldrb	r3, [r7, #10]
20003a62:	ea4f 6203 	mov.w	r2, r3, lsl #24
20003a66:	7afb      	ldrb	r3, [r7, #11]
20003a68:	ea4f 4303 	mov.w	r3, r3, lsl #16
20003a6c:	ea42 0203 	orr.w	r2, r2, r3
20003a70:	7b3b      	ldrb	r3, [r7, #12]
20003a72:	ea4f 2303 	mov.w	r3, r3, lsl #8
20003a76:	ea42 0203 	orr.w	r2, r2, r3
20003a7a:	7b7b      	ldrb	r3, [r7, #13]
20003a7c:	ea42 0303 	orr.w	r3, r2, r3
20003a80:	461a      	mov	r2, r3
20003a82:	f24d 03d8 	movw	r3, #53464	; 0xd0d8
20003a86:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a8a:	601a      	str	r2, [r3, #0]

	cmd_adf_read_addr += 4;
20003a8c:	f24c 23e0 	movw	r3, #49888	; 0xc2e0
20003a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a94:	681b      	ldr	r3, [r3, #0]
20003a96:	f103 0204 	add.w	r2, r3, #4
20003a9a:	f24c 23e0 	movw	r3, #49888	; 0xc2e0
20003a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003aa2:	601a      	str	r2, [r3, #0]

	adf_read_from_memory(RMODE_1, cmd_adf_read_addr, data_read, 6);
20003aa4:	f24c 23e0 	movw	r3, #49888	; 0xc2e0
20003aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003aac:	681a      	ldr	r2, [r3, #0]
20003aae:	f107 0308 	add.w	r3, r7, #8
20003ab2:	f04f 0078 	mov.w	r0, #120	; 0x78
20003ab6:	4611      	mov	r1, r2
20003ab8:	461a      	mov	r2, r3
20003aba:	f04f 0306 	mov.w	r3, #6
20003abe:	f002 f813 	bl	20005ae8 <adf_read_from_memory>

	cmd_adf_data[1] = (data_read[2] << 24) | (data_read[3] << 16) | (data_read[4] << 8) | (data_read[5]);
20003ac2:	7abb      	ldrb	r3, [r7, #10]
20003ac4:	ea4f 6203 	mov.w	r2, r3, lsl #24
20003ac8:	7afb      	ldrb	r3, [r7, #11]
20003aca:	ea4f 4303 	mov.w	r3, r3, lsl #16
20003ace:	ea42 0203 	orr.w	r2, r2, r3
20003ad2:	7b3b      	ldrb	r3, [r7, #12]
20003ad4:	ea4f 2303 	mov.w	r3, r3, lsl #8
20003ad8:	ea42 0203 	orr.w	r2, r2, r3
20003adc:	7b7b      	ldrb	r3, [r7, #13]
20003ade:	ea42 0303 	orr.w	r3, r2, r3
20003ae2:	461a      	mov	r2, r3
20003ae4:	f24d 03d8 	movw	r3, #53464	; 0xd0d8
20003ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003aec:	605a      	str	r2, [r3, #4]


}
20003aee:	f107 0710 	add.w	r7, r7, #16
20003af2:	46bd      	mov	sp, r7
20003af4:	bd80      	pop	{r7, pc}
20003af6:	bf00      	nop

20003af8 <exe_rtm>:

void exe_rtm(rx_cmd_t* rcv_cmd){
20003af8:	b480      	push	{r7}
20003afa:	b085      	sub	sp, #20
20003afc:	af00      	add	r7, sp, #0
20003afe:	6078      	str	r0, [r7, #4]
	uint8_t i = 0;
20003b00:	f04f 0300 	mov.w	r3, #0
20003b04:	73fb      	strb	r3, [r7, #15]

	for(;i<16;i++){
20003b06:	e00d      	b.n	20003b24 <exe_rtm+0x2c>
		RTM[i] = rcv_cmd->parameters[i];
20003b08:	7bfa      	ldrb	r2, [r7, #15]
20003b0a:	7bf9      	ldrb	r1, [r7, #15]
20003b0c:	687b      	ldr	r3, [r7, #4]
20003b0e:	440b      	add	r3, r1
20003b10:	7859      	ldrb	r1, [r3, #1]
20003b12:	f24d 0338 	movw	r3, #53304	; 0xd038
20003b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003b1a:	5499      	strb	r1, [r3, r2]
}

void exe_rtm(rx_cmd_t* rcv_cmd){
	uint8_t i = 0;

	for(;i<16;i++){
20003b1c:	7bfb      	ldrb	r3, [r7, #15]
20003b1e:	f103 0301 	add.w	r3, r3, #1
20003b22:	73fb      	strb	r3, [r7, #15]
20003b24:	7bfb      	ldrb	r3, [r7, #15]
20003b26:	2b0f      	cmp	r3, #15
20003b28:	d9ee      	bls.n	20003b08 <exe_rtm+0x10>
		RTM[i] = rcv_cmd->parameters[i];
	}

}
20003b2a:	f107 0714 	add.w	r7, r7, #20
20003b2e:	46bd      	mov	sp, r7
20003b30:	bc80      	pop	{r7}
20003b32:	4770      	bx	lr

20003b34 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20003b34:	b480      	push	{r7}
20003b36:	b083      	sub	sp, #12
20003b38:	af00      	add	r7, sp, #0
20003b3a:	4603      	mov	r3, r0
20003b3c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20003b3e:	f24e 1300 	movw	r3, #57600	; 0xe100
20003b42:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003b46:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003b4a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20003b4e:	79f9      	ldrb	r1, [r7, #7]
20003b50:	f001 011f 	and.w	r1, r1, #31
20003b54:	f04f 0001 	mov.w	r0, #1
20003b58:	fa00 f101 	lsl.w	r1, r0, r1
20003b5c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003b60:	f107 070c 	add.w	r7, r7, #12
20003b64:	46bd      	mov	sp, r7
20003b66:	bc80      	pop	{r7}
20003b68:	4770      	bx	lr
20003b6a:	bf00      	nop

20003b6c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number. 
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
20003b6c:	b480      	push	{r7}
20003b6e:	b083      	sub	sp, #12
20003b70:	af00      	add	r7, sp, #0
20003b72:	4603      	mov	r3, r0
20003b74:	6039      	str	r1, [r7, #0]
20003b76:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
20003b78:	f997 3007 	ldrsb.w	r3, [r7, #7]
20003b7c:	2b00      	cmp	r3, #0
20003b7e:	da10      	bge.n	20003ba2 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
20003b80:	f64e 5300 	movw	r3, #60672	; 0xed00
20003b84:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003b88:	79fa      	ldrb	r2, [r7, #7]
20003b8a:	f002 020f 	and.w	r2, r2, #15
20003b8e:	f1a2 0104 	sub.w	r1, r2, #4
20003b92:	683a      	ldr	r2, [r7, #0]
20003b94:	b2d2      	uxtb	r2, r2
20003b96:	ea4f 1202 	mov.w	r2, r2, lsl #4
20003b9a:	b2d2      	uxtb	r2, r2
20003b9c:	440b      	add	r3, r1
20003b9e:	761a      	strb	r2, [r3, #24]
20003ba0:	e00d      	b.n	20003bbe <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
20003ba2:	f24e 1300 	movw	r3, #57600	; 0xe100
20003ba6:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003baa:	f997 1007 	ldrsb.w	r1, [r7, #7]
20003bae:	683a      	ldr	r2, [r7, #0]
20003bb0:	b2d2      	uxtb	r2, r2
20003bb2:	ea4f 1202 	mov.w	r2, r2, lsl #4
20003bb6:	b2d2      	uxtb	r2, r2
20003bb8:	440b      	add	r3, r1
20003bba:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
20003bbe:	f107 070c 	add.w	r7, r7, #12
20003bc2:	46bd      	mov	sp, r7
20003bc4:	bc80      	pop	{r7}
20003bc6:	4770      	bx	lr

20003bc8 <GPIO1_IRQHandler>:
extern uint8_t cmd_rs485_succ_count;
extern uint8_t cmd_rs485_fail_count;
extern uint8_t store_in_sd_card;
extern timer_instance_t sd_timer;

void GPIO1_IRQHandler( void ){
20003bc8:	b580      	push	{r7, lr}
20003bca:	b084      	sub	sp, #16
20003bcc:	af00      	add	r7, sp, #0
    uint16_t a, i = 0;
20003bce:	f04f 0300 	mov.w	r3, #0
20003bd2:	817b      	strh	r3, [r7, #10]
    a  = 1;
20003bd4:	f04f 0301 	mov.w	r3, #1
20003bd8:	813b      	strh	r3, [r7, #8]
    uint16_t buf[1];
    uint16_t r_addr, w_addr;
    buf[0] = 0xFF;
20003bda:	f04f 03ff 	mov.w	r3, #255	; 0xff
20003bde:	80bb      	strh	r3, [r7, #4]
//
		r_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_RADDR);
20003be0:	f245 000c 	movw	r0, #20492	; 0x500c
20003be4:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003be8:	f002 face 	bl	20006188 <HW_get_16bit_reg>
20003bec:	4603      	mov	r3, r0
20003bee:	81bb      	strh	r3, [r7, #12]
		w_addr = HAL_get_16bit_reg(RS_485_Controller_0, READ_WADDR);
20003bf0:	f245 0010 	movw	r0, #20496	; 0x5010
20003bf4:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003bf8:	f002 fac6 	bl	20006188 <HW_get_16bit_reg>
20003bfc:	4603      	mov	r3, r0
20003bfe:	81fb      	strh	r3, [r7, #14]

		//Start storing the packets in sd card

		store_in_sd_card = 1;
20003c00:	f24c 23d9 	movw	r3, #49881	; 0xc2d9
20003c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003c08:	f04f 0201 	mov.w	r2, #1
20003c0c:	701a      	strb	r2, [r3, #0]


		MSS_GPIO_clear_irq(MSS_GPIO_1);
20003c0e:	f04f 0001 	mov.w	r0, #1
20003c12:	f005 fcad 	bl	20009570 <MSS_GPIO_clear_irq>
		return ;


    //Start storing in SD_CARD
    //Clear the interrupt after reading a 256 block packet
}
20003c16:	f107 0710 	add.w	r7, r7, #16
20003c1a:	46bd      	mov	sp, r7
20003c1c:	bd80      	pop	{r7, pc}
20003c1e:	bf00      	nop

20003c20 <GPIO3_IRQHandler>:

void GPIO3_IRQHandler(void){
20003c20:	b590      	push	{r4, r7, lr}
20003c22:	b08b      	sub	sp, #44	; 0x2c
20003c24:	af00      	add	r7, sp, #0

//	uint8_t cmd[32];
//	for(;i<32;i++){
//		cmd[i] = HAL_get_8bit_reg(RS_485_Controller_0, READ_SRAM_CMD);
//	}
	uint8_t i = 0;
20003c26:	f04f 0300 	mov.w	r3, #0
20003c2a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	uint8_t cmd[32];
	for(;i<32;i++){
20003c2e:	e015      	b.n	20003c5c <GPIO3_IRQHandler+0x3c>
		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
20003c30:	f897 4027 	ldrb.w	r4, [r7, #39]	; 0x27
20003c34:	f24b 000c 	movw	r0, #45068	; 0xb00c
20003c38:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003c3c:	f002 fabc 	bl	200061b8 <HW_get_8bit_reg>
20003c40:	4603      	mov	r3, r0
20003c42:	461a      	mov	r2, r3
20003c44:	f107 0128 	add.w	r1, r7, #40	; 0x28
20003c48:	eb01 0304 	add.w	r3, r1, r4
20003c4c:	f803 2c24 	strb.w	r2, [r3, #-36]
//	for(;i<32;i++){
//		cmd[i] = HAL_get_8bit_reg(RS_485_Controller_0, READ_SRAM_CMD);
//	}
	uint8_t i = 0;
	uint8_t cmd[32];
	for(;i<32;i++){
20003c50:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20003c54:	f103 0301 	add.w	r3, r3, #1
20003c58:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
20003c5c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20003c60:	2b1f      	cmp	r3, #31
20003c62:	d9e5      	bls.n	20003c30 <GPIO3_IRQHandler+0x10>
		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
	}

	for(;i<32;i++){
20003c64:	e015      	b.n	20003c92 <GPIO3_IRQHandler+0x72>
		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
20003c66:	f897 4027 	ldrb.w	r4, [r7, #39]	; 0x27
20003c6a:	f24b 000c 	movw	r0, #45068	; 0xb00c
20003c6e:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003c72:	f002 faa1 	bl	200061b8 <HW_get_8bit_reg>
20003c76:	4603      	mov	r3, r0
20003c78:	461a      	mov	r2, r3
20003c7a:	f107 0128 	add.w	r1, r7, #40	; 0x28
20003c7e:	eb01 0304 	add.w	r3, r1, r4
20003c82:	f803 2c24 	strb.w	r2, [r3, #-36]
	uint8_t cmd[32];
	for(;i<32;i++){
		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
	}

	for(;i<32;i++){
20003c86:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20003c8a:	f103 0301 	add.w	r3, r3, #1
20003c8e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
20003c92:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20003c96:	2b1f      	cmp	r3, #31
20003c98:	d9e5      	bls.n	20003c66 <GPIO3_IRQHandler+0x46>
		cmd[i] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_SRAM_CMD);
	}

	get_cmd(cmd, 0);
20003c9a:	f107 0304 	add.w	r3, r7, #4
20003c9e:	4618      	mov	r0, r3
20003ca0:	f04f 0100 	mov.w	r1, #0
20003ca4:	f7ff f864 	bl	20002d70 <get_cmd>
//	else{
//		cmd_rs485_fail_count++;
//	}


	MSS_GPIO_clear_irq( MSS_GPIO_3);
20003ca8:	f04f 0003 	mov.w	r0, #3
20003cac:	f005 fc60 	bl	20009570 <MSS_GPIO_clear_irq>

}
20003cb0:	f107 072c 	add.w	r7, r7, #44	; 0x2c
20003cb4:	46bd      	mov	sp, r7
20003cb6:	bd90      	pop	{r4, r7, pc}

20003cb8 <get_time_vector>:

void get_time_vector(uint8_t* time_vect){
20003cb8:	b590      	push	{r4, r7, lr}
20003cba:	b085      	sub	sp, #20
20003cbc:	af00      	add	r7, sp, #0
20003cbe:	6078      	str	r0, [r7, #4]

	uint8_t i = 0;
20003cc0:	f04f 0300 	mov.w	r3, #0
20003cc4:	73fb      	strb	r3, [r7, #15]

	for(;i<32;i++){
20003cc6:	e00f      	b.n	20003ce8 <get_time_vector+0x30>
		time_vect[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
20003cc8:	7bfa      	ldrb	r2, [r7, #15]
20003cca:	687b      	ldr	r3, [r7, #4]
20003ccc:	eb02 0403 	add.w	r4, r2, r3
20003cd0:	f24c 000c 	movw	r0, #49164	; 0xc00c
20003cd4:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003cd8:	f002 fa6e 	bl	200061b8 <HW_get_8bit_reg>
20003cdc:	4603      	mov	r3, r0
20003cde:	7023      	strb	r3, [r4, #0]

void get_time_vector(uint8_t* time_vect){

	uint8_t i = 0;

	for(;i<32;i++){
20003ce0:	7bfb      	ldrb	r3, [r7, #15]
20003ce2:	f103 0301 	add.w	r3, r3, #1
20003ce6:	73fb      	strb	r3, [r7, #15]
20003ce8:	7bfb      	ldrb	r3, [r7, #15]
20003cea:	2b1f      	cmp	r3, #31
20003cec:	d9ec      	bls.n	20003cc8 <get_time_vector+0x10>
		time_vect[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
	 }
	 i=0;
20003cee:	f04f 0300 	mov.w	r3, #0
20003cf2:	73fb      	strb	r3, [r7, #15]
	 for(;i<32;i++){
20003cf4:	e00f      	b.n	20003d16 <get_time_vector+0x5e>
		 time_vect[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
20003cf6:	7bfa      	ldrb	r2, [r7, #15]
20003cf8:	687b      	ldr	r3, [r7, #4]
20003cfa:	eb02 0403 	add.w	r4, r2, r3
20003cfe:	f24c 000c 	movw	r0, #49164	; 0xc00c
20003d02:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003d06:	f002 fa57 	bl	200061b8 <HW_get_8bit_reg>
20003d0a:	4603      	mov	r3, r0
20003d0c:	7023      	strb	r3, [r4, #0]

	for(;i<32;i++){
		time_vect[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
	 }
	 i=0;
	 for(;i<32;i++){
20003d0e:	7bfb      	ldrb	r3, [r7, #15]
20003d10:	f103 0301 	add.w	r3, r3, #1
20003d14:	73fb      	strb	r3, [r7, #15]
20003d16:	7bfb      	ldrb	r3, [r7, #15]
20003d18:	2b1f      	cmp	r3, #31
20003d1a:	d9ec      	bls.n	20003cf6 <get_time_vector+0x3e>
		 time_vect[i] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
	 }
}
20003d1c:	f107 0714 	add.w	r7, r7, #20
20003d20:	46bd      	mov	sp, r7
20003d22:	bd90      	pop	{r4, r7, pc}

20003d24 <init_RS485_Controller>:


uint8_t init_RS485_Controller(){
20003d24:	b580      	push	{r7, lr}
20003d26:	b084      	sub	sp, #16
20003d28:	af00      	add	r7, sp, #0

    MSS_GPIO_config(MSS_GPIO_1, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);		//SRAM Full INTR
20003d2a:	f04f 0001 	mov.w	r0, #1
20003d2e:	f04f 0142 	mov.w	r1, #66	; 0x42
20003d32:	f005 fb97 	bl	20009464 <MSS_GPIO_config>
    MSS_GPIO_enable_irq(MSS_GPIO_1);
20003d36:	f04f 0001 	mov.w	r0, #1
20003d3a:	f005 fbe9 	bl	20009510 <MSS_GPIO_enable_irq>
    NVIC_EnableIRQ(GPIO1_IRQn);
20003d3e:	f04f 0033 	mov.w	r0, #51	; 0x33
20003d42:	f7ff fef7 	bl	20003b34 <NVIC_EnableIRQ>
    NVIC_SetPriority(GPIO1_IRQn, 255);
20003d46:	f04f 0033 	mov.w	r0, #51	; 0x33
20003d4a:	f04f 01ff 	mov.w	r1, #255	; 0xff
20003d4e:	f7ff ff0d 	bl	20003b6c <NVIC_SetPriority>

    MSS_GPIO_config(MSS_GPIO_3, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_NEGATIVE);		//RS485_cmd_INTR
20003d52:	f04f 0003 	mov.w	r0, #3
20003d56:	f04f 0162 	mov.w	r1, #98	; 0x62
20003d5a:	f005 fb83 	bl	20009464 <MSS_GPIO_config>
	MSS_GPIO_enable_irq(MSS_GPIO_3);
20003d5e:	f04f 0003 	mov.w	r0, #3
20003d62:	f005 fbd5 	bl	20009510 <MSS_GPIO_enable_irq>
	NVIC_EnableIRQ(GPIO3_IRQn);
20003d66:	f04f 0035 	mov.w	r0, #53	; 0x35
20003d6a:	f7ff fee3 	bl	20003b34 <NVIC_EnableIRQ>
	NVIC_SetPriority(GPIO3_IRQn, 253);
20003d6e:	f04f 0035 	mov.w	r0, #53	; 0x35
20003d72:	f04f 01fd 	mov.w	r1, #253	; 0xfd
20003d76:	f7ff fef9 	bl	20003b6c <NVIC_SetPriority>
    uint16_t buf[1];
    uint16_t waddr, i, raddr;
    buf[0] = 0;
20003d7a:	f04f 0300 	mov.w	r3, #0
20003d7e:	80bb      	strh	r3, [r7, #4]
    i = 0;
20003d80:	f04f 0300 	mov.w	r3, #0
20003d84:	817b      	strh	r3, [r7, #10]
    uint8_t cont;
    uint8_t status;

    HAL_set_8bit_reg(RS_485_Controller_0, WRITE_SLAVE_ADDR, (uint_fast8_t) SLAVE_ADDR);
20003d86:	f245 0014 	movw	r0, #20500	; 0x5014
20003d8a:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003d8e:	f04f 010a 	mov.w	r1, #10
20003d92:	f002 fa0f 	bl	200061b4 <HW_set_8bit_reg>

    HAL_set_8bit_reg(RS_485_Controller_0, WRITE_CLKS_PER_BIT, (uint_fast8_t) CLKS_PER_BIT);
20003d96:	f245 0018 	movw	r0, #20504	; 0x5018
20003d9a:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003d9e:	f04f 0119 	mov.w	r1, #25
20003da2:	f002 fa07 	bl	200061b4 <HW_set_8bit_reg>

    HAL_set_8bit_reg(APB_READ_CMD_0, WRITE_PAY_ID, (uint_fast8_t) PAY_ID);
20003da6:	f24b 0010 	movw	r0, #45072	; 0xb010
20003daa:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003dae:	f04f 0107 	mov.w	r1, #7
20003db2:	f002 f9ff 	bl	200061b4 <HW_set_8bit_reg>

    cont = HAL_get_8bit_reg(RS_485_Controller_0, READ_CONST);
20003db6:	f245 0008 	movw	r0, #20488	; 0x5008
20003dba:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003dbe:	f002 f9fb 	bl	200061b8 <HW_get_8bit_reg>
20003dc2:	4603      	mov	r3, r0
20003dc4:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
20003dc6:	7bbb      	ldrb	r3, [r7, #14]
20003dc8:	2bab      	cmp	r3, #171	; 0xab
20003dca:	d007      	beq.n	20003ddc <init_RS485_Controller+0xb8>
    	status |= 0x01;
20003dcc:	7bfb      	ldrb	r3, [r7, #15]
20003dce:	f043 0301 	orr.w	r3, r3, #1
20003dd2:	73fb      	strb	r3, [r7, #15]
    	status  = status << 1;
20003dd4:	7bfb      	ldrb	r3, [r7, #15]
20003dd6:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003dda:	73fb      	strb	r3, [r7, #15]
    }
    status  = status << 1;
20003ddc:	7bfb      	ldrb	r3, [r7, #15]
20003dde:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003de2:	73fb      	strb	r3, [r7, #15]
    cont = HAL_get_8bit_reg(APB_READ_CMD_0, READ_CONST);
20003de4:	f24b 0008 	movw	r0, #45064	; 0xb008
20003de8:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003dec:	f002 f9e4 	bl	200061b8 <HW_get_8bit_reg>
20003df0:	4603      	mov	r3, r0
20003df2:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
20003df4:	7bbb      	ldrb	r3, [r7, #14]
20003df6:	2bab      	cmp	r3, #171	; 0xab
20003df8:	d007      	beq.n	20003e0a <init_RS485_Controller+0xe6>
		status |= 0x01;
20003dfa:	7bfb      	ldrb	r3, [r7, #15]
20003dfc:	f043 0301 	orr.w	r3, r3, #1
20003e00:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
20003e02:	7bfb      	ldrb	r3, [r7, #15]
20003e04:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e08:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
20003e0a:	7bfb      	ldrb	r3, [r7, #15]
20003e0c:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e10:	73fb      	strb	r3, [r7, #15]
    cont = HAL_get_8bit_reg(APB_READ_TLM_0, READ_CONST);
20003e12:	f24c 0008 	movw	r0, #49160	; 0xc008
20003e16:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003e1a:	f002 f9cd 	bl	200061b8 <HW_get_8bit_reg>
20003e1e:	4603      	mov	r3, r0
20003e20:	73bb      	strb	r3, [r7, #14]
    if(cont != 0xab){
20003e22:	7bbb      	ldrb	r3, [r7, #14]
20003e24:	2bab      	cmp	r3, #171	; 0xab
20003e26:	d007      	beq.n	20003e38 <init_RS485_Controller+0x114>
		status |= 0x01;
20003e28:	7bfb      	ldrb	r3, [r7, #15]
20003e2a:	f043 0301 	orr.w	r3, r3, #1
20003e2e:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
20003e30:	7bfb      	ldrb	r3, [r7, #15]
20003e32:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e36:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
20003e38:	7bfb      	ldrb	r3, [r7, #15]
20003e3a:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e3e:	73fb      	strb	r3, [r7, #15]

	raddr = HAL_get_16bit_reg(RS_485_CONTROLLER_0, READ_RADDR);
20003e40:	f245 000c 	movw	r0, #20492	; 0x500c
20003e44:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003e48:	f002 f99e 	bl	20006188 <HW_get_16bit_reg>
20003e4c:	4603      	mov	r3, r0
20003e4e:	81bb      	strh	r3, [r7, #12]

	if(raddr != 0){
20003e50:	89bb      	ldrh	r3, [r7, #12]
20003e52:	2b00      	cmp	r3, #0
20003e54:	d007      	beq.n	20003e66 <init_RS485_Controller+0x142>
		status |= 0x01;
20003e56:	7bfb      	ldrb	r3, [r7, #15]
20003e58:	f043 0301 	orr.w	r3, r3, #1
20003e5c:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
20003e5e:	7bfb      	ldrb	r3, [r7, #15]
20003e60:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e64:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
20003e66:	7bfb      	ldrb	r3, [r7, #15]
20003e68:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e6c:	73fb      	strb	r3, [r7, #15]

	waddr = HAL_get_16bit_reg(RS_485_Controller_0, READ_WADDR);
20003e6e:	f245 0010 	movw	r0, #20496	; 0x5010
20003e72:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003e76:	f002 f987 	bl	20006188 <HW_get_16bit_reg>
20003e7a:	4603      	mov	r3, r0
20003e7c:	813b      	strh	r3, [r7, #8]
	if(waddr != 2){
20003e7e:	893b      	ldrh	r3, [r7, #8]
20003e80:	2b02      	cmp	r3, #2
20003e82:	d007      	beq.n	20003e94 <init_RS485_Controller+0x170>
		status |= 0x01;
20003e84:	7bfb      	ldrb	r3, [r7, #15]
20003e86:	f043 0301 	orr.w	r3, r3, #1
20003e8a:	73fb      	strb	r3, [r7, #15]
		status  = status << 1;
20003e8c:	7bfb      	ldrb	r3, [r7, #15]
20003e8e:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e92:	73fb      	strb	r3, [r7, #15]
	}
	status  = status << 1;
20003e94:	7bfb      	ldrb	r3, [r7, #15]
20003e96:	ea4f 0343 	mov.w	r3, r3, lsl #1
20003e9a:	73fb      	strb	r3, [r7, #15]


    buf[0] = HAL_get_8bit_reg(APB_READ_CMD_0, READ_RADDR);
20003e9c:	f24b 000c 	movw	r0, #45068	; 0xb00c
20003ea0:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003ea4:	f002 f988 	bl	200061b8 <HW_get_8bit_reg>
20003ea8:	4603      	mov	r3, r0
20003eaa:	80bb      	strh	r3, [r7, #4]
	buf[0] = HAL_get_8bit_reg(APB_READ_TLM_0, READ_RADDR);
20003eac:	f24c 000c 	movw	r0, #49164	; 0xc00c
20003eb0:	f2c5 0000 	movt	r0, #20480	; 0x5000
20003eb4:	f002 f980 	bl	200061b8 <HW_get_8bit_reg>
20003eb8:	4603      	mov	r3, r0
20003eba:	80bb      	strh	r3, [r7, #4]
//    for(;i<1025;i++){
//
//        HAL_set_16bit_reg(RS_485_Controller_0, WRITE_SRAM, (uint_fast16_t) buf[0]);
//    }

    return status;
20003ebc:	7bfb      	ldrb	r3, [r7, #15]
}
20003ebe:	4618      	mov	r0, r3
20003ec0:	f107 0710 	add.w	r7, r7, #16
20003ec4:	46bd      	mov	sp, r7
20003ec6:	bd80      	pop	{r7, pc}

20003ec8 <vc_write>:
uint8_t config_reg;
i2c_status_t status;
uint8_t read[2];
uint16_t bvol;

uint8_t vc_write(uint8_t addr, uint8_t *tx, uint8_t tx_size) {
20003ec8:	b580      	push	{r7, lr}
20003eca:	b086      	sub	sp, #24
20003ecc:	af02      	add	r7, sp, #8
20003ece:	60b9      	str	r1, [r7, #8]
20003ed0:	4613      	mov	r3, r2
20003ed2:	4602      	mov	r2, r0
20003ed4:	73fa      	strb	r2, [r7, #15]
20003ed6:	71fb      	strb	r3, [r7, #7]
     count = 0;
20003ed8:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003edc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003ee0:	f04f 0200 	mov.w	r2, #0
20003ee4:	701a      	strb	r2, [r3, #0]
    while(count < 10) {
20003ee6:	e032      	b.n	20003f4e <vc_write+0x86>
        I2C_write(VC_SENSOR_I2C,addr,tx,tx_size,I2C_RELEASE_BUS);
20003ee8:	79fb      	ldrb	r3, [r7, #7]
20003eea:	7bfa      	ldrb	r2, [r7, #15]
20003eec:	f04f 0100 	mov.w	r1, #0
20003ef0:	9100      	str	r1, [sp, #0]
20003ef2:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
20003ef6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003efa:	4611      	mov	r1, r2
20003efc:	68ba      	ldr	r2, [r7, #8]
20003efe:	f006 f837 	bl	20009f70 <I2C_write>
        status = I2C_wait_complete(VC_SENSOR_I2C,I2C_NO_TIMEOUT);
20003f02:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
20003f06:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003f0a:	f04f 0100 	mov.w	r1, #0
20003f0e:	f006 f9ab 	bl	2000a268 <I2C_wait_complete>
20003f12:	4603      	mov	r3, r0
20003f14:	461a      	mov	r2, r3
20003f16:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20003f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f1e:	701a      	strb	r2, [r3, #0]
        if(status == I2C_SUCCESS) {
20003f20:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20003f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f28:	781b      	ldrb	r3, [r3, #0]
20003f2a:	2b00      	cmp	r3, #0
20003f2c:	d102      	bne.n	20003f34 <vc_write+0x6c>
            return 0;
20003f2e:	f04f 0300 	mov.w	r3, #0
20003f32:	e018      	b.n	20003f66 <vc_write+0x9e>
        }
        count++;
20003f34:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f3c:	781b      	ldrb	r3, [r3, #0]
20003f3e:	f103 0301 	add.w	r3, r3, #1
20003f42:	b2da      	uxtb	r2, r3
20003f44:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003f48:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f4c:	701a      	strb	r2, [r3, #0]
uint8_t read[2];
uint16_t bvol;

uint8_t vc_write(uint8_t addr, uint8_t *tx, uint8_t tx_size) {
     count = 0;
    while(count < 10) {
20003f4e:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f56:	781b      	ldrb	r3, [r3, #0]
20003f58:	2b09      	cmp	r3, #9
20003f5a:	d9c5      	bls.n	20003ee8 <vc_write+0x20>
        if(status == I2C_SUCCESS) {
            return 0;
        }
        count++;
    }
    return count;
20003f5c:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003f60:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f64:	781b      	ldrb	r3, [r3, #0]

}
20003f66:	4618      	mov	r0, r3
20003f68:	f107 0710 	add.w	r7, r7, #16
20003f6c:	46bd      	mov	sp, r7
20003f6e:	bd80      	pop	{r7, pc}

20003f70 <vc_read>:

uint8_t vc_read(uint8_t addr, uint8_t *rx, uint8_t rx_size) {
20003f70:	b580      	push	{r7, lr}
20003f72:	b086      	sub	sp, #24
20003f74:	af02      	add	r7, sp, #8
20003f76:	60b9      	str	r1, [r7, #8]
20003f78:	4613      	mov	r3, r2
20003f7a:	4602      	mov	r2, r0
20003f7c:	73fa      	strb	r2, [r7, #15]
20003f7e:	71fb      	strb	r3, [r7, #7]
    count = 0;
20003f80:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f88:	f04f 0200 	mov.w	r2, #0
20003f8c:	701a      	strb	r2, [r3, #0]
    while(count < 10) {
20003f8e:	e032      	b.n	20003ff6 <vc_read+0x86>
        I2C_read(VC_SENSOR_I2C,addr,rx,rx_size,I2C_RELEASE_BUS);
20003f90:	79fb      	ldrb	r3, [r7, #7]
20003f92:	7bfa      	ldrb	r2, [r7, #15]
20003f94:	f04f 0100 	mov.w	r1, #0
20003f98:	9100      	str	r1, [sp, #0]
20003f9a:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
20003f9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003fa2:	4611      	mov	r1, r2
20003fa4:	68ba      	ldr	r2, [r7, #8]
20003fa6:	f006 f855 	bl	2000a054 <I2C_read>
        status = I2C_wait_complete(VC_SENSOR_I2C,I2C_NO_TIMEOUT);
20003faa:	f24c 30b8 	movw	r0, #50104	; 0xc3b8
20003fae:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003fb2:	f04f 0100 	mov.w	r1, #0
20003fb6:	f006 f957 	bl	2000a268 <I2C_wait_complete>
20003fba:	4603      	mov	r3, r0
20003fbc:	461a      	mov	r2, r3
20003fbe:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20003fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003fc6:	701a      	strb	r2, [r3, #0]
        if(status == I2C_SUCCESS) {
20003fc8:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20003fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003fd0:	781b      	ldrb	r3, [r3, #0]
20003fd2:	2b00      	cmp	r3, #0
20003fd4:	d102      	bne.n	20003fdc <vc_read+0x6c>
            return 0;
20003fd6:	f04f 0300 	mov.w	r3, #0
20003fda:	e018      	b.n	2000400e <vc_read+0x9e>
        }
        count++;
20003fdc:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003fe4:	781b      	ldrb	r3, [r3, #0]
20003fe6:	f103 0301 	add.w	r3, r3, #1
20003fea:	b2da      	uxtb	r2, r3
20003fec:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003ff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003ff4:	701a      	strb	r2, [r3, #0]

}

uint8_t vc_read(uint8_t addr, uint8_t *rx, uint8_t rx_size) {
    count = 0;
    while(count < 10) {
20003ff6:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20003ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003ffe:	781b      	ldrb	r3, [r3, #0]
20004000:	2b09      	cmp	r3, #9
20004002:	d9c5      	bls.n	20003f90 <vc_read+0x20>
        if(status == I2C_SUCCESS) {
            return 0;
        }
        count++;
    }
    return count;
20004004:	f24d 33f4 	movw	r3, #54260	; 0xd3f4
20004008:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000400c:	781b      	ldrb	r3, [r3, #0]

}
2000400e:	4618      	mov	r0, r3
20004010:	f107 0710 	add.w	r7, r7, #16
20004014:	46bd      	mov	sp, r7
20004016:	bd80      	pop	{r7, pc}

20004018 <vc_read_reg>:

uint8_t vc_read_reg(uint8_t vc_addr, uint8_t reg_addr,uint8_t *rx) {
20004018:	b580      	push	{r7, lr}
2000401a:	b082      	sub	sp, #8
2000401c:	af00      	add	r7, sp, #0
2000401e:	460b      	mov	r3, r1
20004020:	603a      	str	r2, [r7, #0]
20004022:	4602      	mov	r2, r0
20004024:	71fa      	strb	r2, [r7, #7]
20004026:	71bb      	strb	r3, [r7, #6]
    if((vc_write(vc_addr,&reg_addr,sizeof(reg_addr))) >= 10) {
20004028:	79fa      	ldrb	r2, [r7, #7]
2000402a:	f107 0306 	add.w	r3, r7, #6
2000402e:	4610      	mov	r0, r2
20004030:	4619      	mov	r1, r3
20004032:	f04f 0201 	mov.w	r2, #1
20004036:	f7ff ff47 	bl	20003ec8 <vc_write>
2000403a:	4603      	mov	r3, r0
2000403c:	2b09      	cmp	r3, #9
2000403e:	d902      	bls.n	20004046 <vc_read_reg+0x2e>
        return 1;
20004040:	f04f 0301 	mov.w	r3, #1
20004044:	e00e      	b.n	20004064 <vc_read_reg+0x4c>
    }
    if((vc_read(vc_addr,(uint8_t*)rx,2)) >= 10) {
20004046:	79fb      	ldrb	r3, [r7, #7]
20004048:	4618      	mov	r0, r3
2000404a:	6839      	ldr	r1, [r7, #0]
2000404c:	f04f 0202 	mov.w	r2, #2
20004050:	f7ff ff8e 	bl	20003f70 <vc_read>
20004054:	4603      	mov	r3, r0
20004056:	2b09      	cmp	r3, #9
20004058:	d902      	bls.n	20004060 <vc_read_reg+0x48>
        return 1;
2000405a:	f04f 0301 	mov.w	r3, #1
2000405e:	e001      	b.n	20004064 <vc_read_reg+0x4c>
    }

    return 0;
20004060:	f04f 0300 	mov.w	r3, #0
}
20004064:	4618      	mov	r0, r3
20004066:	f107 0708 	add.w	r7, r7, #8
2000406a:	46bd      	mov	sp, r7
2000406c:	bd80      	pop	{r7, pc}
2000406e:	bf00      	nop

20004070 <vc_init>:
    }

    return 0;
}

uint8_t vc_init(uint8_t addr) {
20004070:	b580      	push	{r7, lr}
20004072:	b082      	sub	sp, #8
20004074:	af00      	add	r7, sp, #0
20004076:	4603      	mov	r3, r0
20004078:	71fb      	strb	r3, [r7, #7]

    init_command = VC_INIT_CMD;
2000407a:	f24d 33ec 	movw	r3, #54252	; 0xd3ec
2000407e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004082:	f247 0207 	movw	r2, #28679	; 0x7007
20004086:	801a      	strh	r2, [r3, #0]
    config_reg = VC_CONFIG_REG;
20004088:	f24d 33f5 	movw	r3, #54261	; 0xd3f5
2000408c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004090:	f04f 0200 	mov.w	r2, #0
20004094:	701a      	strb	r2, [r3, #0]
    if(vc_write(addr,&config_reg,sizeof(config_reg)) >= 10) {
20004096:	79fb      	ldrb	r3, [r7, #7]
20004098:	4618      	mov	r0, r3
2000409a:	f24d 31f5 	movw	r1, #54261	; 0xd3f5
2000409e:	f2c2 0100 	movt	r1, #8192	; 0x2000
200040a2:	f04f 0201 	mov.w	r2, #1
200040a6:	f7ff ff0f 	bl	20003ec8 <vc_write>
200040aa:	4603      	mov	r3, r0
200040ac:	2b09      	cmp	r3, #9
200040ae:	d902      	bls.n	200040b6 <vc_init+0x46>
        return 1;
200040b0:	f04f 0301 	mov.w	r3, #1
200040b4:	e012      	b.n	200040dc <vc_init+0x6c>
    }
    if(vc_write(addr,(uint8_t*)(&init_command),sizeof(init_command)) >= 10) {
200040b6:	f24d 33ec 	movw	r3, #54252	; 0xd3ec
200040ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200040be:	79fa      	ldrb	r2, [r7, #7]
200040c0:	4610      	mov	r0, r2
200040c2:	4619      	mov	r1, r3
200040c4:	f04f 0202 	mov.w	r2, #2
200040c8:	f7ff fefe 	bl	20003ec8 <vc_write>
200040cc:	4603      	mov	r3, r0
200040ce:	2b09      	cmp	r3, #9
200040d0:	d902      	bls.n	200040d8 <vc_init+0x68>
        return 1;
200040d2:	f04f 0301 	mov.w	r3, #1
200040d6:	e001      	b.n	200040dc <vc_init+0x6c>
    }

    return 0;
200040d8:	f04f 0300 	mov.w	r3, #0
}
200040dc:	4618      	mov	r0, r3
200040de:	f107 0708 	add.w	r7, r7, #8
200040e2:	46bd      	mov	sp, r7
200040e4:	bd80      	pop	{r7, pc}
200040e6:	bf00      	nop

200040e8 <read_bus_voltage>:

uint16_t read_bus_voltage(uint8_t addr, uint8_t chx,uint8_t *flag) {
200040e8:	b580      	push	{r7, lr}
200040ea:	b082      	sub	sp, #8
200040ec:	af00      	add	r7, sp, #0
200040ee:	460b      	mov	r3, r1
200040f0:	603a      	str	r2, [r7, #0]
200040f2:	4602      	mov	r2, r0
200040f4:	71fa      	strb	r2, [r7, #7]
200040f6:	71bb      	strb	r3, [r7, #6]
    read[0] = 0;
200040f8:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
200040fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004100:	f04f 0200 	mov.w	r2, #0
20004104:	701a      	strb	r2, [r3, #0]
    read[1] = 0;
20004106:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
2000410a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000410e:	f04f 0200 	mov.w	r2, #0
20004112:	705a      	strb	r2, [r3, #1]
    bvol = 0;
20004114:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004118:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000411c:	f04f 0200 	mov.w	r2, #0
20004120:	801a      	strh	r2, [r3, #0]
    if(vc_read_reg(addr,VC_BUSV_CHx(chx),read) == 0) {
20004122:	79bb      	ldrb	r3, [r7, #6]
20004124:	ea4f 0343 	mov.w	r3, r3, lsl #1
20004128:	b2db      	uxtb	r3, r3
2000412a:	79fa      	ldrb	r2, [r7, #7]
2000412c:	4610      	mov	r0, r2
2000412e:	4619      	mov	r1, r3
20004130:	f24d 32f0 	movw	r2, #54256	; 0xd3f0
20004134:	f2c2 0200 	movt	r2, #8192	; 0x2000
20004138:	f7ff ff6e 	bl	20004018 <vc_read_reg>
2000413c:	4603      	mov	r3, r0
2000413e:	2b00      	cmp	r3, #0
20004140:	d11a      	bne.n	20004178 <read_bus_voltage+0x90>
        bvol = read[0]<<8 | read[1];
20004142:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
20004146:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000414a:	781b      	ldrb	r3, [r3, #0]
2000414c:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004150:	b29a      	uxth	r2, r3
20004152:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
20004156:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000415a:	785b      	ldrb	r3, [r3, #1]
2000415c:	ea42 0303 	orr.w	r3, r2, r3
20004160:	b29b      	uxth	r3, r3
20004162:	b29a      	uxth	r2, r3
20004164:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004168:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000416c:	801a      	strh	r2, [r3, #0]
        *flag = 0;
2000416e:	683b      	ldr	r3, [r7, #0]
20004170:	f04f 0200 	mov.w	r2, #0
20004174:	701a      	strb	r2, [r3, #0]
20004176:	e00a      	b.n	2000418e <read_bus_voltage+0xa6>

    } else {
        *flag = 1;
20004178:	683b      	ldr	r3, [r7, #0]
2000417a:	f04f 0201 	mov.w	r2, #1
2000417e:	701a      	strb	r2, [r3, #0]
        bvol = 0;
20004180:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004184:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004188:	f04f 0200 	mov.w	r2, #0
2000418c:	801a      	strh	r2, [r3, #0]
    }
    return bvol;
2000418e:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004192:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004196:	881b      	ldrh	r3, [r3, #0]
}
20004198:	4618      	mov	r0, r3
2000419a:	f107 0708 	add.w	r7, r7, #8
2000419e:	46bd      	mov	sp, r7
200041a0:	bd80      	pop	{r7, pc}
200041a2:	bf00      	nop

200041a4 <read_shunt_voltage>:

uint16_t read_shunt_voltage(uint8_t addr, uint8_t chx,uint8_t *flag) {
200041a4:	b580      	push	{r7, lr}
200041a6:	b082      	sub	sp, #8
200041a8:	af00      	add	r7, sp, #0
200041aa:	460b      	mov	r3, r1
200041ac:	603a      	str	r2, [r7, #0]
200041ae:	4602      	mov	r2, r0
200041b0:	71fa      	strb	r2, [r7, #7]
200041b2:	71bb      	strb	r3, [r7, #6]
    read[0] = 0;
200041b4:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
200041b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041bc:	f04f 0200 	mov.w	r2, #0
200041c0:	701a      	strb	r2, [r3, #0]
    read[1] = 0;
200041c2:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
200041c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041ca:	f04f 0200 	mov.w	r2, #0
200041ce:	705a      	strb	r2, [r3, #1]
    bvol = 0;
200041d0:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
200041d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041d8:	f04f 0200 	mov.w	r2, #0
200041dc:	801a      	strh	r2, [r3, #0]
    if(vc_read_reg(addr,VC_SHUNTV_CHx(chx),read) == 0) {
200041de:	79bb      	ldrb	r3, [r7, #6]
200041e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
200041e4:	b2db      	uxtb	r3, r3
200041e6:	f103 33ff 	add.w	r3, r3, #4294967295
200041ea:	b2db      	uxtb	r3, r3
200041ec:	79fa      	ldrb	r2, [r7, #7]
200041ee:	4610      	mov	r0, r2
200041f0:	4619      	mov	r1, r3
200041f2:	f24d 32f0 	movw	r2, #54256	; 0xd3f0
200041f6:	f2c2 0200 	movt	r2, #8192	; 0x2000
200041fa:	f7ff ff0d 	bl	20004018 <vc_read_reg>
200041fe:	4603      	mov	r3, r0
20004200:	2b00      	cmp	r3, #0
20004202:	d11a      	bne.n	2000423a <read_shunt_voltage+0x96>
        bvol = read[0]<<8 | read[1];
20004204:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
20004208:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000420c:	781b      	ldrb	r3, [r3, #0]
2000420e:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004212:	b29a      	uxth	r2, r3
20004214:	f24d 33f0 	movw	r3, #54256	; 0xd3f0
20004218:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000421c:	785b      	ldrb	r3, [r3, #1]
2000421e:	ea42 0303 	orr.w	r3, r2, r3
20004222:	b29b      	uxth	r3, r3
20004224:	b29a      	uxth	r2, r3
20004226:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
2000422a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000422e:	801a      	strh	r2, [r3, #0]
        *flag = 0;
20004230:	683b      	ldr	r3, [r7, #0]
20004232:	f04f 0200 	mov.w	r2, #0
20004236:	701a      	strb	r2, [r3, #0]
20004238:	e00a      	b.n	20004250 <read_shunt_voltage+0xac>
    } else {
        *flag = 1;
2000423a:	683b      	ldr	r3, [r7, #0]
2000423c:	f04f 0201 	mov.w	r2, #1
20004240:	701a      	strb	r2, [r3, #0]
        bvol = 0;
20004242:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004246:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000424a:	f04f 0200 	mov.w	r2, #0
2000424e:	801a      	strh	r2, [r3, #0]
    }
    return bvol;
20004250:	f24d 33f2 	movw	r3, #54258	; 0xd3f2
20004254:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004258:	881b      	ldrh	r3, [r3, #0]
}
2000425a:	4618      	mov	r0, r3
2000425c:	f107 0708 	add.w	r7, r7, #8
20004260:	46bd      	mov	sp, r7
20004262:	bd80      	pop	{r7, pc}

20004264 <ADC_Init>:
 *      Author: S-SPACE
 */

#include "ADC.h"

uint8_t ADC_Init(i2c_instance_t *i2c_chx,uint8_t address){
20004264:	b580      	push	{r7, lr}
20004266:	b088      	sub	sp, #32
20004268:	af02      	add	r7, sp, #8
2000426a:	6078      	str	r0, [r7, #4]
2000426c:	460b      	mov	r3, r1
2000426e:	70fb      	strb	r3, [r7, #3]
    i2c_status_t status;
    uint8_t channel = 0;
20004270:	f04f 0300 	mov.w	r3, #0
20004274:	75bb      	strb	r3, [r7, #22]
    uint8_t return_value = 0;
20004276:	f04f 0300 	mov.w	r3, #0
2000427a:	75fb      	strb	r3, [r7, #23]
    //Write max and min values to DATA HIGH and DATA LOW registers respectively for all channels
    uint8_t DATA_HIGH[] = {DATA_HIGH_REG(0),DATAHIGH_MAX_H,DATAHIGH_MAX_L};
2000427c:	f64b 6280 	movw	r2, #48768	; 0xbe80
20004280:	f2c2 0200 	movt	r2, #8192	; 0x2000
20004284:	f107 0310 	add.w	r3, r7, #16
20004288:	6812      	ldr	r2, [r2, #0]
2000428a:	4611      	mov	r1, r2
2000428c:	8019      	strh	r1, [r3, #0]
2000428e:	f103 0302 	add.w	r3, r3, #2
20004292:	ea4f 4212 	mov.w	r2, r2, lsr #16
20004296:	701a      	strb	r2, [r3, #0]
    uint8_t DATA_LOW[] = {DATA_LOW_REG(0),DATA_LOW_MIN_H,DATA_LOW_MIN_L};
20004298:	f04f 0304 	mov.w	r3, #4
2000429c:	733b      	strb	r3, [r7, #12]
2000429e:	f04f 0300 	mov.w	r3, #0
200042a2:	737b      	strb	r3, [r7, #13]
200042a4:	f04f 0300 	mov.w	r3, #0
200042a8:	73bb      	strb	r3, [r7, #14]
    for(;channel <= 3;channel++) {
200042aa:	e049      	b.n	20004340 <ADC_Init+0xdc>
        DATA_HIGH[0] = DATA_HIGH_REG(channel);
200042ac:	7dbb      	ldrb	r3, [r7, #22]
200042ae:	461a      	mov	r2, r3
200042b0:	ea4f 0242 	mov.w	r2, r2, lsl #1
200042b4:	4413      	add	r3, r2
200042b6:	b2db      	uxtb	r3, r3
200042b8:	f103 0305 	add.w	r3, r3, #5
200042bc:	b2db      	uxtb	r3, r3
200042be:	743b      	strb	r3, [r7, #16]
        DATA_LOW[0] = DATA_LOW_REG(channel);
200042c0:	7dbb      	ldrb	r3, [r7, #22]
200042c2:	461a      	mov	r2, r3
200042c4:	ea4f 0242 	mov.w	r2, r2, lsl #1
200042c8:	4413      	add	r3, r2
200042ca:	b2db      	uxtb	r3, r3
200042cc:	f103 0304 	add.w	r3, r3, #4
200042d0:	b2db      	uxtb	r3, r3
200042d2:	733b      	strb	r3, [r7, #12]
        I2C_write(i2c_chx,address,DATA_HIGH,3,I2C_RELEASE_BUS);
200042d4:	78fa      	ldrb	r2, [r7, #3]
200042d6:	f107 0310 	add.w	r3, r7, #16
200042da:	f04f 0100 	mov.w	r1, #0
200042de:	9100      	str	r1, [sp, #0]
200042e0:	6878      	ldr	r0, [r7, #4]
200042e2:	4611      	mov	r1, r2
200042e4:	461a      	mov	r2, r3
200042e6:	f04f 0303 	mov.w	r3, #3
200042ea:	f005 fe41 	bl	20009f70 <I2C_write>
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
200042ee:	6878      	ldr	r0, [r7, #4]
200042f0:	f04f 0100 	mov.w	r1, #0
200042f4:	f005 ffb8 	bl	2000a268 <I2C_wait_complete>
200042f8:	4603      	mov	r3, r0
200042fa:	757b      	strb	r3, [r7, #21]
        I2C_write(i2c_chx,address,DATA_LOW,3,I2C_RELEASE_BUS);
200042fc:	78fa      	ldrb	r2, [r7, #3]
200042fe:	f107 030c 	add.w	r3, r7, #12
20004302:	f04f 0100 	mov.w	r1, #0
20004306:	9100      	str	r1, [sp, #0]
20004308:	6878      	ldr	r0, [r7, #4]
2000430a:	4611      	mov	r1, r2
2000430c:	461a      	mov	r2, r3
2000430e:	f04f 0303 	mov.w	r3, #3
20004312:	f005 fe2d 	bl	20009f70 <I2C_write>
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
20004316:	6878      	ldr	r0, [r7, #4]
20004318:	f04f 0100 	mov.w	r1, #0
2000431c:	f005 ffa4 	bl	2000a268 <I2C_wait_complete>
20004320:	4603      	mov	r3, r0
20004322:	757b      	strb	r3, [r7, #21]
        return_value |= (status << channel);
20004324:	7d7a      	ldrb	r2, [r7, #21]
20004326:	7dbb      	ldrb	r3, [r7, #22]
20004328:	fa02 f303 	lsl.w	r3, r2, r3
2000432c:	b2da      	uxtb	r2, r3
2000432e:	7dfb      	ldrb	r3, [r7, #23]
20004330:	ea42 0303 	orr.w	r3, r2, r3
20004334:	b2db      	uxtb	r3, r3
20004336:	75fb      	strb	r3, [r7, #23]
    uint8_t channel = 0;
    uint8_t return_value = 0;
    //Write max and min values to DATA HIGH and DATA LOW registers respectively for all channels
    uint8_t DATA_HIGH[] = {DATA_HIGH_REG(0),DATAHIGH_MAX_H,DATAHIGH_MAX_L};
    uint8_t DATA_LOW[] = {DATA_LOW_REG(0),DATA_LOW_MIN_H,DATA_LOW_MIN_L};
    for(;channel <= 3;channel++) {
20004338:	7dbb      	ldrb	r3, [r7, #22]
2000433a:	f103 0301 	add.w	r3, r3, #1
2000433e:	75bb      	strb	r3, [r7, #22]
20004340:	7dbb      	ldrb	r3, [r7, #22]
20004342:	2b03      	cmp	r3, #3
20004344:	d9b2      	bls.n	200042ac <ADC_Init+0x48>
        I2C_write(i2c_chx,address,DATA_LOW,3,I2C_RELEASE_BUS);
        status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
        return_value |= (status << channel);
    }

    return return_value;
20004346:	7dfb      	ldrb	r3, [r7, #23]
}
20004348:	4618      	mov	r0, r3
2000434a:	f107 0718 	add.w	r7, r7, #24
2000434e:	46bd      	mov	sp, r7
20004350:	bd80      	pop	{r7, pc}
20004352:	bf00      	nop

20004354 <get_ADC_value>:

uint16_t get_ADC_value(i2c_instance_t *i2c_chx,uint8_t address,uint8_t chx,uint8_t *flag) {
20004354:	b580      	push	{r7, lr}
20004356:	b08c      	sub	sp, #48	; 0x30
20004358:	af04      	add	r7, sp, #16
2000435a:	60f8      	str	r0, [r7, #12]
2000435c:	607b      	str	r3, [r7, #4]
2000435e:	460b      	mov	r3, r1
20004360:	72fb      	strb	r3, [r7, #11]
20004362:	4613      	mov	r3, r2
20004364:	72bb      	strb	r3, [r7, #10]
    uint8_t adc_read_value[2];
    uint8_t ch_read[] = {chx};
20004366:	7abb      	ldrb	r3, [r7, #10]
20004368:	753b      	strb	r3, [r7, #20]
    ch_read[0] |= 0x8;
2000436a:	7d3b      	ldrb	r3, [r7, #20]
2000436c:	f043 0308 	orr.w	r3, r3, #8
20004370:	b2db      	uxtb	r3, r3
20004372:	753b      	strb	r3, [r7, #20]
    ch_read[0] = ch_read[0] << 4;
20004374:	7d3b      	ldrb	r3, [r7, #20]
20004376:	ea4f 1303 	mov.w	r3, r3, lsl #4
2000437a:	b2db      	uxtb	r3, r3
2000437c:	753b      	strb	r3, [r7, #20]
    uint8_t status;
    uint16_t voltage;
    I2C_write_read(i2c_chx,address,ch_read,1,adc_read_value,2,I2C_RELEASE_BUS);
2000437e:	7afa      	ldrb	r2, [r7, #11]
20004380:	f107 0314 	add.w	r3, r7, #20
20004384:	f107 0118 	add.w	r1, r7, #24
20004388:	9100      	str	r1, [sp, #0]
2000438a:	f04f 0102 	mov.w	r1, #2
2000438e:	9101      	str	r1, [sp, #4]
20004390:	f04f 0100 	mov.w	r1, #0
20004394:	9102      	str	r1, [sp, #8]
20004396:	68f8      	ldr	r0, [r7, #12]
20004398:	4611      	mov	r1, r2
2000439a:	461a      	mov	r2, r3
2000439c:	f04f 0301 	mov.w	r3, #1
200043a0:	f005 feca 	bl	2000a138 <I2C_write_read>
    status = I2C_wait_complete(i2c_chx, I2C_NO_TIMEOUT);
200043a4:	68f8      	ldr	r0, [r7, #12]
200043a6:	f04f 0100 	mov.w	r1, #0
200043aa:	f005 ff5d 	bl	2000a268 <I2C_wait_complete>
200043ae:	4603      	mov	r3, r0
200043b0:	777b      	strb	r3, [r7, #29]
    if(status != 0) {
200043b2:	7f7b      	ldrb	r3, [r7, #29]
200043b4:	2b00      	cmp	r3, #0
200043b6:	d004      	beq.n	200043c2 <get_ADC_value+0x6e>
        *flag = 1;
200043b8:	687b      	ldr	r3, [r7, #4]
200043ba:	f04f 0201 	mov.w	r2, #1
200043be:	701a      	strb	r2, [r3, #0]
200043c0:	e012      	b.n	200043e8 <get_ADC_value+0x94>
    } else {
        voltage = (adc_read_value[0] << 8 ) | adc_read_value[1];
200043c2:	7e3b      	ldrb	r3, [r7, #24]
200043c4:	ea4f 2303 	mov.w	r3, r3, lsl #8
200043c8:	b29a      	uxth	r2, r3
200043ca:	7e7b      	ldrb	r3, [r7, #25]
200043cc:	ea42 0303 	orr.w	r3, r2, r3
200043d0:	b29b      	uxth	r3, r3
200043d2:	83fb      	strh	r3, [r7, #30]
        voltage &= 0x0FFF;
200043d4:	8bfb      	ldrh	r3, [r7, #30]
200043d6:	ea4f 5303 	mov.w	r3, r3, lsl #20
200043da:	ea4f 5313 	mov.w	r3, r3, lsr #20
200043de:	83fb      	strh	r3, [r7, #30]
        *flag = 0;
200043e0:	687b      	ldr	r3, [r7, #4]
200043e2:	f04f 0200 	mov.w	r2, #0
200043e6:	701a      	strb	r2, [r3, #0]
    }
    return voltage;
200043e8:	8bfb      	ldrh	r3, [r7, #30]
}
200043ea:	4618      	mov	r0, r3
200043ec:	f107 0720 	add.w	r7, r7, #32
200043f0:	46bd      	mov	sp, r7
200043f2:	bd80      	pop	{r7, pc}

200043f4 <get_IMU_acc>:
#include <stdio.h>

#include <core_i2c.h>
#include "IMU.h"

uint8_t get_IMU_acc(uint16_t *a_x,uint16_t *a_y,uint16_t *a_z) {
200043f4:	b580      	push	{r7, lr}
200043f6:	b092      	sub	sp, #72	; 0x48
200043f8:	af04      	add	r7, sp, #16
200043fa:	60f8      	str	r0, [r7, #12]
200043fc:	60b9      	str	r1, [r7, #8]
200043fe:	607a      	str	r2, [r7, #4]
    uint8_t write_CTRL_REG6_XL[2] = {0x20,0x60};
20004400:	f64b 6388 	movw	r3, #48776	; 0xbe88
20004404:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004408:	881b      	ldrh	r3, [r3, #0]
2000440a:	86bb      	strh	r3, [r7, #52]	; 0x34
    uint8_t read_ACC_out_X_L[] = {0x28};
2000440c:	f04f 0328 	mov.w	r3, #40	; 0x28
20004410:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    uint8_t read_ACC_out_Y_L[] = {0x2A};
20004414:	f04f 032a 	mov.w	r3, #42	; 0x2a
20004418:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    uint8_t read_ACC_out_Z_L[] = {0x2C};
2000441c:	f04f 032c 	mov.w	r3, #44	; 0x2c
20004420:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    uint8_t read_ACC_out_X_H[] = {0x29};
20004424:	f04f 0329 	mov.w	r3, #41	; 0x29
20004428:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    uint8_t read_ACC_out_Y_H[] = {0x2B};
2000442c:	f04f 032b 	mov.w	r3, #43	; 0x2b
20004430:	f887 3020 	strb.w	r3, [r7, #32]
    uint8_t read_ACC_out_Z_H[] = {0x2D};
20004434:	f04f 032d 	mov.w	r3, #45	; 0x2d
20004438:	773b      	strb	r3, [r7, #28]
    uint8_t rx_buffer[1],rx_buffer_2[1];
    uint8_t result = 0,status;
2000443a:	f04f 0300 	mov.w	r3, #0
2000443e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36


    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,write_CTRL_REG6_XL,2,rx_buffer,
20004442:	f107 0334 	add.w	r3, r7, #52	; 0x34
20004446:	f107 0218 	add.w	r2, r7, #24
2000444a:	9200      	str	r2, [sp, #0]
2000444c:	f04f 0201 	mov.w	r2, #1
20004450:	9201      	str	r2, [sp, #4]
20004452:	f04f 0200 	mov.w	r2, #0
20004456:	9202      	str	r2, [sp, #8]
20004458:	f24c 5048 	movw	r0, #50504	; 0xc548
2000445c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004460:	f04f 016a 	mov.w	r1, #106	; 0x6a
20004464:	461a      	mov	r2, r3
20004466:	f04f 0302 	mov.w	r3, #2
2000446a:	f005 fe65 	bl	2000a138 <I2C_write_read>
                    1,I2C_RELEASE_BUS);
    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000446e:	f24c 5048 	movw	r0, #50504	; 0xc548
20004472:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004476:	f04f 0100 	mov.w	r1, #0
2000447a:	f005 fef5 	bl	2000a268 <I2C_wait_complete>
2000447e:	4603      	mov	r3, r0
20004480:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
20004484:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
20004488:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
2000448c:	4413      	add	r3, r2
2000448e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Z_L,1,rx_buffer,
20004492:	f107 0328 	add.w	r3, r7, #40	; 0x28
20004496:	f107 0218 	add.w	r2, r7, #24
2000449a:	9200      	str	r2, [sp, #0]
2000449c:	f04f 0201 	mov.w	r2, #1
200044a0:	9201      	str	r2, [sp, #4]
200044a2:	f04f 0200 	mov.w	r2, #0
200044a6:	9202      	str	r2, [sp, #8]
200044a8:	f24c 5048 	movw	r0, #50504	; 0xc548
200044ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
200044b0:	f04f 016a 	mov.w	r1, #106	; 0x6a
200044b4:	461a      	mov	r2, r3
200044b6:	f04f 0301 	mov.w	r3, #1
200044ba:	f005 fe3d 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200044be:	f24c 5048 	movw	r0, #50504	; 0xc548
200044c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200044c6:	f04f 0100 	mov.w	r1, #0
200044ca:	f005 fecd 	bl	2000a268 <I2C_wait_complete>
200044ce:	4603      	mov	r3, r0
200044d0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
200044d4:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200044d8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200044dc:	4413      	add	r3, r2
200044de:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Z_H,1,rx_buffer_2,
200044e2:	f107 031c 	add.w	r3, r7, #28
200044e6:	f107 0214 	add.w	r2, r7, #20
200044ea:	9200      	str	r2, [sp, #0]
200044ec:	f04f 0201 	mov.w	r2, #1
200044f0:	9201      	str	r2, [sp, #4]
200044f2:	f04f 0200 	mov.w	r2, #0
200044f6:	9202      	str	r2, [sp, #8]
200044f8:	f24c 5048 	movw	r0, #50504	; 0xc548
200044fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004500:	f04f 016a 	mov.w	r1, #106	; 0x6a
20004504:	461a      	mov	r2, r3
20004506:	f04f 0301 	mov.w	r3, #1
2000450a:	f005 fe15 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000450e:	f24c 5048 	movw	r0, #50504	; 0xc548
20004512:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004516:	f04f 0100 	mov.w	r1, #0
2000451a:	f005 fea5 	bl	2000a268 <I2C_wait_complete>
2000451e:	4603      	mov	r3, r0
20004520:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
20004524:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
20004528:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
2000452c:	4413      	add	r3, r2
2000452e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_z = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
20004532:	7d3b      	ldrb	r3, [r7, #20]
20004534:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004538:	b29a      	uxth	r2, r3
2000453a:	7e3b      	ldrb	r3, [r7, #24]
2000453c:	ea42 0303 	orr.w	r3, r2, r3
20004540:	b29b      	uxth	r3, r3
20004542:	b29a      	uxth	r2, r3
20004544:	687b      	ldr	r3, [r7, #4]
20004546:	801a      	strh	r2, [r3, #0]
    if((*a_z) > 32768) {
20004548:	687b      	ldr	r3, [r7, #4]
2000454a:	881b      	ldrh	r3, [r3, #0]
2000454c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20004550:	d906      	bls.n	20004560 <get_IMU_acc+0x16c>
        *a_z = 65535-*a_z;
20004552:	687b      	ldr	r3, [r7, #4]
20004554:	881b      	ldrh	r3, [r3, #0]
20004556:	ea6f 0303 	mvn.w	r3, r3
2000455a:	b29a      	uxth	r2, r3
2000455c:	687b      	ldr	r3, [r7, #4]
2000455e:	801a      	strh	r2, [r3, #0]
    }

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Y_L,1,rx_buffer,
20004560:	f107 032c 	add.w	r3, r7, #44	; 0x2c
20004564:	f107 0218 	add.w	r2, r7, #24
20004568:	9200      	str	r2, [sp, #0]
2000456a:	f04f 0201 	mov.w	r2, #1
2000456e:	9201      	str	r2, [sp, #4]
20004570:	f04f 0200 	mov.w	r2, #0
20004574:	9202      	str	r2, [sp, #8]
20004576:	f24c 5048 	movw	r0, #50504	; 0xc548
2000457a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000457e:	f04f 016a 	mov.w	r1, #106	; 0x6a
20004582:	461a      	mov	r2, r3
20004584:	f04f 0301 	mov.w	r3, #1
20004588:	f005 fdd6 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000458c:	f24c 5048 	movw	r0, #50504	; 0xc548
20004590:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004594:	f04f 0100 	mov.w	r1, #0
20004598:	f005 fe66 	bl	2000a268 <I2C_wait_complete>
2000459c:	4603      	mov	r3, r0
2000459e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
200045a2:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200045a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200045aa:	4413      	add	r3, r2
200045ac:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_Y_H,1,rx_buffer_2,
200045b0:	f107 0320 	add.w	r3, r7, #32
200045b4:	f107 0214 	add.w	r2, r7, #20
200045b8:	9200      	str	r2, [sp, #0]
200045ba:	f04f 0201 	mov.w	r2, #1
200045be:	9201      	str	r2, [sp, #4]
200045c0:	f04f 0200 	mov.w	r2, #0
200045c4:	9202      	str	r2, [sp, #8]
200045c6:	f24c 5048 	movw	r0, #50504	; 0xc548
200045ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
200045ce:	f04f 016a 	mov.w	r1, #106	; 0x6a
200045d2:	461a      	mov	r2, r3
200045d4:	f04f 0301 	mov.w	r3, #1
200045d8:	f005 fdae 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200045dc:	f24c 5048 	movw	r0, #50504	; 0xc548
200045e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200045e4:	f04f 0100 	mov.w	r1, #0
200045e8:	f005 fe3e 	bl	2000a268 <I2C_wait_complete>
200045ec:	4603      	mov	r3, r0
200045ee:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
200045f2:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200045f6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200045fa:	4413      	add	r3, r2
200045fc:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_y = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
20004600:	7d3b      	ldrb	r3, [r7, #20]
20004602:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004606:	b29a      	uxth	r2, r3
20004608:	7e3b      	ldrb	r3, [r7, #24]
2000460a:	ea42 0303 	orr.w	r3, r2, r3
2000460e:	b29b      	uxth	r3, r3
20004610:	b29a      	uxth	r2, r3
20004612:	68bb      	ldr	r3, [r7, #8]
20004614:	801a      	strh	r2, [r3, #0]
    if((*a_y) > 32768) {
20004616:	68bb      	ldr	r3, [r7, #8]
20004618:	881b      	ldrh	r3, [r3, #0]
2000461a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000461e:	d906      	bls.n	2000462e <get_IMU_acc+0x23a>
        *a_y = 65535-*a_y;
20004620:	68bb      	ldr	r3, [r7, #8]
20004622:	881b      	ldrh	r3, [r3, #0]
20004624:	ea6f 0303 	mvn.w	r3, r3
20004628:	b29a      	uxth	r2, r3
2000462a:	68bb      	ldr	r3, [r7, #8]
2000462c:	801a      	strh	r2, [r3, #0]
    }

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_X_L,1,rx_buffer,
2000462e:	f107 0330 	add.w	r3, r7, #48	; 0x30
20004632:	f107 0218 	add.w	r2, r7, #24
20004636:	9200      	str	r2, [sp, #0]
20004638:	f04f 0201 	mov.w	r2, #1
2000463c:	9201      	str	r2, [sp, #4]
2000463e:	f04f 0200 	mov.w	r2, #0
20004642:	9202      	str	r2, [sp, #8]
20004644:	f24c 5048 	movw	r0, #50504	; 0xc548
20004648:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000464c:	f04f 016a 	mov.w	r1, #106	; 0x6a
20004650:	461a      	mov	r2, r3
20004652:	f04f 0301 	mov.w	r3, #1
20004656:	f005 fd6f 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000465a:	f24c 5048 	movw	r0, #50504	; 0xc548
2000465e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004662:	f04f 0100 	mov.w	r1, #0
20004666:	f005 fdff 	bl	2000a268 <I2C_wait_complete>
2000466a:	4603      	mov	r3, r0
2000466c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
20004670:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
20004674:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
20004678:	4413      	add	r3, r2
2000467a:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    I2C_write_read(IMU_CORE_I2C,IMU_ADDR,read_ACC_out_X_H,1,rx_buffer_2,
2000467e:	f107 0324 	add.w	r3, r7, #36	; 0x24
20004682:	f107 0214 	add.w	r2, r7, #20
20004686:	9200      	str	r2, [sp, #0]
20004688:	f04f 0201 	mov.w	r2, #1
2000468c:	9201      	str	r2, [sp, #4]
2000468e:	f04f 0200 	mov.w	r2, #0
20004692:	9202      	str	r2, [sp, #8]
20004694:	f24c 5048 	movw	r0, #50504	; 0xc548
20004698:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000469c:	f04f 016a 	mov.w	r1, #106	; 0x6a
200046a0:	461a      	mov	r2, r3
200046a2:	f04f 0301 	mov.w	r3, #1
200046a6:	f005 fd47 	bl	2000a138 <I2C_write_read>
                            1,I2C_RELEASE_BUS);

    status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200046aa:	f24c 5048 	movw	r0, #50504	; 0xc548
200046ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
200046b2:	f04f 0100 	mov.w	r1, #0
200046b6:	f005 fdd7 	bl	2000a268 <I2C_wait_complete>
200046ba:	4603      	mov	r3, r0
200046bc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    result+=status;
200046c0:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200046c4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200046c8:	4413      	add	r3, r2
200046ca:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    *a_x = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
200046ce:	7d3b      	ldrb	r3, [r7, #20]
200046d0:	ea4f 2303 	mov.w	r3, r3, lsl #8
200046d4:	b29a      	uxth	r2, r3
200046d6:	7e3b      	ldrb	r3, [r7, #24]
200046d8:	ea42 0303 	orr.w	r3, r2, r3
200046dc:	b29b      	uxth	r3, r3
200046de:	b29a      	uxth	r2, r3
200046e0:	68fb      	ldr	r3, [r7, #12]
200046e2:	801a      	strh	r2, [r3, #0]
    if((*a_x) > 32768) {
200046e4:	68fb      	ldr	r3, [r7, #12]
200046e6:	881b      	ldrh	r3, [r3, #0]
200046e8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
200046ec:	d906      	bls.n	200046fc <get_IMU_acc+0x308>
        *a_x = 65535-*a_x;
200046ee:	68fb      	ldr	r3, [r7, #12]
200046f0:	881b      	ldrh	r3, [r3, #0]
200046f2:	ea6f 0303 	mvn.w	r3, r3
200046f6:	b29a      	uxth	r2, r3
200046f8:	68fb      	ldr	r3, [r7, #12]
200046fa:	801a      	strh	r2, [r3, #0]
    }

    return status;
200046fc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37

}
20004700:	4618      	mov	r0, r3
20004702:	f107 0738 	add.w	r7, r7, #56	; 0x38
20004706:	46bd      	mov	sp, r7
20004708:	bd80      	pop	{r7, pc}
2000470a:	bf00      	nop

2000470c <get_IMU_gyro>:

uint8_t get_IMU_gyro(uint16_t *roll_rate, uint16_t *pitch_rate,uint16_t *yaw_rate) {
2000470c:	b580      	push	{r7, lr}
2000470e:	b092      	sub	sp, #72	; 0x48
20004710:	af04      	add	r7, sp, #16
20004712:	60f8      	str	r0, [r7, #12]
20004714:	60b9      	str	r1, [r7, #8]
20004716:	607a      	str	r2, [r7, #4]

    uint8_t write_CTRL_REG1_G[2] = {0x10,0x6A};
20004718:	f64b 6384 	movw	r3, #48772	; 0xbe84
2000471c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004720:	881b      	ldrh	r3, [r3, #0]
20004722:	863b      	strh	r3, [r7, #48]	; 0x30
        uint8_t read_ACC_out_X_L[] = {0x18};
20004724:	f04f 0318 	mov.w	r3, #24
20004728:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        uint8_t read_ACC_out_Y_L[] = {0x1A};
2000472c:	f04f 031a 	mov.w	r3, #26
20004730:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
        uint8_t read_ACC_out_Z_L[] = {0x1C};
20004734:	f04f 031c 	mov.w	r3, #28
20004738:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        uint8_t read_ACC_out_X_H[] = {0x19};
2000473c:	f04f 0319 	mov.w	r3, #25
20004740:	f887 3020 	strb.w	r3, [r7, #32]
        uint8_t read_ACC_out_Y_H[] = {0x1B};
20004744:	f04f 031b 	mov.w	r3, #27
20004748:	773b      	strb	r3, [r7, #28]
        uint8_t read_ACC_out_Z_H[] = {0x1D};
2000474a:	f04f 031d 	mov.w	r3, #29
2000474e:	763b      	strb	r3, [r7, #24]
        uint8_t IMU_slave_addr = 0x6a;
20004750:	f04f 036a 	mov.w	r3, #106	; 0x6a
20004754:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
        uint8_t rx_buffer[1],rx_buffer_2[1];
        uint8_t result = 0,status;
20004758:	f04f 0300 	mov.w	r3, #0
2000475c:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36


        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,write_CTRL_REG1_G,2,rx_buffer,
20004760:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
20004764:	f107 0330 	add.w	r3, r7, #48	; 0x30
20004768:	f107 0114 	add.w	r1, r7, #20
2000476c:	9100      	str	r1, [sp, #0]
2000476e:	f04f 0101 	mov.w	r1, #1
20004772:	9101      	str	r1, [sp, #4]
20004774:	f04f 0100 	mov.w	r1, #0
20004778:	9102      	str	r1, [sp, #8]
2000477a:	f24c 5048 	movw	r0, #50504	; 0xc548
2000477e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004782:	4611      	mov	r1, r2
20004784:	461a      	mov	r2, r3
20004786:	f04f 0302 	mov.w	r3, #2
2000478a:	f005 fcd5 	bl	2000a138 <I2C_write_read>
                        1,I2C_RELEASE_BUS);
        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000478e:	f24c 5048 	movw	r0, #50504	; 0xc548
20004792:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004796:	f04f 0100 	mov.w	r1, #0
2000479a:	f005 fd65 	bl	2000a268 <I2C_wait_complete>
2000479e:	4603      	mov	r3, r0
200047a0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
200047a4:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200047a8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200047ac:	4413      	add	r3, r2
200047ae:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Z_L,1,rx_buffer,
200047b2:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
200047b6:	f107 0324 	add.w	r3, r7, #36	; 0x24
200047ba:	f107 0114 	add.w	r1, r7, #20
200047be:	9100      	str	r1, [sp, #0]
200047c0:	f04f 0101 	mov.w	r1, #1
200047c4:	9101      	str	r1, [sp, #4]
200047c6:	f04f 0100 	mov.w	r1, #0
200047ca:	9102      	str	r1, [sp, #8]
200047cc:	f24c 5048 	movw	r0, #50504	; 0xc548
200047d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200047d4:	4611      	mov	r1, r2
200047d6:	461a      	mov	r2, r3
200047d8:	f04f 0301 	mov.w	r3, #1
200047dc:	f005 fcac 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200047e0:	f24c 5048 	movw	r0, #50504	; 0xc548
200047e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200047e8:	f04f 0100 	mov.w	r1, #0
200047ec:	f005 fd3c 	bl	2000a268 <I2C_wait_complete>
200047f0:	4603      	mov	r3, r0
200047f2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
200047f6:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200047fa:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200047fe:	4413      	add	r3, r2
20004800:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Z_H,1,rx_buffer_2,
20004804:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
20004808:	f107 0318 	add.w	r3, r7, #24
2000480c:	f107 0110 	add.w	r1, r7, #16
20004810:	9100      	str	r1, [sp, #0]
20004812:	f04f 0101 	mov.w	r1, #1
20004816:	9101      	str	r1, [sp, #4]
20004818:	f04f 0100 	mov.w	r1, #0
2000481c:	9102      	str	r1, [sp, #8]
2000481e:	f24c 5048 	movw	r0, #50504	; 0xc548
20004822:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004826:	4611      	mov	r1, r2
20004828:	461a      	mov	r2, r3
2000482a:	f04f 0301 	mov.w	r3, #1
2000482e:	f005 fc83 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
20004832:	f24c 5048 	movw	r0, #50504	; 0xc548
20004836:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000483a:	f04f 0100 	mov.w	r1, #0
2000483e:	f005 fd13 	bl	2000a268 <I2C_wait_complete>
20004842:	4603      	mov	r3, r0
20004844:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
20004848:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
2000484c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
20004850:	4413      	add	r3, r2
20004852:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *roll_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
20004856:	7c3b      	ldrb	r3, [r7, #16]
20004858:	ea4f 2303 	mov.w	r3, r3, lsl #8
2000485c:	b29a      	uxth	r2, r3
2000485e:	7d3b      	ldrb	r3, [r7, #20]
20004860:	ea42 0303 	orr.w	r3, r2, r3
20004864:	b29b      	uxth	r3, r3
20004866:	b29a      	uxth	r2, r3
20004868:	68fb      	ldr	r3, [r7, #12]
2000486a:	801a      	strh	r2, [r3, #0]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Y_L,1,rx_buffer,
2000486c:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
20004870:	f107 0328 	add.w	r3, r7, #40	; 0x28
20004874:	f107 0114 	add.w	r1, r7, #20
20004878:	9100      	str	r1, [sp, #0]
2000487a:	f04f 0101 	mov.w	r1, #1
2000487e:	9101      	str	r1, [sp, #4]
20004880:	f04f 0100 	mov.w	r1, #0
20004884:	9102      	str	r1, [sp, #8]
20004886:	f24c 5048 	movw	r0, #50504	; 0xc548
2000488a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000488e:	4611      	mov	r1, r2
20004890:	461a      	mov	r2, r3
20004892:	f04f 0301 	mov.w	r3, #1
20004896:	f005 fc4f 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
2000489a:	f24c 5048 	movw	r0, #50504	; 0xc548
2000489e:	f2c2 0000 	movt	r0, #8192	; 0x2000
200048a2:	f04f 0100 	mov.w	r1, #0
200048a6:	f005 fcdf 	bl	2000a268 <I2C_wait_complete>
200048aa:	4603      	mov	r3, r0
200048ac:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
200048b0:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200048b4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200048b8:	4413      	add	r3, r2
200048ba:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_Y_H,1,rx_buffer_2,
200048be:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
200048c2:	f107 031c 	add.w	r3, r7, #28
200048c6:	f107 0110 	add.w	r1, r7, #16
200048ca:	9100      	str	r1, [sp, #0]
200048cc:	f04f 0101 	mov.w	r1, #1
200048d0:	9101      	str	r1, [sp, #4]
200048d2:	f04f 0100 	mov.w	r1, #0
200048d6:	9102      	str	r1, [sp, #8]
200048d8:	f24c 5048 	movw	r0, #50504	; 0xc548
200048dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200048e0:	4611      	mov	r1, r2
200048e2:	461a      	mov	r2, r3
200048e4:	f04f 0301 	mov.w	r3, #1
200048e8:	f005 fc26 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200048ec:	f24c 5048 	movw	r0, #50504	; 0xc548
200048f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200048f4:	f04f 0100 	mov.w	r1, #0
200048f8:	f005 fcb6 	bl	2000a268 <I2C_wait_complete>
200048fc:	4603      	mov	r3, r0
200048fe:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
20004902:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
20004906:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
2000490a:	4413      	add	r3, r2
2000490c:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *pitch_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
20004910:	7c3b      	ldrb	r3, [r7, #16]
20004912:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004916:	b29a      	uxth	r2, r3
20004918:	7d3b      	ldrb	r3, [r7, #20]
2000491a:	ea42 0303 	orr.w	r3, r2, r3
2000491e:	b29b      	uxth	r3, r3
20004920:	b29a      	uxth	r2, r3
20004922:	68bb      	ldr	r3, [r7, #8]
20004924:	801a      	strh	r2, [r3, #0]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_X_L,1,rx_buffer,
20004926:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
2000492a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
2000492e:	f107 0114 	add.w	r1, r7, #20
20004932:	9100      	str	r1, [sp, #0]
20004934:	f04f 0101 	mov.w	r1, #1
20004938:	9101      	str	r1, [sp, #4]
2000493a:	f04f 0100 	mov.w	r1, #0
2000493e:	9102      	str	r1, [sp, #8]
20004940:	f24c 5048 	movw	r0, #50504	; 0xc548
20004944:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004948:	4611      	mov	r1, r2
2000494a:	461a      	mov	r2, r3
2000494c:	f04f 0301 	mov.w	r3, #1
20004950:	f005 fbf2 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
20004954:	f24c 5048 	movw	r0, #50504	; 0xc548
20004958:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000495c:	f04f 0100 	mov.w	r1, #0
20004960:	f005 fc82 	bl	2000a268 <I2C_wait_complete>
20004964:	4603      	mov	r3, r0
20004966:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
2000496a:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
2000496e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
20004972:	4413      	add	r3, r2
20004974:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_ACC_out_X_H,1,rx_buffer_2,
20004978:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
2000497c:	f107 0320 	add.w	r3, r7, #32
20004980:	f107 0110 	add.w	r1, r7, #16
20004984:	9100      	str	r1, [sp, #0]
20004986:	f04f 0101 	mov.w	r1, #1
2000498a:	9101      	str	r1, [sp, #4]
2000498c:	f04f 0100 	mov.w	r1, #0
20004990:	9102      	str	r1, [sp, #8]
20004992:	f24c 5048 	movw	r0, #50504	; 0xc548
20004996:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000499a:	4611      	mov	r1, r2
2000499c:	461a      	mov	r2, r3
2000499e:	f04f 0301 	mov.w	r3, #1
200049a2:	f005 fbc9 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
200049a6:	f24c 5048 	movw	r0, #50504	; 0xc548
200049aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200049ae:	f04f 0100 	mov.w	r1, #0
200049b2:	f005 fc59 	bl	2000a268 <I2C_wait_complete>
200049b6:	4603      	mov	r3, r0
200049b8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        result+=status;
200049bc:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
200049c0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
200049c4:	4413      	add	r3, r2
200049c6:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        *yaw_rate = ((rx_buffer_2[0] << 8) | rx_buffer[0]);
200049ca:	7c3b      	ldrb	r3, [r7, #16]
200049cc:	ea4f 2303 	mov.w	r3, r3, lsl #8
200049d0:	b29a      	uxth	r2, r3
200049d2:	7d3b      	ldrb	r3, [r7, #20]
200049d4:	ea42 0303 	orr.w	r3, r2, r3
200049d8:	b29b      	uxth	r3, r3
200049da:	b29a      	uxth	r2, r3
200049dc:	687b      	ldr	r3, [r7, #4]
200049de:	801a      	strh	r2, [r3, #0]

        return status;
200049e0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
200049e4:	4618      	mov	r0, r3
200049e6:	f107 0738 	add.w	r7, r7, #56	; 0x38
200049ea:	46bd      	mov	sp, r7
200049ec:	bd80      	pop	{r7, pc}
200049ee:	bf00      	nop

200049f0 <get_IMU_temp>:

uint8_t get_IMU_temp(uint16_t *temp) {
200049f0:	b580      	push	{r7, lr}
200049f2:	b08a      	sub	sp, #40	; 0x28
200049f4:	af04      	add	r7, sp, #16
200049f6:	6078      	str	r0, [r7, #4]

        uint8_t read_temp_L[] = {0x15};
200049f8:	f04f 0315 	mov.w	r3, #21
200049fc:	753b      	strb	r3, [r7, #20]
        uint8_t read_temp_H[] = {0x16};
200049fe:	f04f 0316 	mov.w	r3, #22
20004a02:	743b      	strb	r3, [r7, #16]
        uint8_t IMU_slave_addr = 0x6a;
20004a04:	f04f 036a 	mov.w	r3, #106	; 0x6a
20004a08:	75bb      	strb	r3, [r7, #22]
        uint8_t rx_buffer[1],rx_buffer_2[1];
        i2c_status_t status;

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_temp_L,1,rx_buffer,
20004a0a:	7dba      	ldrb	r2, [r7, #22]
20004a0c:	f107 0314 	add.w	r3, r7, #20
20004a10:	f107 010c 	add.w	r1, r7, #12
20004a14:	9100      	str	r1, [sp, #0]
20004a16:	f04f 0101 	mov.w	r1, #1
20004a1a:	9101      	str	r1, [sp, #4]
20004a1c:	f04f 0100 	mov.w	r1, #0
20004a20:	9102      	str	r1, [sp, #8]
20004a22:	f24c 5048 	movw	r0, #50504	; 0xc548
20004a26:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004a2a:	4611      	mov	r1, r2
20004a2c:	461a      	mov	r2, r3
20004a2e:	f04f 0301 	mov.w	r3, #1
20004a32:	f005 fb81 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
20004a36:	f24c 5048 	movw	r0, #50504	; 0xc548
20004a3a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004a3e:	f04f 0100 	mov.w	r1, #0
20004a42:	f005 fc11 	bl	2000a268 <I2C_wait_complete>
20004a46:	4603      	mov	r3, r0
20004a48:	75fb      	strb	r3, [r7, #23]

        I2C_write_read(IMU_CORE_I2C,IMU_slave_addr,read_temp_H,1,rx_buffer_2,
20004a4a:	7dba      	ldrb	r2, [r7, #22]
20004a4c:	f107 0310 	add.w	r3, r7, #16
20004a50:	f107 0108 	add.w	r1, r7, #8
20004a54:	9100      	str	r1, [sp, #0]
20004a56:	f04f 0101 	mov.w	r1, #1
20004a5a:	9101      	str	r1, [sp, #4]
20004a5c:	f04f 0100 	mov.w	r1, #0
20004a60:	9102      	str	r1, [sp, #8]
20004a62:	f24c 5048 	movw	r0, #50504	; 0xc548
20004a66:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004a6a:	4611      	mov	r1, r2
20004a6c:	461a      	mov	r2, r3
20004a6e:	f04f 0301 	mov.w	r3, #1
20004a72:	f005 fb61 	bl	2000a138 <I2C_write_read>
                                1,I2C_RELEASE_BUS);

        status = I2C_wait_complete(IMU_CORE_I2C,I2C_NO_TIMEOUT);
20004a76:	f24c 5048 	movw	r0, #50504	; 0xc548
20004a7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004a7e:	f04f 0100 	mov.w	r1, #0
20004a82:	f005 fbf1 	bl	2000a268 <I2C_wait_complete>
20004a86:	4603      	mov	r3, r0
20004a88:	75fb      	strb	r3, [r7, #23]

        *temp = (rx_buffer[0]) | (rx_buffer_2[0] << 8);
20004a8a:	7b3b      	ldrb	r3, [r7, #12]
20004a8c:	461a      	mov	r2, r3
20004a8e:	7a3b      	ldrb	r3, [r7, #8]
20004a90:	ea4f 2303 	mov.w	r3, r3, lsl #8
20004a94:	b29b      	uxth	r3, r3
20004a96:	ea42 0303 	orr.w	r3, r2, r3
20004a9a:	b29b      	uxth	r3, r3
20004a9c:	b29a      	uxth	r2, r3
20004a9e:	687b      	ldr	r3, [r7, #4]
20004aa0:	801a      	strh	r2, [r3, #0]

        return 0;
20004aa2:	f04f 0300 	mov.w	r3, #0

}
20004aa6:	4618      	mov	r0, r3
20004aa8:	f107 0718 	add.w	r7, r7, #24
20004aac:	46bd      	mov	sp, r7
20004aae:	bd80      	pop	{r7, pc}

20004ab0 <SD_Init>:
uint8_t CMD8[] = {0x48, 0x00, 0x00, 0x01, 0xAA, 0x87,0xff};
uint8_t CMD58[] = {0x7A,0x00,0x00,0x00,0x00,0xFD,0xFF};
uint8_t CMD55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65,0xff};	// last 0xff is use to give sd card buffer clock
uint8_t ACMD41[] = {0x69, 0x40, 0x00, 0x00, 0x00, 0xE5,0xff};
uint8_t CMD1[] = {0x41,0x00,0x00,0x00,0x00,0xF9,0xff};
uint8_t SD_Init() {
20004ab0:	b580      	push	{r7, lr}
20004ab2:	b086      	sub	sp, #24
20004ab4:	af02      	add	r7, sp, #8
	flag = 0;
20004ab6:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004aba:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004abe:	f04f 0200 	mov.w	r2, #0
20004ac2:	701a      	strb	r2, [r3, #0]
	MSS_GPIO_set_output( SD_CARD_GPIO,1);
20004ac4:	f04f 000a 	mov.w	r0, #10
20004ac8:	f04f 0101 	mov.w	r1, #1
20004acc:	f004 fce8 	bl	200094a0 <MSS_GPIO_set_output>
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
20004ad0:	f04f 0300 	mov.w	r3, #0
20004ad4:	713b      	strb	r3, [r7, #4]
20004ad6:	f04f 0300 	mov.w	r3, #0
20004ada:	717b      	strb	r3, [r7, #5]
20004adc:	f04f 0300 	mov.w	r3, #0
20004ae0:	71bb      	strb	r3, [r7, #6]
20004ae2:	f04f 0300 	mov.w	r3, #0
20004ae6:	71fb      	strb	r3, [r7, #7]
20004ae8:	f04f 0300 	mov.w	r3, #0
20004aec:	723b      	strb	r3, [r7, #8]

	uint32_t i = 0;
20004aee:	f04f 0300 	mov.w	r3, #0
20004af2:	60fb      	str	r3, [r7, #12]

	for(i =0; i<10; i++){
20004af4:	f04f 0300 	mov.w	r3, #0
20004af8:	60fb      	str	r3, [r7, #12]
20004afa:	e00b      	b.n	20004b14 <SD_Init+0x64>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004afc:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b00:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004b04:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004b08:	f003 f934 	bl	20007d74 <MSS_SPI_transfer_frame>
	MSS_GPIO_set_output( SD_CARD_GPIO,1);
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};

	uint32_t i = 0;

	for(i =0; i<10; i++){
20004b0c:	68fb      	ldr	r3, [r7, #12]
20004b0e:	f103 0301 	add.w	r3, r3, #1
20004b12:	60fb      	str	r3, [r7, #12]
20004b14:	68fb      	ldr	r3, [r7, #12]
20004b16:	2b09      	cmp	r3, #9
20004b18:	d9f0      	bls.n	20004afc <SD_Init+0x4c>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
	}

	MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004b1a:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b1e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004b22:	f04f 0100 	mov.w	r1, #0
20004b26:	f003 f859 	bl	20007bdc <MSS_SPI_set_slave_select>
	do {
		MSS_SPI_transfer_block(&g_mss_spi1, CMD0, 7, rx_buffer, 1);
20004b2a:	f107 0304 	add.w	r3, r7, #4
20004b2e:	f04f 0201 	mov.w	r2, #1
20004b32:	9200      	str	r2, [sp, #0]
20004b34:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b38:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004b3c:	f64b 7190 	movw	r1, #49040	; 0xbf90
20004b40:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004b44:	f04f 0207 	mov.w	r2, #7
20004b48:	f003 f974 	bl	20007e34 <MSS_SPI_transfer_block>
		i++;
20004b4c:	68fb      	ldr	r3, [r7, #12]
20004b4e:	f103 0301 	add.w	r3, r3, #1
20004b52:	60fb      	str	r3, [r7, #12]
		if(rx_buffer[0] == 1) {
20004b54:	793b      	ldrb	r3, [r7, #4]
20004b56:	2b01      	cmp	r3, #1
20004b58:	d006      	beq.n	20004b68 <SD_Init+0xb8>
			break;
		}
	} while(rx_buffer[0] != 1 && i < 255);
20004b5a:	793b      	ldrb	r3, [r7, #4]
20004b5c:	2b01      	cmp	r3, #1
20004b5e:	d004      	beq.n	20004b6a <SD_Init+0xba>
20004b60:	68fb      	ldr	r3, [r7, #12]
20004b62:	2bfe      	cmp	r3, #254	; 0xfe
20004b64:	d9e1      	bls.n	20004b2a <SD_Init+0x7a>
20004b66:	e000      	b.n	20004b6a <SD_Init+0xba>
	MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
	do {
		MSS_SPI_transfer_block(&g_mss_spi1, CMD0, 7, rx_buffer, 1);
		i++;
		if(rx_buffer[0] == 1) {
			break;
20004b68:	bf00      	nop
		}
	} while(rx_buffer[0] != 1 && i < 255);


	i = 0;
20004b6a:	f04f 0300 	mov.w	r3, #0
20004b6e:	60fb      	str	r3, [r7, #12]


	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004b70:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b74:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004b78:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004b7c:	f003 f8fa 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004b80:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b84:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004b88:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004b8c:	f003 f8f2 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD8, 7, rx_buffer, 5);
20004b90:	f107 0304 	add.w	r3, r7, #4
20004b94:	f04f 0205 	mov.w	r2, #5
20004b98:	9200      	str	r2, [sp, #0]
20004b9a:	f24d 4080 	movw	r0, #54400	; 0xd480
20004b9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004ba2:	f64b 7198 	movw	r1, #49048	; 0xbf98
20004ba6:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004baa:	f04f 0207 	mov.w	r2, #7
20004bae:	f003 f941 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004bb2:	f24d 4080 	movw	r0, #54400	; 0xd480
20004bb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004bba:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004bbe:	f003 f8d9 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004bc2:	f24d 4080 	movw	r0, #54400	; 0xd480
20004bc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004bca:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004bce:	f003 f8d1 	bl	20007d74 <MSS_SPI_transfer_frame>

		i++;
20004bd2:	68fb      	ldr	r3, [r7, #12]
20004bd4:	f103 0301 	add.w	r3, r3, #1
20004bd8:	60fb      	str	r3, [r7, #12]
		if(rx_buffer[4] == 0xaa && rx_buffer[3] == 0x01 && rx_buffer[2] == 0x00 && rx_buffer[1] == 0x00) {
20004bda:	7a3b      	ldrb	r3, [r7, #8]
20004bdc:	2baa      	cmp	r3, #170	; 0xaa
20004bde:	d110      	bne.n	20004c02 <SD_Init+0x152>
20004be0:	79fb      	ldrb	r3, [r7, #7]
20004be2:	2b01      	cmp	r3, #1
20004be4:	d10d      	bne.n	20004c02 <SD_Init+0x152>
20004be6:	79bb      	ldrb	r3, [r7, #6]
20004be8:	2b00      	cmp	r3, #0
20004bea:	d10a      	bne.n	20004c02 <SD_Init+0x152>
20004bec:	797b      	ldrb	r3, [r7, #5]
20004bee:	2b00      	cmp	r3, #0
20004bf0:	d107      	bne.n	20004c02 <SD_Init+0x152>
			flag =  1;
20004bf2:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004bf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004bfa:	f04f 0201 	mov.w	r2, #1
20004bfe:	701a      	strb	r2, [r3, #0]
			break;
20004c00:	e002      	b.n	20004c08 <SD_Init+0x158>
		}

	} while( i < 255);
20004c02:	68fb      	ldr	r3, [r7, #12]
20004c04:	2bfe      	cmp	r3, #254	; 0xfe
20004c06:	d9b3      	bls.n	20004b70 <SD_Init+0xc0>
	if(i >= 255) {
20004c08:	68fb      	ldr	r3, [r7, #12]
20004c0a:	2bfe      	cmp	r3, #254	; 0xfe
20004c0c:	d90a      	bls.n	20004c24 <SD_Init+0x174>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004c0e:	f24d 4080 	movw	r0, #54400	; 0xd480
20004c12:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004c16:	f04f 0100 	mov.w	r1, #0
20004c1a:	f003 f863 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		return 1;
20004c1e:	f04f 0301 	mov.w	r3, #1
20004c22:	e17e      	b.n	20004f22 <SD_Init+0x472>
	}


	rx_buffer[0] = 0x00;
20004c24:	f04f 0300 	mov.w	r3, #0
20004c28:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
20004c2a:	f04f 0300 	mov.w	r3, #0
20004c2e:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
20004c30:	f04f 0300 	mov.w	r3, #0
20004c34:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
20004c36:	f04f 0300 	mov.w	r3, #0
20004c3a:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
20004c3c:	f04f 0300 	mov.w	r3, #0
20004c40:	723b      	strb	r3, [r7, #8]
	i = 0;
20004c42:	f04f 0300 	mov.w	r3, #0
20004c46:	60fb      	str	r3, [r7, #12]
	flag = 0;
20004c48:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004c50:	f04f 0200 	mov.w	r2, #0
20004c54:	701a      	strb	r2, [r3, #0]
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004c56:	f24d 4080 	movw	r0, #54400	; 0xd480
20004c5a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004c5e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004c62:	f003 f887 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004c66:	f24d 4080 	movw	r0, #54400	; 0xd480
20004c6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004c6e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004c72:	f003 f87f 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD58, 7, rx_buffer, 5);
20004c76:	f107 0304 	add.w	r3, r7, #4
20004c7a:	f04f 0205 	mov.w	r2, #5
20004c7e:	9200      	str	r2, [sp, #0]
20004c80:	f24d 4080 	movw	r0, #54400	; 0xd480
20004c84:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004c88:	f64b 71a0 	movw	r1, #49056	; 0xbfa0
20004c8c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004c90:	f04f 0207 	mov.w	r2, #7
20004c94:	f003 f8ce 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004c98:	f24d 4080 	movw	r0, #54400	; 0xd480
20004c9c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004ca0:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004ca4:	f003 f866 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004ca8:	f24d 4080 	movw	r0, #54400	; 0xd480
20004cac:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004cb0:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004cb4:	f003 f85e 	bl	20007d74 <MSS_SPI_transfer_frame>

		i++;
20004cb8:	68fb      	ldr	r3, [r7, #12]
20004cba:	f103 0301 	add.w	r3, r3, #1
20004cbe:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[3] == 0x80 && rx_buffer[2] == 0xFF) {
20004cc0:	79fb      	ldrb	r3, [r7, #7]
20004cc2:	2b80      	cmp	r3, #128	; 0x80
20004cc4:	d10a      	bne.n	20004cdc <SD_Init+0x22c>
20004cc6:	79bb      	ldrb	r3, [r7, #6]
20004cc8:	2bff      	cmp	r3, #255	; 0xff
20004cca:	d107      	bne.n	20004cdc <SD_Init+0x22c>
			flag = 1;
20004ccc:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004cd4:	f04f 0201 	mov.w	r2, #1
20004cd8:	701a      	strb	r2, [r3, #0]
			break;
20004cda:	e002      	b.n	20004ce2 <SD_Init+0x232>
		}

	} while( i < 255);
20004cdc:	68fb      	ldr	r3, [r7, #12]
20004cde:	2bfe      	cmp	r3, #254	; 0xfe
20004ce0:	d9b9      	bls.n	20004c56 <SD_Init+0x1a6>
	if(i >= 255) {
20004ce2:	68fb      	ldr	r3, [r7, #12]
20004ce4:	2bfe      	cmp	r3, #254	; 0xfe
20004ce6:	d90a      	bls.n	20004cfe <SD_Init+0x24e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004ce8:	f24d 4080 	movw	r0, #54400	; 0xd480
20004cec:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004cf0:	f04f 0100 	mov.w	r1, #0
20004cf4:	f002 fff6 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		return 1;
20004cf8:	f04f 0301 	mov.w	r3, #1
20004cfc:	e111      	b.n	20004f22 <SD_Init+0x472>
	}



	rx_buffer[0] = 0x00;
20004cfe:	f04f 0300 	mov.w	r3, #0
20004d02:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
20004d04:	f04f 0300 	mov.w	r3, #0
20004d08:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
20004d0a:	f04f 0300 	mov.w	r3, #0
20004d0e:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
20004d10:	f04f 0300 	mov.w	r3, #0
20004d14:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
20004d16:	f04f 0300 	mov.w	r3, #0
20004d1a:	723b      	strb	r3, [r7, #8]
	i = 0;
20004d1c:	f04f 0300 	mov.w	r3, #0
20004d20:	60fb      	str	r3, [r7, #12]
	flag = 0;
20004d22:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004d26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004d2a:	f04f 0200 	mov.w	r2, #0
20004d2e:	701a      	strb	r2, [r3, #0]


	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004d30:	f24d 4080 	movw	r0, #54400	; 0xd480
20004d34:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004d38:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004d3c:	f003 f81a 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004d40:	f24d 4080 	movw	r0, #54400	; 0xd480
20004d44:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004d48:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004d4c:	f003 f812 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD55, 7, rx_buffer, 1);
20004d50:	f107 0304 	add.w	r3, r7, #4
20004d54:	f04f 0201 	mov.w	r2, #1
20004d58:	9200      	str	r2, [sp, #0]
20004d5a:	f24d 4080 	movw	r0, #54400	; 0xd480
20004d5e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004d62:	f64b 71a8 	movw	r1, #49064	; 0xbfa8
20004d66:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004d6a:	f04f 0207 	mov.w	r2, #7
20004d6e:	f003 f861 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004d72:	f24d 4080 	movw	r0, #54400	; 0xd480
20004d76:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004d7a:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004d7e:	f002 fff9 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, ACMD41, 7, rx_buffer, 1);
20004d82:	f107 0304 	add.w	r3, r7, #4
20004d86:	f04f 0201 	mov.w	r2, #1
20004d8a:	9200      	str	r2, [sp, #0]
20004d8c:	f24d 4080 	movw	r0, #54400	; 0xd480
20004d90:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004d94:	f64b 71b0 	movw	r1, #49072	; 0xbfb0
20004d98:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004d9c:	f04f 0207 	mov.w	r2, #7
20004da0:	f003 f848 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004da4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004da8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004dac:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004db0:	f002 ffe0 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004db4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004db8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004dbc:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004dc0:	f002 ffd8 	bl	20007d74 <MSS_SPI_transfer_frame>

		i++;
20004dc4:	68fb      	ldr	r3, [r7, #12]
20004dc6:	f103 0301 	add.w	r3, r3, #1
20004dca:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[0] == 0x00) {
20004dcc:	793b      	ldrb	r3, [r7, #4]
20004dce:	2b00      	cmp	r3, #0
20004dd0:	d107      	bne.n	20004de2 <SD_Init+0x332>
			flag = 1;
20004dd2:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004dd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004dda:	f04f 0201 	mov.w	r2, #1
20004dde:	701a      	strb	r2, [r3, #0]
			break;
20004de0:	e004      	b.n	20004dec <SD_Init+0x33c>
		}


	} while( i <2550);
20004de2:	68fa      	ldr	r2, [r7, #12]
20004de4:	f640 13f5 	movw	r3, #2549	; 0x9f5
20004de8:	429a      	cmp	r2, r3
20004dea:	d9a1      	bls.n	20004d30 <SD_Init+0x280>
	if(flag == 0) {
20004dec:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004df4:	781b      	ldrb	r3, [r3, #0]
20004df6:	2b00      	cmp	r3, #0
20004df8:	d10a      	bne.n	20004e10 <SD_Init+0x360>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004dfa:	f24d 4080 	movw	r0, #54400	; 0xd480
20004dfe:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e02:	f04f 0100 	mov.w	r1, #0
20004e06:	f002 ff6d 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		return 1;
20004e0a:	f04f 0301 	mov.w	r3, #1
20004e0e:	e088      	b.n	20004f22 <SD_Init+0x472>
	}

	rx_buffer[0] = 0x00;
20004e10:	f04f 0300 	mov.w	r3, #0
20004e14:	713b      	strb	r3, [r7, #4]
	rx_buffer[1] = 0x00;
20004e16:	f04f 0300 	mov.w	r3, #0
20004e1a:	717b      	strb	r3, [r7, #5]
	rx_buffer[2] = 0x00;
20004e1c:	f04f 0300 	mov.w	r3, #0
20004e20:	71bb      	strb	r3, [r7, #6]
	rx_buffer[3] = 0x00;
20004e22:	f04f 0300 	mov.w	r3, #0
20004e26:	71fb      	strb	r3, [r7, #7]
	rx_buffer[4] = 0x00;
20004e28:	f04f 0300 	mov.w	r3, #0
20004e2c:	723b      	strb	r3, [r7, #8]
	i = 0;
20004e2e:	f04f 0300 	mov.w	r3, #0
20004e32:	60fb      	str	r3, [r7, #12]
	flag = 0;
20004e34:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004e3c:	f04f 0200 	mov.w	r2, #0
20004e40:	701a      	strb	r2, [r3, #0]
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004e42:	f24d 4080 	movw	r0, #54400	; 0xd480
20004e46:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e4a:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004e4e:	f002 ff91 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004e52:	f24d 4080 	movw	r0, #54400	; 0xd480
20004e56:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e5a:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004e5e:	f002 ff89 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD58, 7, rx_buffer, 5);
20004e62:	f107 0304 	add.w	r3, r7, #4
20004e66:	f04f 0205 	mov.w	r2, #5
20004e6a:	9200      	str	r2, [sp, #0]
20004e6c:	f24d 4080 	movw	r0, #54400	; 0xd480
20004e70:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e74:	f64b 71a0 	movw	r1, #49056	; 0xbfa0
20004e78:	f2c2 0100 	movt	r1, #8192	; 0x2000
20004e7c:	f04f 0207 	mov.w	r2, #7
20004e80:	f002 ffd8 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004e84:	f24d 4080 	movw	r0, #54400	; 0xd480
20004e88:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e8c:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004e90:	f002 ff70 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004e94:	f24d 4080 	movw	r0, #54400	; 0xd480
20004e98:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004e9c:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004ea0:	f002 ff68 	bl	20007d74 <MSS_SPI_transfer_frame>

		i++;
20004ea4:	68fb      	ldr	r3, [r7, #12]
20004ea6:	f103 0301 	add.w	r3, r3, #1
20004eaa:	60fb      	str	r3, [r7, #12]

		if(rx_buffer[3] == 0x80 && rx_buffer[2] == 0xFF) {
20004eac:	79fb      	ldrb	r3, [r7, #7]
20004eae:	2b80      	cmp	r3, #128	; 0x80
20004eb0:	d10a      	bne.n	20004ec8 <SD_Init+0x418>
20004eb2:	79bb      	ldrb	r3, [r7, #6]
20004eb4:	2bff      	cmp	r3, #255	; 0xff
20004eb6:	d107      	bne.n	20004ec8 <SD_Init+0x418>
			flag = 1;
20004eb8:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004ec0:	f04f 0201 	mov.w	r2, #1
20004ec4:	701a      	strb	r2, [r3, #0]
			break;
20004ec6:	e002      	b.n	20004ece <SD_Init+0x41e>
		}

	} while( i < 255);
20004ec8:	68fb      	ldr	r3, [r7, #12]
20004eca:	2bfe      	cmp	r3, #254	; 0xfe
20004ecc:	d9b9      	bls.n	20004e42 <SD_Init+0x392>

	if(i >= 255) {
20004ece:	68fb      	ldr	r3, [r7, #12]
20004ed0:	2bfe      	cmp	r3, #254	; 0xfe
20004ed2:	d90a      	bls.n	20004eea <SD_Init+0x43a>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004ed4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004ed8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004edc:	f04f 0100 	mov.w	r1, #0
20004ee0:	f002 ff00 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		return 1;
20004ee4:	f04f 0301 	mov.w	r3, #1
20004ee8:	e01b      	b.n	20004f22 <SD_Init+0x472>
	}

	if(flag == 1) {
20004eea:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
20004eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004ef2:	781b      	ldrb	r3, [r3, #0]
20004ef4:	2b01      	cmp	r3, #1
20004ef6:	d10a      	bne.n	20004f0e <SD_Init+0x45e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004ef8:	f24d 4080 	movw	r0, #54400	; 0xd480
20004efc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004f00:	f04f 0100 	mov.w	r1, #0
20004f04:	f002 feee 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		return 0;
20004f08:	f04f 0300 	mov.w	r3, #0
20004f0c:	e009      	b.n	20004f22 <SD_Init+0x472>
	}
	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004f0e:	f24d 4080 	movw	r0, #54400	; 0xd480
20004f12:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004f16:	f04f 0100 	mov.w	r1, #0
20004f1a:	f002 fee3 	bl	20007ce4 <MSS_SPI_clear_slave_select>
	return 1;
20004f1e:	f04f 0301 	mov.w	r3, #1
}
20004f22:	4618      	mov	r0, r3
20004f24:	f107 0710 	add.w	r7, r7, #16
20004f28:	46bd      	mov	sp, r7
20004f2a:	bd80      	pop	{r7, pc}

20004f2c <SD_Write>:

uint8_t SD_Write(uint32_t addr,uint8_t *buff) {
20004f2c:	b580      	push	{r7, lr}
20004f2e:	b08c      	sub	sp, #48	; 0x30
20004f30:	af02      	add	r7, sp, #8
20004f32:	6078      	str	r0, [r7, #4]
20004f34:	6039      	str	r1, [r7, #0]
	uint8_t CMD24[] = {0x58,((addr >> 24) & 0xff ),((addr >> 16) & 0xff ),((addr >> 8) & 0xff ),(addr & 0xff ),0xFF,0xff};
20004f36:	687b      	ldr	r3, [r7, #4]
20004f38:	ea4f 6313 	mov.w	r3, r3, lsr #24
20004f3c:	b2d8      	uxtb	r0, r3
20004f3e:	687b      	ldr	r3, [r7, #4]
20004f40:	ea4f 4313 	mov.w	r3, r3, lsr #16
20004f44:	b2d9      	uxtb	r1, r3
20004f46:	687b      	ldr	r3, [r7, #4]
20004f48:	ea4f 2313 	mov.w	r3, r3, lsr #8
20004f4c:	b2da      	uxtb	r2, r3
20004f4e:	687b      	ldr	r3, [r7, #4]
20004f50:	b2db      	uxtb	r3, r3
20004f52:	f04f 0c58 	mov.w	ip, #88	; 0x58
20004f56:	f887 c018 	strb.w	ip, [r7, #24]
20004f5a:	7678      	strb	r0, [r7, #25]
20004f5c:	76b9      	strb	r1, [r7, #26]
20004f5e:	76fa      	strb	r2, [r7, #27]
20004f60:	773b      	strb	r3, [r7, #28]
20004f62:	f04f 33ff 	mov.w	r3, #4294967295
20004f66:	777b      	strb	r3, [r7, #29]
20004f68:	f04f 33ff 	mov.w	r3, #4294967295
20004f6c:	77bb      	strb	r3, [r7, #30]
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
20004f6e:	f04f 0300 	mov.w	r3, #0
20004f72:	743b      	strb	r3, [r7, #16]
20004f74:	f04f 0300 	mov.w	r3, #0
20004f78:	747b      	strb	r3, [r7, #17]
20004f7a:	f04f 0300 	mov.w	r3, #0
20004f7e:	74bb      	strb	r3, [r7, #18]
20004f80:	f04f 0300 	mov.w	r3, #0
20004f84:	74fb      	strb	r3, [r7, #19]
20004f86:	f04f 0300 	mov.w	r3, #0
20004f8a:	753b      	strb	r3, [r7, #20]
	uint8_t flag = 0;
20004f8c:	f04f 0300 	mov.w	r3, #0
20004f90:	77fb      	strb	r3, [r7, #31]
	uint8_t start_flag = 0xFE;
20004f92:	f06f 0301 	mvn.w	r3, #1
20004f96:	73fb      	strb	r3, [r7, #15]
	uint32_t i = 0,j = 0;
20004f98:	f04f 0300 	mov.w	r3, #0
20004f9c:	623b      	str	r3, [r7, #32]
20004f9e:	f04f 0300 	mov.w	r3, #0
20004fa2:	627b      	str	r3, [r7, #36]	; 0x24

	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004fa4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004fa8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004fac:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004fb0:	f002 fee0 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20004fb4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004fb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004fbc:	f04f 0100 	mov.w	r1, #0
20004fc0:	f002 fe0c 	bl	20007bdc <MSS_SPI_set_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004fc4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004fc8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004fcc:	f04f 01ff 	mov.w	r1, #255	; 0xff
20004fd0:	f002 fed0 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD24, 7, rx_buffer, 1);
20004fd4:	f107 0218 	add.w	r2, r7, #24
20004fd8:	f107 0310 	add.w	r3, r7, #16
20004fdc:	f04f 0101 	mov.w	r1, #1
20004fe0:	9100      	str	r1, [sp, #0]
20004fe2:	f24d 4080 	movw	r0, #54400	; 0xd480
20004fe6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004fea:	4611      	mov	r1, r2
20004fec:	f04f 0207 	mov.w	r2, #7
20004ff0:	f002 ff20 	bl	20007e34 <MSS_SPI_transfer_block>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20004ff4:	f24d 4080 	movw	r0, #54400	; 0xd480
20004ff8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004ffc:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005000:	f002 feb8 	bl	20007d74 <MSS_SPI_transfer_frame>

		i++;
20005004:	6a3b      	ldr	r3, [r7, #32]
20005006:	f103 0301 	add.w	r3, r3, #1
2000500a:	623b      	str	r3, [r7, #32]

		if(rx_buffer[0] == 0x00) {
2000500c:	7c3b      	ldrb	r3, [r7, #16]
2000500e:	2b00      	cmp	r3, #0
20005010:	d177      	bne.n	20005102 <SD_Write+0x1d6>
			MSS_SPI_transfer_block(&g_mss_spi1, &start_flag, 1, rx_buffer, 1);
20005012:	f107 020f 	add.w	r2, r7, #15
20005016:	f107 0310 	add.w	r3, r7, #16
2000501a:	f04f 0101 	mov.w	r1, #1
2000501e:	9100      	str	r1, [sp, #0]
20005020:	f24d 4080 	movw	r0, #54400	; 0xd480
20005024:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005028:	4611      	mov	r1, r2
2000502a:	f04f 0201 	mov.w	r2, #1
2000502e:	f002 ff01 	bl	20007e34 <MSS_SPI_transfer_block>
			MSS_SPI_transfer_block(&g_mss_spi1, buff, 512, rx_buffer, 0);
20005032:	f107 0310 	add.w	r3, r7, #16
20005036:	f04f 0200 	mov.w	r2, #0
2000503a:	9200      	str	r2, [sp, #0]
2000503c:	f24d 4080 	movw	r0, #54400	; 0xd480
20005040:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005044:	6839      	ldr	r1, [r7, #0]
20005046:	f44f 7200 	mov.w	r2, #512	; 0x200
2000504a:	f002 fef3 	bl	20007e34 <MSS_SPI_transfer_block>
			while(j<100){
2000504e:	e017      	b.n	20005080 <SD_Write+0x154>
				rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005050:	f24d 4080 	movw	r0, #54400	; 0xd480
20005054:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005058:	f04f 01ff 	mov.w	r1, #255	; 0xff
2000505c:	f002 fe8a 	bl	20007d74 <MSS_SPI_transfer_frame>
20005060:	4603      	mov	r3, r0
20005062:	b2db      	uxtb	r3, r3
20005064:	743b      	strb	r3, [r7, #16]
				if((rx_buffer[0]&0x1F) == 0x05) {
20005066:	7c3b      	ldrb	r3, [r7, #16]
20005068:	f003 031f 	and.w	r3, r3, #31
2000506c:	2b05      	cmp	r3, #5
2000506e:	d103      	bne.n	20005078 <SD_Write+0x14c>
					flag = 1;
20005070:	f04f 0301 	mov.w	r3, #1
20005074:	77fb      	strb	r3, [r7, #31]
					break;
20005076:	e006      	b.n	20005086 <SD_Write+0x15a>
				}
				j++;
20005078:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000507a:	f103 0301 	add.w	r3, r3, #1
2000507e:	627b      	str	r3, [r7, #36]	; 0x24
		i++;

		if(rx_buffer[0] == 0x00) {
			MSS_SPI_transfer_block(&g_mss_spi1, &start_flag, 1, rx_buffer, 1);
			MSS_SPI_transfer_block(&g_mss_spi1, buff, 512, rx_buffer, 0);
			while(j<100){
20005080:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20005082:	2b63      	cmp	r3, #99	; 0x63
20005084:	d9e4      	bls.n	20005050 <SD_Write+0x124>
					flag = 1;
					break;
				}
				j++;
			}
			if(flag == 1) {
20005086:	7ffb      	ldrb	r3, [r7, #31]
20005088:	2b01      	cmp	r3, #1
2000508a:	d13f      	bne.n	2000510c <SD_Write+0x1e0>
				flag = 0;
2000508c:	f04f 0300 	mov.w	r3, #0
20005090:	77fb      	strb	r3, [r7, #31]
				j = 0;
20005092:	f04f 0300 	mov.w	r3, #0
20005096:	627b      	str	r3, [r7, #36]	; 0x24
				while(j<100) {
20005098:	e02f      	b.n	200050fa <SD_Write+0x1ce>
					rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
2000509a:	f24d 4080 	movw	r0, #54400	; 0xd480
2000509e:	f2c2 0000 	movt	r0, #8192	; 0x2000
200050a2:	f04f 01ff 	mov.w	r1, #255	; 0xff
200050a6:	f002 fe65 	bl	20007d74 <MSS_SPI_transfer_frame>
200050aa:	4603      	mov	r3, r0
200050ac:	b2db      	uxtb	r3, r3
200050ae:	743b      	strb	r3, [r7, #16]
					if(rx_buffer[0]!=0x00) {
200050b0:	7c3b      	ldrb	r3, [r7, #16]
200050b2:	2b00      	cmp	r3, #0
200050b4:	d01d      	beq.n	200050f2 <SD_Write+0x1c6>
						flag = 1;
200050b6:	f04f 0301 	mov.w	r3, #1
200050ba:	77fb      	strb	r3, [r7, #31]
						MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
200050bc:	f24d 4080 	movw	r0, #54400	; 0xd480
200050c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200050c4:	f04f 01ff 	mov.w	r1, #255	; 0xff
200050c8:	f002 fe54 	bl	20007d74 <MSS_SPI_transfer_frame>
						MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
200050cc:	f24d 4080 	movw	r0, #54400	; 0xd480
200050d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200050d4:	f04f 0100 	mov.w	r1, #0
200050d8:	f002 fe04 	bl	20007ce4 <MSS_SPI_clear_slave_select>
						MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
200050dc:	f24d 4080 	movw	r0, #54400	; 0xd480
200050e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200050e4:	f04f 01ff 	mov.w	r1, #255	; 0xff
200050e8:	f002 fe44 	bl	20007d74 <MSS_SPI_transfer_frame>
						return 0;
200050ec:	f04f 0300 	mov.w	r3, #0
200050f0:	e035      	b.n	2000515e <SD_Write+0x232>
					}
					j++;
200050f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200050f4:	f103 0301 	add.w	r3, r3, #1
200050f8:	627b      	str	r3, [r7, #36]	; 0x24
				j++;
			}
			if(flag == 1) {
				flag = 0;
				j = 0;
				while(j<100) {
200050fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200050fc:	2b63      	cmp	r3, #99	; 0x63
200050fe:	d9cc      	bls.n	2000509a <SD_Write+0x16e>
						return 0;
					}
					j++;
				}
			}
			break;
20005100:	e005      	b.n	2000510e <SD_Write+0x1e2>
		}

	} while( i < 255);
20005102:	6a3b      	ldr	r3, [r7, #32]
20005104:	2bfe      	cmp	r3, #254	; 0xfe
20005106:	f67f af4d 	bls.w	20004fa4 <SD_Write+0x78>
2000510a:	e000      	b.n	2000510e <SD_Write+0x1e2>
						return 0;
					}
					j++;
				}
			}
			break;
2000510c:	bf00      	nop
		}

	} while( i < 255);

	if(i >= 255) {
2000510e:	6a3b      	ldr	r3, [r7, #32]
20005110:	2bfe      	cmp	r3, #254	; 0xfe
20005112:	d912      	bls.n	2000513a <SD_Write+0x20e>
		MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
20005114:	f24d 4080 	movw	r0, #54400	; 0xd480
20005118:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000511c:	f04f 0100 	mov.w	r1, #0
20005120:	f002 fde0 	bl	20007ce4 <MSS_SPI_clear_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005124:	f24d 4080 	movw	r0, #54400	; 0xd480
20005128:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000512c:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005130:	f002 fe20 	bl	20007d74 <MSS_SPI_transfer_frame>
		return 1;
20005134:	f04f 0301 	mov.w	r3, #1
20005138:	e011      	b.n	2000515e <SD_Write+0x232>
	}
	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
2000513a:	f24d 4080 	movw	r0, #54400	; 0xd480
2000513e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005142:	f04f 0100 	mov.w	r1, #0
20005146:	f002 fdcd 	bl	20007ce4 <MSS_SPI_clear_slave_select>
	MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
2000514a:	f24d 4080 	movw	r0, #54400	; 0xd480
2000514e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005152:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005156:	f002 fe0d 	bl	20007d74 <MSS_SPI_transfer_frame>
	return 1;
2000515a:	f04f 0301 	mov.w	r3, #1
}
2000515e:	4618      	mov	r0, r3
20005160:	f107 0728 	add.w	r7, r7, #40	; 0x28
20005164:	46bd      	mov	sp, r7
20005166:	bd80      	pop	{r7, pc}

20005168 <SD_Read>:

uint8_t SD_Read(const uint32_t addr,uint8_t *buff) {
20005168:	b580      	push	{r7, lr}
2000516a:	b08c      	sub	sp, #48	; 0x30
2000516c:	af02      	add	r7, sp, #8
2000516e:	6078      	str	r0, [r7, #4]
20005170:	6039      	str	r1, [r7, #0]
	uint8_t CMD17[] = {0x51,((addr >> 24) & 0xff ),((addr >> 16) & 0xff ),((addr >> 8) & 0xff ),(addr & 0xff ),0xFF,0xff};
20005172:	687b      	ldr	r3, [r7, #4]
20005174:	ea4f 6313 	mov.w	r3, r3, lsr #24
20005178:	b2d8      	uxtb	r0, r3
2000517a:	687b      	ldr	r3, [r7, #4]
2000517c:	ea4f 4313 	mov.w	r3, r3, lsr #16
20005180:	b2d9      	uxtb	r1, r3
20005182:	687b      	ldr	r3, [r7, #4]
20005184:	ea4f 2313 	mov.w	r3, r3, lsr #8
20005188:	b2da      	uxtb	r2, r3
2000518a:	687b      	ldr	r3, [r7, #4]
2000518c:	b2db      	uxtb	r3, r3
2000518e:	f04f 0c51 	mov.w	ip, #81	; 0x51
20005192:	f887 c018 	strb.w	ip, [r7, #24]
20005196:	7678      	strb	r0, [r7, #25]
20005198:	76b9      	strb	r1, [r7, #26]
2000519a:	76fa      	strb	r2, [r7, #27]
2000519c:	773b      	strb	r3, [r7, #28]
2000519e:	f04f 33ff 	mov.w	r3, #4294967295
200051a2:	777b      	strb	r3, [r7, #29]
200051a4:	f04f 33ff 	mov.w	r3, #4294967295
200051a8:	77bb      	strb	r3, [r7, #30]
	uint8_t rx_buffer[5] = {0x00,0x00,0x00,0x00,0x00};
200051aa:	f04f 0300 	mov.w	r3, #0
200051ae:	743b      	strb	r3, [r7, #16]
200051b0:	f04f 0300 	mov.w	r3, #0
200051b4:	747b      	strb	r3, [r7, #17]
200051b6:	f04f 0300 	mov.w	r3, #0
200051ba:	74bb      	strb	r3, [r7, #18]
200051bc:	f04f 0300 	mov.w	r3, #0
200051c0:	74fb      	strb	r3, [r7, #19]
200051c2:	f04f 0300 	mov.w	r3, #0
200051c6:	753b      	strb	r3, [r7, #20]
	uint8_t flag = 0;
200051c8:	f04f 0300 	mov.w	r3, #0
200051cc:	77fb      	strb	r3, [r7, #31]
	uint8_t dummy_data = 0xff;
200051ce:	f04f 33ff 	mov.w	r3, #4294967295
200051d2:	73fb      	strb	r3, [r7, #15]
	uint32_t i = 0;
200051d4:	f04f 0300 	mov.w	r3, #0
200051d8:	623b      	str	r3, [r7, #32]
	uint16_t c = 0;
200051da:	f04f 0300 	mov.w	r3, #0
200051de:	84fb      	strh	r3, [r7, #38]	; 0x26

	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
200051e0:	f24d 4080 	movw	r0, #54400	; 0xd480
200051e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200051e8:	f04f 01ff 	mov.w	r1, #255	; 0xff
200051ec:	f002 fdc2 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
200051f0:	f24d 4080 	movw	r0, #54400	; 0xd480
200051f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200051f8:	f04f 0100 	mov.w	r1, #0
200051fc:	f002 fcee 	bl	20007bdc <MSS_SPI_set_slave_select>
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005200:	f24d 4080 	movw	r0, #54400	; 0xd480
20005204:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005208:	f04f 01ff 	mov.w	r1, #255	; 0xff
2000520c:	f002 fdb2 	bl	20007d74 <MSS_SPI_transfer_frame>
		MSS_SPI_transfer_block(&g_mss_spi1, CMD17, 7, rx_buffer, 1);
20005210:	f107 0218 	add.w	r2, r7, #24
20005214:	f107 0310 	add.w	r3, r7, #16
20005218:	f04f 0101 	mov.w	r1, #1
2000521c:	9100      	str	r1, [sp, #0]
2000521e:	f24d 4080 	movw	r0, #54400	; 0xd480
20005222:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005226:	4611      	mov	r1, r2
20005228:	f04f 0207 	mov.w	r2, #7
2000522c:	f002 fe02 	bl	20007e34 <MSS_SPI_transfer_block>
		while(c<250) {
20005230:	e056      	b.n	200052e0 <SD_Read+0x178>
			rx_buffer[0] = MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005232:	f24d 4080 	movw	r0, #54400	; 0xd480
20005236:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000523a:	f04f 01ff 	mov.w	r1, #255	; 0xff
2000523e:	f002 fd99 	bl	20007d74 <MSS_SPI_transfer_frame>
20005242:	4603      	mov	r3, r0
20005244:	b2db      	uxtb	r3, r3
20005246:	743b      	strb	r3, [r7, #16]
			c++;
20005248:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000524a:	f103 0301 	add.w	r3, r3, #1
2000524e:	84fb      	strh	r3, [r7, #38]	; 0x26
			if(rx_buffer[0] == 0xFE) {
20005250:	7c3b      	ldrb	r3, [r7, #16]
20005252:	2bfe      	cmp	r3, #254	; 0xfe
20005254:	d144      	bne.n	200052e0 <SD_Read+0x178>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005256:	f24d 4080 	movw	r0, #54400	; 0xd480
2000525a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000525e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005262:	f002 fd87 	bl	20007d74 <MSS_SPI_transfer_frame>
				MSS_SPI_transfer_block(&g_mss_spi1,&dummy_data,0,buff,512);
20005266:	f107 030f 	add.w	r3, r7, #15
2000526a:	f44f 7200 	mov.w	r2, #512	; 0x200
2000526e:	9200      	str	r2, [sp, #0]
20005270:	f24d 4080 	movw	r0, #54400	; 0xd480
20005274:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005278:	4619      	mov	r1, r3
2000527a:	f04f 0200 	mov.w	r2, #0
2000527e:	683b      	ldr	r3, [r7, #0]
20005280:	f002 fdd8 	bl	20007e34 <MSS_SPI_transfer_block>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005284:	f24d 4080 	movw	r0, #54400	; 0xd480
20005288:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000528c:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005290:	f002 fd70 	bl	20007d74 <MSS_SPI_transfer_frame>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005294:	f24d 4080 	movw	r0, #54400	; 0xd480
20005298:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000529c:	f04f 01ff 	mov.w	r1, #255	; 0xff
200052a0:	f002 fd68 	bl	20007d74 <MSS_SPI_transfer_frame>
				flag = 1;
200052a4:	f04f 0301 	mov.w	r3, #1
200052a8:	77fb      	strb	r3, [r7, #31]
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
200052aa:	f24d 4080 	movw	r0, #54400	; 0xd480
200052ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
200052b2:	f04f 01ff 	mov.w	r1, #255	; 0xff
200052b6:	f002 fd5d 	bl	20007d74 <MSS_SPI_transfer_frame>
				MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
200052ba:	f24d 4080 	movw	r0, #54400	; 0xd480
200052be:	f2c2 0000 	movt	r0, #8192	; 0x2000
200052c2:	f04f 0100 	mov.w	r1, #0
200052c6:	f002 fd0d 	bl	20007ce4 <MSS_SPI_clear_slave_select>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
200052ca:	f24d 4080 	movw	r0, #54400	; 0xd480
200052ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
200052d2:	f04f 01ff 	mov.w	r1, #255	; 0xff
200052d6:	f002 fd4d 	bl	20007d74 <MSS_SPI_transfer_frame>
				return 0;
200052da:	f04f 0300 	mov.w	r3, #0
200052de:	e01c      	b.n	2000531a <SD_Read+0x1b2>
	do {
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
		MSS_SPI_set_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
		MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
		MSS_SPI_transfer_block(&g_mss_spi1, CMD17, 7, rx_buffer, 1);
		while(c<250) {
200052e0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200052e2:	2bf9      	cmp	r3, #249	; 0xf9
200052e4:	d9a5      	bls.n	20005232 <SD_Read+0xca>
				MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
				return 0;
				break;
			}
		}
		i++;
200052e6:	6a3b      	ldr	r3, [r7, #32]
200052e8:	f103 0301 	add.w	r3, r3, #1
200052ec:	623b      	str	r3, [r7, #32]
	}while(i<100);
200052ee:	6a3b      	ldr	r3, [r7, #32]
200052f0:	2b63      	cmp	r3, #99	; 0x63
200052f2:	f67f af75 	bls.w	200051e0 <SD_Read+0x78>

	MSS_SPI_clear_slave_select(&g_mss_spi1, MSS_SPI_SLAVE_0);
200052f6:	f24d 4080 	movw	r0, #54400	; 0xd480
200052fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200052fe:	f04f 0100 	mov.w	r1, #0
20005302:	f002 fcef 	bl	20007ce4 <MSS_SPI_clear_slave_select>
	MSS_SPI_transfer_frame(&g_mss_spi1, 0xff);
20005306:	f24d 4080 	movw	r0, #54400	; 0xd480
2000530a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000530e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20005312:	f002 fd2f 	bl	20007d74 <MSS_SPI_transfer_frame>
	return 1;
20005316:	f04f 0301 	mov.w	r3, #1
}
2000531a:	4618      	mov	r0, r3
2000531c:	f107 0728 	add.w	r7, r7, #40	; 0x28
20005320:	46bd      	mov	sp, r7
20005322:	bd80      	pop	{r7, pc}

20005324 <initialise_partition>:
 * 
 */

#include "memory.h"

void initialise_partition(partition_t *partition, uint32_t start_b,uint32_t end_b) {
20005324:	b480      	push	{r7}
20005326:	b085      	sub	sp, #20
20005328:	af00      	add	r7, sp, #0
2000532a:	60f8      	str	r0, [r7, #12]
2000532c:	60b9      	str	r1, [r7, #8]
2000532e:	607a      	str	r2, [r7, #4]
	partition->start_block = start_b;
20005330:	68fb      	ldr	r3, [r7, #12]
20005332:	68ba      	ldr	r2, [r7, #8]
20005334:	601a      	str	r2, [r3, #0]
	partition->end_block = end_b;
20005336:	68fb      	ldr	r3, [r7, #12]
20005338:	687a      	ldr	r2, [r7, #4]
2000533a:	605a      	str	r2, [r3, #4]
	partition->read_pointer = start_b;
2000533c:	68fb      	ldr	r3, [r7, #12]
2000533e:	68ba      	ldr	r2, [r7, #8]
20005340:	609a      	str	r2, [r3, #8]
	partition->write_pointer = start_b;
20005342:	68fb      	ldr	r3, [r7, #12]
20005344:	68ba      	ldr	r2, [r7, #8]
20005346:	60da      	str	r2, [r3, #12]
}
20005348:	f107 0714 	add.w	r7, r7, #20
2000534c:	46bd      	mov	sp, r7
2000534e:	bc80      	pop	{r7}
20005350:	4770      	bx	lr
20005352:	bf00      	nop

20005354 <store_data>:

uint8_t store_data(partition_t *partition,uint8_t *data) {
20005354:	b580      	push	{r7, lr}
20005356:	b082      	sub	sp, #8
20005358:	af00      	add	r7, sp, #0
2000535a:	6078      	str	r0, [r7, #4]
2000535c:	6039      	str	r1, [r7, #0]
	if((partition->write_pointer >= partition->end_block) || (partition->write_pointer < partition->start_block)) {
2000535e:	687b      	ldr	r3, [r7, #4]
20005360:	68da      	ldr	r2, [r3, #12]
20005362:	687b      	ldr	r3, [r7, #4]
20005364:	685b      	ldr	r3, [r3, #4]
20005366:	429a      	cmp	r2, r3
20005368:	d205      	bcs.n	20005376 <store_data+0x22>
2000536a:	687b      	ldr	r3, [r7, #4]
2000536c:	68da      	ldr	r2, [r3, #12]
2000536e:	687b      	ldr	r3, [r7, #4]
20005370:	681b      	ldr	r3, [r3, #0]
20005372:	429a      	cmp	r2, r3
20005374:	d202      	bcs.n	2000537c <store_data+0x28>
		return 2;
20005376:	f04f 0302 	mov.w	r3, #2
2000537a:	e013      	b.n	200053a4 <store_data+0x50>
	}

	if(SD_Write(partition->write_pointer,data) == 0) {
2000537c:	687b      	ldr	r3, [r7, #4]
2000537e:	68db      	ldr	r3, [r3, #12]
20005380:	4618      	mov	r0, r3
20005382:	6839      	ldr	r1, [r7, #0]
20005384:	f7ff fdd2 	bl	20004f2c <SD_Write>
20005388:	4603      	mov	r3, r0
2000538a:	2b00      	cmp	r3, #0
2000538c:	d108      	bne.n	200053a0 <store_data+0x4c>
		partition->write_pointer++;
2000538e:	687b      	ldr	r3, [r7, #4]
20005390:	68db      	ldr	r3, [r3, #12]
20005392:	f103 0201 	add.w	r2, r3, #1
20005396:	687b      	ldr	r3, [r7, #4]
20005398:	60da      	str	r2, [r3, #12]
		return 0;
2000539a:	f04f 0300 	mov.w	r3, #0
2000539e:	e001      	b.n	200053a4 <store_data+0x50>
	}

	return 1;
200053a0:	f04f 0301 	mov.w	r3, #1
}
200053a4:	4618      	mov	r0, r3
200053a6:	f107 0708 	add.w	r7, r7, #8
200053aa:	46bd      	mov	sp, r7
200053ac:	bd80      	pop	{r7, pc}
200053ae:	bf00      	nop

200053b0 <read_data>:

uint8_t read_data(partition_t *partition,uint8_t *data) {
200053b0:	b580      	push	{r7, lr}
200053b2:	b082      	sub	sp, #8
200053b4:	af00      	add	r7, sp, #0
200053b6:	6078      	str	r0, [r7, #4]
200053b8:	6039      	str	r1, [r7, #0]
	if((partition->read_pointer >= partition->write_pointer) || (partition->read_pointer < partition->start_block)) {
200053ba:	687b      	ldr	r3, [r7, #4]
200053bc:	689a      	ldr	r2, [r3, #8]
200053be:	687b      	ldr	r3, [r7, #4]
200053c0:	68db      	ldr	r3, [r3, #12]
200053c2:	429a      	cmp	r2, r3
200053c4:	d205      	bcs.n	200053d2 <read_data+0x22>
200053c6:	687b      	ldr	r3, [r7, #4]
200053c8:	689a      	ldr	r2, [r3, #8]
200053ca:	687b      	ldr	r3, [r7, #4]
200053cc:	681b      	ldr	r3, [r3, #0]
200053ce:	429a      	cmp	r2, r3
200053d0:	d202      	bcs.n	200053d8 <read_data+0x28>
		return 2;
200053d2:	f04f 0302 	mov.w	r3, #2
200053d6:	e013      	b.n	20005400 <read_data+0x50>
	}

	if(SD_Read(partition->read_pointer,data) == 0) {
200053d8:	687b      	ldr	r3, [r7, #4]
200053da:	689b      	ldr	r3, [r3, #8]
200053dc:	4618      	mov	r0, r3
200053de:	6839      	ldr	r1, [r7, #0]
200053e0:	f7ff fec2 	bl	20005168 <SD_Read>
200053e4:	4603      	mov	r3, r0
200053e6:	2b00      	cmp	r3, #0
200053e8:	d108      	bne.n	200053fc <read_data+0x4c>
		partition->read_pointer++;
200053ea:	687b      	ldr	r3, [r7, #4]
200053ec:	689b      	ldr	r3, [r3, #8]
200053ee:	f103 0201 	add.w	r2, r3, #1
200053f2:	687b      	ldr	r3, [r7, #4]
200053f4:	609a      	str	r2, [r3, #8]
		return 0;
200053f6:	f04f 0300 	mov.w	r3, #0
200053fa:	e001      	b.n	20005400 <read_data+0x50>
	}

	return 1;
200053fc:	f04f 0301 	mov.w	r3, #1
}
20005400:	4618      	mov	r0, r3
20005402:	f107 0708 	add.w	r7, r7, #8
20005406:	46bd      	mov	sp, r7
20005408:	bd80      	pop	{r7, pc}
2000540a:	bf00      	nop

2000540c <counter_init>:
uint8_t rx_size = 3u;
i2c_status_t status;
uint8_t flag;
uint8_t gmc_voltage_flags;

i2c_status_t counter_init(i2c_instance_t *i2c_GMC_counter){
2000540c:	b580      	push	{r7, lr}
2000540e:	b082      	sub	sp, #8
20005410:	af00      	add	r7, sp, #0
20005412:	6078      	str	r0, [r7, #4]
    MSS_GPIO_config(RESET_GMC_GPIO, MSS_GPIO_OUTPUT_MODE);
20005414:	f04f 0006 	mov.w	r0, #6
20005418:	f04f 0105 	mov.w	r1, #5
2000541c:	f004 f822 	bl	20009464 <MSS_GPIO_config>
    MSS_GPIO_set_output(RESET_GMC_GPIO, 1);
20005420:	f04f 0006 	mov.w	r0, #6
20005424:	f04f 0101 	mov.w	r1, #1
20005428:	f004 f83a 	bl	200094a0 <MSS_GPIO_set_output>
	I2C_init(
2000542c:	6878      	ldr	r0, [r7, #4]
2000542e:	f242 0100 	movw	r1, #8192	; 0x2000
20005432:	f2c5 0100 	movt	r1, #20480	; 0x5000
20005436:	f04f 0210 	mov.w	r2, #16
2000543a:	f04f 0300 	mov.w	r3, #0
2000543e:	f004 fd21 	bl	20009e84 <I2C_init>
				i2c_GMC_counter,
				base_addr,
				DUMMY_SLAVE_ADDRESS,
				I2C_PCLK_DIV_256
				);
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
20005442:	6878      	ldr	r0, [r7, #4]
20005444:	f04f 0100 	mov.w	r1, #0
20005448:	f004 ff0e 	bl	2000a268 <I2C_wait_complete>
2000544c:	4603      	mov	r3, r0
2000544e:	461a      	mov	r2, r3
20005450:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20005454:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005458:	701a      	strb	r2, [r3, #0]
	return status;
2000545a:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
2000545e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005462:	781b      	ldrb	r3, [r3, #0]
}
20005464:	4618      	mov	r0, r3
20005466:	f107 0708 	add.w	r7, r7, #8
2000546a:	46bd      	mov	sp, r7
2000546c:	bd80      	pop	{r7, pc}
2000546e:	bf00      	nop

20005470 <get_count>:
	I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_RELEASE_BUS);
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
	return status;
}

i2c_status_t get_count(i2c_instance_t *i2c_GMC_counter, uint8_t* count){
20005470:	b580      	push	{r7, lr}
20005472:	b084      	sub	sp, #16
20005474:	af02      	add	r7, sp, #8
20005476:	6078      	str	r0, [r7, #4]
20005478:	6039      	str	r1, [r7, #0]
	I2C_read(i2c_GMC_counter, counter_addr, count, rx_size, I2C_RELEASE_BUS);
2000547a:	f64b 73b8 	movw	r3, #49080	; 0xbfb8
2000547e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005482:	781b      	ldrb	r3, [r3, #0]
20005484:	f04f 0200 	mov.w	r2, #0
20005488:	9200      	str	r2, [sp, #0]
2000548a:	6878      	ldr	r0, [r7, #4]
2000548c:	f04f 0132 	mov.w	r1, #50	; 0x32
20005490:	683a      	ldr	r2, [r7, #0]
20005492:	f004 fddf 	bl	2000a054 <I2C_read>
	status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
20005496:	6878      	ldr	r0, [r7, #4]
20005498:	f04f 0100 	mov.w	r1, #0
2000549c:	f004 fee4 	bl	2000a268 <I2C_wait_complete>
200054a0:	4603      	mov	r3, r0
200054a2:	461a      	mov	r2, r3
200054a4:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200054a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200054ac:	701a      	strb	r2, [r3, #0]
	return status;
200054ae:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
200054b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200054b6:	781b      	ldrb	r3, [r3, #0]
}
200054b8:	4618      	mov	r0, r3
200054ba:	f107 0708 	add.w	r7, r7, #8
200054be:	46bd      	mov	sp, r7
200054c0:	bd80      	pop	{r7, pc}
200054c2:	bf00      	nop

200054c4 <get_free_res>:
    I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_RELEASE_BUS);
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
    return status;
}

i2c_status_t get_free_res(i2c_instance_t *i2c_GMC_counter, uint8_t* free_res){
200054c4:	b580      	push	{r7, lr}
200054c6:	b086      	sub	sp, #24
200054c8:	af02      	add	r7, sp, #8
200054ca:	6078      	str	r0, [r7, #4]
200054cc:	6039      	str	r1, [r7, #0]
    uint8_t tx_size = 1;
200054ce:	f04f 0301 	mov.w	r3, #1
200054d2:	73fb      	strb	r3, [r7, #15]
    uint8_t tx_buffer[1];
    tx_buffer[0] = 0x01;  //1xxxxxx1 address pointer and test bit(why sending this byte after slave address?)
200054d4:	f04f 0301 	mov.w	r3, #1
200054d8:	733b      	strb	r3, [r7, #12]

    I2C_write(i2c_GMC_counter, counter_addr, tx_buffer, tx_size, I2C_HOLD_BUS);
200054da:	7bfb      	ldrb	r3, [r7, #15]
200054dc:	f107 020c 	add.w	r2, r7, #12
200054e0:	f04f 0101 	mov.w	r1, #1
200054e4:	9100      	str	r1, [sp, #0]
200054e6:	6878      	ldr	r0, [r7, #4]
200054e8:	f04f 0132 	mov.w	r1, #50	; 0x32
200054ec:	f004 fd40 	bl	20009f70 <I2C_write>
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
200054f0:	6878      	ldr	r0, [r7, #4]
200054f2:	f04f 0100 	mov.w	r1, #0
200054f6:	f004 feb7 	bl	2000a268 <I2C_wait_complete>
200054fa:	4603      	mov	r3, r0
200054fc:	461a      	mov	r2, r3
200054fe:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20005502:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005506:	701a      	strb	r2, [r3, #0]


    I2C_read(i2c_GMC_counter, counter_addr, free_res, rx_size, I2C_RELEASE_BUS);
20005508:	f64b 73b8 	movw	r3, #49080	; 0xbfb8
2000550c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005510:	781b      	ldrb	r3, [r3, #0]
20005512:	f04f 0200 	mov.w	r2, #0
20005516:	9200      	str	r2, [sp, #0]
20005518:	6878      	ldr	r0, [r7, #4]
2000551a:	f04f 0132 	mov.w	r1, #50	; 0x32
2000551e:	683a      	ldr	r2, [r7, #0]
20005520:	f004 fd98 	bl	2000a054 <I2C_read>
    status = I2C_wait_complete(i2c_GMC_counter, I2C_NO_TIMEOUT);
20005524:	6878      	ldr	r0, [r7, #4]
20005526:	f04f 0100 	mov.w	r1, #0
2000552a:	f004 fe9d 	bl	2000a268 <I2C_wait_complete>
2000552e:	4603      	mov	r3, r0
20005530:	461a      	mov	r2, r3
20005532:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20005536:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000553a:	701a      	strb	r2, [r3, #0]
    return status;
2000553c:	f24d 03fc 	movw	r3, #53500	; 0xd0fc
20005540:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005544:	781b      	ldrb	r3, [r3, #0]
}
20005546:	4618      	mov	r0, r3
20005548:	f107 0710 	add.w	r7, r7, #16
2000554c:	46bd      	mov	sp, r7
2000554e:	bd80      	pop	{r7, pc}

20005550 <get_gmc_voltages>:

i2c_status_t get_gmc_voltages(i2c_instance_t *i2c_GMC_ADC, uint8_t* ADC_voltages){
20005550:	b590      	push	{r4, r7, lr}
20005552:	b085      	sub	sp, #20
20005554:	af00      	add	r7, sp, #0
20005556:	6078      	str	r0, [r7, #4]
20005558:	6039      	str	r1, [r7, #0]
	uint8_t channel;
	for (channel=0; channel<8; channel++){
2000555a:	f04f 0300 	mov.w	r3, #0
2000555e:	73fb      	strb	r3, [r7, #15]
20005560:	e02e      	b.n	200055c0 <get_gmc_voltages+0x70>
		ADC_voltages[channel] = get_ADC_value(&counter_i2c, GMC_ADC_address, channel, &flag);
20005562:	7bfa      	ldrb	r2, [r7, #15]
20005564:	683b      	ldr	r3, [r7, #0]
20005566:	eb02 0403 	add.w	r4, r2, r3
2000556a:	7bfb      	ldrb	r3, [r7, #15]
2000556c:	f64c 70cc 	movw	r0, #53196	; 0xcfcc
20005570:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005574:	f04f 0121 	mov.w	r1, #33	; 0x21
20005578:	461a      	mov	r2, r3
2000557a:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
2000557e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005582:	f7fe fee7 	bl	20004354 <get_ADC_value>
20005586:	4603      	mov	r3, r0
20005588:	b2db      	uxtb	r3, r3
2000558a:	7023      	strb	r3, [r4, #0]
		gmc_voltage_flags = gmc_voltage_flags << 1 | flag;
2000558c:	f24d 33f7 	movw	r3, #54263	; 0xd3f7
20005590:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005594:	781b      	ldrb	r3, [r3, #0]
20005596:	ea4f 0343 	mov.w	r3, r3, lsl #1
2000559a:	b2da      	uxtb	r2, r3
2000559c:	f24d 33f6 	movw	r3, #54262	; 0xd3f6
200055a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200055a4:	781b      	ldrb	r3, [r3, #0]
200055a6:	ea42 0303 	orr.w	r3, r2, r3
200055aa:	b2db      	uxtb	r3, r3
200055ac:	b2da      	uxtb	r2, r3
200055ae:	f24d 33f7 	movw	r3, #54263	; 0xd3f7
200055b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200055b6:	701a      	strb	r2, [r3, #0]
    return status;
}

i2c_status_t get_gmc_voltages(i2c_instance_t *i2c_GMC_ADC, uint8_t* ADC_voltages){
	uint8_t channel;
	for (channel=0; channel<8; channel++){
200055b8:	7bfb      	ldrb	r3, [r7, #15]
200055ba:	f103 0301 	add.w	r3, r3, #1
200055be:	73fb      	strb	r3, [r7, #15]
200055c0:	7bfb      	ldrb	r3, [r7, #15]
200055c2:	2b07      	cmp	r3, #7
200055c4:	d9cd      	bls.n	20005562 <get_gmc_voltages+0x12>
		ADC_voltages[channel] = get_ADC_value(&counter_i2c, GMC_ADC_address, channel, &flag);
		gmc_voltage_flags = gmc_voltage_flags << 1 | flag;
	}
}
200055c6:	f107 0714 	add.w	r7, r7, #20
200055ca:	46bd      	mov	sp, r7
200055cc:	bd90      	pop	{r4, r7, pc}
200055ce:	bf00      	nop

200055d0 <set_adf_spi_instance>:
#include "adf7030.h"

ADF_SPI_INSTANCE_t *adf_spi;
extern cmd_t cmd_list[NUM_CMDS];

void set_adf_spi_instance(ADF_SPI_INSTANCE_t *instance) {
200055d0:	b480      	push	{r7}
200055d2:	b083      	sub	sp, #12
200055d4:	af00      	add	r7, sp, #0
200055d6:	6078      	str	r0, [r7, #4]
    adf_spi = instance;
200055d8:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
200055dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200055e0:	687a      	ldr	r2, [r7, #4]
200055e2:	601a      	str	r2, [r3, #0]
}
200055e4:	f107 070c 	add.w	r7, r7, #12
200055e8:	46bd      	mov	sp, r7
200055ea:	bc80      	pop	{r7}
200055ec:	4770      	bx	lr
200055ee:	bf00      	nop

200055f0 <adf_init>:
static uint32_t config_length_header;

//Pointer to store the beginning of the SPI commands in radio_memory_configuration
uint8_t *radio_memory_configuration_start_spi_command;

uint8_t adf_init(){
200055f0:	b580      	push	{r7, lr}
200055f2:	b08a      	sub	sp, #40	; 0x28
200055f4:	af02      	add	r7, sp, #8
	uint32_t before = 0xFFFFFFFF,current,limit;
200055f6:	f04f 33ff 	mov.w	r3, #4294967295
200055fa:	60fb      	str	r3, [r7, #12]
	uint8_t buf=0xFF, count=0;
200055fc:	f04f 33ff 	mov.w	r3, #4294967295
20005600:	72fb      	strb	r3, [r7, #11]
20005602:	f04f 0300 	mov.w	r3, #0
20005606:	76bb      	strb	r3, [r7, #26]
	uint8_t flag = 1,rx_data =0;
20005608:	f04f 0301 	mov.w	r3, #1
2000560c:	76fb      	strb	r3, [r7, #27]
2000560e:	f04f 0300 	mov.w	r3, #0
20005612:	72bb      	strb	r3, [r7, #10]
	uint8_t enable_intr[4];
	enable_intr[0] = 0x00;
20005614:	f04f 0300 	mov.w	r3, #0
20005618:	713b      	strb	r3, [r7, #4]
	enable_intr[1] = 0xFF;
2000561a:	f04f 33ff 	mov.w	r3, #4294967295
2000561e:	717b      	strb	r3, [r7, #5]
	enable_intr[2] = 0x10;
20005620:	f04f 0310 	mov.w	r3, #16
20005624:	71bb      	strb	r3, [r7, #6]
	enable_intr[3] = 0x17;
20005626:	f04f 0317 	mov.w	r3, #23
2000562a:	71fb      	strb	r3, [r7, #7]
	//Timer to check if MISO is reacting on time. Typical delay bw #CS Low and MISO high is 92us from datasheet. Here
//	TMR_init(&timer,CORETIMER_0_0,TMR_ONE_SHOT_MODE,PRESCALER_DIV_2,before);

	//Set the adf spi as g_core_spi0

	SPI_init(&g_core_spi0, CORESPI_C0_0, 8);
2000562c:	f24c 4094 	movw	r0, #50324	; 0xc494
20005630:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005634:	f244 0100 	movw	r1, #16384	; 0x4000
20005638:	f2c5 0100 	movt	r1, #20480	; 0x5000
2000563c:	f04f 0208 	mov.w	r2, #8
20005640:	f004 f892 	bl	20009768 <SPI_init>
	SPI_configure_master_mode(&g_core_spi0);
20005644:	f24c 4094 	movw	r0, #50324	; 0xc494
20005648:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000564c:	f004 f8fe 	bl	2000984c <SPI_configure_master_mode>

	MSS_GPIO_config(MSS_GPIO_5, MSS_GPIO_OUTPUT_MODE);
20005650:	f04f 0005 	mov.w	r0, #5
20005654:	f04f 0105 	mov.w	r1, #5
20005658:	f003 ff04 	bl	20009464 <MSS_GPIO_config>

	set_adf_spi_instance(&g_core_spi0);
2000565c:	f24c 4094 	movw	r0, #50324	; 0xc494
20005660:	f2c2 0000 	movt	r0, #8192	; 0x2000
20005664:	f7ff ffb4 	bl	200055d0 <set_adf_spi_instance>

	//Doing ADF_RESET

	MSS_GPIO_set_output(ADF_RST,0);
20005668:	f04f 0005 	mov.w	r0, #5
2000566c:	f04f 0100 	mov.w	r1, #0
20005670:	f003 ff16 	bl	200094a0 <MSS_GPIO_set_output>
	uint16_t i = 0;
20005674:	f04f 0300 	mov.w	r3, #0
20005678:	83bb      	strh	r3, [r7, #28]
	for(i=0;i<1000;i++){
2000567a:	f04f 0300 	mov.w	r3, #0
2000567e:	83bb      	strh	r3, [r7, #28]
20005680:	e003      	b.n	2000568a <adf_init+0x9a>
20005682:	8bbb      	ldrh	r3, [r7, #28]
20005684:	f103 0301 	add.w	r3, r3, #1
20005688:	83bb      	strh	r3, [r7, #28]
2000568a:	8bba      	ldrh	r2, [r7, #28]
2000568c:	f240 33e7 	movw	r3, #999	; 0x3e7
20005690:	429a      	cmp	r2, r3
20005692:	d9f6      	bls.n	20005682 <adf_init+0x92>

	}
	MSS_GPIO_set_output(ADF_RST,1);
20005694:	f04f 0005 	mov.w	r0, #5
20005698:	f04f 0101 	mov.w	r1, #1
2000569c:	f003 ff00 	bl	200094a0 <MSS_GPIO_set_output>
	//Start timer
//	TMR_start(&timer);

	//Bring #CS Low by selecting the slave
//	ADF_SPI_SLAVE_SELECT(adf_spi, ADF_SPI_SLAVE);
	i = 0;
200056a0:	f04f 0300 	mov.w	r3, #0
200056a4:	83bb      	strh	r3, [r7, #28]

//		ADF_SPI_BLOCK_READ(adf_spi, &rx_data ,1, &rx_data, 1);
		//Older version
		//MSS_GPIO_set_output(MSS_GPIO_3, 0);
		//New Version
		ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
200056a6:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
200056aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200056ae:	681b      	ldr	r3, [r3, #0]
200056b0:	4618      	mov	r0, r3
200056b2:	f04f 0100 	mov.w	r1, #0
200056b6:	f004 f90b 	bl	200098d0 <SPI_set_slave_select>
		for(i=0;i<350;i++){
200056ba:	f04f 0300 	mov.w	r3, #0
200056be:	83bb      	strh	r3, [r7, #28]
200056c0:	e003      	b.n	200056ca <adf_init+0xda>
200056c2:	8bbb      	ldrh	r3, [r7, #28]
200056c4:	f103 0301 	add.w	r3, r3, #1
200056c8:	83bb      	strh	r3, [r7, #28]
200056ca:	8bba      	ldrh	r2, [r7, #28]
200056cc:	f240 135d 	movw	r3, #349	; 0x15d
200056d0:	429a      	cmp	r2, r3
200056d2:	d9f6      	bls.n	200056c2 <adf_init+0xd2>

		}
		ADF_SPI_BLOCK_READ(adf_spi, &buf ,1, &rx_data, 1);
200056d4:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
200056d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200056dc:	6819      	ldr	r1, [r3, #0]
200056de:	f107 020b 	add.w	r2, r7, #11
200056e2:	f107 030a 	add.w	r3, r7, #10
200056e6:	f04f 0001 	mov.w	r0, #1
200056ea:	9000      	str	r0, [sp, #0]
200056ec:	4608      	mov	r0, r1
200056ee:	4611      	mov	r1, r2
200056f0:	f04f 0201 	mov.w	r2, #1
200056f4:	f000 fb26 	bl	20005d44 <adf_spi_trans_read>

//		for(i=0;i<350;i++){
//
//		}

		if(rx_data) {
200056f8:	7abb      	ldrb	r3, [r7, #10]
200056fa:	2b00      	cmp	r3, #0
200056fc:	d01a      	beq.n	20005734 <adf_init+0x144>
			flag = 0;
200056fe:	f04f 0300 	mov.w	r3, #0
20005702:	76fb      	strb	r3, [r7, #27]
			//Older version
//			MSS_GPIO_set_output(MSS_GPIO_3, 1);
			//New version
			ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
20005704:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005708:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000570c:	681b      	ldr	r3, [r3, #0]
2000570e:	4618      	mov	r0, r3
20005710:	f04f 0100 	mov.w	r1, #0
20005714:	f004 f930 	bl	20009978 <SPI_clear_slave_select>
			for(i=0;i<1000;i++){
20005718:	f04f 0300 	mov.w	r3, #0
2000571c:	83bb      	strh	r3, [r7, #28]
2000571e:	e003      	b.n	20005728 <adf_init+0x138>
20005720:	8bbb      	ldrh	r3, [r7, #28]
20005722:	f103 0301 	add.w	r3, r3, #1
20005726:	83bb      	strh	r3, [r7, #28]
20005728:	8bba      	ldrh	r2, [r7, #28]
2000572a:	f240 33e7 	movw	r3, #999	; 0x3e7
2000572e:	429a      	cmp	r2, r3
20005730:	d9f6      	bls.n	20005720 <adf_init+0x130>

			}
			break;
20005732:	e006      	b.n	20005742 <adf_init+0x152>
		}
		// current = TMR_current_value(&timer);
		// if((before - current) > limit) {
		// 	flag = 1;
		// 	break;
		count++;
20005734:	7ebb      	ldrb	r3, [r7, #26]
20005736:	f103 0301 	add.w	r3, r3, #1
2000573a:	76bb      	strb	r3, [r7, #26]
		// }
	}while(count<10);
2000573c:	7ebb      	ldrb	r3, [r7, #26]
2000573e:	2b09      	cmp	r3, #9
20005740:	d9b1      	bls.n	200056a6 <adf_init+0xb6>


	ADF_SPI_SLAVE_SELECT(adf_spi, ADF_SPI_SLAVE);
20005742:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005746:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000574a:	681b      	ldr	r3, [r3, #0]
2000574c:	4618      	mov	r0, r3
2000574e:	f04f 0100 	mov.w	r1, #0
20005752:	f004 f8bd 	bl	200098d0 <SPI_set_slave_select>
	ADF_SPI_BLOCK_READ(adf_spi, &buf ,1, &rx_data, 1);
20005756:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
2000575a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000575e:	6819      	ldr	r1, [r3, #0]
20005760:	f107 020b 	add.w	r2, r7, #11
20005764:	f107 030a 	add.w	r3, r7, #10
20005768:	f04f 0001 	mov.w	r0, #1
2000576c:	9000      	str	r0, [sp, #0]
2000576e:	4608      	mov	r0, r1
20005770:	4611      	mov	r1, r2
20005772:	f04f 0201 	mov.w	r2, #1
20005776:	f000 fae5 	bl	20005d44 <adf_spi_trans_read>
	uint8_t check_val = 0,nop = ADF_NOP;
2000577a:	f04f 0300 	mov.w	r3, #0
2000577e:	70fb      	strb	r3, [r7, #3]
20005780:	f04f 33ff 	mov.w	r3, #4294967295
20005784:	70bb      	strb	r3, [r7, #2]
	uint8_t tries = 0;
20005786:	f04f 0300 	mov.w	r3, #0
2000578a:	77bb      	strb	r3, [r7, #30]
	//Send NOP command(0xFF) until adf is ready to receive command and also adf is in idle state
	do {
		ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
2000578c:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005790:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005794:	6819      	ldr	r1, [r3, #0]
20005796:	f107 0202 	add.w	r2, r7, #2
2000579a:	f107 0303 	add.w	r3, r7, #3
2000579e:	f04f 0001 	mov.w	r0, #1
200057a2:	9000      	str	r0, [sp, #0]
200057a4:	4608      	mov	r0, r1
200057a6:	4611      	mov	r1, r2
200057a8:	f04f 0201 	mov.w	r2, #1
200057ac:	f000 faca 	bl	20005d44 <adf_spi_trans_read>
		if(((check_val & CMD_READY) != 0) && ((check_val & 0x04) != 0)) {
200057b0:	78fb      	ldrb	r3, [r7, #3]
200057b2:	f003 0320 	and.w	r3, r3, #32
200057b6:	2b00      	cmp	r3, #0
200057b8:	d004      	beq.n	200057c4 <adf_init+0x1d4>
200057ba:	78fb      	ldrb	r3, [r7, #3]
200057bc:	f003 0304 	and.w	r3, r3, #4
200057c0:	2b00      	cmp	r3, #0
200057c2:	d10c      	bne.n	200057de <adf_init+0x1ee>
			break;
		}
	}while(tries++ < 100);
200057c4:	7fbb      	ldrb	r3, [r7, #30]
200057c6:	2b63      	cmp	r3, #99	; 0x63
200057c8:	bf8c      	ite	hi
200057ca:	2300      	movhi	r3, #0
200057cc:	2301      	movls	r3, #1
200057ce:	b2db      	uxtb	r3, r3
200057d0:	7fba      	ldrb	r2, [r7, #30]
200057d2:	f102 0201 	add.w	r2, r2, #1
200057d6:	77ba      	strb	r2, [r7, #30]
200057d8:	2b00      	cmp	r3, #0
200057da:	d1d7      	bne.n	2000578c <adf_init+0x19c>
200057dc:	e000      	b.n	200057e0 <adf_init+0x1f0>
	uint8_t tries = 0;
	//Send NOP command(0xFF) until adf is ready to receive command and also adf is in idle state
	do {
		ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
		if(((check_val & CMD_READY) != 0) && ((check_val & 0x04) != 0)) {
			break;
200057de:	bf00      	nop

	//Pull #CS high again
	//Old version
//	ADF_SPI_SLAVE_SELECT(adf_spi, 0);
	//New version
	ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
200057e0:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
200057e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200057e8:	681b      	ldr	r3, [r3, #0]
200057ea:	4618      	mov	r0, r3
200057ec:	f04f 0100 	mov.w	r1, #0
200057f0:	f004 f8c2 	bl	20009978 <SPI_clear_slave_select>
//	TMR_stop(&timer);

	uint8_t ret_val;
	tries = 0;
200057f4:	f04f 0300 	mov.w	r3, #0
200057f8:	77bb      	strb	r3, [r7, #30]
	//Call adf_config to configure the ADF
	while(tries++ < 100) {
200057fa:	e006      	b.n	2000580a <adf_init+0x21a>
	   ret_val = adf_get_state();
200057fc:	f000 fb50 	bl	20005ea0 <adf_get_state>
20005800:	4603      	mov	r3, r0
20005802:	77fb      	strb	r3, [r7, #31]
	   if(ret_val == PHY_OFF) {
20005804:	7ffb      	ldrb	r3, [r7, #31]
20005806:	2b01      	cmp	r3, #1
20005808:	d00c      	beq.n	20005824 <adf_init+0x234>
//	TMR_stop(&timer);

	uint8_t ret_val;
	tries = 0;
	//Call adf_config to configure the ADF
	while(tries++ < 100) {
2000580a:	7fbb      	ldrb	r3, [r7, #30]
2000580c:	2b63      	cmp	r3, #99	; 0x63
2000580e:	bf8c      	ite	hi
20005810:	2300      	movhi	r3, #0
20005812:	2301      	movls	r3, #1
20005814:	b2db      	uxtb	r3, r3
20005816:	7fba      	ldrb	r2, [r7, #30]
20005818:	f102 0201 	add.w	r2, r2, #1
2000581c:	77ba      	strb	r2, [r7, #30]
2000581e:	2b00      	cmp	r3, #0
20005820:	d1ec      	bne.n	200057fc <adf_init+0x20c>
20005822:	e000      	b.n	20005826 <adf_init+0x236>
	   ret_val = adf_get_state();
	   if(ret_val == PHY_OFF) {
		   break;
20005824:	bf00      	nop

	if(tries >= 100) {
//		return ERR_FAIL_TO_SET_PHY_OFF;
	}

	count = config_adf7030();
20005826:	f000 f895 	bl	20005954 <config_adf7030>
2000582a:	4603      	mov	r3, r0
2000582c:	76bb      	strb	r3, [r7, #26]

	if(count == 0){
2000582e:	7ebb      	ldrb	r3, [r7, #26]
20005830:	2b00      	cmp	r3, #0
20005832:	d107      	bne.n	20005844 <adf_init+0x254>
		count = cmd_ready_set();
20005834:	f000 fa0a 	bl	20005c4c <cmd_ready_set>
20005838:	4603      	mov	r3, r0
2000583a:	76bb      	strb	r3, [r7, #26]
	} else {
		return ERR_CONFIG_FILE_FAILED;
	}

	if(count == 0){
2000583c:	7ebb      	ldrb	r3, [r7, #26]
2000583e:	2b00      	cmp	r3, #0
20005840:	d003      	beq.n	2000584a <adf_init+0x25a>
20005842:	e00a      	b.n	2000585a <adf_init+0x26a>
	count = config_adf7030();

	if(count == 0){
		count = cmd_ready_set();
	} else {
		return ERR_CONFIG_FILE_FAILED;
20005844:	f04f 0303 	mov.w	r3, #3
20005848:	e018      	b.n	2000587c <adf_init+0x28c>
	}

	if(count == 0){
		count = adf_in_idle();
2000584a:	f000 fa3d 	bl	20005cc8 <adf_in_idle>
2000584e:	4603      	mov	r3, r0
20005850:	76bb      	strb	r3, [r7, #26]
	} else {
		return ERR_CMD_FAILED;
	}

	if(count == 0){
20005852:	7ebb      	ldrb	r3, [r7, #26]
20005854:	2b00      	cmp	r3, #0
20005856:	d003      	beq.n	20005860 <adf_init+0x270>
20005858:	e00f      	b.n	2000587a <adf_init+0x28a>
	}

	if(count == 0){
		count = adf_in_idle();
	} else {
		return ERR_CMD_FAILED;
2000585a:	f04f 0302 	mov.w	r3, #2
2000585e:	e00d      	b.n	2000587c <adf_init+0x28c>
	}

	if(count == 0){
		adf_write_to_memory(WMODE_1, GENERIC_PKT_FRAME_CFG1, enable_intr, 4);
20005860:	f107 0304 	add.w	r3, r7, #4
20005864:	f04f 0038 	mov.w	r0, #56	; 0x38
20005868:	f240 5100 	movw	r1, #1280	; 0x500
2000586c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20005870:	461a      	mov	r2, r3
20005872:	f04f 0304 	mov.w	r3, #4
20005876:	f000 f8ed 	bl	20005a54 <adf_write_to_memory>
2000587a:	e7ff      	b.n	2000587c <adf_init+0x28c>
	} else {
//		return ERR_IN_IDLE_FAILED;
	}

}
2000587c:	4618      	mov	r0, r3
2000587e:	f107 0720 	add.w	r7, r7, #32
20005882:	46bd      	mov	sp, r7
20005884:	bd80      	pop	{r7, pc}
20005886:	bf00      	nop

20005888 <apply_file>:

uint8_t apply_file(uint8_t *file, uint16_t size) {
20005888:	b580      	push	{r7, lr}
2000588a:	b088      	sub	sp, #32
2000588c:	af02      	add	r7, sp, #8
2000588e:	6078      	str	r0, [r7, #4]
20005890:	460b      	mov	r3, r1
20005892:	807b      	strh	r3, [r7, #2]
//    uint32_t size = sizeof(file);
	//uint32_t size = 728;
    uint32_t array_position = 0;
20005894:	f04f 0300 	mov.w	r3, #0
20005898:	60fb      	str	r3, [r7, #12]
    uint8_t *pSeqData;
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
2000589a:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
2000589e:	f2c2 0300 	movt	r3, #8192	; 0x2000
200058a2:	681b      	ldr	r3, [r3, #0]
200058a4:	4618      	mov	r0, r3
200058a6:	f04f 0100 	mov.w	r1, #0
200058aa:	f004 f811 	bl	200098d0 <SPI_set_slave_select>
    do 
    { 
      // Calculate the number of bytes to write
      uint32_t length =  (*(file + array_position ) << 16) | 
200058ae:	687a      	ldr	r2, [r7, #4]
200058b0:	68fb      	ldr	r3, [r7, #12]
200058b2:	4413      	add	r3, r2
200058b4:	781b      	ldrb	r3, [r3, #0]
200058b6:	ea4f 4203 	mov.w	r2, r3, lsl #16
                         (*(file + array_position + 1) << 8) |
200058ba:	68fb      	ldr	r3, [r7, #12]
200058bc:	f103 0101 	add.w	r1, r3, #1
200058c0:	687b      	ldr	r3, [r7, #4]
200058c2:	440b      	add	r3, r1
200058c4:	781b      	ldrb	r3, [r3, #0]
200058c6:	ea4f 2303 	mov.w	r3, r3, lsl #8
200058ca:	ea42 0203 	orr.w	r2, r2, r3
                         (*(file + array_position + 2));
200058ce:	68fb      	ldr	r3, [r7, #12]
200058d0:	f103 0102 	add.w	r1, r3, #2
200058d4:	687b      	ldr	r3, [r7, #4]
200058d6:	440b      	add	r3, r1
200058d8:	781b      	ldrb	r3, [r3, #0]
    uint8_t *pSeqData;
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
    do 
    { 
      // Calculate the number of bytes to write
      uint32_t length =  (*(file + array_position ) << 16) | 
200058da:	ea42 0303 	orr.w	r3, r2, r3
                         (*(file + array_position + 1) << 8) |
                         (*(file + array_position + 2));
200058de:	617b      	str	r3, [r7, #20]
      
      if(length > 0xFFFF)
200058e0:	697a      	ldr	r2, [r7, #20]
200058e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
200058e6:	429a      	cmp	r2, r3
200058e8:	d902      	bls.n	200058f0 <apply_file+0x68>
      {
         return ERR_LENGTH_OVERFLOW;
200058ea:	f04f 0301 	mov.w	r3, #1
200058ee:	e02b      	b.n	20005948 <apply_file+0xc0>
      } 
      
      // Write the SPI data pointed to location (MEMORY_FILE + array_position) with specified length (length)
      pSeqData = (file + array_position + 3);
200058f0:	68fb      	ldr	r3, [r7, #12]
200058f2:	f103 0303 	add.w	r3, r3, #3
200058f6:	687a      	ldr	r2, [r7, #4]
200058f8:	4413      	add	r3, r2
200058fa:	613b      	str	r3, [r7, #16]
      
      // Transfer the Configuration sequence
      ADF_SPI_BLOCK_WRITE(adf_spi,pSeqData,1,(pSeqData+1),(length-4));
200058fc:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005900:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005904:	681a      	ldr	r2, [r3, #0]
20005906:	693b      	ldr	r3, [r7, #16]
20005908:	f103 0301 	add.w	r3, r3, #1
2000590c:	6979      	ldr	r1, [r7, #20]
2000590e:	f1a1 0104 	sub.w	r1, r1, #4
20005912:	9100      	str	r1, [sp, #0]
20005914:	4610      	mov	r0, r2
20005916:	6939      	ldr	r1, [r7, #16]
20005918:	f04f 0201 	mov.w	r2, #1
2000591c:	f000 fa46 	bl	20005dac <adf_spi_trans_write>

      // Update the array position to point to the next block
      array_position += length;
20005920:	68fa      	ldr	r2, [r7, #12]
20005922:	697b      	ldr	r3, [r7, #20]
20005924:	4413      	add	r3, r2
20005926:	60fb      	str	r3, [r7, #12]
    
    }while(array_position < size); // Continue operation until full data file has been written
20005928:	887a      	ldrh	r2, [r7, #2]
2000592a:	68fb      	ldr	r3, [r7, #12]
2000592c:	429a      	cmp	r2, r3
2000592e:	d8be      	bhi.n	200058ae <apply_file+0x26>
    //ADF_SPI_SLAVE_SELECT(adf_spi,0);
    //using new drivers
    ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
20005930:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005934:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005938:	681b      	ldr	r3, [r3, #0]
2000593a:	4618      	mov	r0, r3
2000593c:	f04f 0100 	mov.w	r1, #0
20005940:	f004 f81a 	bl	20009978 <SPI_clear_slave_select>

    return 0;
20005944:	f04f 0300 	mov.w	r3, #0

}
20005948:	4618      	mov	r0, r3
2000594a:	f107 0718 	add.w	r7, r7, #24
2000594e:	46bd      	mov	sp, r7
20005950:	bd80      	pop	{r7, pc}
20005952:	bf00      	nop

20005954 <config_adf7030>:

uint8_t config_adf7030() {
20005954:	b580      	push	{r7, lr}
20005956:	b088      	sub	sp, #32
20005958:	af00      	add	r7, sp, #0
    //   array_position += length;
    
    // }while(array_position < size); // Continue operation until full data file has been written

    uint8_t ret_val;
    uint8_t en_calib_array[] = {EN_CALIB >> 24,(EN_CALIB >> 16) & 0xFF, (EN_CALIB >> 8) & 0xFF, EN_CALIB & 0xFF};
2000595a:	f64b 638c 	movw	r3, #48780	; 0xbe8c
2000595e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005962:	681b      	ldr	r3, [r3, #0]
20005964:	61bb      	str	r3, [r7, #24]
    uint8_t en_calib_ar[] = {EN_CALIB & 0xFF, (EN_CALIB >> 8) & 0xFF, (EN_CALIB >> 16) & 0xFF, EN_CALIB >> 24 };
20005966:	f64b 6390 	movw	r3, #48784	; 0xbe90
2000596a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000596e:	681b      	ldr	r3, [r3, #0]
20005970:	617b      	str	r3, [r7, #20]
    uint8_t dis_calib_array[] = {DIS_CALIB >> 24,(DIS_CALIB >> 16) & 0xFF, (DIS_CALIB >> 8) & 0xFF, DIS_CALIB & 0xFF};
20005972:	f64b 6394 	movw	r3, #48788	; 0xbe94
20005976:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000597a:	681b      	ldr	r3, [r3, #0]
2000597c:	613b      	str	r3, [r7, #16]
    uint8_t dis_calib_ar[] = {DIS_CALIB & 0xFF, (DIS_CALIB >> 8) & 0xFF, (DIS_CALIB >> 16) & 0xFF, DIS_CALIB >> 24};
2000597e:	f64b 6398 	movw	r3, #48792	; 0xbe98
20005982:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005986:	681b      	ldr	r3, [r3, #0]
20005988:	60fb      	str	r3, [r7, #12]
    uint8_t read_reg[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
2000598a:	f04f 0300 	mov.w	r3, #0
2000598e:	713b      	strb	r3, [r7, #4]
20005990:	f04f 0300 	mov.w	r3, #0
20005994:	717b      	strb	r3, [r7, #5]
20005996:	f04f 0300 	mov.w	r3, #0
2000599a:	71bb      	strb	r3, [r7, #6]
2000599c:	f04f 0300 	mov.w	r3, #0
200059a0:	71fb      	strb	r3, [r7, #7]
200059a2:	f04f 0300 	mov.w	r3, #0
200059a6:	723b      	strb	r3, [r7, #8]
200059a8:	f04f 0300 	mov.w	r3, #0
200059ac:	727b      	strb	r3, [r7, #9]
	uint8_t tries = 0;
200059ae:	f04f 0300 	mov.w	r3, #0
200059b2:	77fb      	strb	r3, [r7, #31]

    //Apply the configuration file
    ret_val = apply_file(radio_memory_configuration, SIZEOFCONFIG);
200059b4:	f64b 70bc 	movw	r0, #49084	; 0xbfbc
200059b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200059bc:	f44f 7136 	mov.w	r1, #728	; 0x2d8
200059c0:	f7ff ff62 	bl	20005888 <apply_file>
200059c4:	4603      	mov	r3, r0
200059c6:	77bb      	strb	r3, [r7, #30]
    if(ret_val) {
200059c8:	7fbb      	ldrb	r3, [r7, #30]
200059ca:	2b00      	cmp	r3, #0
200059cc:	d002      	beq.n	200059d4 <config_adf7030+0x80>
        return ERR_CONFIG_FILE_FAILED;
200059ce:	f04f 0303 	mov.w	r3, #3
200059d2:	e03a      	b.n	20005a4a <config_adf7030+0xf6>
    //Enable calibration
//    adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,en_calib_ar,4);

//    Issue CMD_CONFIG_DEV command
//    return 0;
    ret_val = adf_send_cmd(CMD_CFG_DEV);
200059d4:	f04f 0085 	mov.w	r0, #133	; 0x85
200059d8:	f000 f8d2 	bl	20005b80 <adf_send_cmd>
200059dc:	4603      	mov	r3, r0
200059de:	77bb      	strb	r3, [r7, #30]

	if(ret_val != 0) {
200059e0:	7fbb      	ldrb	r3, [r7, #30]
200059e2:	2b00      	cmp	r3, #0
200059e4:	d002      	beq.n	200059ec <config_adf7030+0x98>
		return 1;
200059e6:	f04f 0301 	mov.w	r3, #1
200059ea:	e02e      	b.n	20005a4a <config_adf7030+0xf6>
//	   }
//   }

//    adf_in_idle();
    //Issue CMD_PHY_ON
    ret_val = adf_send_cmd(CMD_PHY_ON);
200059ec:	f04f 0082 	mov.w	r0, #130	; 0x82
200059f0:	f000 f8c6 	bl	20005b80 <adf_send_cmd>
200059f4:	4603      	mov	r3, r0
200059f6:	77bb      	strb	r3, [r7, #30]
    if(ret_val) {
200059f8:	7fbb      	ldrb	r3, [r7, #30]
200059fa:	2b00      	cmp	r3, #0
200059fc:	d00e      	beq.n	20005a1c <config_adf7030+0xc8>
//        adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);
        return (ret_val | 0xC0);
200059fe:	7fbb      	ldrb	r3, [r7, #30]
20005a00:	ea6f 6383 	mvn.w	r3, r3, lsl #26
20005a04:	ea6f 6393 	mvn.w	r3, r3, lsr #26
20005a08:	b2db      	uxtb	r3, r3
20005a0a:	e01e      	b.n	20005a4a <config_adf7030+0xf6>
    }
    while(tries++ < 100) {
    	ret_val = adf_get_state();
20005a0c:	f000 fa48 	bl	20005ea0 <adf_get_state>
20005a10:	4603      	mov	r3, r0
20005a12:	77bb      	strb	r3, [r7, #30]
	   if(ret_val == PHY_ON) {
20005a14:	7fbb      	ldrb	r3, [r7, #30]
20005a16:	2b02      	cmp	r3, #2
20005a18:	d00e      	beq.n	20005a38 <config_adf7030+0xe4>
20005a1a:	e000      	b.n	20005a1e <config_adf7030+0xca>
    ret_val = adf_send_cmd(CMD_PHY_ON);
    if(ret_val) {
//        adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);
        return (ret_val | 0xC0);
    }
    while(tries++ < 100) {
20005a1c:	bf00      	nop
20005a1e:	7ffb      	ldrb	r3, [r7, #31]
20005a20:	2b63      	cmp	r3, #99	; 0x63
20005a22:	bf8c      	ite	hi
20005a24:	2300      	movhi	r3, #0
20005a26:	2301      	movls	r3, #1
20005a28:	b2db      	uxtb	r3, r3
20005a2a:	7ffa      	ldrb	r2, [r7, #31]
20005a2c:	f102 0201 	add.w	r2, r2, #1
20005a30:	77fa      	strb	r2, [r7, #31]
20005a32:	2b00      	cmp	r3, #0
20005a34:	d1ea      	bne.n	20005a0c <config_adf7030+0xb8>
20005a36:	e000      	b.n	20005a3a <config_adf7030+0xe6>
    	ret_val = adf_get_state();
	   if(ret_val == PHY_ON) {
		   break;
20005a38:	bf00      	nop
	   }
   }

	if(tries >= 100) {
20005a3a:	7ffb      	ldrb	r3, [r7, #31]
20005a3c:	2b63      	cmp	r3, #99	; 0x63
20005a3e:	d902      	bls.n	20005a46 <config_adf7030+0xf2>
		return 1;
20005a40:	f04f 0301 	mov.w	r3, #1
20005a44:	e001      	b.n	20005a4a <config_adf7030+0xf6>
//    }

    //Disable calibration
//    adf_write_to_memory(WMODE_1,SM_DATA_CALIBRATION,dis_calib_ar,4);

    return 0;
20005a46:	f04f 0300 	mov.w	r3, #0

#else

#endif
}
20005a4a:	4618      	mov	r0, r3
20005a4c:	f107 0720 	add.w	r7, r7, #32
20005a50:	46bd      	mov	sp, r7
20005a52:	bd80      	pop	{r7, pc}

20005a54 <adf_write_to_memory>:


uint8_t adf_write_to_memory(uint8_t mode,uint32_t addr,uint8_t *data,uint32_t size) {
20005a54:	b580      	push	{r7, lr}
20005a56:	b088      	sub	sp, #32
20005a58:	af02      	add	r7, sp, #8
20005a5a:	60b9      	str	r1, [r7, #8]
20005a5c:	607a      	str	r2, [r7, #4]
20005a5e:	603b      	str	r3, [r7, #0]
20005a60:	4603      	mov	r3, r0
20005a62:	73fb      	strb	r3, [r7, #15]
    //Currently implementing mode1 for testing. Need to implement other modes
    if((mode & WMODE_1) == WMODE_1){
        uint8_t cmd_data[] = {mode,(addr >> 24),((addr >> 16) & 0xFF),((addr >> 8) & 0xFF),(addr & 0xFF )};
20005a64:	68bb      	ldr	r3, [r7, #8]
20005a66:	ea4f 6313 	mov.w	r3, r3, lsr #24
20005a6a:	b2d8      	uxtb	r0, r3
20005a6c:	68bb      	ldr	r3, [r7, #8]
20005a6e:	ea4f 4313 	mov.w	r3, r3, lsr #16
20005a72:	b2d9      	uxtb	r1, r3
20005a74:	68bb      	ldr	r3, [r7, #8]
20005a76:	ea4f 2313 	mov.w	r3, r3, lsr #8
20005a7a:	b2da      	uxtb	r2, r3
20005a7c:	68bb      	ldr	r3, [r7, #8]
20005a7e:	b2db      	uxtb	r3, r3
20005a80:	f897 c00f 	ldrb.w	ip, [r7, #15]
20005a84:	f887 c010 	strb.w	ip, [r7, #16]
20005a88:	7478      	strb	r0, [r7, #17]
20005a8a:	74b9      	strb	r1, [r7, #18]
20005a8c:	74fa      	strb	r2, [r7, #19]
20005a8e:	753b      	strb	r3, [r7, #20]
        ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
20005a90:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005a98:	681b      	ldr	r3, [r3, #0]
20005a9a:	4618      	mov	r0, r3
20005a9c:	f04f 0100 	mov.w	r1, #0
20005aa0:	f003 ff16 	bl	200098d0 <SPI_set_slave_select>
        ADF_SPI_BLOCK_WRITE(adf_spi,cmd_data,5,data,size);
20005aa4:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005aac:	681a      	ldr	r2, [r3, #0]
20005aae:	f107 0310 	add.w	r3, r7, #16
20005ab2:	6839      	ldr	r1, [r7, #0]
20005ab4:	9100      	str	r1, [sp, #0]
20005ab6:	4610      	mov	r0, r2
20005ab8:	4619      	mov	r1, r3
20005aba:	f04f 0205 	mov.w	r2, #5
20005abe:	687b      	ldr	r3, [r7, #4]
20005ac0:	f000 f974 	bl	20005dac <adf_spi_trans_write>
        ADF_SPI_SLAVE_CLEAR(adf_spi, ADF_SPI_SLAVE);
20005ac4:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005acc:	681b      	ldr	r3, [r3, #0]
20005ace:	4618      	mov	r0, r3
20005ad0:	f04f 0100 	mov.w	r1, #0
20005ad4:	f003 ff50 	bl	20009978 <SPI_clear_slave_select>
    }

    return 0;
20005ad8:	f04f 0300 	mov.w	r3, #0
    

}
20005adc:	4618      	mov	r0, r3
20005ade:	f107 0718 	add.w	r7, r7, #24
20005ae2:	46bd      	mov	sp, r7
20005ae4:	bd80      	pop	{r7, pc}
20005ae6:	bf00      	nop

20005ae8 <adf_read_from_memory>:

uint8_t* adf_read_from_memory(uint8_t mode,uint32_t addr,uint8_t *data,uint32_t size) {
20005ae8:	b580      	push	{r7, lr}
20005aea:	b088      	sub	sp, #32
20005aec:	af02      	add	r7, sp, #8
20005aee:	60b9      	str	r1, [r7, #8]
20005af0:	607a      	str	r2, [r7, #4]
20005af2:	603b      	str	r3, [r7, #0]
20005af4:	4603      	mov	r3, r0
20005af6:	73fb      	strb	r3, [r7, #15]
    if((mode & RMODE_1) == RMODE_1){
        uint8_t cmd_data[] = {mode,(addr >> 24),((addr >> 16) & 0xFF),((addr >> 8) & 0xFF),(addr & 0xFF )};
20005af8:	68bb      	ldr	r3, [r7, #8]
20005afa:	ea4f 6313 	mov.w	r3, r3, lsr #24
20005afe:	b2d8      	uxtb	r0, r3
20005b00:	68bb      	ldr	r3, [r7, #8]
20005b02:	ea4f 4313 	mov.w	r3, r3, lsr #16
20005b06:	b2d9      	uxtb	r1, r3
20005b08:	68bb      	ldr	r3, [r7, #8]
20005b0a:	ea4f 2313 	mov.w	r3, r3, lsr #8
20005b0e:	b2da      	uxtb	r2, r3
20005b10:	68bb      	ldr	r3, [r7, #8]
20005b12:	b2db      	uxtb	r3, r3
20005b14:	f897 c00f 	ldrb.w	ip, [r7, #15]
20005b18:	f887 c010 	strb.w	ip, [r7, #16]
20005b1c:	7478      	strb	r0, [r7, #17]
20005b1e:	74b9      	strb	r1, [r7, #18]
20005b20:	74fa      	strb	r2, [r7, #19]
20005b22:	753b      	strb	r3, [r7, #20]
        ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
20005b24:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005b28:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005b2c:	681b      	ldr	r3, [r3, #0]
20005b2e:	4618      	mov	r0, r3
20005b30:	f04f 0100 	mov.w	r1, #0
20005b34:	f003 fecc 	bl	200098d0 <SPI_set_slave_select>
        ADF_SPI_BLOCK_READ(adf_spi,cmd_data,5,data,size+RMODE1_OFFSET);
20005b38:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005b3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005b40:	681a      	ldr	r2, [r3, #0]
20005b42:	683b      	ldr	r3, [r7, #0]
20005b44:	f103 0102 	add.w	r1, r3, #2
20005b48:	f107 0310 	add.w	r3, r7, #16
20005b4c:	9100      	str	r1, [sp, #0]
20005b4e:	4610      	mov	r0, r2
20005b50:	4619      	mov	r1, r3
20005b52:	f04f 0205 	mov.w	r2, #5
20005b56:	687b      	ldr	r3, [r7, #4]
20005b58:	f000 f8f4 	bl	20005d44 <adf_spi_trans_read>
        ADF_SPI_SLAVE_CLEAR(adf_spi, ADF_SPI_SLAVE);
20005b5c:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005b64:	681b      	ldr	r3, [r3, #0]
20005b66:	4618      	mov	r0, r3
20005b68:	f04f 0100 	mov.w	r1, #0
20005b6c:	f003 ff04 	bl	20009978 <SPI_clear_slave_select>
    }
    return (data+RMODE1_OFFSET);
20005b70:	687b      	ldr	r3, [r7, #4]
20005b72:	f103 0302 	add.w	r3, r3, #2
}
20005b76:	4618      	mov	r0, r3
20005b78:	f107 0718 	add.w	r7, r7, #24
20005b7c:	46bd      	mov	sp, r7
20005b7e:	bd80      	pop	{r7, pc}

20005b80 <adf_send_cmd>:

uint8_t adf_send_cmd(uint8_t command) {
20005b80:	b580      	push	{r7, lr}
20005b82:	b086      	sub	sp, #24
20005b84:	af02      	add	r7, sp, #8
20005b86:	4603      	mov	r3, r0
20005b88:	71fb      	strb	r3, [r7, #7]
    ADF_SPI_SLAVE_SELECT(adf_spi,ADF_SPI_SLAVE);
20005b8a:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005b92:	681b      	ldr	r3, [r3, #0]
20005b94:	4618      	mov	r0, r3
20005b96:	f04f 0100 	mov.w	r1, #0
20005b9a:	f003 fe99 	bl	200098d0 <SPI_set_slave_select>
    uint8_t check_val = 0,nop = ADF_NOP;
20005b9e:	f04f 0300 	mov.w	r3, #0
20005ba2:	73bb      	strb	r3, [r7, #14]
20005ba4:	f04f 33ff 	mov.w	r3, #4294967295
20005ba8:	737b      	strb	r3, [r7, #13]
    uint8_t tries = 0;
20005baa:	f04f 0300 	mov.w	r3, #0
20005bae:	73fb      	strb	r3, [r7, #15]
    //Send NOP command(0xFF) until adf is ready to receive command
   do {
       ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
20005bb0:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005bb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005bb8:	6819      	ldr	r1, [r3, #0]
20005bba:	f107 020d 	add.w	r2, r7, #13
20005bbe:	f107 030e 	add.w	r3, r7, #14
20005bc2:	f04f 0001 	mov.w	r0, #1
20005bc6:	9000      	str	r0, [sp, #0]
20005bc8:	4608      	mov	r0, r1
20005bca:	4611      	mov	r1, r2
20005bcc:	f04f 0201 	mov.w	r2, #1
20005bd0:	f000 f8b8 	bl	20005d44 <adf_spi_trans_read>
       if((check_val & CMD_READY) != 0) {
20005bd4:	7bbb      	ldrb	r3, [r7, #14]
20005bd6:	f003 0320 	and.w	r3, r3, #32
20005bda:	2b00      	cmp	r3, #0
20005bdc:	d10c      	bne.n	20005bf8 <adf_send_cmd+0x78>
           break;
       }
   }while(tries++ < 100);
20005bde:	7bfb      	ldrb	r3, [r7, #15]
20005be0:	2b63      	cmp	r3, #99	; 0x63
20005be2:	bf8c      	ite	hi
20005be4:	2300      	movhi	r3, #0
20005be6:	2301      	movls	r3, #1
20005be8:	b2db      	uxtb	r3, r3
20005bea:	7bfa      	ldrb	r2, [r7, #15]
20005bec:	f102 0201 	add.w	r2, r2, #1
20005bf0:	73fa      	strb	r2, [r7, #15]
20005bf2:	2b00      	cmp	r3, #0
20005bf4:	d1dc      	bne.n	20005bb0 <adf_send_cmd+0x30>
20005bf6:	e000      	b.n	20005bfa <adf_send_cmd+0x7a>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
   do {
       ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
       if((check_val & CMD_READY) != 0) {
           break;
20005bf8:	bf00      	nop
       }
   }while(tries++ < 100);
   if(tries >= 100) {
20005bfa:	7bfb      	ldrb	r3, [r7, #15]
20005bfc:	2b63      	cmp	r3, #99	; 0x63
20005bfe:	d902      	bls.n	20005c06 <adf_send_cmd+0x86>
       return ERR_CMD_FAILED;
20005c00:	f04f 0302 	mov.w	r3, #2
20005c04:	e01d      	b.n	20005c42 <adf_send_cmd+0xc2>
   }

    //Send the command
    ADF_SPI_BLOCK_WRITE(adf_spi,&command, 1, &check_val, 1);
20005c06:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005c0e:	6819      	ldr	r1, [r3, #0]
20005c10:	f107 0207 	add.w	r2, r7, #7
20005c14:	f107 030e 	add.w	r3, r7, #14
20005c18:	f04f 0001 	mov.w	r0, #1
20005c1c:	9000      	str	r0, [sp, #0]
20005c1e:	4608      	mov	r0, r1
20005c20:	4611      	mov	r1, r2
20005c22:	f04f 0201 	mov.w	r2, #1
20005c26:	f000 f8c1 	bl	20005dac <adf_spi_trans_write>
    //Using old drivers
    //ADF_SPI_SLAVE_SELECT(adf_spi,0);
    //Using new drivers
    ADF_SPI_SLAVE_CLEAR(adf_spi,ADF_SPI_SLAVE);
20005c2a:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005c32:	681b      	ldr	r3, [r3, #0]
20005c34:	4618      	mov	r0, r3
20005c36:	f04f 0100 	mov.w	r1, #0
20005c3a:	f003 fe9d 	bl	20009978 <SPI_clear_slave_select>

    return 0;
20005c3e:	f04f 0300 	mov.w	r3, #0

}
20005c42:	4618      	mov	r0, r3
20005c44:	f107 0710 	add.w	r7, r7, #16
20005c48:	46bd      	mov	sp, r7
20005c4a:	bd80      	pop	{r7, pc}

20005c4c <cmd_ready_set>:

    return 0;

}

uint8_t cmd_ready_set() {
20005c4c:	b580      	push	{r7, lr}
20005c4e:	b084      	sub	sp, #16
20005c50:	af02      	add	r7, sp, #8
    uint8_t check_val = 0,nop = ADF_NOP;
20005c52:	f04f 0300 	mov.w	r3, #0
20005c56:	71bb      	strb	r3, [r7, #6]
20005c58:	f04f 33ff 	mov.w	r3, #4294967295
20005c5c:	717b      	strb	r3, [r7, #5]
    uint8_t tries = 0;
20005c5e:	f04f 0300 	mov.w	r3, #0
20005c62:	71fb      	strb	r3, [r7, #7]
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
20005c64:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005c6c:	6819      	ldr	r1, [r3, #0]
20005c6e:	f107 0205 	add.w	r2, r7, #5
20005c72:	f107 0306 	add.w	r3, r7, #6
20005c76:	f04f 0001 	mov.w	r0, #1
20005c7a:	9000      	str	r0, [sp, #0]
20005c7c:	4608      	mov	r0, r1
20005c7e:	4611      	mov	r1, r2
20005c80:	f04f 0201 	mov.w	r2, #1
20005c84:	f000 f85e 	bl	20005d44 <adf_spi_trans_read>
        if((check_val & CMD_READY) != 0) {
20005c88:	79bb      	ldrb	r3, [r7, #6]
20005c8a:	f003 0320 	and.w	r3, r3, #32
20005c8e:	2b00      	cmp	r3, #0
20005c90:	d10c      	bne.n	20005cac <cmd_ready_set+0x60>
            break;
        }
    }while(tries++ < 100);
20005c92:	79fb      	ldrb	r3, [r7, #7]
20005c94:	2b63      	cmp	r3, #99	; 0x63
20005c96:	bf8c      	ite	hi
20005c98:	2300      	movhi	r3, #0
20005c9a:	2301      	movls	r3, #1
20005c9c:	b2db      	uxtb	r3, r3
20005c9e:	79fa      	ldrb	r2, [r7, #7]
20005ca0:	f102 0201 	add.w	r2, r2, #1
20005ca4:	71fa      	strb	r2, [r7, #7]
20005ca6:	2b00      	cmp	r3, #0
20005ca8:	d1dc      	bne.n	20005c64 <cmd_ready_set+0x18>
20005caa:	e000      	b.n	20005cae <cmd_ready_set+0x62>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
        if((check_val & CMD_READY) != 0) {
            break;
20005cac:	bf00      	nop
        }
    }while(tries++ < 100);
    if(tries >= 100) {
20005cae:	79fb      	ldrb	r3, [r7, #7]
20005cb0:	2b63      	cmp	r3, #99	; 0x63
20005cb2:	d902      	bls.n	20005cba <cmd_ready_set+0x6e>
        return 1;
20005cb4:	f04f 0301 	mov.w	r3, #1
20005cb8:	e001      	b.n	20005cbe <cmd_ready_set+0x72>
    }
    return 0;
20005cba:	f04f 0300 	mov.w	r3, #0
}
20005cbe:	4618      	mov	r0, r3
20005cc0:	f107 0708 	add.w	r7, r7, #8
20005cc4:	46bd      	mov	sp, r7
20005cc6:	bd80      	pop	{r7, pc}

20005cc8 <adf_in_idle>:

uint8_t adf_in_idle() {
20005cc8:	b580      	push	{r7, lr}
20005cca:	b084      	sub	sp, #16
20005ccc:	af02      	add	r7, sp, #8
    uint8_t check_val = 0,nop = ADF_NOP;
20005cce:	f04f 0300 	mov.w	r3, #0
20005cd2:	71bb      	strb	r3, [r7, #6]
20005cd4:	f04f 33ff 	mov.w	r3, #4294967295
20005cd8:	717b      	strb	r3, [r7, #5]
    uint8_t tries = 0;
20005cda:	f04f 0300 	mov.w	r3, #0
20005cde:	71fb      	strb	r3, [r7, #7]
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
20005ce0:	f24d 33f8 	movw	r3, #54264	; 0xd3f8
20005ce4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20005ce8:	6819      	ldr	r1, [r3, #0]
20005cea:	f107 0205 	add.w	r2, r7, #5
20005cee:	f107 0306 	add.w	r3, r7, #6
20005cf2:	f04f 0001 	mov.w	r0, #1
20005cf6:	9000      	str	r0, [sp, #0]
20005cf8:	4608      	mov	r0, r1
20005cfa:	4611      	mov	r1, r2
20005cfc:	f04f 0201 	mov.w	r2, #1
20005d00:	f000 f820 	bl	20005d44 <adf_spi_trans_read>
        if((check_val & 0x04) != 0) {
20005d04:	79bb      	ldrb	r3, [r7, #6]
20005d06:	f003 0304 	and.w	r3, r3, #4
20005d0a:	2b00      	cmp	r3, #0
20005d0c:	d10c      	bne.n	20005d28 <adf_in_idle+0x60>
            break;
        }
    }while(tries++ < 100);
20005d0e:	79fb      	ldrb	r3, [r7, #7]
20005d10:	2b63      	cmp	r3, #99	; 0x63
20005d12:	bf8c      	ite	hi
20005d14:	2300      	movhi	r3, #0
20005d16:	2301      	movls	r3, #1
20005d18:	b2db      	uxtb	r3, r3
20005d1a:	79fa      	ldrb	r2, [r7, #7]
20005d1c:	f102 0201 	add.w	r2, r2, #1
20005d20:	71fa      	strb	r2, [r7, #7]
20005d22:	2b00      	cmp	r3, #0
20005d24:	d1dc      	bne.n	20005ce0 <adf_in_idle+0x18>
20005d26:	e000      	b.n	20005d2a <adf_in_idle+0x62>
    uint8_t tries = 0;
    //Send NOP command(0xFF) until adf is ready to receive command
    do {
        ADF_SPI_BLOCK_READ(adf_spi,&nop,1,&check_val,1);
        if((check_val & 0x04) != 0) {
            break;
20005d28:	bf00      	nop
        }
    }while(tries++ < 100);
    if(tries >= 100) {
20005d2a:	79fb      	ldrb	r3, [r7, #7]
20005d2c:	2b63      	cmp	r3, #99	; 0x63
20005d2e:	d902      	bls.n	20005d36 <adf_in_idle+0x6e>
        return 1;
20005d30:	f04f 0301 	mov.w	r3, #1
20005d34:	e001      	b.n	20005d3a <adf_in_idle+0x72>
    }
    return 0;
20005d36:	f04f 0300 	mov.w	r3, #0
}
20005d3a:	4618      	mov	r0, r3
20005d3c:	f107 0708 	add.w	r7, r7, #8
20005d40:	46bd      	mov	sp, r7
20005d42:	bd80      	pop	{r7, pc}

20005d44 <adf_spi_trans_read>:

void adf_spi_trans_read( spi_instance_t * this_spi,
    uint8_t * cmd_buffer,
    size_t cmd_byte_size,
    uint8_t * rd_buffer,
    size_t rd_byte_size){
20005d44:	b580      	push	{r7, lr}
20005d46:	b088      	sub	sp, #32
20005d48:	af02      	add	r7, sp, #8
20005d4a:	60f8      	str	r0, [r7, #12]
20005d4c:	60b9      	str	r1, [r7, #8]
20005d4e:	607a      	str	r2, [r7, #4]
20005d50:	603b      	str	r3, [r7, #0]

	uint16_t i;
	uint8_t r_buf[6];
	r_buf[0] = 0x00;
20005d52:	f04f 0300 	mov.w	r3, #0
20005d56:	743b      	strb	r3, [r7, #16]
//	MSS_GPIO_set_output(MSS_GPIO_3, 1);
	//Using new drivers
//	SPI_set_slave_select(this_spi,ADF_SPI_SLAVE);


		SPI_transfer_block(this_spi,cmd_buffer,cmd_byte_size,r_buf,rd_byte_size);
20005d58:	687b      	ldr	r3, [r7, #4]
20005d5a:	b29a      	uxth	r2, r3
20005d5c:	6a3b      	ldr	r3, [r7, #32]
20005d5e:	b299      	uxth	r1, r3
20005d60:	f107 0310 	add.w	r3, r7, #16
20005d64:	9100      	str	r1, [sp, #0]
20005d66:	68f8      	ldr	r0, [r7, #12]
20005d68:	68b9      	ldr	r1, [r7, #8]
20005d6a:	f003 fe5b 	bl	20009a24 <SPI_transfer_block>

//	SPI_transfer_block(this_spi,0,0,rd_buffer,rd_byte_size);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
20005d6e:	f04f 0300 	mov.w	r3, #0
20005d72:	82fb      	strh	r3, [r7, #22]
20005d74:	e011      	b.n	20005d9a <adf_spi_trans_read+0x56>
		if(i<rd_byte_size){
20005d76:	8afa      	ldrh	r2, [r7, #22]
20005d78:	6a3b      	ldr	r3, [r7, #32]
20005d7a:	429a      	cmp	r2, r3
20005d7c:	d209      	bcs.n	20005d92 <adf_spi_trans_read+0x4e>
			rd_buffer[i] = r_buf[i];
20005d7e:	8afa      	ldrh	r2, [r7, #22]
20005d80:	683b      	ldr	r3, [r7, #0]
20005d82:	4413      	add	r3, r2
20005d84:	8afa      	ldrh	r2, [r7, #22]
20005d86:	f107 0118 	add.w	r1, r7, #24
20005d8a:	440a      	add	r2, r1
20005d8c:	f812 2c08 	ldrb.w	r2, [r2, #-8]
20005d90:	701a      	strb	r2, [r3, #0]

		SPI_transfer_block(this_spi,cmd_buffer,cmd_byte_size,r_buf,rd_byte_size);

//	SPI_transfer_block(this_spi,0,0,rd_buffer,rd_byte_size);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
20005d92:	8afb      	ldrh	r3, [r7, #22]
20005d94:	f103 0301 	add.w	r3, r3, #1
20005d98:	82fb      	strh	r3, [r7, #22]
20005d9a:	8afa      	ldrh	r2, [r7, #22]
20005d9c:	f240 33e7 	movw	r3, #999	; 0x3e7
20005da0:	429a      	cmp	r2, r3
20005da2:	d9e8      	bls.n	20005d76 <adf_spi_trans_read+0x32>
		if(i<rd_byte_size){
			rd_buffer[i] = r_buf[i];
		}
	}
}
20005da4:	f107 0718 	add.w	r7, r7, #24
20005da8:	46bd      	mov	sp, r7
20005daa:	bd80      	pop	{r7, pc}

20005dac <adf_spi_trans_write>:

void adf_spi_trans_write( spi_instance_t * this_spi,
    uint8_t * cmd_buffer,
    size_t cmd_byte_size,
    uint8_t * wr_buffer,
    size_t wr_byte_size){
20005dac:	b580      	push	{r7, lr}
20005dae:	b0d2      	sub	sp, #328	; 0x148
20005db0:	af02      	add	r7, sp, #8
20005db2:	f107 0c0c 	add.w	ip, r7, #12
20005db6:	f8cc 0000 	str.w	r0, [ip]
20005dba:	f107 0008 	add.w	r0, r7, #8
20005dbe:	6001      	str	r1, [r0, #0]
20005dc0:	f107 0104 	add.w	r1, r7, #4
20005dc4:	600a      	str	r2, [r1, #0]
20005dc6:	463a      	mov	r2, r7
20005dc8:	6013      	str	r3, [r2, #0]

	uint8_t data[300];
	uint16_t i = 0;
20005dca:	f04f 0300 	mov.w	r3, #0
20005dce:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e

	for(;i<cmd_byte_size;i++){
20005dd2:	e011      	b.n	20005df8 <adf_spi_trans_write+0x4c>
		data[i] = cmd_buffer[i];
20005dd4:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
20005dd8:	f8b7 113e 	ldrh.w	r1, [r7, #318]	; 0x13e
20005ddc:	f107 0208 	add.w	r2, r7, #8
20005de0:	6812      	ldr	r2, [r2, #0]
20005de2:	440a      	add	r2, r1
20005de4:	7811      	ldrb	r1, [r2, #0]
20005de6:	f107 0210 	add.w	r2, r7, #16
20005dea:	54d1      	strb	r1, [r2, r3]
    size_t wr_byte_size){

	uint8_t data[300];
	uint16_t i = 0;

	for(;i<cmd_byte_size;i++){
20005dec:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
20005df0:	f103 0301 	add.w	r3, r3, #1
20005df4:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
20005df8:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
20005dfc:	f107 0304 	add.w	r3, r7, #4
20005e00:	681b      	ldr	r3, [r3, #0]
20005e02:	429a      	cmp	r2, r3
20005e04:	d3e6      	bcc.n	20005dd4 <adf_spi_trans_write+0x28>
		data[i] = cmd_buffer[i];
	}
	for(;i<cmd_byte_size + wr_byte_size;i++){
20005e06:	e015      	b.n	20005e34 <adf_spi_trans_write+0x88>
		data[i] = wr_buffer[i-cmd_byte_size];
20005e08:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
20005e0c:	f8b7 113e 	ldrh.w	r1, [r7, #318]	; 0x13e
20005e10:	f107 0204 	add.w	r2, r7, #4
20005e14:	6812      	ldr	r2, [r2, #0]
20005e16:	ebc2 0101 	rsb	r1, r2, r1
20005e1a:	463a      	mov	r2, r7
20005e1c:	6812      	ldr	r2, [r2, #0]
20005e1e:	440a      	add	r2, r1
20005e20:	7811      	ldrb	r1, [r2, #0]
20005e22:	f107 0210 	add.w	r2, r7, #16
20005e26:	54d1      	strb	r1, [r2, r3]
	uint16_t i = 0;

	for(;i<cmd_byte_size;i++){
		data[i] = cmd_buffer[i];
	}
	for(;i<cmd_byte_size + wr_byte_size;i++){
20005e28:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
20005e2c:	f103 0301 	add.w	r3, r3, #1
20005e30:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
20005e34:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
20005e38:	f107 0304 	add.w	r3, r7, #4
20005e3c:	6819      	ldr	r1, [r3, #0]
20005e3e:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
20005e42:	440b      	add	r3, r1
20005e44:	429a      	cmp	r2, r3
20005e46:	d3df      	bcc.n	20005e08 <adf_spi_trans_write+0x5c>
//	MSS_GPIO_set_output(MSS_GPIO_3, 0);
//	SPI_block_write(this_spi, cmd_buffer, cmd_byte_size, wr_buffer, wr_byte_size);
//	MSS_GPIO_set_output(MSS_GPIO_3, 1);
	//Using new drivers
//	SPI_set_slave_select(this_spi,ADF_SPI_SLAVE);
	SPI_transfer_block(this_spi,data,cmd_byte_size + wr_byte_size,0,0);
20005e48:	f107 0304 	add.w	r3, r7, #4
20005e4c:	681b      	ldr	r3, [r3, #0]
20005e4e:	b29a      	uxth	r2, r3
20005e50:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
20005e54:	b29b      	uxth	r3, r3
20005e56:	4413      	add	r3, r2
20005e58:	b29b      	uxth	r3, r3
20005e5a:	f107 010c 	add.w	r1, r7, #12
20005e5e:	f107 0210 	add.w	r2, r7, #16
20005e62:	f04f 0000 	mov.w	r0, #0
20005e66:	9000      	str	r0, [sp, #0]
20005e68:	6808      	ldr	r0, [r1, #0]
20005e6a:	4611      	mov	r1, r2
20005e6c:	461a      	mov	r2, r3
20005e6e:	f04f 0300 	mov.w	r3, #0
20005e72:	f003 fdd7 	bl	20009a24 <SPI_transfer_block>
//	SPI_transfer_block(this_spi,wr_buffer,wr_byte_size,0,0);
//	SPI_clear_slave_select(this_spi,ADF_SPI_SLAVE);
	for(i=0;i<1000;i++){
20005e76:	f04f 0300 	mov.w	r3, #0
20005e7a:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
20005e7e:	e005      	b.n	20005e8c <adf_spi_trans_write+0xe0>
20005e80:	f8b7 313e 	ldrh.w	r3, [r7, #318]	; 0x13e
20005e84:	f103 0301 	add.w	r3, r3, #1
20005e88:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
20005e8c:	f8b7 213e 	ldrh.w	r2, [r7, #318]	; 0x13e
20005e90:	f240 33e7 	movw	r3, #999	; 0x3e7
20005e94:	429a      	cmp	r2, r3
20005e96:	d9f3      	bls.n	20005e80 <adf_spi_trans_write+0xd4>

	}
}
20005e98:	f507 77a0 	add.w	r7, r7, #320	; 0x140
20005e9c:	46bd      	mov	sp, r7
20005e9e:	bd80      	pop	{r7, pc}

20005ea0 <adf_get_state>:

uint8_t adf_get_state() {
20005ea0:	b580      	push	{r7, lr}
20005ea2:	b082      	sub	sp, #8
20005ea4:	af00      	add	r7, sp, #0
    uint8_t misc_fw[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
20005ea6:	f04f 0300 	mov.w	r3, #0
20005eaa:	703b      	strb	r3, [r7, #0]
20005eac:	f04f 0300 	mov.w	r3, #0
20005eb0:	707b      	strb	r3, [r7, #1]
20005eb2:	f04f 0300 	mov.w	r3, #0
20005eb6:	70bb      	strb	r3, [r7, #2]
20005eb8:	f04f 0300 	mov.w	r3, #0
20005ebc:	70fb      	strb	r3, [r7, #3]
20005ebe:	f04f 0300 	mov.w	r3, #0
20005ec2:	713b      	strb	r3, [r7, #4]
20005ec4:	f04f 0300 	mov.w	r3, #0
20005ec8:	717b      	strb	r3, [r7, #5]
    uint8_t curr_mode = 0;
20005eca:	f04f 0300 	mov.w	r3, #0
20005ece:	71bb      	strb	r3, [r7, #6]
	uint8_t tries = 0;
20005ed0:	f04f 0300 	mov.w	r3, #0
20005ed4:	71fb      	strb	r3, [r7, #7]
    while((!(misc_fw[0] == 0xe4 || misc_fw[0] == 0xA4)) && tries++ < 100){
20005ed6:	e014      	b.n	20005f02 <adf_get_state+0x62>
    	adf_read_from_memory(RMODE_1,MISC_FW,misc_fw,4);
20005ed8:	463b      	mov	r3, r7
20005eda:	f04f 0078 	mov.w	r0, #120	; 0x78
20005ede:	f244 21b4 	movw	r1, #17076	; 0x42b4
20005ee2:	f2c4 0100 	movt	r1, #16384	; 0x4000
20005ee6:	461a      	mov	r2, r3
20005ee8:	f04f 0304 	mov.w	r3, #4
20005eec:	f7ff fdfc 	bl	20005ae8 <adf_read_from_memory>
    	if( misc_fw[0] == 0xe2 || misc_fw[0] == 0xA2 || misc_fw[0] == 0x00){
20005ef0:	783b      	ldrb	r3, [r7, #0]
20005ef2:	2be2      	cmp	r3, #226	; 0xe2
20005ef4:	d017      	beq.n	20005f26 <adf_get_state+0x86>
20005ef6:	783b      	ldrb	r3, [r7, #0]
20005ef8:	2ba2      	cmp	r3, #162	; 0xa2
20005efa:	d014      	beq.n	20005f26 <adf_get_state+0x86>
20005efc:	783b      	ldrb	r3, [r7, #0]
20005efe:	2b00      	cmp	r3, #0
20005f00:	d011      	beq.n	20005f26 <adf_get_state+0x86>

uint8_t adf_get_state() {
    uint8_t misc_fw[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
    uint8_t curr_mode = 0;
	uint8_t tries = 0;
    while((!(misc_fw[0] == 0xe4 || misc_fw[0] == 0xA4)) && tries++ < 100){
20005f02:	783b      	ldrb	r3, [r7, #0]
20005f04:	2be4      	cmp	r3, #228	; 0xe4
20005f06:	d00e      	beq.n	20005f26 <adf_get_state+0x86>
20005f08:	783b      	ldrb	r3, [r7, #0]
20005f0a:	2ba4      	cmp	r3, #164	; 0xa4
20005f0c:	d00b      	beq.n	20005f26 <adf_get_state+0x86>
20005f0e:	79fb      	ldrb	r3, [r7, #7]
20005f10:	2b63      	cmp	r3, #99	; 0x63
20005f12:	bf8c      	ite	hi
20005f14:	2300      	movhi	r3, #0
20005f16:	2301      	movls	r3, #1
20005f18:	b2db      	uxtb	r3, r3
20005f1a:	79fa      	ldrb	r2, [r7, #7]
20005f1c:	f102 0201 	add.w	r2, r2, #1
20005f20:	71fa      	strb	r2, [r7, #7]
20005f22:	2b00      	cmp	r3, #0
20005f24:	d1d8      	bne.n	20005ed8 <adf_get_state+0x38>
    	if( misc_fw[0] == 0xe2 || misc_fw[0] == 0xA2 || misc_fw[0] == 0x00){
    		break;
    	}
    }
	//PHY SLEEP is zero. Need to discuss what to return when tries goes out of limits
    curr_mode = misc_fw[4] & 0x3F;
20005f26:	793b      	ldrb	r3, [r7, #4]
20005f28:	f003 033f 	and.w	r3, r3, #63	; 0x3f
20005f2c:	71bb      	strb	r3, [r7, #6]
    return curr_mode;
20005f2e:	79bb      	ldrb	r3, [r7, #6]
}
20005f30:	4618      	mov	r0, r3
20005f32:	f107 0708 	add.w	r7, r7, #8
20005f36:	46bd      	mov	sp, r7
20005f38:	bd80      	pop	{r7, pc}
20005f3a:	bf00      	nop

20005f3c <get_rssi_data>:
	while(cmd_buff[0] == 0x00){
		adf_read_from_memory(RMODE_1, RX_BUFFER, cmd_buff, 4);
	}
}

void get_rssi_data(uint16_t* rssi){
20005f3c:	b580      	push	{r7, lr}
20005f3e:	b084      	sub	sp, #16
20005f40:	af00      	add	r7, sp, #0
20005f42:	6078      	str	r0, [r7, #4]

	uint8_t rx_buf[6];
	rx_buf[0] = 0x00;
20005f44:	f04f 0300 	mov.w	r3, #0
20005f48:	723b      	strb	r3, [r7, #8]

	while(rx_buf[0] == 0x00){
20005f4a:	e00c      	b.n	20005f66 <get_rssi_data+0x2a>
		adf_read_from_memory(RMODE_1, RSSI_ADDR, rx_buf, 4);
20005f4c:	f107 0308 	add.w	r3, r7, #8
20005f50:	f04f 0078 	mov.w	r0, #120	; 0x78
20005f54:	f240 5138 	movw	r1, #1336	; 0x538
20005f58:	f2c2 0100 	movt	r1, #8192	; 0x2000
20005f5c:	461a      	mov	r2, r3
20005f5e:	f04f 0304 	mov.w	r3, #4
20005f62:	f7ff fdc1 	bl	20005ae8 <adf_read_from_memory>
void get_rssi_data(uint16_t* rssi){

	uint8_t rx_buf[6];
	rx_buf[0] = 0x00;

	while(rx_buf[0] == 0x00){
20005f66:	7a3b      	ldrb	r3, [r7, #8]
20005f68:	2b00      	cmp	r3, #0
20005f6a:	d0ef      	beq.n	20005f4c <get_rssi_data+0x10>
		adf_read_from_memory(RMODE_1, RSSI_ADDR, rx_buf, 4);
	}

	*rssi = (uint16_t)((rx_buf[2] & 0x07) << 8) + rx_buf[3];
20005f6c:	7abb      	ldrb	r3, [r7, #10]
20005f6e:	f003 0307 	and.w	r3, r3, #7
20005f72:	ea4f 2303 	mov.w	r3, r3, lsl #8
20005f76:	b29a      	uxth	r2, r3
20005f78:	7afb      	ldrb	r3, [r7, #11]
20005f7a:	4413      	add	r3, r2
20005f7c:	b29a      	uxth	r2, r3
20005f7e:	687b      	ldr	r3, [r7, #4]
20005f80:	801a      	strh	r2, [r3, #0]
	*rssi = ~(*rssi) + 1;
20005f82:	687b      	ldr	r3, [r7, #4]
20005f84:	881b      	ldrh	r3, [r3, #0]
20005f86:	f1c3 0300 	rsb	r3, r3, #0
20005f8a:	b29b      	uxth	r3, r3
20005f8c:	b29a      	uxth	r2, r3
20005f8e:	687b      	ldr	r3, [r7, #4]
20005f90:	801a      	strh	r2, [r3, #0]
	*rssi = *rssi & 0x0FFF;
20005f92:	687b      	ldr	r3, [r7, #4]
20005f94:	881b      	ldrh	r3, [r3, #0]
20005f96:	ea4f 5303 	mov.w	r3, r3, lsl #20
20005f9a:	ea4f 5313 	mov.w	r3, r3, lsr #20
20005f9e:	687a      	ldr	r2, [r7, #4]
20005fa0:	8013      	strh	r3, [r2, #0]
	if(*rssi > 2048){
20005fa2:	687b      	ldr	r3, [r7, #4]
20005fa4:	881b      	ldrh	r3, [r3, #0]
20005fa6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20005faa:	d906      	bls.n	20005fba <get_rssi_data+0x7e>
		*rssi = *rssi - 2048;
20005fac:	687b      	ldr	r3, [r7, #4]
20005fae:	881b      	ldrh	r3, [r3, #0]
20005fb0:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
20005fb4:	b29a      	uxth	r2, r3
20005fb6:	687b      	ldr	r3, [r7, #4]
20005fb8:	801a      	strh	r2, [r3, #0]
	}
	*rssi = *rssi/4;
20005fba:	687b      	ldr	r3, [r7, #4]
20005fbc:	881b      	ldrh	r3, [r3, #0]
20005fbe:	ea4f 0393 	mov.w	r3, r3, lsr #2
20005fc2:	b29a      	uxth	r2, r3
20005fc4:	687b      	ldr	r3, [r7, #4]
20005fc6:	801a      	strh	r2, [r3, #0]

}
20005fc8:	f107 0710 	add.w	r7, r7, #16
20005fcc:	46bd      	mov	sp, r7
20005fce:	bd80      	pop	{r7, pc}

20005fd0 <get_rssi_cca_data>:
	temp[0] = rx_buf[5];
	temp[1] = rx_buf[4] & 0x0F;

}

void get_rssi_cca_data(uint16_t* rssi){
20005fd0:	b580      	push	{r7, lr}
20005fd2:	b084      	sub	sp, #16
20005fd4:	af00      	add	r7, sp, #0
20005fd6:	6078      	str	r0, [r7, #4]
	uint8_t rx_buf[6];
	//uint16_t rssi;
	rx_buf[0] = 0x00;
20005fd8:	f04f 0300 	mov.w	r3, #0
20005fdc:	723b      	strb	r3, [r7, #8]
	uint8_t state;

	adf_send_cmd(CMD_PHY_CCA);
20005fde:	f04f 0086 	mov.w	r0, #134	; 0x86
20005fe2:	f7ff fdcd 	bl	20005b80 <adf_send_cmd>

	state = adf_get_state();
20005fe6:	f7ff ff5b 	bl	20005ea0 <adf_get_state>
20005fea:	4603      	mov	r3, r0
20005fec:	73fb      	strb	r3, [r7, #15]

	while(state != 2){
20005fee:	e003      	b.n	20005ff8 <get_rssi_cca_data+0x28>
		state = adf_get_state();
20005ff0:	f7ff ff56 	bl	20005ea0 <adf_get_state>
20005ff4:	4603      	mov	r3, r0
20005ff6:	73fb      	strb	r3, [r7, #15]

	adf_send_cmd(CMD_PHY_CCA);

	state = adf_get_state();

	while(state != 2){
20005ff8:	7bfb      	ldrb	r3, [r7, #15]
20005ffa:	2b02      	cmp	r3, #2
20005ffc:	d1f8      	bne.n	20005ff0 <get_rssi_cca_data+0x20>
		state = adf_get_state();
	}

	while(rx_buf[0] == 0x00){
20005ffe:	e00c      	b.n	2000601a <get_rssi_cca_data+0x4a>
		adf_read_from_memory(RMODE_1, PROFILE_CCA_READBACK, rx_buf, 4);
20006000:	f107 0308 	add.w	r3, r7, #8
20006004:	f04f 0078 	mov.w	r0, #120	; 0x78
20006008:	f240 317c 	movw	r1, #892	; 0x37c
2000600c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20006010:	461a      	mov	r2, r3
20006012:	f04f 0304 	mov.w	r3, #4
20006016:	f7ff fd67 	bl	20005ae8 <adf_read_from_memory>

	while(state != 2){
		state = adf_get_state();
	}

	while(rx_buf[0] == 0x00){
2000601a:	7a3b      	ldrb	r3, [r7, #8]
2000601c:	2b00      	cmp	r3, #0
2000601e:	d0ef      	beq.n	20006000 <get_rssi_cca_data+0x30>
		adf_read_from_memory(RMODE_1, PROFILE_CCA_READBACK, rx_buf, 4);
	}

	*rssi = (uint16_t)((rx_buf[4] & 0x07) << 8) + rx_buf[5];
20006020:	7b3b      	ldrb	r3, [r7, #12]
20006022:	f003 0307 	and.w	r3, r3, #7
20006026:	ea4f 2303 	mov.w	r3, r3, lsl #8
2000602a:	b29a      	uxth	r2, r3
2000602c:	7b7b      	ldrb	r3, [r7, #13]
2000602e:	4413      	add	r3, r2
20006030:	b29a      	uxth	r2, r3
20006032:	687b      	ldr	r3, [r7, #4]
20006034:	801a      	strh	r2, [r3, #0]
	*rssi = ~(*rssi) + 1;
20006036:	687b      	ldr	r3, [r7, #4]
20006038:	881b      	ldrh	r3, [r3, #0]
2000603a:	f1c3 0300 	rsb	r3, r3, #0
2000603e:	b29b      	uxth	r3, r3
20006040:	b29a      	uxth	r2, r3
20006042:	687b      	ldr	r3, [r7, #4]
20006044:	801a      	strh	r2, [r3, #0]
	*rssi = *rssi & 0x0FFF;
20006046:	687b      	ldr	r3, [r7, #4]
20006048:	881b      	ldrh	r3, [r3, #0]
2000604a:	ea4f 5303 	mov.w	r3, r3, lsl #20
2000604e:	ea4f 5313 	mov.w	r3, r3, lsr #20
20006052:	687a      	ldr	r2, [r7, #4]
20006054:	8013      	strh	r3, [r2, #0]
	if(*rssi > 2048){
20006056:	687b      	ldr	r3, [r7, #4]
20006058:	881b      	ldrh	r3, [r3, #0]
2000605a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2000605e:	d906      	bls.n	2000606e <get_rssi_cca_data+0x9e>
		*rssi = *rssi - 2048;
20006060:	687b      	ldr	r3, [r7, #4]
20006062:	881b      	ldrh	r3, [r3, #0]
20006064:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
20006068:	b29a      	uxth	r2, r3
2000606a:	687b      	ldr	r3, [r7, #4]
2000606c:	801a      	strh	r2, [r3, #0]
	}
	*rssi = *rssi/4;
2000606e:	687b      	ldr	r3, [r7, #4]
20006070:	881b      	ldrh	r3, [r3, #0]
20006072:	ea4f 0393 	mov.w	r3, r3, lsr #2
20006076:	b29a      	uxth	r2, r3
20006078:	687b      	ldr	r3, [r7, #4]
2000607a:	801a      	strh	r2, [r3, #0]

}
2000607c:	f107 0710 	add.w	r7, r7, #16
20006080:	46bd      	mov	sp, r7
20006082:	bd80      	pop	{r7, pc}

20006084 <get_preamble_pkt>:


	return 0;
}

uint8_t get_preamble_pkt(){
20006084:	b580      	push	{r7, lr}
20006086:	b082      	sub	sp, #8
20006088:	af00      	add	r7, sp, #0
	uint8_t pre[6];
	uint8_t preamble;

	adf_read_from_memory(RMODE_1, PREAMBLE_READ_REG, pre, 4);
2000608a:	463b      	mov	r3, r7
2000608c:	f04f 0078 	mov.w	r0, #120	; 0x78
20006090:	f240 5104 	movw	r1, #1284	; 0x504
20006094:	f2c2 0100 	movt	r1, #8192	; 0x2000
20006098:	461a      	mov	r2, r3
2000609a:	f04f 0304 	mov.w	r3, #4
2000609e:	f7ff fd23 	bl	20005ae8 <adf_read_from_memory>
	preamble = pre[3];
200060a2:	78fb      	ldrb	r3, [r7, #3]
200060a4:	71fb      	strb	r3, [r7, #7]

	return preamble;
200060a6:	79fb      	ldrb	r3, [r7, #7]
}
200060a8:	4618      	mov	r0, r3
200060aa:	f107 0708 	add.w	r7, r7, #8
200060ae:	46bd      	mov	sp, r7
200060b0:	bd80      	pop	{r7, pc}
200060b2:	bf00      	nop

200060b4 <get_sync_word>:

uint32_t get_sync_word(){
200060b4:	b580      	push	{r7, lr}
200060b6:	b084      	sub	sp, #16
200060b8:	af00      	add	r7, sp, #0
	uint8_t sw[6];
	uint32_t sync_word;

	adf_read_from_memory(RMODE_1, SYNC_WORD_READ_REG, sw, 4);
200060ba:	f107 0304 	add.w	r3, r7, #4
200060be:	f04f 0078 	mov.w	r0, #120	; 0x78
200060c2:	f240 5114 	movw	r1, #1300	; 0x514
200060c6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200060ca:	461a      	mov	r2, r3
200060cc:	f04f 0304 	mov.w	r3, #4
200060d0:	f7ff fd0a 	bl	20005ae8 <adf_read_from_memory>
	sync_word = (sw[2] << 24) | (sw[3] << 16) | (sw[4] << 8) | (sw[5]);
200060d4:	79bb      	ldrb	r3, [r7, #6]
200060d6:	ea4f 6203 	mov.w	r2, r3, lsl #24
200060da:	79fb      	ldrb	r3, [r7, #7]
200060dc:	ea4f 4303 	mov.w	r3, r3, lsl #16
200060e0:	ea42 0203 	orr.w	r2, r2, r3
200060e4:	7a3b      	ldrb	r3, [r7, #8]
200060e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
200060ea:	ea42 0203 	orr.w	r2, r2, r3
200060ee:	7a7b      	ldrb	r3, [r7, #9]
200060f0:	ea42 0303 	orr.w	r3, r2, r3
200060f4:	60fb      	str	r3, [r7, #12]

	return sync_word;
200060f6:	68fb      	ldr	r3, [r7, #12]
}
200060f8:	4618      	mov	r0, r3
200060fa:	f107 0710 	add.w	r7, r7, #16
200060fe:	46bd      	mov	sp, r7
20006100:	bd80      	pop	{r7, pc}
20006102:	bf00      	nop

20006104 <get_freq>:

uint32_t get_freq(){
20006104:	b580      	push	{r7, lr}
20006106:	b084      	sub	sp, #16
20006108:	af00      	add	r7, sp, #0
	uint8_t fre[6];
	uint32_t frequency;

	adf_read_from_memory(RMODE_1, PROFILE_CH_FREQ, fre, 4);
2000610a:	f107 0304 	add.w	r3, r7, #4
2000610e:	f04f 0078 	mov.w	r0, #120	; 0x78
20006112:	f240 21ec 	movw	r1, #748	; 0x2ec
20006116:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000611a:	461a      	mov	r2, r3
2000611c:	f04f 0304 	mov.w	r3, #4
20006120:	f7ff fce2 	bl	20005ae8 <adf_read_from_memory>
	frequency = (fre[2] << 24) | (fre[3] << 16) | (fre[4] << 8) | (fre[5]);
20006124:	79bb      	ldrb	r3, [r7, #6]
20006126:	ea4f 6203 	mov.w	r2, r3, lsl #24
2000612a:	79fb      	ldrb	r3, [r7, #7]
2000612c:	ea4f 4303 	mov.w	r3, r3, lsl #16
20006130:	ea42 0203 	orr.w	r2, r2, r3
20006134:	7a3b      	ldrb	r3, [r7, #8]
20006136:	ea4f 2303 	mov.w	r3, r3, lsl #8
2000613a:	ea42 0203 	orr.w	r2, r2, r3
2000613e:	7a7b      	ldrb	r3, [r7, #9]
20006140:	ea42 0303 	orr.w	r3, r2, r3
20006144:	60fb      	str	r3, [r7, #12]

	return frequency;
20006146:	68fb      	ldr	r3, [r7, #12]
}
20006148:	4618      	mov	r0, r3
2000614a:	f107 0710 	add.w	r7, r7, #16
2000614e:	46bd      	mov	sp, r7
20006150:	bd80      	pop	{r7, pc}
20006152:	bf00      	nop

20006154 <HW_set_32bit_reg>:
20006154:	6001      	str	r1, [r0, #0]
20006156:	4770      	bx	lr

20006158 <HW_get_32bit_reg>:
20006158:	6800      	ldr	r0, [r0, #0]
2000615a:	4770      	bx	lr

2000615c <HW_set_32bit_reg_field>:
2000615c:	b50e      	push	{r1, r2, r3, lr}
2000615e:	fa03 f301 	lsl.w	r3, r3, r1
20006162:	ea03 0302 	and.w	r3, r3, r2
20006166:	6801      	ldr	r1, [r0, #0]
20006168:	ea6f 0202 	mvn.w	r2, r2
2000616c:	ea01 0102 	and.w	r1, r1, r2
20006170:	ea41 0103 	orr.w	r1, r1, r3
20006174:	6001      	str	r1, [r0, #0]
20006176:	bd0e      	pop	{r1, r2, r3, pc}

20006178 <HW_get_32bit_reg_field>:
20006178:	6800      	ldr	r0, [r0, #0]
2000617a:	ea00 0002 	and.w	r0, r0, r2
2000617e:	fa20 f001 	lsr.w	r0, r0, r1
20006182:	4770      	bx	lr

20006184 <HW_set_16bit_reg>:
20006184:	8001      	strh	r1, [r0, #0]
20006186:	4770      	bx	lr

20006188 <HW_get_16bit_reg>:
20006188:	8800      	ldrh	r0, [r0, #0]
2000618a:	4770      	bx	lr

2000618c <HW_set_16bit_reg_field>:
2000618c:	b50e      	push	{r1, r2, r3, lr}
2000618e:	fa03 f301 	lsl.w	r3, r3, r1
20006192:	ea03 0302 	and.w	r3, r3, r2
20006196:	8801      	ldrh	r1, [r0, #0]
20006198:	ea6f 0202 	mvn.w	r2, r2
2000619c:	ea01 0102 	and.w	r1, r1, r2
200061a0:	ea41 0103 	orr.w	r1, r1, r3
200061a4:	8001      	strh	r1, [r0, #0]
200061a6:	bd0e      	pop	{r1, r2, r3, pc}

200061a8 <HW_get_16bit_reg_field>:
200061a8:	8800      	ldrh	r0, [r0, #0]
200061aa:	ea00 0002 	and.w	r0, r0, r2
200061ae:	fa20 f001 	lsr.w	r0, r0, r1
200061b2:	4770      	bx	lr

200061b4 <HW_set_8bit_reg>:
200061b4:	7001      	strb	r1, [r0, #0]
200061b6:	4770      	bx	lr

200061b8 <HW_get_8bit_reg>:
200061b8:	7800      	ldrb	r0, [r0, #0]
200061ba:	4770      	bx	lr

200061bc <HW_set_8bit_reg_field>:
200061bc:	b50e      	push	{r1, r2, r3, lr}
200061be:	fa03 f301 	lsl.w	r3, r3, r1
200061c2:	ea03 0302 	and.w	r3, r3, r2
200061c6:	7801      	ldrb	r1, [r0, #0]
200061c8:	ea6f 0202 	mvn.w	r2, r2
200061cc:	ea01 0102 	and.w	r1, r1, r2
200061d0:	ea41 0103 	orr.w	r1, r1, r3
200061d4:	7001      	strb	r1, [r0, #0]
200061d6:	bd0e      	pop	{r1, r2, r3, pc}

200061d8 <HW_get_8bit_reg_field>:
200061d8:	7800      	ldrb	r0, [r0, #0]
200061da:	ea00 0002 	and.w	r0, r0, r2
200061de:	fa20 f001 	lsr.w	r0, r0, r1
200061e2:	4770      	bx	lr

200061e4 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200061e4:	b480      	push	{r7}
200061e6:	b083      	sub	sp, #12
200061e8:	af00      	add	r7, sp, #0
200061ea:	4603      	mov	r3, r0
200061ec:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200061ee:	f24e 1300 	movw	r3, #57600	; 0xe100
200061f2:	f2ce 0300 	movt	r3, #57344	; 0xe000
200061f6:	f997 2007 	ldrsb.w	r2, [r7, #7]
200061fa:	ea4f 1252 	mov.w	r2, r2, lsr #5
200061fe:	79f9      	ldrb	r1, [r7, #7]
20006200:	f001 011f 	and.w	r1, r1, #31
20006204:	f04f 0001 	mov.w	r0, #1
20006208:	fa00 f101 	lsl.w	r1, r0, r1
2000620c:	f102 0260 	add.w	r2, r2, #96	; 0x60
20006210:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20006214:	f107 070c 	add.w	r7, r7, #12
20006218:	46bd      	mov	sp, r7
2000621a:	bc80      	pop	{r7}
2000621c:	4770      	bx	lr
2000621e:	bf00      	nop

20006220 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20006220:	b480      	push	{r7}
20006222:	b083      	sub	sp, #12
20006224:	af00      	add	r7, sp, #0
20006226:	6078      	str	r0, [r7, #4]
20006228:	460b      	mov	r3, r1
2000622a:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
2000622c:	687b      	ldr	r3, [r7, #4]
2000622e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20006232:	687b      	ldr	r3, [r7, #4]
20006234:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20006238:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000623c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20006240:	441a      	add	r2, r3
20006242:	78fb      	ldrb	r3, [r7, #3]
20006244:	ea4f 0383 	mov.w	r3, r3, lsl #2
20006248:	4413      	add	r3, r2
2000624a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000624e:	f04f 0201 	mov.w	r2, #1
20006252:	601a      	str	r2, [r3, #0]
}
20006254:	f107 070c 	add.w	r7, r7, #12
20006258:	46bd      	mov	sp, r7
2000625a:	bc80      	pop	{r7}
2000625c:	4770      	bx	lr
2000625e:	bf00      	nop

20006260 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20006260:	b480      	push	{r7}
20006262:	b083      	sub	sp, #12
20006264:	af00      	add	r7, sp, #0
20006266:	6078      	str	r0, [r7, #4]
20006268:	460b      	mov	r3, r1
2000626a:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
2000626c:	687b      	ldr	r3, [r7, #4]
2000626e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20006272:	687b      	ldr	r3, [r7, #4]
20006274:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20006278:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000627c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20006280:	441a      	add	r2, r3
20006282:	78fb      	ldrb	r3, [r7, #3]
20006284:	ea4f 0383 	mov.w	r3, r3, lsl #2
20006288:	4413      	add	r3, r2
2000628a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000628e:	f04f 0200 	mov.w	r2, #0
20006292:	601a      	str	r2, [r3, #0]
}
20006294:	f107 070c 	add.w	r7, r7, #12
20006298:	46bd      	mov	sp, r7
2000629a:	bc80      	pop	{r7}
2000629c:	4770      	bx	lr
2000629e:	bf00      	nop

200062a0 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
200062a0:	b480      	push	{r7}
200062a2:	b083      	sub	sp, #12
200062a4:	af00      	add	r7, sp, #0
200062a6:	6078      	str	r0, [r7, #4]
200062a8:	460b      	mov	r3, r1
200062aa:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
200062ac:	687b      	ldr	r3, [r7, #4]
200062ae:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
200062b2:	687b      	ldr	r3, [r7, #4]
200062b4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
200062b8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
200062bc:	ea4f 1343 	mov.w	r3, r3, lsl #5
200062c0:	441a      	add	r2, r3
200062c2:	78fb      	ldrb	r3, [r7, #3]
200062c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200062c8:	4413      	add	r3, r2
200062ca:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
200062ce:	681b      	ldr	r3, [r3, #0]
200062d0:	b2db      	uxtb	r3, r3
}
200062d2:	4618      	mov	r0, r3
200062d4:	f107 070c 	add.w	r7, r7, #12
200062d8:	46bd      	mov	sp, r7
200062da:	bc80      	pop	{r7}
200062dc:	4770      	bx	lr
200062de:	bf00      	nop

200062e0 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
200062e0:	b580      	push	{r7, lr}
200062e2:	b084      	sub	sp, #16
200062e4:	af00      	add	r7, sp, #0
200062e6:	60f8      	str	r0, [r7, #12]
200062e8:	60b9      	str	r1, [r7, #8]
200062ea:	4613      	mov	r3, r2
200062ec:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
200062ee:	68fa      	ldr	r2, [r7, #12]
200062f0:	f24d 4340 	movw	r3, #54336	; 0xd440
200062f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200062f8:	429a      	cmp	r2, r3
200062fa:	d007      	beq.n	2000630c <MSS_UART_init+0x2c>
200062fc:	68fa      	ldr	r2, [r7, #12]
200062fe:	f24d 4300 	movw	r3, #54272	; 0xd400
20006302:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006306:	429a      	cmp	r2, r3
20006308:	d000      	beq.n	2000630c <MSS_UART_init+0x2c>
2000630a:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
2000630c:	79fb      	ldrb	r3, [r7, #7]
2000630e:	68f8      	ldr	r0, [r7, #12]
20006310:	68b9      	ldr	r1, [r7, #8]
20006312:	461a      	mov	r2, r3
20006314:	f000 f988 	bl	20006628 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
20006318:	68fb      	ldr	r3, [r7, #12]
2000631a:	681b      	ldr	r3, [r3, #0]
2000631c:	f103 0330 	add.w	r3, r3, #48	; 0x30
20006320:	4618      	mov	r0, r3
20006322:	f04f 0103 	mov.w	r1, #3
20006326:	f7ff ff9b 	bl	20006260 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
2000632a:	68fb      	ldr	r3, [r7, #12]
2000632c:	681b      	ldr	r3, [r3, #0]
2000632e:	f103 0334 	add.w	r3, r3, #52	; 0x34
20006332:	4618      	mov	r0, r3
20006334:	f04f 0102 	mov.w	r1, #2
20006338:	f7ff ff92 	bl	20006260 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
2000633c:	68fb      	ldr	r3, [r7, #12]
2000633e:	681b      	ldr	r3, [r3, #0]
20006340:	f103 0338 	add.w	r3, r3, #56	; 0x38
20006344:	4618      	mov	r0, r3
20006346:	f04f 0100 	mov.w	r1, #0
2000634a:	f7ff ff89 	bl	20006260 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
2000634e:	68fa      	ldr	r2, [r7, #12]
20006350:	f646 23c1 	movw	r3, #27329	; 0x6ac1
20006354:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006358:	6253      	str	r3, [r2, #36]	; 0x24
}
2000635a:	f107 0710 	add.w	r7, r7, #16
2000635e:	46bd      	mov	sp, r7
20006360:	bd80      	pop	{r7, pc}
20006362:	bf00      	nop

20006364 <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
20006364:	b480      	push	{r7}
20006366:	b089      	sub	sp, #36	; 0x24
20006368:	af00      	add	r7, sp, #0
2000636a:	60f8      	str	r0, [r7, #12]
2000636c:	60b9      	str	r1, [r7, #8]
2000636e:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
20006370:	f04f 0300 	mov.w	r3, #0
20006374:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20006376:	68fa      	ldr	r2, [r7, #12]
20006378:	f24d 4340 	movw	r3, #54336	; 0xd440
2000637c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006380:	429a      	cmp	r2, r3
20006382:	d007      	beq.n	20006394 <MSS_UART_polled_tx+0x30>
20006384:	68fa      	ldr	r2, [r7, #12]
20006386:	f24d 4300 	movw	r3, #54272	; 0xd400
2000638a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000638e:	429a      	cmp	r2, r3
20006390:	d000      	beq.n	20006394 <MSS_UART_polled_tx+0x30>
20006392:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
20006394:	68bb      	ldr	r3, [r7, #8]
20006396:	2b00      	cmp	r3, #0
20006398:	d100      	bne.n	2000639c <MSS_UART_polled_tx+0x38>
2000639a:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
2000639c:	687b      	ldr	r3, [r7, #4]
2000639e:	2b00      	cmp	r3, #0
200063a0:	d100      	bne.n	200063a4 <MSS_UART_polled_tx+0x40>
200063a2:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
200063a4:	68fa      	ldr	r2, [r7, #12]
200063a6:	f24d 4340 	movw	r3, #54336	; 0xd440
200063aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200063ae:	429a      	cmp	r2, r3
200063b0:	d006      	beq.n	200063c0 <MSS_UART_polled_tx+0x5c>
200063b2:	68fa      	ldr	r2, [r7, #12]
200063b4:	f24d 4300 	movw	r3, #54272	; 0xd400
200063b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200063bc:	429a      	cmp	r2, r3
200063be:	d13d      	bne.n	2000643c <MSS_UART_polled_tx+0xd8>
200063c0:	68bb      	ldr	r3, [r7, #8]
200063c2:	2b00      	cmp	r3, #0
200063c4:	d03a      	beq.n	2000643c <MSS_UART_polled_tx+0xd8>
200063c6:	687b      	ldr	r3, [r7, #4]
200063c8:	2b00      	cmp	r3, #0
200063ca:	d037      	beq.n	2000643c <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
200063cc:	68fb      	ldr	r3, [r7, #12]
200063ce:	681b      	ldr	r3, [r3, #0]
200063d0:	7d1b      	ldrb	r3, [r3, #20]
200063d2:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
200063d4:	68fb      	ldr	r3, [r7, #12]
200063d6:	7b5a      	ldrb	r2, [r3, #13]
200063d8:	7efb      	ldrb	r3, [r7, #27]
200063da:	ea42 0303 	orr.w	r3, r2, r3
200063de:	b2da      	uxtb	r2, r3
200063e0:	68fb      	ldr	r3, [r7, #12]
200063e2:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
200063e4:	7efb      	ldrb	r3, [r7, #27]
200063e6:	f003 0320 	and.w	r3, r3, #32
200063ea:	2b00      	cmp	r3, #0
200063ec:	d023      	beq.n	20006436 <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
200063ee:	f04f 0310 	mov.w	r3, #16
200063f2:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
200063f4:	687b      	ldr	r3, [r7, #4]
200063f6:	2b0f      	cmp	r3, #15
200063f8:	d801      	bhi.n	200063fe <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
200063fa:	687b      	ldr	r3, [r7, #4]
200063fc:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
200063fe:	f04f 0300 	mov.w	r3, #0
20006402:	617b      	str	r3, [r7, #20]
20006404:	e00e      	b.n	20006424 <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
20006406:	68fb      	ldr	r3, [r7, #12]
20006408:	681b      	ldr	r3, [r3, #0]
2000640a:	68b9      	ldr	r1, [r7, #8]
2000640c:	693a      	ldr	r2, [r7, #16]
2000640e:	440a      	add	r2, r1
20006410:	7812      	ldrb	r2, [r2, #0]
20006412:	701a      	strb	r2, [r3, #0]
                    char_idx++;
20006414:	693b      	ldr	r3, [r7, #16]
20006416:	f103 0301 	add.w	r3, r3, #1
2000641a:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
2000641c:	697b      	ldr	r3, [r7, #20]
2000641e:	f103 0301 	add.w	r3, r3, #1
20006422:	617b      	str	r3, [r7, #20]
20006424:	697a      	ldr	r2, [r7, #20]
20006426:	69fb      	ldr	r3, [r7, #28]
20006428:	429a      	cmp	r2, r3
2000642a:	d3ec      	bcc.n	20006406 <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
2000642c:	687a      	ldr	r2, [r7, #4]
2000642e:	697b      	ldr	r3, [r7, #20]
20006430:	ebc3 0302 	rsb	r3, r3, r2
20006434:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
20006436:	687b      	ldr	r3, [r7, #4]
20006438:	2b00      	cmp	r3, #0
2000643a:	d1c7      	bne.n	200063cc <MSS_UART_polled_tx+0x68>
    }
}
2000643c:	f107 0724 	add.w	r7, r7, #36	; 0x24
20006440:	46bd      	mov	sp, r7
20006442:	bc80      	pop	{r7}
20006444:	4770      	bx	lr
20006446:	bf00      	nop

20006448 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
20006448:	4668      	mov	r0, sp
2000644a:	f020 0107 	bic.w	r1, r0, #7
2000644e:	468d      	mov	sp, r1
20006450:	b589      	push	{r0, r3, r7, lr}
20006452:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
20006454:	f24d 4040 	movw	r0, #54336	; 0xd440
20006458:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000645c:	f000 fa1a 	bl	20006894 <MSS_UART_isr>
}
20006460:	46bd      	mov	sp, r7
20006462:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20006466:	4685      	mov	sp, r0
20006468:	4770      	bx	lr
2000646a:	bf00      	nop

2000646c <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
2000646c:	4668      	mov	r0, sp
2000646e:	f020 0107 	bic.w	r1, r0, #7
20006472:	468d      	mov	sp, r1
20006474:	b589      	push	{r0, r3, r7, lr}
20006476:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
20006478:	f24d 4000 	movw	r0, #54272	; 0xd400
2000647c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20006480:	f000 fa08 	bl	20006894 <MSS_UART_isr>
}
20006484:	46bd      	mov	sp, r7
20006486:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
2000648a:	4685      	mov	sp, r0
2000648c:	4770      	bx	lr
2000648e:	bf00      	nop

20006490 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
20006490:	b580      	push	{r7, lr}
20006492:	b088      	sub	sp, #32
20006494:	af00      	add	r7, sp, #0
20006496:	6078      	str	r0, [r7, #4]
20006498:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
2000649a:	687a      	ldr	r2, [r7, #4]
2000649c:	f24d 4340 	movw	r3, #54336	; 0xd440
200064a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064a4:	429a      	cmp	r2, r3
200064a6:	d007      	beq.n	200064b8 <config_baud_divisors+0x28>
200064a8:	687a      	ldr	r2, [r7, #4]
200064aa:	f24d 4300 	movw	r3, #54272	; 0xd400
200064ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064b2:	429a      	cmp	r2, r3
200064b4:	d000      	beq.n	200064b8 <config_baud_divisors+0x28>
200064b6:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
200064b8:	687a      	ldr	r2, [r7, #4]
200064ba:	f24d 4340 	movw	r3, #54336	; 0xd440
200064be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064c2:	429a      	cmp	r2, r3
200064c4:	d007      	beq.n	200064d6 <config_baud_divisors+0x46>
200064c6:	687a      	ldr	r2, [r7, #4]
200064c8:	f24d 4300 	movw	r3, #54272	; 0xd400
200064cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064d0:	429a      	cmp	r2, r3
200064d2:	f040 80a4 	bne.w	2000661e <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
200064d6:	687b      	ldr	r3, [r7, #4]
200064d8:	683a      	ldr	r2, [r7, #0]
200064da:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
200064dc:	f004 fd24 	bl	2000af28 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
200064e0:	687a      	ldr	r2, [r7, #4]
200064e2:	f24d 4340 	movw	r3, #54336	; 0xd440
200064e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064ea:	429a      	cmp	r2, r3
200064ec:	d106      	bne.n	200064fc <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
200064ee:	f24c 23b8 	movw	r3, #49848	; 0xc2b8
200064f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200064f6:	681b      	ldr	r3, [r3, #0]
200064f8:	61fb      	str	r3, [r7, #28]
200064fa:	e005      	b.n	20006508 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
200064fc:	f24c 23bc 	movw	r3, #49852	; 0xc2bc
20006500:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006504:	681b      	ldr	r3, [r3, #0]
20006506:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
20006508:	69fb      	ldr	r3, [r7, #28]
2000650a:	ea4f 02c3 	mov.w	r2, r3, lsl #3
2000650e:	683b      	ldr	r3, [r7, #0]
20006510:	fbb2 f3f3 	udiv	r3, r2, r3
20006514:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
20006516:	697b      	ldr	r3, [r7, #20]
20006518:	ea4f 0353 	mov.w	r3, r3, lsr #1
2000651c:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
2000651e:	693b      	ldr	r3, [r7, #16]
20006520:	ea4f 1393 	mov.w	r3, r3, lsr #6
20006524:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
20006526:	68fb      	ldr	r3, [r7, #12]
20006528:	ea4f 1383 	mov.w	r3, r3, lsl #6
2000652c:	693a      	ldr	r2, [r7, #16]
2000652e:	ebc3 0302 	rsb	r3, r3, r2
20006532:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
20006534:	68fb      	ldr	r3, [r7, #12]
20006536:	ea4f 13c3 	mov.w	r3, r3, lsl #7
2000653a:	697a      	ldr	r2, [r7, #20]
2000653c:	ebc3 0202 	rsb	r2, r3, r2
20006540:	69bb      	ldr	r3, [r7, #24]
20006542:	ea4f 0343 	mov.w	r3, r3, lsl #1
20006546:	ebc3 0302 	rsb	r3, r3, r2
2000654a:	69ba      	ldr	r2, [r7, #24]
2000654c:	4413      	add	r3, r2
2000654e:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
20006550:	68fa      	ldr	r2, [r7, #12]
20006552:	f64f 73ff 	movw	r3, #65535	; 0xffff
20006556:	429a      	cmp	r2, r3
20006558:	d900      	bls.n	2000655c <config_baud_divisors+0xcc>
2000655a:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
2000655c:	68fa      	ldr	r2, [r7, #12]
2000655e:	f64f 73ff 	movw	r3, #65535	; 0xffff
20006562:	429a      	cmp	r2, r3
20006564:	d85b      	bhi.n	2000661e <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
20006566:	68fb      	ldr	r3, [r7, #12]
20006568:	2b01      	cmp	r3, #1
2000656a:	d931      	bls.n	200065d0 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
2000656c:	687b      	ldr	r3, [r7, #4]
2000656e:	681b      	ldr	r3, [r3, #0]
20006570:	f103 030c 	add.w	r3, r3, #12
20006574:	4618      	mov	r0, r3
20006576:	f04f 0107 	mov.w	r1, #7
2000657a:	f7ff fe51 	bl	20006220 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
2000657e:	687b      	ldr	r3, [r7, #4]
20006580:	681b      	ldr	r3, [r3, #0]
20006582:	68fa      	ldr	r2, [r7, #12]
20006584:	ea4f 2212 	mov.w	r2, r2, lsr #8
20006588:	b2d2      	uxtb	r2, r2
2000658a:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
2000658c:	687b      	ldr	r3, [r7, #4]
2000658e:	681b      	ldr	r3, [r3, #0]
20006590:	68fa      	ldr	r2, [r7, #12]
20006592:	b2d2      	uxtb	r2, r2
20006594:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20006596:	687b      	ldr	r3, [r7, #4]
20006598:	681b      	ldr	r3, [r3, #0]
2000659a:	f103 030c 	add.w	r3, r3, #12
2000659e:	4618      	mov	r0, r3
200065a0:	f04f 0107 	mov.w	r1, #7
200065a4:	f7ff fe5c 	bl	20006260 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
200065a8:	687b      	ldr	r3, [r7, #4]
200065aa:	681b      	ldr	r3, [r3, #0]
200065ac:	f103 0330 	add.w	r3, r3, #48	; 0x30
200065b0:	4618      	mov	r0, r3
200065b2:	f04f 0107 	mov.w	r1, #7
200065b6:	f7ff fe33 	bl	20006220 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
200065ba:	69bb      	ldr	r3, [r7, #24]
200065bc:	2bff      	cmp	r3, #255	; 0xff
200065be:	d900      	bls.n	200065c2 <config_baud_divisors+0x132>
200065c0:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
200065c2:	687b      	ldr	r3, [r7, #4]
200065c4:	681b      	ldr	r3, [r3, #0]
200065c6:	69ba      	ldr	r2, [r7, #24]
200065c8:	b2d2      	uxtb	r2, r2
200065ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
200065ce:	e026      	b.n	2000661e <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
200065d0:	687b      	ldr	r3, [r7, #4]
200065d2:	681b      	ldr	r3, [r3, #0]
200065d4:	f103 030c 	add.w	r3, r3, #12
200065d8:	4618      	mov	r0, r3
200065da:	f04f 0107 	mov.w	r1, #7
200065de:	f7ff fe1f 	bl	20006220 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
200065e2:	687b      	ldr	r3, [r7, #4]
200065e4:	681b      	ldr	r3, [r3, #0]
200065e6:	68fa      	ldr	r2, [r7, #12]
200065e8:	ea4f 2212 	mov.w	r2, r2, lsr #8
200065ec:	b2d2      	uxtb	r2, r2
200065ee:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
200065f0:	687b      	ldr	r3, [r7, #4]
200065f2:	681b      	ldr	r3, [r3, #0]
200065f4:	68fa      	ldr	r2, [r7, #12]
200065f6:	b2d2      	uxtb	r2, r2
200065f8:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
200065fa:	687b      	ldr	r3, [r7, #4]
200065fc:	681b      	ldr	r3, [r3, #0]
200065fe:	f103 030c 	add.w	r3, r3, #12
20006602:	4618      	mov	r0, r3
20006604:	f04f 0107 	mov.w	r1, #7
20006608:	f7ff fe2a 	bl	20006260 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
2000660c:	687b      	ldr	r3, [r7, #4]
2000660e:	681b      	ldr	r3, [r3, #0]
20006610:	f103 0330 	add.w	r3, r3, #48	; 0x30
20006614:	4618      	mov	r0, r3
20006616:	f04f 0107 	mov.w	r1, #7
2000661a:	f7ff fe21 	bl	20006260 <clear_bit_reg8>
            }
        }
    }
}
2000661e:	f107 0720 	add.w	r7, r7, #32
20006622:	46bd      	mov	sp, r7
20006624:	bd80      	pop	{r7, pc}
20006626:	bf00      	nop

20006628 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
20006628:	b580      	push	{r7, lr}
2000662a:	b084      	sub	sp, #16
2000662c:	af00      	add	r7, sp, #0
2000662e:	60f8      	str	r0, [r7, #12]
20006630:	60b9      	str	r1, [r7, #8]
20006632:	4613      	mov	r3, r2
20006634:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20006636:	68fa      	ldr	r2, [r7, #12]
20006638:	f24d 4340 	movw	r3, #54336	; 0xd440
2000663c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006640:	429a      	cmp	r2, r3
20006642:	d007      	beq.n	20006654 <global_init+0x2c>
20006644:	68fa      	ldr	r2, [r7, #12]
20006646:	f24d 4300 	movw	r3, #54272	; 0xd400
2000664a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000664e:	429a      	cmp	r2, r3
20006650:	d000      	beq.n	20006654 <global_init+0x2c>
20006652:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
20006654:	68fa      	ldr	r2, [r7, #12]
20006656:	f24d 4340 	movw	r3, #54336	; 0xd440
2000665a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000665e:	429a      	cmp	r2, r3
20006660:	d124      	bne.n	200066ac <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
20006662:	68fb      	ldr	r3, [r7, #12]
20006664:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
20006668:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
2000666a:	68fb      	ldr	r3, [r7, #12]
2000666c:	f04f 020a 	mov.w	r2, #10
20006670:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
20006672:	f248 0300 	movw	r3, #32768	; 0x8000
20006676:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000667a:	f248 0200 	movw	r2, #32768	; 0x8000
2000667e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20006682:	6c92      	ldr	r2, [r2, #72]	; 0x48
20006684:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20006688:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
2000668a:	f04f 000a 	mov.w	r0, #10
2000668e:	f7ff fda9 	bl	200061e4 <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
20006692:	f248 0300 	movw	r3, #32768	; 0x8000
20006696:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000669a:	f248 0200 	movw	r2, #32768	; 0x8000
2000669e:	f2c4 0203 	movt	r2, #16387	; 0x4003
200066a2:	6c92      	ldr	r2, [r2, #72]	; 0x48
200066a4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
200066a8:	649a      	str	r2, [r3, #72]	; 0x48
200066aa:	e025      	b.n	200066f8 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
200066ac:	68fa      	ldr	r2, [r7, #12]
200066ae:	f240 0300 	movw	r3, #0
200066b2:	f2c4 0301 	movt	r3, #16385	; 0x4001
200066b6:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
200066b8:	68fb      	ldr	r3, [r7, #12]
200066ba:	f04f 020b 	mov.w	r2, #11
200066be:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
200066c0:	f248 0300 	movw	r3, #32768	; 0x8000
200066c4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200066c8:	f248 0200 	movw	r2, #32768	; 0x8000
200066cc:	f2c4 0203 	movt	r2, #16387	; 0x4003
200066d0:	6c92      	ldr	r2, [r2, #72]	; 0x48
200066d2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200066d6:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
200066d8:	f04f 000b 	mov.w	r0, #11
200066dc:	f7ff fd82 	bl	200061e4 <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
200066e0:	f248 0300 	movw	r3, #32768	; 0x8000
200066e4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200066e8:	f248 0200 	movw	r2, #32768	; 0x8000
200066ec:	f2c4 0203 	movt	r2, #16387	; 0x4003
200066f0:	6c92      	ldr	r2, [r2, #72]	; 0x48
200066f2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
200066f6:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
200066f8:	68fb      	ldr	r3, [r7, #12]
200066fa:	681b      	ldr	r3, [r3, #0]
200066fc:	f04f 0200 	mov.w	r2, #0
20006700:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
20006702:	68fb      	ldr	r3, [r7, #12]
20006704:	681b      	ldr	r3, [r3, #0]
20006706:	f04f 0200 	mov.w	r2, #0
2000670a:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
2000670c:	68fb      	ldr	r3, [r7, #12]
2000670e:	681b      	ldr	r3, [r3, #0]
20006710:	f103 0308 	add.w	r3, r3, #8
20006714:	4618      	mov	r0, r3
20006716:	f04f 0101 	mov.w	r1, #1
2000671a:	f7ff fd81 	bl	20006220 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
2000671e:	68fb      	ldr	r3, [r7, #12]
20006720:	681b      	ldr	r3, [r3, #0]
20006722:	f103 0308 	add.w	r3, r3, #8
20006726:	4618      	mov	r0, r3
20006728:	f04f 0102 	mov.w	r1, #2
2000672c:	f7ff fd78 	bl	20006220 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
20006730:	68fb      	ldr	r3, [r7, #12]
20006732:	681b      	ldr	r3, [r3, #0]
20006734:	f103 0308 	add.w	r3, r3, #8
20006738:	4618      	mov	r0, r3
2000673a:	f04f 0100 	mov.w	r1, #0
2000673e:	f7ff fd6f 	bl	20006220 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
20006742:	68fb      	ldr	r3, [r7, #12]
20006744:	681b      	ldr	r3, [r3, #0]
20006746:	f103 0310 	add.w	r3, r3, #16
2000674a:	4618      	mov	r0, r3
2000674c:	f04f 0104 	mov.w	r1, #4
20006750:	f7ff fd86 	bl	20006260 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
20006754:	68fb      	ldr	r3, [r7, #12]
20006756:	681b      	ldr	r3, [r3, #0]
20006758:	f103 0310 	add.w	r3, r3, #16
2000675c:	4618      	mov	r0, r3
2000675e:	f04f 0105 	mov.w	r1, #5
20006762:	f7ff fd7d 	bl	20006260 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
20006766:	68fb      	ldr	r3, [r7, #12]
20006768:	681b      	ldr	r3, [r3, #0]
2000676a:	f103 0334 	add.w	r3, r3, #52	; 0x34
2000676e:	4618      	mov	r0, r3
20006770:	f04f 0101 	mov.w	r1, #1
20006774:	f7ff fd74 	bl	20006260 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
20006778:	68fb      	ldr	r3, [r7, #12]
2000677a:	681b      	ldr	r3, [r3, #0]
2000677c:	f103 0334 	add.w	r3, r3, #52	; 0x34
20006780:	4618      	mov	r0, r3
20006782:	f04f 0100 	mov.w	r1, #0
20006786:	f7ff fd6b 	bl	20006260 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
2000678a:	68fb      	ldr	r3, [r7, #12]
2000678c:	681b      	ldr	r3, [r3, #0]
2000678e:	f103 0338 	add.w	r3, r3, #56	; 0x38
20006792:	4618      	mov	r0, r3
20006794:	f04f 0101 	mov.w	r1, #1
20006798:	f7ff fd62 	bl	20006260 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
2000679c:	68fb      	ldr	r3, [r7, #12]
2000679e:	681b      	ldr	r3, [r3, #0]
200067a0:	f103 0330 	add.w	r3, r3, #48	; 0x30
200067a4:	4618      	mov	r0, r3
200067a6:	f04f 0105 	mov.w	r1, #5
200067aa:	f7ff fd59 	bl	20006260 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
200067ae:	68fb      	ldr	r3, [r7, #12]
200067b0:	681b      	ldr	r3, [r3, #0]
200067b2:	f103 0330 	add.w	r3, r3, #48	; 0x30
200067b6:	4618      	mov	r0, r3
200067b8:	f04f 0106 	mov.w	r1, #6
200067bc:	f7ff fd50 	bl	20006260 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
200067c0:	68fb      	ldr	r3, [r7, #12]
200067c2:	681b      	ldr	r3, [r3, #0]
200067c4:	f103 0330 	add.w	r3, r3, #48	; 0x30
200067c8:	4618      	mov	r0, r3
200067ca:	f04f 0107 	mov.w	r1, #7
200067ce:	f7ff fd47 	bl	20006260 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
200067d2:	68fb      	ldr	r3, [r7, #12]
200067d4:	681b      	ldr	r3, [r3, #0]
200067d6:	f103 0338 	add.w	r3, r3, #56	; 0x38
200067da:	4618      	mov	r0, r3
200067dc:	f04f 0103 	mov.w	r1, #3
200067e0:	f7ff fd3e 	bl	20006260 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
200067e4:	68fb      	ldr	r3, [r7, #12]
200067e6:	681b      	ldr	r3, [r3, #0]
200067e8:	f04f 0200 	mov.w	r2, #0
200067ec:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
200067f0:	68fb      	ldr	r3, [r7, #12]
200067f2:	681b      	ldr	r3, [r3, #0]
200067f4:	f04f 0200 	mov.w	r2, #0
200067f8:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
200067fc:	68fb      	ldr	r3, [r7, #12]
200067fe:	681b      	ldr	r3, [r3, #0]
20006800:	f04f 0200 	mov.w	r2, #0
20006804:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
20006808:	68f8      	ldr	r0, [r7, #12]
2000680a:	68b9      	ldr	r1, [r7, #8]
2000680c:	f7ff fe40 	bl	20006490 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
20006810:	68fb      	ldr	r3, [r7, #12]
20006812:	681b      	ldr	r3, [r3, #0]
20006814:	79fa      	ldrb	r2, [r7, #7]
20006816:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
20006818:	68fb      	ldr	r3, [r7, #12]
2000681a:	68ba      	ldr	r2, [r7, #8]
2000681c:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
2000681e:	68fb      	ldr	r3, [r7, #12]
20006820:	79fa      	ldrb	r2, [r7, #7]
20006822:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
20006824:	68fb      	ldr	r3, [r7, #12]
20006826:	f04f 0200 	mov.w	r2, #0
2000682a:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
2000682c:	68fb      	ldr	r3, [r7, #12]
2000682e:	f04f 0200 	mov.w	r2, #0
20006832:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
20006834:	68fb      	ldr	r3, [r7, #12]
20006836:	f04f 0200 	mov.w	r2, #0
2000683a:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
2000683c:	68fb      	ldr	r3, [r7, #12]
2000683e:	f04f 0200 	mov.w	r2, #0
20006842:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
20006844:	68fb      	ldr	r3, [r7, #12]
20006846:	f04f 0200 	mov.w	r2, #0
2000684a:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
2000684c:	68fb      	ldr	r3, [r7, #12]
2000684e:	f04f 0200 	mov.w	r2, #0
20006852:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
20006854:	68fb      	ldr	r3, [r7, #12]
20006856:	f04f 0200 	mov.w	r2, #0
2000685a:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
2000685c:	68fb      	ldr	r3, [r7, #12]
2000685e:	f04f 0200 	mov.w	r2, #0
20006862:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
20006864:	68fb      	ldr	r3, [r7, #12]
20006866:	f04f 0200 	mov.w	r2, #0
2000686a:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
2000686c:	68fb      	ldr	r3, [r7, #12]
2000686e:	f04f 0200 	mov.w	r2, #0
20006872:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
20006874:	68fb      	ldr	r3, [r7, #12]
20006876:	f04f 0200 	mov.w	r2, #0
2000687a:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
2000687c:	68fb      	ldr	r3, [r7, #12]
2000687e:	f04f 0200 	mov.w	r2, #0
20006882:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
20006884:	68fb      	ldr	r3, [r7, #12]
20006886:	f04f 0200 	mov.w	r2, #0
2000688a:	735a      	strb	r2, [r3, #13]
}
2000688c:	f107 0710 	add.w	r7, r7, #16
20006890:	46bd      	mov	sp, r7
20006892:	bd80      	pop	{r7, pc}

20006894 <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
20006894:	b580      	push	{r7, lr}
20006896:	b084      	sub	sp, #16
20006898:	af00      	add	r7, sp, #0
2000689a:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
2000689c:	687a      	ldr	r2, [r7, #4]
2000689e:	f24d 4340 	movw	r3, #54336	; 0xd440
200068a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200068a6:	429a      	cmp	r2, r3
200068a8:	d007      	beq.n	200068ba <MSS_UART_isr+0x26>
200068aa:	687a      	ldr	r2, [r7, #4]
200068ac:	f24d 4300 	movw	r3, #54272	; 0xd400
200068b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200068b4:	429a      	cmp	r2, r3
200068b6:	d000      	beq.n	200068ba <MSS_UART_isr+0x26>
200068b8:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
200068ba:	687a      	ldr	r2, [r7, #4]
200068bc:	f24d 4340 	movw	r3, #54336	; 0xd440
200068c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200068c4:	429a      	cmp	r2, r3
200068c6:	d007      	beq.n	200068d8 <MSS_UART_isr+0x44>
200068c8:	687a      	ldr	r2, [r7, #4]
200068ca:	f24d 4300 	movw	r3, #54272	; 0xd400
200068ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200068d2:	429a      	cmp	r2, r3
200068d4:	f040 80ef 	bne.w	20006ab6 <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
200068d8:	687b      	ldr	r3, [r7, #4]
200068da:	681b      	ldr	r3, [r3, #0]
200068dc:	7a1b      	ldrb	r3, [r3, #8]
200068de:	b2db      	uxtb	r3, r3
200068e0:	f003 030f 	and.w	r3, r3, #15
200068e4:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
200068e6:	7bfb      	ldrb	r3, [r7, #15]
200068e8:	2b0c      	cmp	r3, #12
200068ea:	f200 80d7 	bhi.w	20006a9c <MSS_UART_isr+0x208>
200068ee:	a201      	add	r2, pc, #4	; (adr r2, 200068f4 <MSS_UART_isr+0x60>)
200068f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200068f4:	20006929 	.word	0x20006929
200068f8:	20006a9d 	.word	0x20006a9d
200068fc:	20006947 	.word	0x20006947
20006900:	200069a1 	.word	0x200069a1
20006904:	20006965 	.word	0x20006965
20006908:	20006a9d 	.word	0x20006a9d
2000690c:	20006983 	.word	0x20006983
20006910:	20006a9d 	.word	0x20006a9d
20006914:	20006a9d 	.word	0x20006a9d
20006918:	20006a9d 	.word	0x20006a9d
2000691c:	20006a9d 	.word	0x20006a9d
20006920:	20006a9d 	.word	0x20006a9d
20006924:	20006965 	.word	0x20006965
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
20006928:	687b      	ldr	r3, [r7, #4]
2000692a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000692c:	2b00      	cmp	r3, #0
2000692e:	d100      	bne.n	20006932 <MSS_UART_isr+0x9e>
20006930:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
20006932:	687b      	ldr	r3, [r7, #4]
20006934:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20006936:	2b00      	cmp	r3, #0
20006938:	f000 80b2 	beq.w	20006aa0 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
2000693c:	687b      	ldr	r3, [r7, #4]
2000693e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20006940:	6878      	ldr	r0, [r7, #4]
20006942:	4798      	blx	r3
                }
            }
            break;
20006944:	e0b7      	b.n	20006ab6 <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
20006946:	687b      	ldr	r3, [r7, #4]
20006948:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000694a:	2b00      	cmp	r3, #0
2000694c:	d100      	bne.n	20006950 <MSS_UART_isr+0xbc>
2000694e:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
20006950:	687b      	ldr	r3, [r7, #4]
20006952:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006954:	2b00      	cmp	r3, #0
20006956:	f000 80a5 	beq.w	20006aa4 <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
2000695a:	687b      	ldr	r3, [r7, #4]
2000695c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000695e:	6878      	ldr	r0, [r7, #4]
20006960:	4798      	blx	r3
                }
            }
            break;
20006962:	e0a8      	b.n	20006ab6 <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
20006964:	687b      	ldr	r3, [r7, #4]
20006966:	6a1b      	ldr	r3, [r3, #32]
20006968:	2b00      	cmp	r3, #0
2000696a:	d100      	bne.n	2000696e <MSS_UART_isr+0xda>
2000696c:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
2000696e:	687b      	ldr	r3, [r7, #4]
20006970:	6a1b      	ldr	r3, [r3, #32]
20006972:	2b00      	cmp	r3, #0
20006974:	f000 8098 	beq.w	20006aa8 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
20006978:	687b      	ldr	r3, [r7, #4]
2000697a:	6a1b      	ldr	r3, [r3, #32]
2000697c:	6878      	ldr	r0, [r7, #4]
2000697e:	4798      	blx	r3
                }
            }
            break;
20006980:	e099      	b.n	20006ab6 <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
20006982:	687b      	ldr	r3, [r7, #4]
20006984:	69db      	ldr	r3, [r3, #28]
20006986:	2b00      	cmp	r3, #0
20006988:	d100      	bne.n	2000698c <MSS_UART_isr+0xf8>
2000698a:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
2000698c:	687b      	ldr	r3, [r7, #4]
2000698e:	69db      	ldr	r3, [r3, #28]
20006990:	2b00      	cmp	r3, #0
20006992:	f000 808b 	beq.w	20006aac <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
20006996:	687b      	ldr	r3, [r7, #4]
20006998:	69db      	ldr	r3, [r3, #28]
2000699a:	6878      	ldr	r0, [r7, #4]
2000699c:	4798      	blx	r3
                }
            }
            break;
2000699e:	e08a      	b.n	20006ab6 <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
200069a0:	687b      	ldr	r3, [r7, #4]
200069a2:	681b      	ldr	r3, [r3, #0]
200069a4:	f103 0328 	add.w	r3, r3, #40	; 0x28
200069a8:	4618      	mov	r0, r3
200069aa:	f04f 0100 	mov.w	r1, #0
200069ae:	f7ff fc77 	bl	200062a0 <read_bit_reg8>
200069b2:	4603      	mov	r3, r0
200069b4:	2b00      	cmp	r3, #0
200069b6:	d00c      	beq.n	200069d2 <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
200069b8:	687b      	ldr	r3, [r7, #4]
200069ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200069bc:	2b00      	cmp	r3, #0
200069be:	d100      	bne.n	200069c2 <MSS_UART_isr+0x12e>
200069c0:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
200069c2:	687b      	ldr	r3, [r7, #4]
200069c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200069c6:	2b00      	cmp	r3, #0
200069c8:	d003      	beq.n	200069d2 <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
200069ca:	687b      	ldr	r3, [r7, #4]
200069cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200069ce:	6878      	ldr	r0, [r7, #4]
200069d0:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
200069d2:	687b      	ldr	r3, [r7, #4]
200069d4:	681b      	ldr	r3, [r3, #0]
200069d6:	f103 0328 	add.w	r3, r3, #40	; 0x28
200069da:	4618      	mov	r0, r3
200069dc:	f04f 0101 	mov.w	r1, #1
200069e0:	f7ff fc5e 	bl	200062a0 <read_bit_reg8>
200069e4:	4603      	mov	r3, r0
200069e6:	2b00      	cmp	r3, #0
200069e8:	d00c      	beq.n	20006a04 <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
200069ea:	687b      	ldr	r3, [r7, #4]
200069ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200069ee:	2b00      	cmp	r3, #0
200069f0:	d100      	bne.n	200069f4 <MSS_UART_isr+0x160>
200069f2:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
200069f4:	687b      	ldr	r3, [r7, #4]
200069f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200069f8:	2b00      	cmp	r3, #0
200069fa:	d003      	beq.n	20006a04 <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
200069fc:	687b      	ldr	r3, [r7, #4]
200069fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20006a00:	6878      	ldr	r0, [r7, #4]
20006a02:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
20006a04:	687b      	ldr	r3, [r7, #4]
20006a06:	681b      	ldr	r3, [r3, #0]
20006a08:	f103 0328 	add.w	r3, r3, #40	; 0x28
20006a0c:	4618      	mov	r0, r3
20006a0e:	f04f 0102 	mov.w	r1, #2
20006a12:	f7ff fc45 	bl	200062a0 <read_bit_reg8>
20006a16:	4603      	mov	r3, r0
20006a18:	2b00      	cmp	r3, #0
20006a1a:	d00c      	beq.n	20006a36 <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
20006a1c:	687b      	ldr	r3, [r7, #4]
20006a1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20006a20:	2b00      	cmp	r3, #0
20006a22:	d100      	bne.n	20006a26 <MSS_UART_isr+0x192>
20006a24:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
20006a26:	687b      	ldr	r3, [r7, #4]
20006a28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20006a2a:	2b00      	cmp	r3, #0
20006a2c:	d003      	beq.n	20006a36 <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
20006a2e:	687b      	ldr	r3, [r7, #4]
20006a30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20006a32:	6878      	ldr	r0, [r7, #4]
20006a34:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
20006a36:	687b      	ldr	r3, [r7, #4]
20006a38:	681b      	ldr	r3, [r3, #0]
20006a3a:	f103 0328 	add.w	r3, r3, #40	; 0x28
20006a3e:	4618      	mov	r0, r3
20006a40:	f04f 0103 	mov.w	r1, #3
20006a44:	f7ff fc2c 	bl	200062a0 <read_bit_reg8>
20006a48:	4603      	mov	r3, r0
20006a4a:	2b00      	cmp	r3, #0
20006a4c:	d00c      	beq.n	20006a68 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
20006a4e:	687b      	ldr	r3, [r7, #4]
20006a50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006a52:	2b00      	cmp	r3, #0
20006a54:	d100      	bne.n	20006a58 <MSS_UART_isr+0x1c4>
20006a56:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
20006a58:	687b      	ldr	r3, [r7, #4]
20006a5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006a5c:	2b00      	cmp	r3, #0
20006a5e:	d003      	beq.n	20006a68 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
20006a60:	687b      	ldr	r3, [r7, #4]
20006a62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006a64:	6878      	ldr	r0, [r7, #4]
20006a66:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
20006a68:	687b      	ldr	r3, [r7, #4]
20006a6a:	681b      	ldr	r3, [r3, #0]
20006a6c:	f103 0328 	add.w	r3, r3, #40	; 0x28
20006a70:	4618      	mov	r0, r3
20006a72:	f04f 0104 	mov.w	r1, #4
20006a76:	f7ff fc13 	bl	200062a0 <read_bit_reg8>
20006a7a:	4603      	mov	r3, r0
20006a7c:	2b00      	cmp	r3, #0
20006a7e:	d017      	beq.n	20006ab0 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
20006a80:	687b      	ldr	r3, [r7, #4]
20006a82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006a84:	2b00      	cmp	r3, #0
20006a86:	d100      	bne.n	20006a8a <MSS_UART_isr+0x1f6>
20006a88:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
20006a8a:	687b      	ldr	r3, [r7, #4]
20006a8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006a8e:	2b00      	cmp	r3, #0
20006a90:	d010      	beq.n	20006ab4 <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
20006a92:	687b      	ldr	r3, [r7, #4]
20006a94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006a96:	6878      	ldr	r0, [r7, #4]
20006a98:	4798      	blx	r3
                    }
                }
                break;
20006a9a:	e00c      	b.n	20006ab6 <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
20006a9c:	be00      	bkpt	0x0000
20006a9e:	e00a      	b.n	20006ab6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
20006aa0:	bf00      	nop
20006aa2:	e008      	b.n	20006ab6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
20006aa4:	bf00      	nop
20006aa6:	e006      	b.n	20006ab6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
20006aa8:	bf00      	nop
20006aaa:	e004      	b.n	20006ab6 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
20006aac:	bf00      	nop
20006aae:	e002      	b.n	20006ab6 <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
20006ab0:	bf00      	nop
20006ab2:	e000      	b.n	20006ab6 <MSS_UART_isr+0x222>
20006ab4:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
20006ab6:	f107 0710 	add.w	r7, r7, #16
20006aba:	46bd      	mov	sp, r7
20006abc:	bd80      	pop	{r7, pc}
20006abe:	bf00      	nop

20006ac0 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
20006ac0:	b580      	push	{r7, lr}
20006ac2:	b086      	sub	sp, #24
20006ac4:	af00      	add	r7, sp, #0
20006ac6:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20006ac8:	687a      	ldr	r2, [r7, #4]
20006aca:	f24d 4340 	movw	r3, #54336	; 0xd440
20006ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ad2:	429a      	cmp	r2, r3
20006ad4:	d007      	beq.n	20006ae6 <default_tx_handler+0x26>
20006ad6:	687a      	ldr	r2, [r7, #4]
20006ad8:	f24d 4300 	movw	r3, #54272	; 0xd400
20006adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ae0:	429a      	cmp	r2, r3
20006ae2:	d000      	beq.n	20006ae6 <default_tx_handler+0x26>
20006ae4:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
20006ae6:	687b      	ldr	r3, [r7, #4]
20006ae8:	691b      	ldr	r3, [r3, #16]
20006aea:	2b00      	cmp	r3, #0
20006aec:	d100      	bne.n	20006af0 <default_tx_handler+0x30>
20006aee:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
20006af0:	687b      	ldr	r3, [r7, #4]
20006af2:	695b      	ldr	r3, [r3, #20]
20006af4:	2b00      	cmp	r3, #0
20006af6:	d100      	bne.n	20006afa <default_tx_handler+0x3a>
20006af8:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20006afa:	687a      	ldr	r2, [r7, #4]
20006afc:	f24d 4340 	movw	r3, #54336	; 0xd440
20006b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006b04:	429a      	cmp	r2, r3
20006b06:	d006      	beq.n	20006b16 <default_tx_handler+0x56>
20006b08:	687a      	ldr	r2, [r7, #4]
20006b0a:	f24d 4300 	movw	r3, #54272	; 0xd400
20006b0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006b12:	429a      	cmp	r2, r3
20006b14:	d155      	bne.n	20006bc2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
20006b16:	687b      	ldr	r3, [r7, #4]
20006b18:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20006b1a:	2b00      	cmp	r3, #0
20006b1c:	d051      	beq.n	20006bc2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
20006b1e:	687b      	ldr	r3, [r7, #4]
20006b20:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20006b22:	2b00      	cmp	r3, #0
20006b24:	d04d      	beq.n	20006bc2 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
20006b26:	687b      	ldr	r3, [r7, #4]
20006b28:	681b      	ldr	r3, [r3, #0]
20006b2a:	7d1b      	ldrb	r3, [r3, #20]
20006b2c:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
20006b2e:	687b      	ldr	r3, [r7, #4]
20006b30:	7b5a      	ldrb	r2, [r3, #13]
20006b32:	7afb      	ldrb	r3, [r7, #11]
20006b34:	ea42 0303 	orr.w	r3, r2, r3
20006b38:	b2da      	uxtb	r2, r3
20006b3a:	687b      	ldr	r3, [r7, #4]
20006b3c:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
20006b3e:	7afb      	ldrb	r3, [r7, #11]
20006b40:	f003 0320 	and.w	r3, r3, #32
20006b44:	2b00      	cmp	r3, #0
20006b46:	d029      	beq.n	20006b9c <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
20006b48:	f04f 0310 	mov.w	r3, #16
20006b4c:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
20006b4e:	687b      	ldr	r3, [r7, #4]
20006b50:	695a      	ldr	r2, [r3, #20]
20006b52:	687b      	ldr	r3, [r7, #4]
20006b54:	699b      	ldr	r3, [r3, #24]
20006b56:	ebc3 0302 	rsb	r3, r3, r2
20006b5a:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
20006b5c:	697b      	ldr	r3, [r7, #20]
20006b5e:	2b0f      	cmp	r3, #15
20006b60:	d801      	bhi.n	20006b66 <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
20006b62:	697b      	ldr	r3, [r7, #20]
20006b64:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
20006b66:	f04f 0300 	mov.w	r3, #0
20006b6a:	60fb      	str	r3, [r7, #12]
20006b6c:	e012      	b.n	20006b94 <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
20006b6e:	687b      	ldr	r3, [r7, #4]
20006b70:	681b      	ldr	r3, [r3, #0]
20006b72:	687a      	ldr	r2, [r7, #4]
20006b74:	6911      	ldr	r1, [r2, #16]
20006b76:	687a      	ldr	r2, [r7, #4]
20006b78:	6992      	ldr	r2, [r2, #24]
20006b7a:	440a      	add	r2, r1
20006b7c:	7812      	ldrb	r2, [r2, #0]
20006b7e:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
20006b80:	687b      	ldr	r3, [r7, #4]
20006b82:	699b      	ldr	r3, [r3, #24]
20006b84:	f103 0201 	add.w	r2, r3, #1
20006b88:	687b      	ldr	r3, [r7, #4]
20006b8a:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
20006b8c:	68fb      	ldr	r3, [r7, #12]
20006b8e:	f103 0301 	add.w	r3, r3, #1
20006b92:	60fb      	str	r3, [r7, #12]
20006b94:	68fa      	ldr	r2, [r7, #12]
20006b96:	693b      	ldr	r3, [r7, #16]
20006b98:	429a      	cmp	r2, r3
20006b9a:	d3e8      	bcc.n	20006b6e <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
20006b9c:	687b      	ldr	r3, [r7, #4]
20006b9e:	699a      	ldr	r2, [r3, #24]
20006ba0:	687b      	ldr	r3, [r7, #4]
20006ba2:	695b      	ldr	r3, [r3, #20]
20006ba4:	429a      	cmp	r2, r3
20006ba6:	d10c      	bne.n	20006bc2 <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
20006ba8:	687b      	ldr	r3, [r7, #4]
20006baa:	f04f 0200 	mov.w	r2, #0
20006bae:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
20006bb0:	687b      	ldr	r3, [r7, #4]
20006bb2:	681b      	ldr	r3, [r3, #0]
20006bb4:	f103 0304 	add.w	r3, r3, #4
20006bb8:	4618      	mov	r0, r3
20006bba:	f04f 0101 	mov.w	r1, #1
20006bbe:	f7ff fb4f 	bl	20006260 <clear_bit_reg8>
        }
    }
}
20006bc2:	f107 0718 	add.w	r7, r7, #24
20006bc6:	46bd      	mov	sp, r7
20006bc8:	bd80      	pop	{r7, pc}
20006bca:	bf00      	nop

20006bcc <MSS_SYS_init>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
20006bcc:	b580      	push	{r7, lr}
20006bce:	b082      	sub	sp, #8
20006bd0:	af00      	add	r7, sp, #0
20006bd2:	6078      	str	r0, [r7, #4]
    g_event_handler = event_handler;
20006bd4:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006bdc:	687a      	ldr	r2, [r7, #4]
20006bde:	601a      	str	r2, [r3, #0]
    g_last_response_length = 0u;
20006be0:	f24c 23f4 	movw	r3, #49908	; 0xc2f4
20006be4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006be8:	f04f 0200 	mov.w	r2, #0
20006bec:	801a      	strh	r2, [r3, #0]
    g_request_in_progress = 0u;
20006bee:	f24c 23f3 	movw	r3, #49907	; 0xc2f3
20006bf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006bf6:	f04f 0200 	mov.w	r2, #0
20006bfa:	701a      	strb	r2, [r3, #0]
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
20006bfc:	f248 0300 	movw	r3, #32768	; 0x8000
20006c00:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006c04:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
20006c08:	f24c 3300 	movw	r3, #49920	; 0xc300
20006c0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006c10:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize the COMBLK used to communicate with the System Controller.
     */
    MSS_COMBLK_init(asynchronous_event_handler, g_response);
20006c12:	f646 4031 	movw	r0, #27697	; 0x6c31
20006c16:	f2c2 0000 	movt	r0, #8192	; 0x2000
20006c1a:	f24c 21fc 	movw	r1, #49916	; 0xc2fc
20006c1e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20006c22:	f004 fb39 	bl	2000b298 <MSS_COMBLK_init>
}
20006c26:	f107 0708 	add.w	r7, r7, #8
20006c2a:	46bd      	mov	sp, r7
20006c2c:	bd80      	pop	{r7, pc}
20006c2e:	bf00      	nop

20006c30 <asynchronous_event_handler>:
#define TAMPER_HARDWARE_MONITOR_ERROR_OPCODE_RANGE_MAX   0xB7u

#define FACC_GLMUX_SEL_MASK         0x00001000u
#define DELAY_MORE_THAN_10US        5000U
static void asynchronous_event_handler(uint8_t event_opcode)
{
20006c30:	b580      	push	{r7, lr}
20006c32:	b086      	sub	sp, #24
20006c34:	af00      	add	r7, sp, #0
20006c36:	4603      	mov	r3, r0
20006c38:	71fb      	strb	r3, [r7, #7]
    if (event_opcode == FLASH_FREEZE_SHUTDOWN_OPCODE)
20006c3a:	79fb      	ldrb	r3, [r7, #7]
20006c3c:	2be0      	cmp	r3, #224	; 0xe0
20006c3e:	d12b      	bne.n	20006c98 <asynchronous_event_handler+0x68>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the main clock to the  standby clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
20006c40:	f241 3388 	movw	r3, #5000	; 0x1388
20006c44:	60fb      	str	r3, [r7, #12]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20006c46:	f248 0300 	movw	r3, #32768	; 0x8000
20006c4a:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006c4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006c52:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20006c56:	613b      	str	r3, [r7, #16]
            --timeout;
20006c58:	68fb      	ldr	r3, [r7, #12]
20006c5a:	f103 33ff 	add.w	r3, r3, #4294967295
20006c5e:	60fb      	str	r3, [r7, #12]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
20006c60:	693b      	ldr	r3, [r7, #16]
20006c62:	2b00      	cmp	r3, #0
20006c64:	d102      	bne.n	20006c6c <asynchronous_event_handler+0x3c>
20006c66:	68fb      	ldr	r3, [r7, #12]
20006c68:	2b00      	cmp	r3, #0
20006c6a:	d1ec      	bne.n	20006c46 <asynchronous_event_handler+0x16>

        /* Call the user's event handler. */
        if(g_event_handler != 0)
20006c6c:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006c70:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006c74:	681b      	ldr	r3, [r3, #0]
20006c76:	2b00      	cmp	r3, #0
20006c78:	d068      	beq.n	20006d4c <asynchronous_event_handler+0x11c>
        {
            g_event_handler(event_opcode, g_response[1]);
20006c7a:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006c82:	681a      	ldr	r2, [r3, #0]
20006c84:	f24c 23fc 	movw	r3, #49916	; 0xc2fc
20006c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006c8c:	785b      	ldrb	r3, [r3, #1]
20006c8e:	79f9      	ldrb	r1, [r7, #7]
20006c90:	4608      	mov	r0, r1
20006c92:	4619      	mov	r1, r3
20006c94:	4790      	blx	r2
20006c96:	e05c      	b.n	20006d52 <asynchronous_event_handler+0x122>
        }
    }
    else if (event_opcode == FLASH_FREEZE_EXIT_OPCODE)
20006c98:	79fb      	ldrb	r3, [r7, #7]
20006c9a:	2be1      	cmp	r3, #225	; 0xe1
20006c9c:	d12d      	bne.n	20006cfa <asynchronous_event_handler+0xca>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the standby clock to the main clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
20006c9e:	f241 3388 	movw	r3, #5000	; 0x1388
20006ca2:	60bb      	str	r3, [r7, #8]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20006ca4:	f248 0300 	movw	r3, #32768	; 0x8000
20006ca8:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006cac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006cb0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20006cb4:	617b      	str	r3, [r7, #20]
            --timeout;
20006cb6:	68bb      	ldr	r3, [r7, #8]
20006cb8:	f103 33ff 	add.w	r3, r3, #4294967295
20006cbc:	60bb      	str	r3, [r7, #8]
        }
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
20006cbe:	697b      	ldr	r3, [r7, #20]
20006cc0:	2b00      	cmp	r3, #0
20006cc2:	d002      	beq.n	20006cca <asynchronous_event_handler+0x9a>
20006cc4:	68bb      	ldr	r3, [r7, #8]
20006cc6:	2b00      	cmp	r3, #0
20006cc8:	d1ec      	bne.n	20006ca4 <asynchronous_event_handler+0x74>
        
        /* Restore the clock dividers values of FACC1 register. */
        revert_clk_config();
20006cca:	f000 fa7b 	bl	200071c4 <revert_clk_config>
        
        if(g_event_handler != 0)
20006cce:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006cd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006cd6:	681b      	ldr	r3, [r3, #0]
20006cd8:	2b00      	cmp	r3, #0
20006cda:	d039      	beq.n	20006d50 <asynchronous_event_handler+0x120>
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
20006cdc:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ce4:	681a      	ldr	r2, [r3, #0]
20006ce6:	f24c 23fc 	movw	r3, #49916	; 0xc2fc
20006cea:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006cee:	785b      	ldrb	r3, [r3, #1]
20006cf0:	79f9      	ldrb	r1, [r7, #7]
20006cf2:	4608      	mov	r0, r1
20006cf4:	4619      	mov	r1, r3
20006cf6:	4790      	blx	r2
20006cf8:	e02b      	b.n	20006d52 <asynchronous_event_handler+0x122>
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
20006cfa:	79fb      	ldrb	r3, [r7, #7]
20006cfc:	2bf1      	cmp	r3, #241	; 0xf1
20006cfe:	d00f      	beq.n	20006d20 <asynchronous_event_handler+0xf0>
            ((event_opcode >= TAMPER_ATTEMPT_DETECT_OPCODE_RANGE_MIN) && \
20006d00:	79fb      	ldrb	r3, [r7, #7]
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
20006d02:	b25b      	sxtb	r3, r3
20006d04:	2b00      	cmp	r3, #0
20006d06:	da02      	bge.n	20006d0e <asynchronous_event_handler+0xde>
20006d08:	79fb      	ldrb	r3, [r7, #7]
20006d0a:	2b9f      	cmp	r3, #159	; 0x9f
20006d0c:	d908      	bls.n	20006d20 <asynchronous_event_handler+0xf0>
20006d0e:	79fb      	ldrb	r3, [r7, #7]
20006d10:	2ba0      	cmp	r3, #160	; 0xa0
20006d12:	d005      	beq.n	20006d20 <asynchronous_event_handler+0xf0>
20006d14:	79fb      	ldrb	r3, [r7, #7]
20006d16:	2bb0      	cmp	r3, #176	; 0xb0
20006d18:	d91b      	bls.n	20006d52 <asynchronous_event_handler+0x122>
20006d1a:	79fb      	ldrb	r3, [r7, #7]
20006d1c:	2bb7      	cmp	r3, #183	; 0xb7
20006d1e:	d818      	bhi.n	20006d52 <asynchronous_event_handler+0x122>
            /* 
             * Inform to the application that new asynchronous message is received, 
             * only if application call-back function is registered during 
             * initialization. 
             */
            if(g_event_handler != 0)
20006d20:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006d28:	681b      	ldr	r3, [r3, #0]
20006d2a:	2b00      	cmp	r3, #0
20006d2c:	d011      	beq.n	20006d52 <asynchronous_event_handler+0x122>
            {
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
20006d2e:	f24c 23f8 	movw	r3, #49912	; 0xc2f8
20006d32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006d36:	681a      	ldr	r2, [r3, #0]
20006d38:	f24c 23fc 	movw	r3, #49916	; 0xc2fc
20006d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006d40:	785b      	ldrb	r3, [r3, #1]
20006d42:	79f9      	ldrb	r1, [r7, #7]
20006d44:	4608      	mov	r0, r1
20006d46:	4619      	mov	r1, r3
20006d48:	4790      	blx	r2
20006d4a:	e002      	b.n	20006d52 <asynchronous_event_handler+0x122>
        while ((running_on_standby_clock == 0U) && (timeout != 0U));

        /* Call the user's event handler. */
        if(g_event_handler != 0)
        {
            g_event_handler(event_opcode, g_response[1]);
20006d4c:	bf00      	nop
20006d4e:	e000      	b.n	20006d52 <asynchronous_event_handler+0x122>
        revert_clk_config();
        
        if(g_event_handler != 0)
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
20006d50:	bf00      	nop
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
            }
        }
    }
}
20006d52:	f107 0718 	add.w	r7, r7, #24
20006d56:	46bd      	mov	sp, r7
20006d58:	bd80      	pop	{r7, pc}
20006d5a:	bf00      	nop

20006d5c <determine_seq>:
 */
uint32_t divisor[4] = {0x00};
volatile uint8_t ind = 0;

static uint8_t* determine_seq(uint8_t val, uint8_t* len)
{
20006d5c:	b480      	push	{r7}
20006d5e:	b085      	sub	sp, #20
20006d60:	af00      	add	r7, sp, #0
20006d62:	4603      	mov	r3, r0
20006d64:	6039      	str	r1, [r7, #0]
20006d66:	71fb      	strb	r3, [r7, #7]
    uint8_t*seq;
    
    switch(val)
20006d68:	79fb      	ldrb	r3, [r7, #7]
20006d6a:	2b06      	cmp	r3, #6
20006d6c:	d84c      	bhi.n	20006e08 <determine_seq+0xac>
20006d6e:	a201      	add	r2, pc, #4	; (adr r2, 20006d74 <determine_seq+0x18>)
20006d70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20006d74:	20006d91 	.word	0x20006d91
20006d78:	20006da5 	.word	0x20006da5
20006d7c:	20006db9 	.word	0x20006db9
20006d80:	20006e09 	.word	0x20006e09
20006d84:	20006dcd 	.word	0x20006dcd
20006d88:	20006de1 	.word	0x20006de1
20006d8c:	20006df5 	.word	0x20006df5
    {
        case 0:
                seq = &div1_seq[0];
20006d90:	f24c 2394 	movw	r3, #49812	; 0xc294
20006d94:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006d98:	60fb      	str	r3, [r7, #12]
                *len = 4;
20006d9a:	683b      	ldr	r3, [r7, #0]
20006d9c:	f04f 0204 	mov.w	r2, #4
20006da0:	701a      	strb	r2, [r3, #0]
            break;
20006da2:	e038      	b.n	20006e16 <determine_seq+0xba>

        case 1:
                seq = &div2_seq[0];
20006da4:	f24c 2398 	movw	r3, #49816	; 0xc298
20006da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006dac:	60fb      	str	r3, [r7, #12]
                *len = 3;
20006dae:	683b      	ldr	r3, [r7, #0]
20006db0:	f04f 0203 	mov.w	r2, #3
20006db4:	701a      	strb	r2, [r3, #0]
            break;
20006db6:	e02e      	b.n	20006e16 <determine_seq+0xba>

        case 2:
                seq = &div4_seq[0];
20006db8:	f24c 239c 	movw	r3, #49820	; 0xc29c
20006dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006dc0:	60fb      	str	r3, [r7, #12]
                *len = 5;
20006dc2:	683b      	ldr	r3, [r7, #0]
20006dc4:	f04f 0205 	mov.w	r2, #5
20006dc8:	701a      	strb	r2, [r3, #0]
            break;
20006dca:	e024      	b.n	20006e16 <determine_seq+0xba>

        case 4:
                seq = &div8_seq[0];
20006dcc:	f24c 23a4 	movw	r3, #49828	; 0xc2a4
20006dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006dd4:	60fb      	str	r3, [r7, #12]
                *len = 3;
20006dd6:	683b      	ldr	r3, [r7, #0]
20006dd8:	f04f 0203 	mov.w	r2, #3
20006ddc:	701a      	strb	r2, [r3, #0]
            break;
20006dde:	e01a      	b.n	20006e16 <determine_seq+0xba>

        case 5:
                seq = &div16_seq[0];
20006de0:	f24c 23a8 	movw	r3, #49832	; 0xc2a8
20006de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006de8:	60fb      	str	r3, [r7, #12]
                *len = 2;
20006dea:	683b      	ldr	r3, [r7, #0]
20006dec:	f04f 0202 	mov.w	r2, #2
20006df0:	701a      	strb	r2, [r3, #0]
            break;
20006df2:	e010      	b.n	20006e16 <determine_seq+0xba>

        case 6:
                seq = &div32_seq[0];
20006df4:	f24c 23ac 	movw	r3, #49836	; 0xc2ac
20006df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006dfc:	60fb      	str	r3, [r7, #12]
                *len = 2;
20006dfe:	683b      	ldr	r3, [r7, #0]
20006e00:	f04f 0202 	mov.w	r2, #2
20006e04:	701a      	strb	r2, [r3, #0]
            break;
20006e06:	e006      	b.n	20006e16 <determine_seq+0xba>

        default:
                *len = 0;
20006e08:	683b      	ldr	r3, [r7, #0]
20006e0a:	f04f 0200 	mov.w	r2, #0
20006e0e:	701a      	strb	r2, [r3, #0]
                seq = NULL;
20006e10:	f04f 0300 	mov.w	r3, #0
20006e14:	60fb      	str	r3, [r7, #12]
            break;
    }
    
    return seq;
20006e16:	68fb      	ldr	r3, [r7, #12]
}
20006e18:	4618      	mov	r0, r3
20006e1a:	f107 0714 	add.w	r7, r7, #20
20006e1e:	46bd      	mov	sp, r7
20006e20:	bc80      	pop	{r7}
20006e22:	4770      	bx	lr

20006e24 <clk_switching_fix>:
 * divisor values of fclk, pclk0, pclk1 and clk_fic64, and if the divisor 
 * values are equal to each other, then firmware will send requested command to 
 * system controller otherwise return CLOCK_SWITCHING_ERROR error.
 */
static uint8_t clk_switching_fix(void)
{
20006e24:	b580      	push	{r7, lr}
20006e26:	b088      	sub	sp, #32
20006e28:	af00      	add	r7, sp, #0
    uint8_t* sequence;
    uint8_t len;
    volatile uint32_t g_mssddr_facc1_cr =  SYSREG->MSSDDR_FACC1_CR;
20006e2a:	f248 0300 	movw	r3, #32768	; 0x8000
20006e2e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006e32:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006e36:	607b      	str	r3, [r7, #4]
    uint32_t var = 0;
20006e38:	f04f 0300 	mov.w	r3, #0
20006e3c:	613b      	str	r3, [r7, #16]
    uint32_t temp = 0;
20006e3e:	f04f 0300 	mov.w	r3, #0
20006e42:	617b      	str	r3, [r7, #20]
    uint32_t device_version;
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
20006e44:	f04f 0300 	mov.w	r3, #0
20006e48:	77fb      	strb	r3, [r7, #31]
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
20006e4a:	f248 0300 	movw	r3, #32768	; 0x8000
20006e4e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006e52:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
20006e56:	ea4f 4303 	mov.w	r3, r3, lsl #16
20006e5a:	ea4f 4313 	mov.w	r3, r3, lsr #16
20006e5e:	61bb      	str	r3, [r7, #24]

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
20006e60:	69ba      	ldr	r2, [r7, #24]
20006e62:	f64f 0302 	movw	r3, #63490	; 0xf802
20006e66:	429a      	cmp	r2, r3
20006e68:	d013      	beq.n	20006e92 <clk_switching_fix+0x6e>
20006e6a:	69ba      	ldr	r2, [r7, #24]
20006e6c:	f64f 0303 	movw	r3, #63491	; 0xf803
20006e70:	429a      	cmp	r2, r3
20006e72:	d00e      	beq.n	20006e92 <clk_switching_fix+0x6e>
20006e74:	69ba      	ldr	r2, [r7, #24]
20006e76:	f64f 0304 	movw	r3, #63492	; 0xf804
20006e7a:	429a      	cmp	r2, r3
20006e7c:	d009      	beq.n	20006e92 <clk_switching_fix+0x6e>
20006e7e:	69ba      	ldr	r2, [r7, #24]
20006e80:	f64f 0307 	movw	r3, #63495	; 0xf807
20006e84:	429a      	cmp	r2, r3
20006e86:	d004      	beq.n	20006e92 <clk_switching_fix+0x6e>
20006e88:	69ba      	ldr	r2, [r7, #24]
20006e8a:	f64f 0306 	movw	r3, #63494	; 0xf806
20006e8e:	429a      	cmp	r2, r3
20006e90:	d11b      	bne.n	20006eca <clk_switching_fix+0xa6>
    {
        /* Dynamically divides down fclk, pclk0, pclk1 and clk_fic64
         * to the divided by 32 versions and M3_CLK, PCLK0, PCLK1, 
         * CLK_FIC64 all driven from CLK_STANDBY clock.
         */
        SYSREG->MSSDDR_FACC1_CR = (SYSREG->MSSDDR_FACC1_CR & CONFIG_CLOCK_DIV_MASK) | \
20006e92:	f248 0100 	movw	r1, #32768	; 0x8000
20006e96:	f2c4 0103 	movt	r1, #16387	; 0x4003
20006e9a:	f248 0300 	movw	r3, #32768	; 0x8000
20006e9e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006ea2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006ea6:	f24e 1203 	movw	r2, #57603	; 0xe103
20006eaa:	f6cf 72c7 	movt	r2, #65479	; 0xffc7
20006eae:	ea03 0202 	and.w	r2, r3, r2
20006eb2:	f641 43d8 	movw	r3, #7384	; 0x1cd8
20006eb6:	f2c0 0330 	movt	r3, #48	; 0x30
20006eba:	ea42 0303 	orr.w	r3, r2, r3
20006ebe:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
                                   CONFIG_CLOCK_DIV_32_RATIO;
        status = CLOCK_SWITCHING_SUCCESS;
20006ec2:	f04f 0300 	mov.w	r3, #0
20006ec6:	77fb      	strb	r3, [r7, #31]
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
20006ec8:	e175      	b.n	200071b6 <clk_switching_fix+0x392>
    
    /* For 05 devices
     * When modifying clock divisor settings on M2S005, it is necessary to 
     * sequence them, depending on the starting configuration.
     */
    else if(0xF805u == device_version)
20006eca:	69ba      	ldr	r2, [r7, #24]
20006ecc:	f64f 0305 	movw	r3, #63493	; 0xf805
20006ed0:	429a      	cmp	r2, r3
20006ed2:	f040 8116 	bne.w	20007102 <clk_switching_fix+0x2de>
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
20006ed6:	687b      	ldr	r3, [r7, #4]
20006ed8:	ea4f 0393 	mov.w	r3, r3, lsr #2
20006edc:	f003 0207 	and.w	r2, r3, #7
20006ee0:	f24c 3304 	movw	r3, #49924	; 0xc304
20006ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ee8:	601a      	str	r2, [r3, #0]
        sequence = determine_seq(divisor[0], &len);
20006eea:	f24c 3304 	movw	r3, #49924	; 0xc304
20006eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ef2:	681b      	ldr	r3, [r3, #0]
20006ef4:	b2da      	uxtb	r2, r3
20006ef6:	f107 030b 	add.w	r3, r7, #11
20006efa:	4610      	mov	r0, r2
20006efc:	4619      	mov	r1, r3
20006efe:	f7ff ff2d 	bl	20006d5c <determine_seq>
20006f02:	4603      	mov	r3, r0
20006f04:	60fb      	str	r3, [r7, #12]

        for(var = 1; var < len; var++)
20006f06:	f04f 0301 	mov.w	r3, #1
20006f0a:	613b      	str	r3, [r7, #16]
20006f0c:	e01f      	b.n	20006f4e <clk_switching_fix+0x12a>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20006f0e:	f248 0300 	movw	r3, #32768	; 0x8000
20006f12:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006f16:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006f1a:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFFFE3u;
20006f1c:	697b      	ldr	r3, [r7, #20]
20006f1e:	f023 031c 	bic.w	r3, r3, #28
20006f22:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 2);
20006f24:	68fa      	ldr	r2, [r7, #12]
20006f26:	693b      	ldr	r3, [r7, #16]
20006f28:	4413      	add	r3, r2
20006f2a:	781b      	ldrb	r3, [r3, #0]
20006f2c:	ea4f 0383 	mov.w	r3, r3, lsl #2
20006f30:	697a      	ldr	r2, [r7, #20]
20006f32:	ea42 0303 	orr.w	r3, r2, r3
20006f36:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
20006f38:	f248 0300 	movw	r3, #32768	; 0x8000
20006f3c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006f40:	697a      	ldr	r2, [r7, #20]
20006f42:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
20006f46:	693b      	ldr	r3, [r7, #16]
20006f48:	f103 0301 	add.w	r3, r3, #1
20006f4c:	613b      	str	r3, [r7, #16]
20006f4e:	7afb      	ldrb	r3, [r7, #11]
20006f50:	461a      	mov	r2, r3
20006f52:	693b      	ldr	r3, [r7, #16]
20006f54:	429a      	cmp	r2, r3
20006f56:	d8da      	bhi.n	20006f0e <clk_switching_fix+0xea>
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
20006f58:	687b      	ldr	r3, [r7, #4]
20006f5a:	ea4f 1353 	mov.w	r3, r3, lsr #5
20006f5e:	f003 0207 	and.w	r2, r3, #7
20006f62:	f24c 3304 	movw	r3, #49924	; 0xc304
20006f66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006f6a:	605a      	str	r2, [r3, #4]
        sequence = determine_seq(divisor[1], &len);
20006f6c:	f24c 3304 	movw	r3, #49924	; 0xc304
20006f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006f74:	685b      	ldr	r3, [r3, #4]
20006f76:	b2da      	uxtb	r2, r3
20006f78:	f107 030b 	add.w	r3, r7, #11
20006f7c:	4610      	mov	r0, r2
20006f7e:	4619      	mov	r1, r3
20006f80:	f7ff feec 	bl	20006d5c <determine_seq>
20006f84:	4603      	mov	r3, r0
20006f86:	60fb      	str	r3, [r7, #12]

        for(var = 1; var < len; var++)
20006f88:	f04f 0301 	mov.w	r3, #1
20006f8c:	613b      	str	r3, [r7, #16]
20006f8e:	e01f      	b.n	20006fd0 <clk_switching_fix+0x1ac>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20006f90:	f248 0300 	movw	r3, #32768	; 0x8000
20006f94:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006f98:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20006f9c:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFFF1Fu;
20006f9e:	697b      	ldr	r3, [r7, #20]
20006fa0:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
20006fa4:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 5);
20006fa6:	68fa      	ldr	r2, [r7, #12]
20006fa8:	693b      	ldr	r3, [r7, #16]
20006faa:	4413      	add	r3, r2
20006fac:	781b      	ldrb	r3, [r3, #0]
20006fae:	ea4f 1343 	mov.w	r3, r3, lsl #5
20006fb2:	697a      	ldr	r2, [r7, #20]
20006fb4:	ea42 0303 	orr.w	r3, r2, r3
20006fb8:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
20006fba:	f248 0300 	movw	r3, #32768	; 0x8000
20006fbe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20006fc2:	697a      	ldr	r2, [r7, #20]
20006fc4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
20006fc8:	693b      	ldr	r3, [r7, #16]
20006fca:	f103 0301 	add.w	r3, r3, #1
20006fce:	613b      	str	r3, [r7, #16]
20006fd0:	7afb      	ldrb	r3, [r7, #11]
20006fd2:	461a      	mov	r2, r3
20006fd4:	693b      	ldr	r3, [r7, #16]
20006fd6:	429a      	cmp	r2, r3
20006fd8:	d8da      	bhi.n	20006f90 <clk_switching_fix+0x16c>
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
20006fda:	687b      	ldr	r3, [r7, #4]
20006fdc:	ea4f 2353 	mov.w	r3, r3, lsr #9
20006fe0:	f003 0207 	and.w	r2, r3, #7
20006fe4:	f24c 3304 	movw	r3, #49924	; 0xc304
20006fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006fec:	609a      	str	r2, [r3, #8]
        sequence = determine_seq(divisor[2], &len);
20006fee:	f24c 3304 	movw	r3, #49924	; 0xc304
20006ff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20006ff6:	689b      	ldr	r3, [r3, #8]
20006ff8:	b2da      	uxtb	r2, r3
20006ffa:	f107 030b 	add.w	r3, r7, #11
20006ffe:	4610      	mov	r0, r2
20007000:	4619      	mov	r1, r3
20007002:	f7ff feab 	bl	20006d5c <determine_seq>
20007006:	4603      	mov	r3, r0
20007008:	60fb      	str	r3, [r7, #12]
        
        for(var = 1; var < len; var++)
2000700a:	f04f 0301 	mov.w	r3, #1
2000700e:	613b      	str	r3, [r7, #16]
20007010:	e01f      	b.n	20007052 <clk_switching_fix+0x22e>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20007012:	f248 0300 	movw	r3, #32768	; 0x8000
20007016:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000701a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000701e:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFF1FFu;
20007020:	697b      	ldr	r3, [r7, #20]
20007022:	f423 6360 	bic.w	r3, r3, #3584	; 0xe00
20007026:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 9);
20007028:	68fa      	ldr	r2, [r7, #12]
2000702a:	693b      	ldr	r3, [r7, #16]
2000702c:	4413      	add	r3, r2
2000702e:	781b      	ldrb	r3, [r3, #0]
20007030:	ea4f 2343 	mov.w	r3, r3, lsl #9
20007034:	697a      	ldr	r2, [r7, #20]
20007036:	ea42 0303 	orr.w	r3, r2, r3
2000703a:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
2000703c:	f248 0300 	movw	r3, #32768	; 0x8000
20007040:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007044:	697a      	ldr	r2, [r7, #20]
20007046:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
2000704a:	693b      	ldr	r3, [r7, #16]
2000704c:	f103 0301 	add.w	r3, r3, #1
20007050:	613b      	str	r3, [r7, #16]
20007052:	7afb      	ldrb	r3, [r7, #11]
20007054:	461a      	mov	r2, r3
20007056:	693b      	ldr	r3, [r7, #16]
20007058:	429a      	cmp	r2, r3
2000705a:	d8da      	bhi.n	20007012 <clk_switching_fix+0x1ee>
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
2000705c:	687b      	ldr	r3, [r7, #4]
2000705e:	ea4f 43d3 	mov.w	r3, r3, lsr #19
20007062:	f003 0207 	and.w	r2, r3, #7
20007066:	f24c 3304 	movw	r3, #49924	; 0xc304
2000706a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000706e:	60da      	str	r2, [r3, #12]
        sequence = determine_seq(divisor[3], &len);
20007070:	f24c 3304 	movw	r3, #49924	; 0xc304
20007074:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007078:	68db      	ldr	r3, [r3, #12]
2000707a:	b2da      	uxtb	r2, r3
2000707c:	f107 030b 	add.w	r3, r7, #11
20007080:	4610      	mov	r0, r2
20007082:	4619      	mov	r1, r3
20007084:	f7ff fe6a 	bl	20006d5c <determine_seq>
20007088:	4603      	mov	r3, r0
2000708a:	60fb      	str	r3, [r7, #12]
        for(var = 1; var < len; var++)
2000708c:	f04f 0301 	mov.w	r3, #1
20007090:	613b      	str	r3, [r7, #16]
20007092:	e01f      	b.n	200070d4 <clk_switching_fix+0x2b0>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20007094:	f248 0300 	movw	r3, #32768	; 0x8000
20007098:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000709c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200070a0:	617b      	str	r3, [r7, #20]
            temp &= 0xFFC7FFFFu;
200070a2:	697b      	ldr	r3, [r7, #20]
200070a4:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
200070a8:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 19);
200070aa:	68fa      	ldr	r2, [r7, #12]
200070ac:	693b      	ldr	r3, [r7, #16]
200070ae:	4413      	add	r3, r2
200070b0:	781b      	ldrb	r3, [r3, #0]
200070b2:	ea4f 43c3 	mov.w	r3, r3, lsl #19
200070b6:	697a      	ldr	r2, [r7, #20]
200070b8:	ea42 0303 	orr.w	r3, r2, r3
200070bc:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
200070be:	f248 0300 	movw	r3, #32768	; 0x8000
200070c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200070c6:	697a      	ldr	r2, [r7, #20]
200070c8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
200070cc:	693b      	ldr	r3, [r7, #16]
200070ce:	f103 0301 	add.w	r3, r3, #1
200070d2:	613b      	str	r3, [r7, #16]
200070d4:	7afb      	ldrb	r3, [r7, #11]
200070d6:	461a      	mov	r2, r3
200070d8:	693b      	ldr	r3, [r7, #16]
200070da:	429a      	cmp	r2, r3
200070dc:	d8da      	bhi.n	20007094 <clk_switching_fix+0x270>

        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 1 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from CLK_STANDBY
         * clock.
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR | 0x00001000u;
200070de:	f248 0300 	movw	r3, #32768	; 0x8000
200070e2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200070e6:	f248 0200 	movw	r2, #32768	; 0x8000
200070ea:	f2c4 0203 	movt	r2, #16387	; 0x4003
200070ee:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
200070f2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
200070f6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        
        status = CLOCK_SWITCHING_SUCCESS;
200070fa:	f04f 0300 	mov.w	r3, #0
200070fe:	77fb      	strb	r3, [r7, #31]
20007100:	e059      	b.n	200071b6 <clk_switching_fix+0x392>
    }
    /* For 060 devices */
    else if(0xF808u == device_version)
20007102:	69ba      	ldr	r2, [r7, #24]
20007104:	f64f 0308 	movw	r3, #63496	; 0xf808
20007108:	429a      	cmp	r2, r3
2000710a:	d154      	bne.n	200071b6 <clk_switching_fix+0x392>
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
2000710c:	687b      	ldr	r3, [r7, #4]
2000710e:	ea4f 0393 	mov.w	r3, r3, lsr #2
20007112:	f003 0207 	and.w	r2, r3, #7
20007116:	f24c 3304 	movw	r3, #49924	; 0xc304
2000711a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000711e:	601a      	str	r2, [r3, #0]
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
20007120:	687b      	ldr	r3, [r7, #4]
20007122:	ea4f 1353 	mov.w	r3, r3, lsr #5
20007126:	f003 0207 	and.w	r2, r3, #7
2000712a:	f24c 3304 	movw	r3, #49924	; 0xc304
2000712e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007132:	605a      	str	r2, [r3, #4]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
20007134:	687b      	ldr	r3, [r7, #4]
20007136:	ea4f 2353 	mov.w	r3, r3, lsr #9
2000713a:	f003 0207 	and.w	r2, r3, #7
2000713e:	f24c 3304 	movw	r3, #49924	; 0xc304
20007142:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007146:	609a      	str	r2, [r3, #8]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
20007148:	687b      	ldr	r3, [r7, #4]
2000714a:	ea4f 43d3 	mov.w	r3, r3, lsr #19
2000714e:	f003 0207 	and.w	r2, r3, #7
20007152:	f24c 3304 	movw	r3, #49924	; 0xc304
20007156:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000715a:	60da      	str	r2, [r3, #12]
       
        for(var = 1; var < 4; var++)
2000715c:	f04f 0301 	mov.w	r3, #1
20007160:	613b      	str	r3, [r7, #16]
20007162:	e025      	b.n	200071b0 <clk_switching_fix+0x38c>
        {
            if((divisor[var] != divisor[0]) || \
20007164:	693a      	ldr	r2, [r7, #16]
20007166:	f24c 3304 	movw	r3, #49924	; 0xc304
2000716a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000716e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
20007172:	f24c 3304 	movw	r3, #49924	; 0xc304
20007176:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000717a:	681b      	ldr	r3, [r3, #0]
2000717c:	429a      	cmp	r2, r3
2000717e:	d10f      	bne.n	200071a0 <clk_switching_fix+0x37c>
               (divisor[0] > 5) || (divisor[var] > 5))
20007180:	f24c 3304 	movw	r3, #49924	; 0xc304
20007184:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007188:	681b      	ldr	r3, [r3, #0]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
2000718a:	2b05      	cmp	r3, #5
2000718c:	d808      	bhi.n	200071a0 <clk_switching_fix+0x37c>
               (divisor[0] > 5) || (divisor[var] > 5))
2000718e:	693a      	ldr	r2, [r7, #16]
20007190:	f24c 3304 	movw	r3, #49924	; 0xc304
20007194:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007198:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
2000719c:	2b05      	cmp	r3, #5
2000719e:	d903      	bls.n	200071a8 <clk_switching_fix+0x384>
               (divisor[0] > 5) || (divisor[var] > 5))
            {
                /* If the divisor value does meet the criteria, log the clock 
                 * switching error.
                 */
                status = CLOCK_SWITCHING_ERROR;
200071a0:	f04f 0301 	mov.w	r3, #1
200071a4:	77fb      	strb	r3, [r7, #31]
                break;
200071a6:	e006      	b.n	200071b6 <clk_switching_fix+0x392>
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
200071a8:	693b      	ldr	r3, [r7, #16]
200071aa:	f103 0301 	add.w	r3, r3, #1
200071ae:	613b      	str	r3, [r7, #16]
200071b0:	693b      	ldr	r3, [r7, #16]
200071b2:	2b03      	cmp	r3, #3
200071b4:	d9d6      	bls.n	20007164 <clk_switching_fix+0x340>
    else
    {
         /* Do Nothing. */
    }
    
    return status;
200071b6:	7ffb      	ldrb	r3, [r7, #31]
}
200071b8:	4618      	mov	r0, r3
200071ba:	f107 0720 	add.w	r7, r7, #32
200071be:	46bd      	mov	sp, r7
200071c0:	bd80      	pop	{r7, pc}
200071c2:	bf00      	nop

200071c4 <revert_clk_config>:
/* SAR 80563 - Workaround for Glitchless Clock Multiplexer Switching Issue
 * Revert back original values of various divisor in FACC1 register after 
 * completing the fabric digest check/IAP/Flash Freeze service. 
 */
static void revert_clk_config(void)
{
200071c4:	b580      	push	{r7, lr}
200071c6:	b086      	sub	sp, #24
200071c8:	af00      	add	r7, sp, #0
    uint8_t* sequence;
    uint8_t len;
    uint8_t var = 0;
200071ca:	f04f 0300 	mov.w	r3, #0
200071ce:	73fb      	strb	r3, [r7, #15]
    uint32_t temp = 0;
200071d0:	f04f 0300 	mov.w	r3, #0
200071d4:	613b      	str	r3, [r7, #16]
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
200071d6:	f248 0300 	movw	r3, #32768	; 0x8000
200071da:	f2c4 0303 	movt	r3, #16387	; 0x4003
200071de:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
200071e2:	ea4f 4303 	mov.w	r3, r3, lsl #16
200071e6:	ea4f 4313 	mov.w	r3, r3, lsr #16
200071ea:	617b      	str	r3, [r7, #20]

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
200071ec:	697a      	ldr	r2, [r7, #20]
200071ee:	f64f 0302 	movw	r3, #63490	; 0xf802
200071f2:	429a      	cmp	r2, r3
200071f4:	d013      	beq.n	2000721e <revert_clk_config+0x5a>
200071f6:	697a      	ldr	r2, [r7, #20]
200071f8:	f64f 0303 	movw	r3, #63491	; 0xf803
200071fc:	429a      	cmp	r2, r3
200071fe:	d00e      	beq.n	2000721e <revert_clk_config+0x5a>
20007200:	697a      	ldr	r2, [r7, #20]
20007202:	f64f 0304 	movw	r3, #63492	; 0xf804
20007206:	429a      	cmp	r2, r3
20007208:	d009      	beq.n	2000721e <revert_clk_config+0x5a>
2000720a:	697a      	ldr	r2, [r7, #20]
2000720c:	f64f 0307 	movw	r3, #63495	; 0xf807
20007210:	429a      	cmp	r2, r3
20007212:	d004      	beq.n	2000721e <revert_clk_config+0x5a>
20007214:	697a      	ldr	r2, [r7, #20]
20007216:	f64f 0306 	movw	r3, #63494	; 0xf806
2000721a:	429a      	cmp	r2, r3
2000721c:	d10b      	bne.n	20007236 <revert_clk_config+0x72>
       (0xF804u == device_version)||(0xF807u == device_version) ||   \
       (0xF806u == device_version))
    {
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
2000721e:	f248 0300 	movw	r3, #32768	; 0x8000
20007222:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007226:	f24c 3200 	movw	r2, #49920	; 0xc300
2000722a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000722e:	6812      	ldr	r2, [r2, #0]
20007230:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
20007234:	e0eb      	b.n	2000740e <revert_clk_config+0x24a>
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    }

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
20007236:	697a      	ldr	r2, [r7, #20]
20007238:	f64f 0305 	movw	r3, #63493	; 0xf805
2000723c:	429a      	cmp	r2, r3
2000723e:	f040 80e6 	bne.w	2000740e <revert_clk_config+0x24a>
    {
        sequence = determine_seq(divisor[0], &len);
20007242:	f24c 3304 	movw	r3, #49924	; 0xc304
20007246:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000724a:	681b      	ldr	r3, [r3, #0]
2000724c:	b2da      	uxtb	r2, r3
2000724e:	f107 0307 	add.w	r3, r7, #7
20007252:	4610      	mov	r0, r2
20007254:	4619      	mov	r1, r3
20007256:	f7ff fd81 	bl	20006d5c <determine_seq>
2000725a:	4603      	mov	r3, r0
2000725c:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
2000725e:	79fb      	ldrb	r3, [r7, #7]
20007260:	73fb      	strb	r3, [r7, #15]
20007262:	e021      	b.n	200072a8 <revert_clk_config+0xe4>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20007264:	f248 0300 	movw	r3, #32768	; 0x8000
20007268:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000726c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007270:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFFE3u;
20007272:	693b      	ldr	r3, [r7, #16]
20007274:	f023 031c 	bic.w	r3, r3, #28
20007278:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
2000727a:	7bfb      	ldrb	r3, [r7, #15]
2000727c:	f103 32ff 	add.w	r2, r3, #4294967295
20007280:	68bb      	ldr	r3, [r7, #8]
20007282:	4413      	add	r3, r2
20007284:	781b      	ldrb	r3, [r3, #0]
20007286:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000728a:	693a      	ldr	r2, [r7, #16]
2000728c:	ea42 0303 	orr.w	r3, r2, r3
20007290:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
20007292:	f248 0300 	movw	r3, #32768	; 0x8000
20007296:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000729a:	693a      	ldr	r2, [r7, #16]
2000729c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
200072a0:	7bfb      	ldrb	r3, [r7, #15]
200072a2:	f103 33ff 	add.w	r3, r3, #4294967295
200072a6:	73fb      	strb	r3, [r7, #15]
200072a8:	7bfb      	ldrb	r3, [r7, #15]
200072aa:	2b00      	cmp	r3, #0
200072ac:	d1da      	bne.n	20007264 <revert_clk_config+0xa0>
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
200072ae:	f24c 3304 	movw	r3, #49924	; 0xc304
200072b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200072b6:	685b      	ldr	r3, [r3, #4]
200072b8:	b2da      	uxtb	r2, r3
200072ba:	f107 0307 	add.w	r3, r7, #7
200072be:	4610      	mov	r0, r2
200072c0:	4619      	mov	r1, r3
200072c2:	f7ff fd4b 	bl	20006d5c <determine_seq>
200072c6:	4603      	mov	r3, r0
200072c8:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
200072ca:	79fb      	ldrb	r3, [r7, #7]
200072cc:	73fb      	strb	r3, [r7, #15]
200072ce:	e021      	b.n	20007314 <revert_clk_config+0x150>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
200072d0:	f248 0300 	movw	r3, #32768	; 0x8000
200072d4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200072d8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200072dc:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFF1Fu;
200072de:	693b      	ldr	r3, [r7, #16]
200072e0:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
200072e4:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
200072e6:	7bfb      	ldrb	r3, [r7, #15]
200072e8:	f103 32ff 	add.w	r2, r3, #4294967295
200072ec:	68bb      	ldr	r3, [r7, #8]
200072ee:	4413      	add	r3, r2
200072f0:	781b      	ldrb	r3, [r3, #0]
200072f2:	ea4f 1343 	mov.w	r3, r3, lsl #5
200072f6:	693a      	ldr	r2, [r7, #16]
200072f8:	ea42 0303 	orr.w	r3, r2, r3
200072fc:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
200072fe:	f248 0300 	movw	r3, #32768	; 0x8000
20007302:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007306:	693a      	ldr	r2, [r7, #16]
20007308:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
2000730c:	7bfb      	ldrb	r3, [r7, #15]
2000730e:	f103 33ff 	add.w	r3, r3, #4294967295
20007312:	73fb      	strb	r3, [r7, #15]
20007314:	7bfb      	ldrb	r3, [r7, #15]
20007316:	2b00      	cmp	r3, #0
20007318:	d1da      	bne.n	200072d0 <revert_clk_config+0x10c>
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
2000731a:	f24c 3304 	movw	r3, #49924	; 0xc304
2000731e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007322:	689b      	ldr	r3, [r3, #8]
20007324:	b2da      	uxtb	r2, r3
20007326:	f107 0307 	add.w	r3, r7, #7
2000732a:	4610      	mov	r0, r2
2000732c:	4619      	mov	r1, r3
2000732e:	f7ff fd15 	bl	20006d5c <determine_seq>
20007332:	4603      	mov	r3, r0
20007334:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
20007336:	79fb      	ldrb	r3, [r7, #7]
20007338:	73fb      	strb	r3, [r7, #15]
2000733a:	e021      	b.n	20007380 <revert_clk_config+0x1bc>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
2000733c:	f248 0300 	movw	r3, #32768	; 0x8000
20007340:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007344:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007348:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFF1FFu;
2000734a:	693b      	ldr	r3, [r7, #16]
2000734c:	f423 6360 	bic.w	r3, r3, #3584	; 0xe00
20007350:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
20007352:	7bfb      	ldrb	r3, [r7, #15]
20007354:	f103 32ff 	add.w	r2, r3, #4294967295
20007358:	68bb      	ldr	r3, [r7, #8]
2000735a:	4413      	add	r3, r2
2000735c:	781b      	ldrb	r3, [r3, #0]
2000735e:	ea4f 2343 	mov.w	r3, r3, lsl #9
20007362:	693a      	ldr	r2, [r7, #16]
20007364:	ea42 0303 	orr.w	r3, r2, r3
20007368:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
2000736a:	f248 0300 	movw	r3, #32768	; 0x8000
2000736e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007372:	693a      	ldr	r2, [r7, #16]
20007374:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
20007378:	7bfb      	ldrb	r3, [r7, #15]
2000737a:	f103 33ff 	add.w	r3, r3, #4294967295
2000737e:	73fb      	strb	r3, [r7, #15]
20007380:	7bfb      	ldrb	r3, [r7, #15]
20007382:	2b00      	cmp	r3, #0
20007384:	d1da      	bne.n	2000733c <revert_clk_config+0x178>
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
20007386:	f24c 3304 	movw	r3, #49924	; 0xc304
2000738a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000738e:	68db      	ldr	r3, [r3, #12]
20007390:	b2da      	uxtb	r2, r3
20007392:	f107 0307 	add.w	r3, r7, #7
20007396:	4610      	mov	r0, r2
20007398:	4619      	mov	r1, r3
2000739a:	f7ff fcdf 	bl	20006d5c <determine_seq>
2000739e:	4603      	mov	r3, r0
200073a0:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
200073a2:	79fb      	ldrb	r3, [r7, #7]
200073a4:	73fb      	strb	r3, [r7, #15]
200073a6:	e021      	b.n	200073ec <revert_clk_config+0x228>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
200073a8:	f248 0300 	movw	r3, #32768	; 0x8000
200073ac:	f2c4 0303 	movt	r3, #16387	; 0x4003
200073b0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200073b4:	613b      	str	r3, [r7, #16]
            temp &= 0xFFC7FFFFu;
200073b6:	693b      	ldr	r3, [r7, #16]
200073b8:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
200073bc:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
200073be:	7bfb      	ldrb	r3, [r7, #15]
200073c0:	f103 32ff 	add.w	r2, r3, #4294967295
200073c4:	68bb      	ldr	r3, [r7, #8]
200073c6:	4413      	add	r3, r2
200073c8:	781b      	ldrb	r3, [r3, #0]
200073ca:	ea4f 43c3 	mov.w	r3, r3, lsl #19
200073ce:	693a      	ldr	r2, [r7, #16]
200073d0:	ea42 0303 	orr.w	r3, r2, r3
200073d4:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
200073d6:	f248 0300 	movw	r3, #32768	; 0x8000
200073da:	f2c4 0303 	movt	r3, #16387	; 0x4003
200073de:	693a      	ldr	r2, [r7, #16]
200073e0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
200073e4:	7bfb      	ldrb	r3, [r7, #15]
200073e6:	f103 33ff 	add.w	r3, r3, #4294967295
200073ea:	73fb      	strb	r3, [r7, #15]
200073ec:	7bfb      	ldrb	r3, [r7, #15]
200073ee:	2b00      	cmp	r3, #0
200073f0:	d1da      	bne.n	200073a8 <revert_clk_config+0x1e4>
        
        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 0 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from stage 2 
         * dividers (from CLK_SRC).
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & 0xFFFFEFFFu;
200073f2:	f248 0300 	movw	r3, #32768	; 0x8000
200073f6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200073fa:	f248 0200 	movw	r2, #32768	; 0x8000
200073fe:	f2c4 0203 	movt	r2, #16387	; 0x4003
20007402:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20007406:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000740a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    }
    else
    {
        /* Do Nothing. */
    }
}
2000740e:	f107 0718 	add.w	r7, r7, #24
20007412:	46bd      	mov	sp, r7
20007414:	bd80      	pop	{r7, pc}
20007416:	bf00      	nop

20007418 <MSS_SYS_initiate_iap>:
uint8_t MSS_SYS_initiate_iap
(
    uint8_t mode,
    uint32_t bitstream_spi_addr
)
{
20007418:	b580      	push	{r7, lr}
2000741a:	b08a      	sub	sp, #40	; 0x28
2000741c:	af04      	add	r7, sp, #16
2000741e:	4603      	mov	r3, r0
20007420:	6039      	str	r1, [r7, #0]
20007422:	71fb      	strb	r3, [r7, #7]
    uint8_t status = MSS_SYS_SUCCESS;
20007424:	f04f 0300 	mov.w	r3, #0
20007428:	753b      	strb	r3, [r7, #20]
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
2000742a:	f04f 0300 	mov.w	r3, #0
2000742e:	757b      	strb	r3, [r7, #21]
    uint16_t actual_response_length;
    uint8_t iap_prog_req[6];
    uint8_t response[IAP_PROG_SERV_RESP_LENGTH];
    
    if(mode == MSS_SYS_PROG_VERIFY)
20007430:	79fb      	ldrb	r3, [r7, #7]
20007432:	2b02      	cmp	r3, #2
20007434:	d103      	bne.n	2000743e <MSS_SYS_initiate_iap+0x26>
    {
        /*
         * Check fabric digest before performing IAP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
20007436:	f04f 0001 	mov.w	r0, #1
2000743a:	f000 f8b9 	bl	200075b0 <MSS_SYS_check_digest>
    }
    
    if(mode != MSS_SYS_PROG_AUTHENTICATE)
2000743e:	79fb      	ldrb	r3, [r7, #7]
20007440:	2b00      	cmp	r3, #0
20007442:	d04e      	beq.n	200074e2 <MSS_SYS_initiate_iap+0xca>
        /*
         * Keep a copy of the initial eNVM configuration used before IAP was
         * initiated. The eNVM configuration will be restored, as part of the IAP
         * completion handler, when IAP completes.
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
20007444:	f248 0300 	movw	r3, #32768	; 0x8000
20007448:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000744c:	68da      	ldr	r2, [r3, #12]
2000744e:	f24c 23b0 	movw	r3, #49840	; 0xc2b0
20007452:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007456:	601a      	str	r2, [r3, #0]
     
        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the IAP operation is completed.asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
20007458:	f248 0300 	movw	r3, #32768	; 0x8000
2000745c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007460:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
20007464:	f24c 3314 	movw	r3, #49940	; 0xc314
20007468:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000746c:	601a      	str	r2, [r3, #0]
        
        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;                
2000746e:	f248 0300 	movw	r3, #32768	; 0x8000
20007472:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007476:	f24c 22b0 	movw	r2, #49840	; 0xc2b0
2000747a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000747e:	6812      	ldr	r2, [r2, #0]
20007480:	f442 52ff 	orr.w	r2, r2, #8160	; 0x1fe0
20007484:	60da      	str	r2, [r3, #12]

        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
20007486:	f248 0300 	movw	r3, #32768	; 0x8000
2000748a:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000748e:	f248 0200 	movw	r2, #32768	; 0x8000
20007492:	f2c4 0203 	movt	r2, #16387	; 0x4003
20007496:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
2000749a:	f422 72e0 	bic.w	r2, r2, #448	; 0x1c0
2000749e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 50 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);
200074a2:	f248 0300 	movw	r3, #32768	; 0x8000
200074a6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200074aa:	f248 0200 	movw	r2, #32768	; 0x8000
200074ae:	f2c4 0203 	movt	r2, #16387	; 0x4003
200074b2:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
200074b6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200074ba:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 1 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);
200074be:	f248 0300 	movw	r3, #32768	; 0x8000
200074c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200074c6:	f248 0200 	movw	r2, #32768	; 0x8000
200074ca:	f2c4 0203 	movt	r2, #16387	; 0x4003
200074ce:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
200074d2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
200074d6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
200074da:	f7ff fca3 	bl	20006e24 <clk_switching_fix>
200074de:	4603      	mov	r3, r0
200074e0:	757b      	strb	r3, [r7, #21]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
200074e2:	7d7b      	ldrb	r3, [r7, #21]
200074e4:	2b00      	cmp	r3, #0
200074e6:	d157      	bne.n	20007598 <MSS_SYS_initiate_iap+0x180>
    {
        /*
         * There is no response for Program mode because the Cortex-M3 will
         * get reset on completion of the system service.
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
200074e8:	f04f 0314 	mov.w	r3, #20
200074ec:	733b      	strb	r3, [r7, #12]
        iap_prog_req[1] = mode;
200074ee:	79fb      	ldrb	r3, [r7, #7]
200074f0:	737b      	strb	r3, [r7, #13]

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
200074f2:	683b      	ldr	r3, [r7, #0]
200074f4:	b2db      	uxtb	r3, r3
200074f6:	73bb      	strb	r3, [r7, #14]
        iap_prog_req[3] = (uint8_t)(bitstream_spi_addr >> 8u);
200074f8:	683b      	ldr	r3, [r7, #0]
200074fa:	ea4f 2313 	mov.w	r3, r3, lsr #8
200074fe:	b2db      	uxtb	r3, r3
20007500:	73fb      	strb	r3, [r7, #15]
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
20007502:	683b      	ldr	r3, [r7, #0]
20007504:	ea4f 4313 	mov.w	r3, r3, lsr #16
20007508:	b2db      	uxtb	r3, r3
2000750a:	743b      	strb	r3, [r7, #16]
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);
2000750c:	683b      	ldr	r3, [r7, #0]
2000750e:	ea4f 6313 	mov.w	r3, r3, lsr #24
20007512:	b2db      	uxtb	r3, r3
20007514:	747b      	strb	r3, [r7, #17]

        signal_request_start();
20007516:	f000 f8e7 	bl	200076e8 <signal_request_start>
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
2000751a:	f107 020c 	add.w	r2, r7, #12
2000751e:	f107 0308 	add.w	r3, r7, #8
20007522:	9300      	str	r3, [sp, #0]
20007524:	f04f 0302 	mov.w	r3, #2
20007528:	9301      	str	r3, [sp, #4]
2000752a:	f247 63b9 	movw	r3, #30393	; 0x76b9
2000752e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007532:	9302      	str	r3, [sp, #8]
20007534:	4610      	mov	r0, r2
20007536:	f04f 0106 	mov.w	r1, #6
2000753a:	f04f 0200 	mov.w	r2, #0
2000753e:	f04f 0300 	mov.w	r3, #0
20007542:	f003 ff47 	bl	2000b3d4 <MSS_COMBLK_send_cmd>
                            request_completion_handler);    /* completion_handler */
            
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
20007546:	f000 f8eb 	bl	20007720 <wait_for_request_completion>
2000754a:	4603      	mov	r3, r0
2000754c:	82fb      	strh	r3, [r7, #22]
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
2000754e:	8afb      	ldrh	r3, [r7, #22]
20007550:	2b02      	cmp	r3, #2
20007552:	d105      	bne.n	20007560 <MSS_SYS_initiate_iap+0x148>
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
20007554:	7a3b      	ldrb	r3, [r7, #8]
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
20007556:	2b14      	cmp	r3, #20
20007558:	d102      	bne.n	20007560 <MSS_SYS_initiate_iap+0x148>
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
        {
            status = response[1];
2000755a:	7a7b      	ldrb	r3, [r7, #9]
2000755c:	753b      	strb	r3, [r7, #20]
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
2000755e:	e002      	b.n	20007566 <MSS_SYS_initiate_iap+0x14e>
        {
            status = response[1];
        }
        else
        {
            status = MSS_SYS_UNEXPECTED_ERROR;
20007560:	f06f 0337 	mvn.w	r3, #55	; 0x37
20007564:	753b      	strb	r3, [r7, #20]
        }
        
        if(mode != MSS_SYS_PROG_AUTHENTICATE)
20007566:	79fb      	ldrb	r3, [r7, #7]
20007568:	2b00      	cmp	r3, #0
2000756a:	d019      	beq.n	200075a0 <MSS_SYS_initiate_iap+0x188>
        {
            /* Restore back to original value. */
            SYSREG->ENVM_CR = g_initial_envm_cr;
2000756c:	f248 0300 	movw	r3, #32768	; 0x8000
20007570:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007574:	f24c 22b0 	movw	r2, #49840	; 0xc2b0
20007578:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000757c:	6812      	ldr	r2, [r2, #0]
2000757e:	60da      	str	r2, [r3, #12]
            SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
20007580:	f248 0300 	movw	r3, #32768	; 0x8000
20007584:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007588:	f24c 3214 	movw	r2, #49940	; 0xc314
2000758c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20007590:	6812      	ldr	r2, [r2, #0]
20007592:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
20007596:	e004      	b.n	200075a2 <MSS_SYS_initiate_iap+0x18a>
        /* SAR 80563
         * On 060 device. The user should make sure that the all divisor i.e 
         * fclk, pclk0, pclk1 and clk_fic64 divisor must be equal to each other 
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
20007598:	f06f 0336 	mvn.w	r3, #54	; 0x36
2000759c:	753b      	strb	r3, [r7, #20]
2000759e:	e000      	b.n	200075a2 <MSS_SYS_initiate_iap+0x18a>
        
        if(mode != MSS_SYS_PROG_AUTHENTICATE)
        {
            /* Restore back to original value. */
            SYSREG->ENVM_CR = g_initial_envm_cr;
            SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
200075a0:	bf00      	nop
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
200075a2:	7d3b      	ldrb	r3, [r7, #20]
}
200075a4:	4618      	mov	r0, r3
200075a6:	f107 0718 	add.w	r7, r7, #24
200075aa:	46bd      	mov	sp, r7
200075ac:	bd80      	pop	{r7, pc}
200075ae:	bf00      	nop

200075b0 <MSS_SYS_check_digest>:
 */
uint8_t MSS_SYS_check_digest
(
    uint8_t options
)
{
200075b0:	b580      	push	{r7, lr}
200075b2:	b08a      	sub	sp, #40	; 0x28
200075b4:	af04      	add	r7, sp, #16
200075b6:	4603      	mov	r3, r0
200075b8:	71fb      	strb	r3, [r7, #7]
    uint8_t status;
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
200075ba:	f04f 0300 	mov.w	r3, #0
200075be:	757b      	strb	r3, [r7, #21]
    uint8_t response[DIGEST_CHECK_SERV_RESP_LENGTH];
    
    /*
     * The Digest Check system service is not available on M2S050 rev A, rev B and rev C.
     */
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
200075c0:	f248 0300 	movw	r3, #32768	; 0x8000
200075c4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200075c8:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
200075cc:	f64f 0302 	movw	r3, #63490	; 0xf802
200075d0:	429a      	cmp	r2, r3
200075d2:	d100      	bne.n	200075d6 <MSS_SYS_check_digest+0x26>
200075d4:	be00      	bkpt	0x0000
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
200075d6:	f248 0300 	movw	r3, #32768	; 0x8000
200075da:	f2c4 0303 	movt	r3, #16387	; 0x4003
200075de:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
200075e2:	f64f 0302 	movw	r3, #63490	; 0xf802
200075e6:	f2c0 0301 	movt	r3, #1
200075ea:	429a      	cmp	r2, r3
200075ec:	d100      	bne.n	200075f0 <MSS_SYS_check_digest+0x40>
200075ee:	be00      	bkpt	0x0000
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
200075f0:	f248 0300 	movw	r3, #32768	; 0x8000
200075f4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200075f8:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
200075fc:	f64f 0302 	movw	r3, #63490	; 0xf802
20007600:	f2c0 0302 	movt	r3, #2
20007604:	429a      	cmp	r2, r3
20007606:	d100      	bne.n	2000760a <MSS_SYS_check_digest+0x5a>
20007608:	be00      	bkpt	0x0000
    
    /* 
     * Private ENVM factory digest and user digest is available only on G4X 
     * devices
     */
    if((options & 0x30u) != 0x00)
2000760a:	79fb      	ldrb	r3, [r7, #7]
2000760c:	f003 0330 	and.w	r3, r3, #48	; 0x30
20007610:	2b00      	cmp	r3, #0
20007612:	d00c      	beq.n	2000762e <MSS_SYS_check_digest+0x7e>
    {
        ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
20007614:	f248 0300 	movw	r3, #32768	; 0x8000
20007618:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000761c:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
20007620:	f64f 0302 	movw	r3, #63490	; 0xf802
20007624:	f2c0 0302 	movt	r3, #2
20007628:	429a      	cmp	r2, r3
2000762a:	d100      	bne.n	2000762e <MSS_SYS_check_digest+0x7e>
2000762c:	be00      	bkpt	0x0000
    
    /* SAR 80563
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    if(MSS_SYS_DIGEST_CHECK_FABRIC == (options & 0x01u))
2000762e:	79fb      	ldrb	r3, [r7, #7]
20007630:	f003 0301 	and.w	r3, r3, #1
20007634:	b2db      	uxtb	r3, r3
20007636:	2b00      	cmp	r3, #0
20007638:	d003      	beq.n	20007642 <MSS_SYS_check_digest+0x92>
    {
        clk_switch_status = clk_switching_fix();
2000763a:	f7ff fbf3 	bl	20006e24 <clk_switching_fix>
2000763e:	4603      	mov	r3, r0
20007640:	757b      	strb	r3, [r7, #21]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
20007642:	7d7b      	ldrb	r3, [r7, #21]
20007644:	2b00      	cmp	r3, #0
20007646:	d12e      	bne.n	200076a6 <MSS_SYS_check_digest+0xf6>
    {
      
        signal_request_start();
20007648:	f000 f84e 	bl	200076e8 <signal_request_start>

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
2000764c:	f04f 0317 	mov.w	r3, #23
20007650:	743b      	strb	r3, [r7, #16]
        digest_check_req[1] = options;
20007652:	79fb      	ldrb	r3, [r7, #7]
20007654:	747b      	strb	r3, [r7, #17]

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
20007656:	f107 0210 	add.w	r2, r7, #16
2000765a:	f107 030c 	add.w	r3, r7, #12
2000765e:	9300      	str	r3, [sp, #0]
20007660:	f04f 0302 	mov.w	r3, #2
20007664:	9301      	str	r3, [sp, #4]
20007666:	f247 63b9 	movw	r3, #30393	; 0x76b9
2000766a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000766e:	9302      	str	r3, [sp, #8]
20007670:	4610      	mov	r0, r2
20007672:	f04f 0102 	mov.w	r1, #2
20007676:	f04f 0200 	mov.w	r2, #0
2000767a:	f04f 0300 	mov.w	r3, #0
2000767e:	f003 fea9 	bl	2000b3d4 <MSS_COMBLK_send_cmd>
                            0u,                             /* data_size */
                            response,                       /* p_response */
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();
20007682:	f000 f84d 	bl	20007720 <wait_for_request_completion>
20007686:	4603      	mov	r3, r0
20007688:	82fb      	strh	r3, [r7, #22]

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
2000768a:	8afb      	ldrh	r3, [r7, #22]
2000768c:	2b02      	cmp	r3, #2
2000768e:	d106      	bne.n	2000769e <MSS_SYS_check_digest+0xee>
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
20007690:	7b3b      	ldrb	r3, [r7, #12]
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
20007692:	2b17      	cmp	r3, #23
20007694:	d103      	bne.n	2000769e <MSS_SYS_check_digest+0xee>
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
        {
            status = response[1];
20007696:	7b7b      	ldrb	r3, [r7, #13]
20007698:	753b      	strb	r3, [r7, #20]
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
2000769a:	bf00      	nop
2000769c:	e006      	b.n	200076ac <MSS_SYS_check_digest+0xfc>
        {
            status = response[1];
        }
        else
        {
            status = MSS_SYS_UNEXPECTED_ERROR;
2000769e:	f06f 0337 	mvn.w	r3, #55	; 0x37
200076a2:	753b      	strb	r3, [r7, #20]
200076a4:	e002      	b.n	200076ac <MSS_SYS_check_digest+0xfc>
        /* SAR 80563
         * On 060 device. The user should make sure that the all divisor i.e 
         * fclk, pclk0, pclk1 and clk_fic64 divisor must be equal to each other 
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
200076a6:	f06f 0336 	mvn.w	r3, #54	; 0x36
200076aa:	753b      	strb	r3, [r7, #20]
    }
    
    return status;
200076ac:	7d3b      	ldrb	r3, [r7, #20]
}
200076ae:	4618      	mov	r0, r3
200076b0:	f107 0718 	add.w	r7, r7, #24
200076b4:	46bd      	mov	sp, r7
200076b6:	bd80      	pop	{r7, pc}

200076b8 <request_completion_handler>:
static void request_completion_handler
(
    uint8_t * p_response,
    uint16_t response_size
)
{
200076b8:	b480      	push	{r7}
200076ba:	b083      	sub	sp, #12
200076bc:	af00      	add	r7, sp, #0
200076be:	6078      	str	r0, [r7, #4]
200076c0:	460b      	mov	r3, r1
200076c2:	807b      	strh	r3, [r7, #2]
    g_request_in_progress = 0u;
200076c4:	f24c 23f3 	movw	r3, #49907	; 0xc2f3
200076c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200076cc:	f04f 0200 	mov.w	r2, #0
200076d0:	701a      	strb	r2, [r3, #0]
    g_last_response_length = response_size;
200076d2:	f24c 23f4 	movw	r3, #49908	; 0xc2f4
200076d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200076da:	887a      	ldrh	r2, [r7, #2]
200076dc:	801a      	strh	r2, [r3, #0]
}
200076de:	f107 070c 	add.w	r7, r7, #12
200076e2:	46bd      	mov	sp, r7
200076e4:	bc80      	pop	{r7}
200076e6:	4770      	bx	lr

200076e8 <signal_request_start>:

/*==============================================================================
 *
 */
static void signal_request_start(void)
{
200076e8:	b480      	push	{r7}
200076ea:	af00      	add	r7, sp, #0
    /* Wait for current request to complete. */
    while(g_request_in_progress)
200076ec:	f24c 23f3 	movw	r3, #49907	; 0xc2f3
200076f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200076f4:	781b      	ldrb	r3, [r3, #0]
200076f6:	b2db      	uxtb	r3, r3
200076f8:	2b00      	cmp	r3, #0
200076fa:	d1f7      	bne.n	200076ec <signal_request_start+0x4>
    {
        ;
    }
    
    g_request_in_progress = 1u;
200076fc:	f24c 23f3 	movw	r3, #49907	; 0xc2f3
20007700:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007704:	f04f 0201 	mov.w	r2, #1
20007708:	701a      	strb	r2, [r3, #0]
    g_last_response_length = 0u;
2000770a:	f24c 23f4 	movw	r3, #49908	; 0xc2f4
2000770e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007712:	f04f 0200 	mov.w	r2, #0
20007716:	801a      	strh	r2, [r3, #0]
}
20007718:	46bd      	mov	sp, r7
2000771a:	bc80      	pop	{r7}
2000771c:	4770      	bx	lr
2000771e:	bf00      	nop

20007720 <wait_for_request_completion>:

/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
20007720:	b480      	push	{r7}
20007722:	af00      	add	r7, sp, #0
    while(g_request_in_progress)
20007724:	f24c 23f3 	movw	r3, #49907	; 0xc2f3
20007728:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000772c:	781b      	ldrb	r3, [r3, #0]
2000772e:	b2db      	uxtb	r3, r3
20007730:	2b00      	cmp	r3, #0
20007732:	d1f7      	bne.n	20007724 <wait_for_request_completion+0x4>
    {
        ;
    }
    
    return g_last_response_length;
20007734:	f24c 23f4 	movw	r3, #49908	; 0xc2f4
20007738:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000773c:	881b      	ldrh	r3, [r3, #0]
2000773e:	b29b      	uxth	r3, r3
}
20007740:	4618      	mov	r0, r3
20007742:	46bd      	mov	sp, r7
20007744:	bc80      	pop	{r7}
20007746:	4770      	bx	lr

20007748 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20007748:	b480      	push	{r7}
2000774a:	b083      	sub	sp, #12
2000774c:	af00      	add	r7, sp, #0
2000774e:	4603      	mov	r3, r0
20007750:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20007752:	f24e 1300 	movw	r3, #57600	; 0xe100
20007756:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000775a:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000775e:	ea4f 1252 	mov.w	r2, r2, lsr #5
20007762:	79f9      	ldrb	r1, [r7, #7]
20007764:	f001 011f 	and.w	r1, r1, #31
20007768:	f04f 0001 	mov.w	r0, #1
2000776c:	fa00 f101 	lsl.w	r1, r0, r1
20007770:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20007774:	f107 070c 	add.w	r7, r7, #12
20007778:	46bd      	mov	sp, r7
2000777a:	bc80      	pop	{r7}
2000777c:	4770      	bx	lr
2000777e:	bf00      	nop

20007780 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20007780:	b480      	push	{r7}
20007782:	b083      	sub	sp, #12
20007784:	af00      	add	r7, sp, #0
20007786:	4603      	mov	r3, r0
20007788:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
2000778a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000778e:	f2ce 0300 	movt	r3, #57344	; 0xe000
20007792:	f997 2007 	ldrsb.w	r2, [r7, #7]
20007796:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000779a:	79f9      	ldrb	r1, [r7, #7]
2000779c:	f001 011f 	and.w	r1, r1, #31
200077a0:	f04f 0001 	mov.w	r0, #1
200077a4:	fa00 f101 	lsl.w	r1, r0, r1
200077a8:	f102 0220 	add.w	r2, r2, #32
200077ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200077b0:	f107 070c 	add.w	r7, r7, #12
200077b4:	46bd      	mov	sp, r7
200077b6:	bc80      	pop	{r7}
200077b8:	4770      	bx	lr
200077ba:	bf00      	nop

200077bc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200077bc:	b480      	push	{r7}
200077be:	b083      	sub	sp, #12
200077c0:	af00      	add	r7, sp, #0
200077c2:	4603      	mov	r3, r0
200077c4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200077c6:	f24e 1300 	movw	r3, #57600	; 0xe100
200077ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
200077ce:	f997 2007 	ldrsb.w	r2, [r7, #7]
200077d2:	ea4f 1252 	mov.w	r2, r2, lsr #5
200077d6:	79f9      	ldrb	r1, [r7, #7]
200077d8:	f001 011f 	and.w	r1, r1, #31
200077dc:	f04f 0001 	mov.w	r0, #1
200077e0:	fa00 f101 	lsl.w	r1, r0, r1
200077e4:	f102 0260 	add.w	r2, r2, #96	; 0x60
200077e8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200077ec:	f107 070c 	add.w	r7, r7, #12
200077f0:	46bd      	mov	sp, r7
200077f2:	bc80      	pop	{r7}
200077f4:	4770      	bx	lr
200077f6:	bf00      	nop

200077f8 <MSS_SPI_init>:
 */
void MSS_SPI_init
(
    mss_spi_instance_t * this_spi
)
{
200077f8:	b580      	push	{r7, lr}
200077fa:	b084      	sub	sp, #16
200077fc:	af00      	add	r7, sp, #0
200077fe:	6078      	str	r0, [r7, #4]
    uint16_t slave;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007800:	687a      	ldr	r2, [r7, #4]
20007802:	f24d 5304 	movw	r3, #54532	; 0xd504
20007806:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000780a:	429a      	cmp	r2, r3
2000780c:	d007      	beq.n	2000781e <MSS_SPI_init+0x26>
2000780e:	687a      	ldr	r2, [r7, #4]
20007810:	f24d 4380 	movw	r3, #54400	; 0xd480
20007814:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007818:	429a      	cmp	r2, r3
2000781a:	d000      	beq.n	2000781e <MSS_SPI_init+0x26>
2000781c:	be00      	bkpt	0x0000
     * Initialize SPI driver instance data. Relies on the majority
     * of data requiring 0 for initial state so we just need to fill
     * with 0s and finish off with a small number of non zero values.
     */
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
2000781e:	687b      	ldr	r3, [r7, #4]
20007820:	791b      	ldrb	r3, [r3, #4]
20007822:	b25b      	sxtb	r3, r3
20007824:	4618      	mov	r0, r3
20007826:	f7ff ffab 	bl	20007780 <NVIC_DisableIRQ>

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
2000782a:	6878      	ldr	r0, [r7, #4]
2000782c:	f04f 0100 	mov.w	r1, #0
20007830:	f04f 0284 	mov.w	r2, #132	; 0x84
20007834:	f004 fab0 	bl	2000bd98 <memset>
    
    this_spi->cmd_done = 1u;
20007838:	687b      	ldr	r3, [r7, #4]
2000783a:	f04f 0201 	mov.w	r2, #1
2000783e:	625a      	str	r2, [r3, #36]	; 0x24

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20007840:	f04f 0300 	mov.w	r3, #0
20007844:	81fb      	strh	r3, [r7, #14]
20007846:	e00d      	b.n	20007864 <MSS_SPI_init+0x6c>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
20007848:	89fb      	ldrh	r3, [r7, #14]
2000784a:	687a      	ldr	r2, [r7, #4]
2000784c:	f103 0306 	add.w	r3, r3, #6
20007850:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007854:	4413      	add	r3, r2
20007856:	f04f 32ff 	mov.w	r2, #4294967295
2000785a:	605a      	str	r2, [r3, #4]

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    
    this_spi->cmd_done = 1u;

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
2000785c:	89fb      	ldrh	r3, [r7, #14]
2000785e:	f103 0301 	add.w	r3, r3, #1
20007862:	81fb      	strh	r3, [r7, #14]
20007864:	89fb      	ldrh	r3, [r7, #14]
20007866:	2b07      	cmp	r3, #7
20007868:	d9ee      	bls.n	20007848 <MSS_SPI_init+0x50>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    }

    if(this_spi == &g_mss_spi0)
2000786a:	687a      	ldr	r2, [r7, #4]
2000786c:	f24d 5304 	movw	r3, #54532	; 0xd504
20007870:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007874:	429a      	cmp	r2, r3
20007876:	d126      	bne.n	200078c6 <MSS_SPI_init+0xce>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20007878:	687a      	ldr	r2, [r7, #4]
2000787a:	f241 0300 	movw	r3, #4096	; 0x1000
2000787e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20007882:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20007884:	687b      	ldr	r3, [r7, #4]
20007886:	f04f 0202 	mov.w	r2, #2
2000788a:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
2000788c:	f248 0300 	movw	r3, #32768	; 0x8000
20007890:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007894:	f248 0200 	movw	r2, #32768	; 0x8000
20007898:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000789c:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000789e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200078a2:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
200078a4:	f04f 0002 	mov.w	r0, #2
200078a8:	f7ff ff88 	bl	200077bc <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
200078ac:	f248 0300 	movw	r3, #32768	; 0x8000
200078b0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200078b4:	f248 0200 	movw	r2, #32768	; 0x8000
200078b8:	f2c4 0203 	movt	r2, #16387	; 0x4003
200078bc:	6c92      	ldr	r2, [r2, #72]	; 0x48
200078be:	f422 7200 	bic.w	r2, r2, #512	; 0x200
200078c2:	649a      	str	r2, [r3, #72]	; 0x48
200078c4:	e025      	b.n	20007912 <MSS_SPI_init+0x11a>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
200078c6:	687a      	ldr	r2, [r7, #4]
200078c8:	f241 0300 	movw	r3, #4096	; 0x1000
200078cc:	f2c4 0301 	movt	r3, #16385	; 0x4001
200078d0:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
200078d2:	687b      	ldr	r3, [r7, #4]
200078d4:	f04f 0203 	mov.w	r2, #3
200078d8:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
200078da:	f248 0300 	movw	r3, #32768	; 0x8000
200078de:	f2c4 0303 	movt	r3, #16387	; 0x4003
200078e2:	f248 0200 	movw	r2, #32768	; 0x8000
200078e6:	f2c4 0203 	movt	r2, #16387	; 0x4003
200078ea:	6c92      	ldr	r2, [r2, #72]	; 0x48
200078ec:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
200078f0:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
200078f2:	f04f 0003 	mov.w	r0, #3
200078f6:	f7ff ff61 	bl	200077bc <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
200078fa:	f248 0300 	movw	r3, #32768	; 0x8000
200078fe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007902:	f248 0200 	movw	r2, #32768	; 0x8000
20007906:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000790a:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000790c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20007910:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* De-assert reset bit. */
    this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20007912:	687b      	ldr	r3, [r7, #4]
20007914:	681b      	ldr	r3, [r3, #0]
20007916:	687a      	ldr	r2, [r7, #4]
20007918:	6812      	ldr	r2, [r2, #0]
2000791a:	6812      	ldr	r2, [r2, #0]
2000791c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20007920:	601a      	str	r2, [r3, #0]
}
20007922:	f107 0710 	add.w	r7, r7, #16
20007926:	46bd      	mov	sp, r7
20007928:	bd80      	pop	{r7, pc}
2000792a:	bf00      	nop

2000792c <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    mss_spi_instance_t * this_spi
)
{
2000792c:	b580      	push	{r7, lr}
2000792e:	b08a      	sub	sp, #40	; 0x28
20007930:	af00      	add	r7, sp, #0
20007932:	6078      	str	r0, [r7, #4]
    uint32_t slave_select;
    
    /*
     * Read current SPI hardware block configuration.
     */
    control_reg = this_spi->hw_reg->CONTROL;
20007934:	687b      	ldr	r3, [r7, #4]
20007936:	681b      	ldr	r3, [r3, #0]
20007938:	681b      	ldr	r3, [r3, #0]
2000793a:	60fb      	str	r3, [r7, #12]
    clk_gen = this_spi->hw_reg->CLK_GEN;
2000793c:	687b      	ldr	r3, [r7, #4]
2000793e:	681b      	ldr	r3, [r3, #0]
20007940:	699b      	ldr	r3, [r3, #24]
20007942:	613b      	str	r3, [r7, #16]
    frame_size = this_spi->hw_reg->TXRXDF_SIZE;
20007944:	687b      	ldr	r3, [r7, #4]
20007946:	681b      	ldr	r3, [r3, #0]
20007948:	685b      	ldr	r3, [r3, #4]
2000794a:	617b      	str	r3, [r7, #20]
    control2 = this_spi->hw_reg->CONTROL2;
2000794c:	687b      	ldr	r3, [r7, #4]
2000794e:	681b      	ldr	r3, [r3, #0]
20007950:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20007952:	61bb      	str	r3, [r7, #24]
    packet_size = this_spi->hw_reg->PKTSIZE;
20007954:	687b      	ldr	r3, [r7, #4]
20007956:	681b      	ldr	r3, [r3, #0]
20007958:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000795a:	61fb      	str	r3, [r7, #28]
    cmd_size = this_spi->hw_reg->CMDSIZE;
2000795c:	687b      	ldr	r3, [r7, #4]
2000795e:	681b      	ldr	r3, [r3, #0]
20007960:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20007962:	623b      	str	r3, [r7, #32]
    slave_select = this_spi->hw_reg->SLAVE_SELECT;
20007964:	687b      	ldr	r3, [r7, #4]
20007966:	681b      	ldr	r3, [r3, #0]
20007968:	69db      	ldr	r3, [r3, #28]
2000796a:	627b      	str	r3, [r7, #36]	; 0x24
     
    /*
     * Reset the SPI hardware block.
     */
    if(this_spi == &g_mss_spi0)
2000796c:	687a      	ldr	r2, [r7, #4]
2000796e:	f24d 5304 	movw	r3, #54532	; 0xd504
20007972:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007976:	429a      	cmp	r2, r3
20007978:	d12e      	bne.n	200079d8 <recover_from_rx_overflow+0xac>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
2000797a:	687a      	ldr	r2, [r7, #4]
2000797c:	f241 0300 	movw	r3, #4096	; 0x1000
20007980:	f2c4 0300 	movt	r3, #16384	; 0x4000
20007984:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20007986:	687b      	ldr	r3, [r7, #4]
20007988:	f04f 0202 	mov.w	r2, #2
2000798c:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
2000798e:	f248 0300 	movw	r3, #32768	; 0x8000
20007992:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007996:	f248 0200 	movw	r2, #32768	; 0x8000
2000799a:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000799e:	6c92      	ldr	r2, [r2, #72]	; 0x48
200079a0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200079a4:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
200079a6:	f04f 0002 	mov.w	r0, #2
200079aa:	f7ff ff07 	bl	200077bc <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
200079ae:	f248 0300 	movw	r3, #32768	; 0x8000
200079b2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200079b6:	f248 0200 	movw	r2, #32768	; 0x8000
200079ba:	f2c4 0203 	movt	r2, #16387	; 0x4003
200079be:	6c92      	ldr	r2, [r2, #72]	; 0x48
200079c0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
200079c4:	649a      	str	r2, [r3, #72]	; 0x48

        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
200079c6:	687b      	ldr	r3, [r7, #4]
200079c8:	681b      	ldr	r3, [r3, #0]
200079ca:	687a      	ldr	r2, [r7, #4]
200079cc:	6812      	ldr	r2, [r2, #0]
200079ce:	6812      	ldr	r2, [r2, #0]
200079d0:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
200079d4:	601a      	str	r2, [r3, #0]
200079d6:	e02d      	b.n	20007a34 <recover_from_rx_overflow+0x108>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
200079d8:	687a      	ldr	r2, [r7, #4]
200079da:	f241 0300 	movw	r3, #4096	; 0x1000
200079de:	f2c4 0301 	movt	r3, #16385	; 0x4001
200079e2:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
200079e4:	687b      	ldr	r3, [r7, #4]
200079e6:	f04f 0203 	mov.w	r2, #3
200079ea:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
200079ec:	f248 0300 	movw	r3, #32768	; 0x8000
200079f0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200079f4:	f248 0200 	movw	r2, #32768	; 0x8000
200079f8:	f2c4 0203 	movt	r2, #16387	; 0x4003
200079fc:	6c92      	ldr	r2, [r2, #72]	; 0x48
200079fe:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20007a02:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
20007a04:	f04f 0003 	mov.w	r0, #3
20007a08:	f7ff fed8 	bl	200077bc <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20007a0c:	f248 0300 	movw	r3, #32768	; 0x8000
20007a10:	f2c4 0303 	movt	r3, #16387	; 0x4003
20007a14:	f248 0200 	movw	r2, #32768	; 0x8000
20007a18:	f2c4 0203 	movt	r2, #16387	; 0x4003
20007a1c:	6c92      	ldr	r2, [r2, #72]	; 0x48
20007a1e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20007a22:	649a      	str	r2, [r3, #72]	; 0x48
        
        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20007a24:	687b      	ldr	r3, [r7, #4]
20007a26:	681b      	ldr	r3, [r3, #0]
20007a28:	687a      	ldr	r2, [r7, #4]
20007a2a:	6812      	ldr	r2, [r2, #0]
20007a2c:	6812      	ldr	r2, [r2, #0]
20007a2e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20007a32:	601a      	str	r2, [r3, #0]
    }
    
    /*
     * Restore SPI hardware block configuration.
     */
    control_reg &= ~(uint32_t)CTRL_ENABLE_MASK;
20007a34:	68fb      	ldr	r3, [r7, #12]
20007a36:	f023 0301 	bic.w	r3, r3, #1
20007a3a:	60fb      	str	r3, [r7, #12]
    this_spi->hw_reg->CONTROL = control_reg;
20007a3c:	687b      	ldr	r3, [r7, #4]
20007a3e:	681b      	ldr	r3, [r3, #0]
20007a40:	68fa      	ldr	r2, [r7, #12]
20007a42:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CLK_GEN = clk_gen;
20007a44:	687b      	ldr	r3, [r7, #4]
20007a46:	681b      	ldr	r3, [r3, #0]
20007a48:	693a      	ldr	r2, [r7, #16]
20007a4a:	619a      	str	r2, [r3, #24]
    this_spi->hw_reg->TXRXDF_SIZE = frame_size;
20007a4c:	687b      	ldr	r3, [r7, #4]
20007a4e:	681b      	ldr	r3, [r3, #0]
20007a50:	697a      	ldr	r2, [r7, #20]
20007a52:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20007a54:	687b      	ldr	r3, [r7, #4]
20007a56:	681b      	ldr	r3, [r3, #0]
20007a58:	687a      	ldr	r2, [r7, #4]
20007a5a:	6812      	ldr	r2, [r2, #0]
20007a5c:	6812      	ldr	r2, [r2, #0]
20007a5e:	f042 0201 	orr.w	r2, r2, #1
20007a62:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL2 = control2;
20007a64:	687b      	ldr	r3, [r7, #4]
20007a66:	681b      	ldr	r3, [r3, #0]
20007a68:	69ba      	ldr	r2, [r7, #24]
20007a6a:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->PKTSIZE = packet_size;
20007a6c:	687b      	ldr	r3, [r7, #4]
20007a6e:	681b      	ldr	r3, [r3, #0]
20007a70:	69fa      	ldr	r2, [r7, #28]
20007a72:	631a      	str	r2, [r3, #48]	; 0x30
    this_spi->hw_reg->CMDSIZE = cmd_size;
20007a74:	687b      	ldr	r3, [r7, #4]
20007a76:	681b      	ldr	r3, [r3, #0]
20007a78:	6a3a      	ldr	r2, [r7, #32]
20007a7a:	635a      	str	r2, [r3, #52]	; 0x34
    this_spi->hw_reg->SLAVE_SELECT = slave_select;
20007a7c:	687b      	ldr	r3, [r7, #4]
20007a7e:	681b      	ldr	r3, [r3, #0]
20007a80:	6a7a      	ldr	r2, [r7, #36]	; 0x24
20007a82:	61da      	str	r2, [r3, #28]
}
20007a84:	f107 0728 	add.w	r7, r7, #40	; 0x28
20007a88:	46bd      	mov	sp, r7
20007a8a:	bd80      	pop	{r7, pc}

20007a8c <MSS_SPI_configure_master_mode>:
    mss_spi_slave_t         slave,
    mss_spi_protocol_mode_t protocol_mode,
    uint32_t                clk_div,
    uint8_t                 frame_bit_length
)
{
20007a8c:	b580      	push	{r7, lr}
20007a8e:	b086      	sub	sp, #24
20007a90:	af00      	add	r7, sp, #0
20007a92:	60f8      	str	r0, [r7, #12]
20007a94:	607a      	str	r2, [r7, #4]
20007a96:	603b      	str	r3, [r7, #0]
20007a98:	460b      	mov	r3, r1
20007a9a:	72fb      	strb	r3, [r7, #11]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007a9c:	68fa      	ldr	r2, [r7, #12]
20007a9e:	f24d 5304 	movw	r3, #54532	; 0xd504
20007aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007aa6:	429a      	cmp	r2, r3
20007aa8:	d007      	beq.n	20007aba <MSS_SPI_configure_master_mode+0x2e>
20007aaa:	68fa      	ldr	r2, [r7, #12]
20007aac:	f24d 4380 	movw	r3, #54400	; 0xd480
20007ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007ab4:	429a      	cmp	r2, r3
20007ab6:	d000      	beq.n	20007aba <MSS_SPI_configure_master_mode+0x2e>
20007ab8:	be00      	bkpt	0x0000
    ASSERT(slave < MSS_SPI_MAX_NB_OF_SLAVES);
20007aba:	7afb      	ldrb	r3, [r7, #11]
20007abc:	2b07      	cmp	r3, #7
20007abe:	d900      	bls.n	20007ac2 <MSS_SPI_configure_master_mode+0x36>
20007ac0:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
20007ac2:	f897 3020 	ldrb.w	r3, [r7, #32]
20007ac6:	2b20      	cmp	r3, #32
20007ac8:	d900      	bls.n	20007acc <MSS_SPI_configure_master_mode+0x40>
20007aca:	be00      	bkpt	0x0000
     /* Check that the requested clock divider is within range and an even number. */
    ASSERT(clk_div >= 2u);
20007acc:	683b      	ldr	r3, [r7, #0]
20007ace:	2b01      	cmp	r3, #1
20007ad0:	d800      	bhi.n	20007ad4 <MSS_SPI_configure_master_mode+0x48>
20007ad2:	be00      	bkpt	0x0000
    ASSERT(clk_div <= 512u);
20007ad4:	683b      	ldr	r3, [r7, #0]
20007ad6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20007ada:	d900      	bls.n	20007ade <MSS_SPI_configure_master_mode+0x52>
20007adc:	be00      	bkpt	0x0000
    ASSERT(0u == (clk_div & 0x00000001));
20007ade:	683b      	ldr	r3, [r7, #0]
20007ae0:	f003 0301 	and.w	r3, r3, #1
20007ae4:	2b00      	cmp	r3, #0
20007ae6:	d000      	beq.n	20007aea <MSS_SPI_configure_master_mode+0x5e>
20007ae8:	be00      	bkpt	0x0000
   
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20007aea:	68fb      	ldr	r3, [r7, #12]
20007aec:	791b      	ldrb	r3, [r3, #4]
20007aee:	b25b      	sxtb	r3, r3
20007af0:	4618      	mov	r0, r3
20007af2:	f7ff fe45 	bl	20007780 <NVIC_DisableIRQ>

    /* Reset slave transfer mode to unknown to wipe slate clean */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
20007af6:	68fb      	ldr	r3, [r7, #12]
20007af8:	f04f 0200 	mov.w	r2, #0
20007afc:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20007b00:	68fb      	ldr	r3, [r7, #12]
20007b02:	681b      	ldr	r3, [r3, #0]
20007b04:	68fa      	ldr	r2, [r7, #12]
20007b06:	6812      	ldr	r2, [r2, #0]
20007b08:	6812      	ldr	r2, [r2, #0]
20007b0a:	f022 0201 	bic.w	r2, r2, #1
20007b0e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_MASTER_MASK;
20007b10:	68fb      	ldr	r3, [r7, #12]
20007b12:	681b      	ldr	r3, [r3, #0]
20007b14:	68fa      	ldr	r2, [r7, #12]
20007b16:	6812      	ldr	r2, [r2, #0]
20007b18:	6812      	ldr	r2, [r2, #0]
20007b1a:	f042 0202 	orr.w	r2, r2, #2
20007b1e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20007b20:	68fb      	ldr	r3, [r7, #12]
20007b22:	681b      	ldr	r3, [r3, #0]
20007b24:	68fa      	ldr	r2, [r7, #12]
20007b26:	6812      	ldr	r2, [r2, #0]
20007b28:	6812      	ldr	r2, [r2, #0]
20007b2a:	f042 0201 	orr.w	r2, r2, #1
20007b2e:	601a      	str	r2, [r3, #0]
    /*
     * Keep track of the required register configuration for this slave. These
     * values will be used by the MSS_SPI_set_slave_select() function to configure
     * the master to match the slave being selected.
     */
    if(slave < MSS_SPI_MAX_NB_OF_SLAVES)     
20007b30:	7afb      	ldrb	r3, [r7, #11]
20007b32:	2b07      	cmp	r3, #7
20007b34:	d847      	bhi.n	20007bc6 <MSS_SPI_configure_master_mode+0x13a>
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
20007b36:	687b      	ldr	r3, [r7, #4]
20007b38:	2b00      	cmp	r3, #0
20007b3a:	d00b      	beq.n	20007b54 <MSS_SPI_configure_master_mode+0xc8>
20007b3c:	687b      	ldr	r3, [r7, #4]
20007b3e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
20007b42:	d007      	beq.n	20007b54 <MSS_SPI_configure_master_mode+0xc8>
20007b44:	687b      	ldr	r3, [r7, #4]
20007b46:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20007b4a:	d003      	beq.n	20007b54 <MSS_SPI_configure_master_mode+0xc8>
20007b4c:	687b      	ldr	r3, [r7, #4]
20007b4e:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
20007b52:	d10f      	bne.n	20007b74 <MSS_SPI_configure_master_mode+0xe8>
           (MSS_SPI_MODE2 == protocol_mode) || (MSS_SPI_MODE3 == protocol_mode))
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK | SPS_MASK |
20007b54:	7afa      	ldrb	r2, [r7, #11]
20007b56:	6879      	ldr	r1, [r7, #4]
20007b58:	f240 1302 	movw	r3, #258	; 0x102
20007b5c:	f2c3 4300 	movt	r3, #13312	; 0x3400
20007b60:	ea41 0303 	orr.w	r3, r1, r3
20007b64:	68f9      	ldr	r1, [r7, #12]
20007b66:	f102 0206 	add.w	r2, r2, #6
20007b6a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
20007b6e:	440a      	add	r2, r1
20007b70:	6053      	str	r3, [r2, #4]
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
20007b72:	e00e      	b.n	20007b92 <MSS_SPI_configure_master_mode+0x106>
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        else
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK |
20007b74:	7afa      	ldrb	r2, [r7, #11]
20007b76:	6879      	ldr	r1, [r7, #4]
20007b78:	f240 1302 	movw	r3, #258	; 0x102
20007b7c:	f2c3 0300 	movt	r3, #12288	; 0x3000
20007b80:	ea41 0303 	orr.w	r3, r1, r3
20007b84:	68f9      	ldr	r1, [r7, #12]
20007b86:	f102 0206 	add.w	r2, r2, #6
20007b8a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
20007b8e:	440a      	add	r2, r1
20007b90:	6053      	str	r3, [r2, #4]
                                                   BIGFIFO_MASK | CTRL_CLKMODE_MASK |
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        this_spi->slaves_cfg[slave].txrxdf_size_reg = frame_bit_length;
20007b92:	7afb      	ldrb	r3, [r7, #11]
20007b94:	68fa      	ldr	r2, [r7, #12]
20007b96:	f103 0306 	add.w	r3, r3, #6
20007b9a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007b9e:	4413      	add	r3, r2
20007ba0:	f897 2020 	ldrb.w	r2, [r7, #32]
20007ba4:	721a      	strb	r2, [r3, #8]

        clk_gen = (clk_div / 2u) - 1u;
20007ba6:	683b      	ldr	r3, [r7, #0]
20007ba8:	ea4f 0353 	mov.w	r3, r3, lsr #1
20007bac:	f103 33ff 	add.w	r3, r3, #4294967295
20007bb0:	617b      	str	r3, [r7, #20]
        this_spi->slaves_cfg[slave].clk_gen = (uint8_t)clk_gen;
20007bb2:	7afb      	ldrb	r3, [r7, #11]
20007bb4:	697a      	ldr	r2, [r7, #20]
20007bb6:	b2d2      	uxtb	r2, r2
20007bb8:	68f9      	ldr	r1, [r7, #12]
20007bba:	f103 0306 	add.w	r3, r3, #6
20007bbe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007bc2:	440b      	add	r3, r1
20007bc4:	725a      	strb	r2, [r3, #9]
    }
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20007bc6:	68fb      	ldr	r3, [r7, #12]
20007bc8:	791b      	ldrb	r3, [r3, #4]
20007bca:	b25b      	sxtb	r3, r3
20007bcc:	4618      	mov	r0, r3
20007bce:	f7ff fdbb 	bl	20007748 <NVIC_EnableIRQ>
}
20007bd2:	f107 0718 	add.w	r7, r7, #24
20007bd6:	46bd      	mov	sp, r7
20007bd8:	bd80      	pop	{r7, pc}
20007bda:	bf00      	nop

20007bdc <MSS_SPI_set_slave_select>:
void MSS_SPI_set_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
20007bdc:	b580      	push	{r7, lr}
20007bde:	b084      	sub	sp, #16
20007be0:	af00      	add	r7, sp, #0
20007be2:	6078      	str	r0, [r7, #4]
20007be4:	460b      	mov	r3, r1
20007be6:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007be8:	687a      	ldr	r2, [r7, #4]
20007bea:	f24d 5304 	movw	r3, #54532	; 0xd504
20007bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007bf2:	429a      	cmp	r2, r3
20007bf4:	d007      	beq.n	20007c06 <MSS_SPI_set_slave_select+0x2a>
20007bf6:	687a      	ldr	r2, [r7, #4]
20007bf8:	f24d 4380 	movw	r3, #54400	; 0xd480
20007bfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007c00:	429a      	cmp	r2, r3
20007c02:	d000      	beq.n	20007c06 <MSS_SPI_set_slave_select+0x2a>
20007c04:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20007c06:	687b      	ldr	r3, [r7, #4]
20007c08:	681b      	ldr	r3, [r3, #0]
20007c0a:	681b      	ldr	r3, [r3, #0]
20007c0c:	f003 0302 	and.w	r3, r3, #2
20007c10:	2b00      	cmp	r3, #0
20007c12:	d100      	bne.n	20007c16 <MSS_SPI_set_slave_select+0x3a>
20007c14:	be00      	bkpt	0x0000
    
    ASSERT(this_spi->slaves_cfg[slave].ctrl_reg != NOT_CONFIGURED);
20007c16:	78fb      	ldrb	r3, [r7, #3]
20007c18:	687a      	ldr	r2, [r7, #4]
20007c1a:	f103 0306 	add.w	r3, r3, #6
20007c1e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007c22:	4413      	add	r3, r2
20007c24:	685b      	ldr	r3, [r3, #4]
20007c26:	f1b3 3fff 	cmp.w	r3, #4294967295
20007c2a:	d100      	bne.n	20007c2e <MSS_SPI_set_slave_select+0x52>
20007c2c:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20007c2e:	687b      	ldr	r3, [r7, #4]
20007c30:	791b      	ldrb	r3, [r3, #4]
20007c32:	b25b      	sxtb	r3, r3
20007c34:	4618      	mov	r0, r3
20007c36:	f7ff fda3 	bl	20007780 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20007c3a:	687b      	ldr	r3, [r7, #4]
20007c3c:	681b      	ldr	r3, [r3, #0]
20007c3e:	689b      	ldr	r3, [r3, #8]
20007c40:	f003 0304 	and.w	r3, r3, #4
20007c44:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
20007c46:	68fb      	ldr	r3, [r7, #12]
20007c48:	2b00      	cmp	r3, #0
20007c4a:	d002      	beq.n	20007c52 <MSS_SPI_set_slave_select+0x76>
    {
         recover_from_rx_overflow(this_spi);
20007c4c:	6878      	ldr	r0, [r7, #4]
20007c4e:	f7ff fe6d 	bl	2000792c <recover_from_rx_overflow>
    }
    
    /* Set the clock rate. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20007c52:	687b      	ldr	r3, [r7, #4]
20007c54:	681b      	ldr	r3, [r3, #0]
20007c56:	687a      	ldr	r2, [r7, #4]
20007c58:	6812      	ldr	r2, [r2, #0]
20007c5a:	6812      	ldr	r2, [r2, #0]
20007c5c:	f022 0201 	bic.w	r2, r2, #1
20007c60:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = this_spi->slaves_cfg[slave].ctrl_reg;
20007c62:	687b      	ldr	r3, [r7, #4]
20007c64:	681a      	ldr	r2, [r3, #0]
20007c66:	78fb      	ldrb	r3, [r7, #3]
20007c68:	6879      	ldr	r1, [r7, #4]
20007c6a:	f103 0306 	add.w	r3, r3, #6
20007c6e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007c72:	440b      	add	r3, r1
20007c74:	685b      	ldr	r3, [r3, #4]
20007c76:	6013      	str	r3, [r2, #0]
    this_spi->hw_reg->CLK_GEN = this_spi->slaves_cfg[slave].clk_gen;
20007c78:	687b      	ldr	r3, [r7, #4]
20007c7a:	681a      	ldr	r2, [r3, #0]
20007c7c:	78fb      	ldrb	r3, [r7, #3]
20007c7e:	6879      	ldr	r1, [r7, #4]
20007c80:	f103 0306 	add.w	r3, r3, #6
20007c84:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007c88:	440b      	add	r3, r1
20007c8a:	7a5b      	ldrb	r3, [r3, #9]
20007c8c:	6193      	str	r3, [r2, #24]
    this_spi->hw_reg->TXRXDF_SIZE = this_spi->slaves_cfg[slave].txrxdf_size_reg;
20007c8e:	687b      	ldr	r3, [r7, #4]
20007c90:	681a      	ldr	r2, [r3, #0]
20007c92:	78fb      	ldrb	r3, [r7, #3]
20007c94:	6879      	ldr	r1, [r7, #4]
20007c96:	f103 0306 	add.w	r3, r3, #6
20007c9a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20007c9e:	440b      	add	r3, r1
20007ca0:	7a1b      	ldrb	r3, [r3, #8]
20007ca2:	6053      	str	r3, [r2, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20007ca4:	687b      	ldr	r3, [r7, #4]
20007ca6:	681b      	ldr	r3, [r3, #0]
20007ca8:	687a      	ldr	r2, [r7, #4]
20007caa:	6812      	ldr	r2, [r2, #0]
20007cac:	6812      	ldr	r2, [r2, #0]
20007cae:	f042 0201 	orr.w	r2, r2, #1
20007cb2:	601a      	str	r2, [r3, #0]
    
    /* Set slave select */
    this_spi->hw_reg->SLAVE_SELECT |= ((uint32_t)1 << (uint32_t)slave);
20007cb4:	687b      	ldr	r3, [r7, #4]
20007cb6:	681b      	ldr	r3, [r3, #0]
20007cb8:	687a      	ldr	r2, [r7, #4]
20007cba:	6812      	ldr	r2, [r2, #0]
20007cbc:	69d1      	ldr	r1, [r2, #28]
20007cbe:	78fa      	ldrb	r2, [r7, #3]
20007cc0:	f04f 0001 	mov.w	r0, #1
20007cc4:	fa00 f202 	lsl.w	r2, r0, r2
20007cc8:	ea41 0202 	orr.w	r2, r1, r2
20007ccc:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20007cce:	687b      	ldr	r3, [r7, #4]
20007cd0:	791b      	ldrb	r3, [r3, #4]
20007cd2:	b25b      	sxtb	r3, r3
20007cd4:	4618      	mov	r0, r3
20007cd6:	f7ff fd37 	bl	20007748 <NVIC_EnableIRQ>
}
20007cda:	f107 0710 	add.w	r7, r7, #16
20007cde:	46bd      	mov	sp, r7
20007ce0:	bd80      	pop	{r7, pc}
20007ce2:	bf00      	nop

20007ce4 <MSS_SPI_clear_slave_select>:
void MSS_SPI_clear_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
20007ce4:	b580      	push	{r7, lr}
20007ce6:	b084      	sub	sp, #16
20007ce8:	af00      	add	r7, sp, #0
20007cea:	6078      	str	r0, [r7, #4]
20007cec:	460b      	mov	r3, r1
20007cee:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007cf0:	687a      	ldr	r2, [r7, #4]
20007cf2:	f24d 5304 	movw	r3, #54532	; 0xd504
20007cf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007cfa:	429a      	cmp	r2, r3
20007cfc:	d007      	beq.n	20007d0e <MSS_SPI_clear_slave_select+0x2a>
20007cfe:	687a      	ldr	r2, [r7, #4]
20007d00:	f24d 4380 	movw	r3, #54400	; 0xd480
20007d04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007d08:	429a      	cmp	r2, r3
20007d0a:	d000      	beq.n	20007d0e <MSS_SPI_clear_slave_select+0x2a>
20007d0c:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20007d0e:	687b      	ldr	r3, [r7, #4]
20007d10:	681b      	ldr	r3, [r3, #0]
20007d12:	681b      	ldr	r3, [r3, #0]
20007d14:	f003 0302 	and.w	r3, r3, #2
20007d18:	2b00      	cmp	r3, #0
20007d1a:	d100      	bne.n	20007d1e <MSS_SPI_clear_slave_select+0x3a>
20007d1c:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20007d1e:	687b      	ldr	r3, [r7, #4]
20007d20:	791b      	ldrb	r3, [r3, #4]
20007d22:	b25b      	sxtb	r3, r3
20007d24:	4618      	mov	r0, r3
20007d26:	f7ff fd2b 	bl	20007780 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20007d2a:	687b      	ldr	r3, [r7, #4]
20007d2c:	681b      	ldr	r3, [r3, #0]
20007d2e:	689b      	ldr	r3, [r3, #8]
20007d30:	f003 0304 	and.w	r3, r3, #4
20007d34:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
20007d36:	68fb      	ldr	r3, [r7, #12]
20007d38:	2b00      	cmp	r3, #0
20007d3a:	d002      	beq.n	20007d42 <MSS_SPI_clear_slave_select+0x5e>
    {
         recover_from_rx_overflow(this_spi);
20007d3c:	6878      	ldr	r0, [r7, #4]
20007d3e:	f7ff fdf5 	bl	2000792c <recover_from_rx_overflow>
    }
    
    this_spi->hw_reg->SLAVE_SELECT &= ~((uint32_t)1 << (uint32_t)slave);
20007d42:	687b      	ldr	r3, [r7, #4]
20007d44:	681b      	ldr	r3, [r3, #0]
20007d46:	687a      	ldr	r2, [r7, #4]
20007d48:	6812      	ldr	r2, [r2, #0]
20007d4a:	69d1      	ldr	r1, [r2, #28]
20007d4c:	78fa      	ldrb	r2, [r7, #3]
20007d4e:	f04f 0001 	mov.w	r0, #1
20007d52:	fa00 f202 	lsl.w	r2, r0, r2
20007d56:	ea6f 0202 	mvn.w	r2, r2
20007d5a:	ea01 0202 	and.w	r2, r1, r2
20007d5e:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20007d60:	687b      	ldr	r3, [r7, #4]
20007d62:	791b      	ldrb	r3, [r3, #4]
20007d64:	b25b      	sxtb	r3, r3
20007d66:	4618      	mov	r0, r3
20007d68:	f7ff fcee 	bl	20007748 <NVIC_EnableIRQ>
}
20007d6c:	f107 0710 	add.w	r7, r7, #16
20007d70:	46bd      	mov	sp, r7
20007d72:	bd80      	pop	{r7, pc}

20007d74 <MSS_SPI_transfer_frame>:
uint32_t MSS_SPI_transfer_frame
(
    mss_spi_instance_t * this_spi,
    uint32_t tx_bits
)
{
20007d74:	b480      	push	{r7}
20007d76:	b085      	sub	sp, #20
20007d78:	af00      	add	r7, sp, #0
20007d7a:	6078      	str	r0, [r7, #4]
20007d7c:	6039      	str	r1, [r7, #0]
    uint32_t rx_ready;
    uint32_t tx_done;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007d7e:	687a      	ldr	r2, [r7, #4]
20007d80:	f24d 5304 	movw	r3, #54532	; 0xd504
20007d84:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007d88:	429a      	cmp	r2, r3
20007d8a:	d007      	beq.n	20007d9c <MSS_SPI_transfer_frame+0x28>
20007d8c:	687a      	ldr	r2, [r7, #4]
20007d8e:	f24d 4380 	movw	r3, #54400	; 0xd480
20007d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007d96:	429a      	cmp	r2, r3
20007d98:	d000      	beq.n	20007d9c <MSS_SPI_transfer_frame+0x28>
20007d9a:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20007d9c:	687b      	ldr	r3, [r7, #4]
20007d9e:	681b      	ldr	r3, [r3, #0]
20007da0:	681b      	ldr	r3, [r3, #0]
20007da2:	f003 0302 	and.w	r3, r3, #2
20007da6:	2b00      	cmp	r3, #0
20007da8:	d100      	bne.n	20007dac <MSS_SPI_transfer_frame+0x38>
20007daa:	be00      	bkpt	0x0000
    
    /* Ensure single frame transfer selected so interrupts work correctly */
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20007dac:	687b      	ldr	r3, [r7, #4]
20007dae:	681a      	ldr	r2, [r3, #0]
20007db0:	687b      	ldr	r3, [r7, #4]
20007db2:	681b      	ldr	r3, [r3, #0]
20007db4:	6819      	ldr	r1, [r3, #0]
20007db6:	f240 03ff 	movw	r3, #255	; 0xff
20007dba:	f6cf 7300 	movt	r3, #65280	; 0xff00
20007dbe:	ea01 0303 	and.w	r3, r1, r3
20007dc2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20007dc6:	6013      	str	r3, [r2, #0]
                                | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20007dc8:	687b      	ldr	r3, [r7, #4]
20007dca:	681b      	ldr	r3, [r3, #0]
20007dcc:	687a      	ldr	r2, [r7, #4]
20007dce:	6812      	ldr	r2, [r2, #0]
20007dd0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20007dd2:	f042 020c 	orr.w	r2, r2, #12
20007dd6:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
20007dd8:	687b      	ldr	r3, [r7, #4]
20007dda:	681b      	ldr	r3, [r3, #0]
20007ddc:	683a      	ldr	r2, [r7, #0]
20007dde:	615a      	str	r2, [r3, #20]
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
20007de0:	687b      	ldr	r3, [r7, #4]
20007de2:	681b      	ldr	r3, [r3, #0]
20007de4:	689b      	ldr	r3, [r3, #8]
20007de6:	f003 0301 	and.w	r3, r3, #1
20007dea:	60fb      	str	r3, [r7, #12]
    while(0u == tx_done)
20007dec:	e005      	b.n	20007dfa <MSS_SPI_transfer_frame+0x86>
    {
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
20007dee:	687b      	ldr	r3, [r7, #4]
20007df0:	681b      	ldr	r3, [r3, #0]
20007df2:	689b      	ldr	r3, [r3, #8]
20007df4:	f003 0301 	and.w	r3, r3, #1
20007df8:	60fb      	str	r3, [r7, #12]
    /* Send frame. */
    this_spi->hw_reg->TX_DATA = tx_bits;
    
    /* Wait for frame Tx to complete. */
    tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    while(0u == tx_done)
20007dfa:	68fb      	ldr	r3, [r7, #12]
20007dfc:	2b00      	cmp	r3, #0
20007dfe:	d0f6      	beq.n	20007dee <MSS_SPI_transfer_frame+0x7a>
        tx_done = this_spi->hw_reg->STATUS & TX_DONE_MASK;
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
20007e00:	687b      	ldr	r3, [r7, #4]
20007e02:	681b      	ldr	r3, [r3, #0]
20007e04:	689b      	ldr	r3, [r3, #8]
20007e06:	f003 0302 	and.w	r3, r3, #2
20007e0a:	60bb      	str	r3, [r7, #8]
    while(0u == rx_ready)
20007e0c:	e005      	b.n	20007e1a <MSS_SPI_transfer_frame+0xa6>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
20007e0e:	687b      	ldr	r3, [r7, #4]
20007e10:	681b      	ldr	r3, [r3, #0]
20007e12:	689b      	ldr	r3, [r3, #8]
20007e14:	f003 0302 	and.w	r3, r3, #2
20007e18:	60bb      	str	r3, [r7, #8]
    }
    
    /* Read received frame. */
    /* Wait for Rx complete. */
    rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    while(0u == rx_ready)
20007e1a:	68bb      	ldr	r3, [r7, #8]
20007e1c:	2b00      	cmp	r3, #0
20007e1e:	d0f6      	beq.n	20007e0e <MSS_SPI_transfer_frame+0x9a>
    {
        rx_ready = this_spi->hw_reg->STATUS & RX_DATA_READY_MASK;
    }
    /* Return Rx data. */
    return( this_spi->hw_reg->RX_DATA );
20007e20:	687b      	ldr	r3, [r7, #4]
20007e22:	681b      	ldr	r3, [r3, #0]
20007e24:	691b      	ldr	r3, [r3, #16]
}
20007e26:	4618      	mov	r0, r3
20007e28:	f107 0714 	add.w	r7, r7, #20
20007e2c:	46bd      	mov	sp, r7
20007e2e:	bc80      	pop	{r7}
20007e30:	4770      	bx	lr
20007e32:	bf00      	nop

20007e34 <MSS_SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rd_buffer,
    uint16_t rd_byte_size
)
{
20007e34:	b580      	push	{r7, lr}
20007e36:	b08e      	sub	sp, #56	; 0x38
20007e38:	af00      	add	r7, sp, #0
20007e3a:	60f8      	str	r0, [r7, #12]
20007e3c:	60b9      	str	r1, [r7, #8]
20007e3e:	603b      	str	r3, [r7, #0]
20007e40:	4613      	mov	r3, r2
20007e42:	80fb      	strh	r3, [r7, #6]
    uint16_t transfer_idx = 0u;
20007e44:	f04f 0300 	mov.w	r3, #0
20007e48:	837b      	strh	r3, [r7, #26]
    uint16_t tx_idx;
    uint16_t rx_idx;
    uint32_t frame_count;
    volatile uint32_t rx_raw;
    uint16_t transit = 0u;
20007e4a:	f04f 0300 	mov.w	r3, #0
20007e4e:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint32_t rx_overflow;
    uint32_t rx_fifo_empty;
    
    uint16_t transfer_size;     /* Total number of bytes transfered. */
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20007e50:	68fa      	ldr	r2, [r7, #12]
20007e52:	f24d 5304 	movw	r3, #54532	; 0xd504
20007e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007e5a:	429a      	cmp	r2, r3
20007e5c:	d007      	beq.n	20007e6e <MSS_SPI_transfer_block+0x3a>
20007e5e:	68fa      	ldr	r2, [r7, #12]
20007e60:	f24d 4380 	movw	r3, #54400	; 0xd480
20007e64:	f2c2 0300 	movt	r3, #8192	; 0x2000
20007e68:	429a      	cmp	r2, r3
20007e6a:	d000      	beq.n	20007e6e <MSS_SPI_transfer_block+0x3a>
20007e6c:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20007e6e:	68fb      	ldr	r3, [r7, #12]
20007e70:	681b      	ldr	r3, [r3, #0]
20007e72:	681b      	ldr	r3, [r3, #0]
20007e74:	f003 0302 	and.w	r3, r3, #2
20007e78:	2b00      	cmp	r3, #0
20007e7a:	d100      	bne.n	20007e7e <MSS_SPI_transfer_block+0x4a>
20007e7c:	be00      	bkpt	0x0000
    
    /* Compute number of bytes to transfer. */
    transfer_size = cmd_byte_size + rd_byte_size;
20007e7e:	88fa      	ldrh	r2, [r7, #6]
20007e80:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
20007e84:	4413      	add	r3, r2
20007e86:	86fb      	strh	r3, [r7, #54]	; 0x36
    
    /* Adjust to 1 byte transfer to cater for DMA transfers. */
    if(0u == transfer_size)
20007e88:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20007e8a:	2b00      	cmp	r3, #0
20007e8c:	d103      	bne.n	20007e96 <MSS_SPI_transfer_block+0x62>
    {
        frame_count = 1u;
20007e8e:	f04f 0301 	mov.w	r3, #1
20007e92:	623b      	str	r3, [r7, #32]
20007e94:	e001      	b.n	20007e9a <MSS_SPI_transfer_block+0x66>
    }
    else
    {
        frame_count = transfer_size;
20007e96:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20007e98:	623b      	str	r3, [r7, #32]
    }

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20007e9a:	68fb      	ldr	r3, [r7, #12]
20007e9c:	681b      	ldr	r3, [r3, #0]
20007e9e:	68fa      	ldr	r2, [r7, #12]
20007ea0:	6812      	ldr	r2, [r2, #0]
20007ea2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20007ea4:	f042 020c 	orr.w	r2, r2, #12
20007ea8:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20007eaa:	68fb      	ldr	r3, [r7, #12]
20007eac:	681b      	ldr	r3, [r3, #0]
20007eae:	689b      	ldr	r3, [r3, #8]
20007eb0:	f003 0304 	and.w	r3, r3, #4
20007eb4:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(rx_overflow)
20007eb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20007eb8:	2b00      	cmp	r3, #0
20007eba:	d002      	beq.n	20007ec2 <MSS_SPI_transfer_block+0x8e>
    {
         recover_from_rx_overflow(this_spi);
20007ebc:	68f8      	ldr	r0, [r7, #12]
20007ebe:	f7ff fd35 	bl	2000792c <recover_from_rx_overflow>
    }
    
    /* Set frame size to 8 bits and the frame count to the transfer size. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20007ec2:	68fb      	ldr	r3, [r7, #12]
20007ec4:	681b      	ldr	r3, [r3, #0]
20007ec6:	68fa      	ldr	r2, [r7, #12]
20007ec8:	6812      	ldr	r2, [r2, #0]
20007eca:	6812      	ldr	r2, [r2, #0]
20007ecc:	f022 0201 	bic.w	r2, r2, #1
20007ed0:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
20007ed2:	68fb      	ldr	r3, [r7, #12]
20007ed4:	6819      	ldr	r1, [r3, #0]
20007ed6:	68fb      	ldr	r3, [r7, #12]
20007ed8:	681b      	ldr	r3, [r3, #0]
20007eda:	681b      	ldr	r3, [r3, #0]
20007edc:	f240 02ff 	movw	r2, #255	; 0xff
20007ee0:	f6cf 7200 	movt	r2, #65280	; 0xff00
20007ee4:	ea03 0202 	and.w	r2, r3, r2
20007ee8:	6a3b      	ldr	r3, [r7, #32]
20007eea:	ea4f 2003 	mov.w	r0, r3, lsl #8
20007eee:	f64f 7300 	movw	r3, #65280	; 0xff00
20007ef2:	f2c0 03ff 	movt	r3, #255	; 0xff
20007ef6:	ea00 0303 	and.w	r3, r0, r3
20007efa:	ea42 0303 	orr.w	r3, r2, r3
20007efe:	600b      	str	r3, [r1, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
20007f00:	68fb      	ldr	r3, [r7, #12]
20007f02:	681b      	ldr	r3, [r3, #0]
20007f04:	f04f 0208 	mov.w	r2, #8
20007f08:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20007f0a:	68fb      	ldr	r3, [r7, #12]
20007f0c:	681b      	ldr	r3, [r3, #0]
20007f0e:	68fa      	ldr	r2, [r7, #12]
20007f10:	6812      	ldr	r2, [r2, #0]
20007f12:	6812      	ldr	r2, [r2, #0]
20007f14:	f042 0201 	orr.w	r2, r2, #1
20007f18:	601a      	str	r2, [r3, #0]

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20007f1a:	68fb      	ldr	r3, [r7, #12]
20007f1c:	681b      	ldr	r3, [r3, #0]
20007f1e:	689b      	ldr	r3, [r3, #8]
20007f20:	f003 0340 	and.w	r3, r3, #64	; 0x40
20007f24:	633b      	str	r3, [r7, #48]	; 0x30
    while(0u == rx_fifo_empty)
20007f26:	e009      	b.n	20007f3c <MSS_SPI_transfer_block+0x108>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
20007f28:	68fb      	ldr	r3, [r7, #12]
20007f2a:	681b      	ldr	r3, [r3, #0]
20007f2c:	691b      	ldr	r3, [r3, #16]
20007f2e:	617b      	str	r3, [r7, #20]
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20007f30:	68fb      	ldr	r3, [r7, #12]
20007f32:	681b      	ldr	r3, [r3, #0]
20007f34:	689b      	ldr	r3, [r3, #8]
20007f36:	f003 0340 	and.w	r3, r3, #64	; 0x40
20007f3a:	633b      	str	r3, [r7, #48]	; 0x30
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    while(0u == rx_fifo_empty)
20007f3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20007f3e:	2b00      	cmp	r3, #0
20007f40:	d0f2      	beq.n	20007f28 <MSS_SPI_transfer_block+0xf4>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    }
    
    tx_idx = 0u;
20007f42:	f04f 0300 	mov.w	r3, #0
20007f46:	83bb      	strh	r3, [r7, #28]
    rx_idx = 0u;
20007f48:	f04f 0300 	mov.w	r3, #0
20007f4c:	83fb      	strh	r3, [r7, #30]
    if(tx_idx < cmd_byte_size)
20007f4e:	8bba      	ldrh	r2, [r7, #28]
20007f50:	88fb      	ldrh	r3, [r7, #6]
20007f52:	429a      	cmp	r2, r3
20007f54:	d20f      	bcs.n	20007f76 <MSS_SPI_transfer_block+0x142>
    {
        this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
20007f56:	68fb      	ldr	r3, [r7, #12]
20007f58:	681b      	ldr	r3, [r3, #0]
20007f5a:	8bb9      	ldrh	r1, [r7, #28]
20007f5c:	68ba      	ldr	r2, [r7, #8]
20007f5e:	440a      	add	r2, r1
20007f60:	7812      	ldrb	r2, [r2, #0]
20007f62:	615a      	str	r2, [r3, #20]
        ++tx_idx;
20007f64:	8bbb      	ldrh	r3, [r7, #28]
20007f66:	f103 0301 	add.w	r3, r3, #1
20007f6a:	83bb      	strh	r3, [r7, #28]
        ++transit;
20007f6c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20007f6e:	f103 0301 	add.w	r3, r3, #1
20007f72:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20007f74:	e06a      	b.n	2000804c <MSS_SPI_transfer_block+0x218>
        ++tx_idx;
        ++transit;
    }
    else
    {
        if(tx_idx < transfer_size)
20007f76:	8bba      	ldrh	r2, [r7, #28]
20007f78:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20007f7a:	429a      	cmp	r2, r3
20007f7c:	d266      	bcs.n	2000804c <MSS_SPI_transfer_block+0x218>
        {
            this_spi->hw_reg->TX_DATA = 0x00u;
20007f7e:	68fb      	ldr	r3, [r7, #12]
20007f80:	681b      	ldr	r3, [r3, #0]
20007f82:	f04f 0200 	mov.w	r2, #0
20007f86:	615a      	str	r2, [r3, #20]
            ++tx_idx;
20007f88:	8bbb      	ldrh	r3, [r7, #28]
20007f8a:	f103 0301 	add.w	r3, r3, #1
20007f8e:	83bb      	strh	r3, [r7, #28]
            ++transit;
20007f90:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20007f92:	f103 0301 	add.w	r3, r3, #1
20007f96:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20007f98:	e058      	b.n	2000804c <MSS_SPI_transfer_block+0x218>
    {
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20007f9a:	68fb      	ldr	r3, [r7, #12]
20007f9c:	681b      	ldr	r3, [r3, #0]
20007f9e:	689b      	ldr	r3, [r3, #8]
20007fa0:	f003 0340 	and.w	r3, r3, #64	; 0x40
20007fa4:	633b      	str	r3, [r7, #48]	; 0x30
        if(0u == rx_fifo_empty)
20007fa6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20007fa8:	2b00      	cmp	r3, #0
20007faa:	d11e      	bne.n	20007fea <MSS_SPI_transfer_block+0x1b6>
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;
20007fac:	68fb      	ldr	r3, [r7, #12]
20007fae:	681b      	ldr	r3, [r3, #0]
20007fb0:	691b      	ldr	r3, [r3, #16]
20007fb2:	617b      	str	r3, [r7, #20]
            if(transfer_idx >= cmd_byte_size)
20007fb4:	8b7a      	ldrh	r2, [r7, #26]
20007fb6:	88fb      	ldrh	r3, [r7, #6]
20007fb8:	429a      	cmp	r2, r3
20007fba:	d30e      	bcc.n	20007fda <MSS_SPI_transfer_block+0x1a6>
            {
                if(rx_idx < rd_byte_size)
20007fbc:	8bfa      	ldrh	r2, [r7, #30]
20007fbe:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
20007fc2:	429a      	cmp	r2, r3
20007fc4:	d205      	bcs.n	20007fd2 <MSS_SPI_transfer_block+0x19e>
                {
                    rd_buffer[rx_idx] = (uint8_t)rx_raw;   
20007fc6:	8bfa      	ldrh	r2, [r7, #30]
20007fc8:	683b      	ldr	r3, [r7, #0]
20007fca:	4413      	add	r3, r2
20007fcc:	697a      	ldr	r2, [r7, #20]
20007fce:	b2d2      	uxtb	r2, r2
20007fd0:	701a      	strb	r2, [r3, #0]
                }
                ++rx_idx;
20007fd2:	8bfb      	ldrh	r3, [r7, #30]
20007fd4:	f103 0301 	add.w	r3, r3, #1
20007fd8:	83fb      	strh	r3, [r7, #30]
            }
            ++transfer_idx;
20007fda:	8b7b      	ldrh	r3, [r7, #26]
20007fdc:	f103 0301 	add.w	r3, r3, #1
20007fe0:	837b      	strh	r3, [r7, #26]
            --transit;
20007fe2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20007fe4:	f103 33ff 	add.w	r3, r3, #4294967295
20007fe8:	84fb      	strh	r3, [r7, #38]	; 0x26
        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
20007fea:	68fb      	ldr	r3, [r7, #12]
20007fec:	681b      	ldr	r3, [r3, #0]
20007fee:	689b      	ldr	r3, [r3, #8]
20007ff0:	f403 7380 	and.w	r3, r3, #256	; 0x100
20007ff4:	62bb      	str	r3, [r7, #40]	; 0x28
        if(0u == tx_fifo_full)
20007ff6:	6abb      	ldr	r3, [r7, #40]	; 0x28
20007ff8:	2b00      	cmp	r3, #0
20007ffa:	d127      	bne.n	2000804c <MSS_SPI_transfer_block+0x218>
        {
            if(transit < RX_FIFO_SIZE)
20007ffc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20007ffe:	2b03      	cmp	r3, #3
20008000:	d824      	bhi.n	2000804c <MSS_SPI_transfer_block+0x218>
            {
                /* Send another byte. */
                if(tx_idx < cmd_byte_size)
20008002:	8bba      	ldrh	r2, [r7, #28]
20008004:	88fb      	ldrh	r3, [r7, #6]
20008006:	429a      	cmp	r2, r3
20008008:	d20f      	bcs.n	2000802a <MSS_SPI_transfer_block+0x1f6>
                {
                    this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
2000800a:	68fb      	ldr	r3, [r7, #12]
2000800c:	681b      	ldr	r3, [r3, #0]
2000800e:	8bb9      	ldrh	r1, [r7, #28]
20008010:	68ba      	ldr	r2, [r7, #8]
20008012:	440a      	add	r2, r1
20008014:	7812      	ldrb	r2, [r2, #0]
20008016:	615a      	str	r2, [r3, #20]
                    ++tx_idx;
20008018:	8bbb      	ldrh	r3, [r7, #28]
2000801a:	f103 0301 	add.w	r3, r3, #1
2000801e:	83bb      	strh	r3, [r7, #28]
                    ++transit;
20008020:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20008022:	f103 0301 	add.w	r3, r3, #1
20008026:	84fb      	strh	r3, [r7, #38]	; 0x26
20008028:	e010      	b.n	2000804c <MSS_SPI_transfer_block+0x218>
                }
                else
                {
                    if(tx_idx < transfer_size)
2000802a:	8bba      	ldrh	r2, [r7, #28]
2000802c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000802e:	429a      	cmp	r2, r3
20008030:	d20c      	bcs.n	2000804c <MSS_SPI_transfer_block+0x218>
                    {
                        this_spi->hw_reg->TX_DATA = 0x00u;
20008032:	68fb      	ldr	r3, [r7, #12]
20008034:	681b      	ldr	r3, [r3, #0]
20008036:	f04f 0200 	mov.w	r2, #0
2000803a:	615a      	str	r2, [r3, #20]
                        ++tx_idx;
2000803c:	8bbb      	ldrh	r3, [r7, #28]
2000803e:	f103 0301 	add.w	r3, r3, #1
20008042:	83bb      	strh	r3, [r7, #28]
                        ++transit;
20008044:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20008046:	f103 0301 	add.w	r3, r3, #1
2000804a:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
2000804c:	8b7a      	ldrh	r2, [r7, #26]
2000804e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20008050:	429a      	cmp	r2, r3
20008052:	d3a2      	bcc.n	20007f9a <MSS_SPI_transfer_block+0x166>
                    }
                }
            }
        }
    }
}
20008054:	f107 0738 	add.w	r7, r7, #56	; 0x38
20008058:	46bd      	mov	sp, r7
2000805a:	bd80      	pop	{r7, pc}

2000805c <fill_slave_tx_fifo>:
 */
static void fill_slave_tx_fifo
(
    mss_spi_instance_t * this_spi
)
{
2000805c:	b480      	push	{r7}
2000805e:	b085      	sub	sp, #20
20008060:	af00      	add	r7, sp, #0
20008062:	6078      	str	r0, [r7, #4]
    uint32_t guard = 0u;
20008064:	f04f 0300 	mov.w	r3, #0
20008068:	60fb      	str	r3, [r7, #12]

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000806a:	e00e      	b.n	2000808a <fill_slave_tx_fifo+0x2e>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    {
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
2000806c:	687b      	ldr	r3, [r7, #4]
2000806e:	681b      	ldr	r3, [r3, #0]
20008070:	687a      	ldr	r2, [r7, #4]
20008072:	6891      	ldr	r1, [r2, #8]
20008074:	687a      	ldr	r2, [r7, #4]
20008076:	6912      	ldr	r2, [r2, #16]
20008078:	440a      	add	r2, r1
2000807a:	7812      	ldrb	r2, [r2, #0]
2000807c:	615a      	str	r2, [r3, #20]
        ++this_spi->slave_tx_idx;
2000807e:	687b      	ldr	r3, [r7, #4]
20008080:	691b      	ldr	r3, [r3, #16]
20008082:	f103 0201 	add.w	r2, r3, #1
20008086:	687b      	ldr	r3, [r7, #4]
20008088:	611a      	str	r2, [r3, #16]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000808a:	687b      	ldr	r3, [r7, #4]
2000808c:	681b      	ldr	r3, [r3, #0]
2000808e:	689b      	ldr	r3, [r3, #8]
20008090:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008094:	2b00      	cmp	r3, #0
20008096:	d105      	bne.n	200080a4 <fill_slave_tx_fifo+0x48>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
20008098:	687b      	ldr	r3, [r7, #4]
2000809a:	691a      	ldr	r2, [r3, #16]
2000809c:	687b      	ldr	r3, [r7, #4]
2000809e:	68db      	ldr	r3, [r3, #12]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200080a0:	429a      	cmp	r2, r3
200080a2:	d3e3      	bcc.n	2000806c <fill_slave_tx_fifo+0x10>
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
200080a4:	687b      	ldr	r3, [r7, #4]
200080a6:	691a      	ldr	r2, [r3, #16]
200080a8:	687b      	ldr	r3, [r7, #4]
200080aa:	68db      	ldr	r3, [r3, #12]
200080ac:	429a      	cmp	r2, r3
200080ae:	d31c      	bcc.n	200080ea <fill_slave_tx_fifo+0x8e>
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200080b0:	e00e      	b.n	200080d0 <fill_slave_tx_fifo+0x74>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
        {
            /* Sending from command response buffer */
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
200080b2:	687b      	ldr	r3, [r7, #4]
200080b4:	681b      	ldr	r3, [r3, #0]
200080b6:	687a      	ldr	r2, [r7, #4]
200080b8:	6951      	ldr	r1, [r2, #20]
200080ba:	687a      	ldr	r2, [r7, #4]
200080bc:	69d2      	ldr	r2, [r2, #28]
200080be:	440a      	add	r2, r1
200080c0:	7812      	ldrb	r2, [r2, #0]
200080c2:	615a      	str	r2, [r3, #20]
            ++this_spi->resp_buff_tx_idx;
200080c4:	687b      	ldr	r3, [r7, #4]
200080c6:	69db      	ldr	r3, [r3, #28]
200080c8:	f103 0201 	add.w	r2, r3, #1
200080cc:	687b      	ldr	r3, [r7, #4]
200080ce:	61da      	str	r2, [r3, #28]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200080d0:	687b      	ldr	r3, [r7, #4]
200080d2:	681b      	ldr	r3, [r3, #0]
200080d4:	689b      	ldr	r3, [r3, #8]
200080d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
200080da:	2b00      	cmp	r3, #0
200080dc:	d105      	bne.n	200080ea <fill_slave_tx_fifo+0x8e>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
200080de:	687b      	ldr	r3, [r7, #4]
200080e0:	69da      	ldr	r2, [r3, #28]
200080e2:	687b      	ldr	r3, [r7, #4]
200080e4:	699b      	ldr	r3, [r3, #24]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200080e6:	429a      	cmp	r2, r3
200080e8:	d3e3      	bcc.n	200080b2 <fill_slave_tx_fifo+0x56>
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
200080ea:	687b      	ldr	r3, [r7, #4]
200080ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200080ee:	2b00      	cmp	r3, #0
200080f0:	d01f      	beq.n	20008132 <fill_slave_tx_fifo+0xd6>
200080f2:	687b      	ldr	r3, [r7, #4]
200080f4:	691a      	ldr	r2, [r3, #16]
200080f6:	687b      	ldr	r3, [r7, #4]
200080f8:	68db      	ldr	r3, [r3, #12]
200080fa:	429a      	cmp	r2, r3
200080fc:	d319      	bcc.n	20008132 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
200080fe:	687b      	ldr	r3, [r7, #4]
20008100:	69da      	ldr	r2, [r3, #28]
20008102:	687b      	ldr	r3, [r7, #4]
20008104:	699b      	ldr	r3, [r3, #24]
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20008106:	429a      	cmp	r2, r3
20008108:	d313      	bcc.n	20008132 <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000810a:	e008      	b.n	2000811e <fill_slave_tx_fifo+0xc2>
              (guard < BIG_FIFO_SIZE))
        {
            /* Nothing left so pad with 0s for consistency */
            this_spi->hw_reg->TX_DATA = 0x00u;
2000810c:	687b      	ldr	r3, [r7, #4]
2000810e:	681b      	ldr	r3, [r3, #0]
20008110:	f04f 0200 	mov.w	r2, #0
20008114:	615a      	str	r2, [r3, #20]
             * We use the guard count to cover the unlikely event that we are
             * never seeing the TX FIFO full because the data is being pulled
             * out as fast as we can stuff it in. In this event we never spend
             * more than a full FIFOs worth of time spinning here.
             */
            guard++;
20008116:	68fb      	ldr	r3, [r7, #12]
20008118:	f103 0301 	add.w	r3, r3, #1
2000811c:	60fb      	str	r3, [r7, #12]
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000811e:	687b      	ldr	r3, [r7, #4]
20008120:	681b      	ldr	r3, [r3, #0]
20008122:	689b      	ldr	r3, [r3, #8]
20008124:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008128:	2b00      	cmp	r3, #0
2000812a:	d102      	bne.n	20008132 <fill_slave_tx_fifo+0xd6>
2000812c:	68fb      	ldr	r3, [r7, #12]
2000812e:	2b1f      	cmp	r3, #31
20008130:	d9ec      	bls.n	2000810c <fill_slave_tx_fifo+0xb0>
             */
            guard++;
        }
    }

}
20008132:	f107 0714 	add.w	r7, r7, #20
20008136:	46bd      	mov	sp, r7
20008138:	bc80      	pop	{r7}
2000813a:	4770      	bx	lr

2000813c <read_slave_rx_fifo>:
 */
static void read_slave_rx_fifo
(
    mss_spi_instance_t * this_spi
)
{
2000813c:	b580      	push	{r7, lr}
2000813e:	b084      	sub	sp, #16
20008140:	af00      	add	r7, sp, #0
20008142:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20008144:	687b      	ldr	r3, [r7, #4]
20008146:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
2000814a:	2b02      	cmp	r3, #2
2000814c:	d115      	bne.n	2000817a <read_slave_rx_fifo+0x3e>
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000814e:	e00c      	b.n	2000816a <read_slave_rx_fifo+0x2e>
        {
            /* Single frame handling mode. */
            rx_frame = this_spi->hw_reg->RX_DATA;
20008150:	687b      	ldr	r3, [r7, #4]
20008152:	681b      	ldr	r3, [r3, #0]
20008154:	691b      	ldr	r3, [r3, #16]
20008156:	60fb      	str	r3, [r7, #12]
            if(0u != this_spi->frame_rx_handler)
20008158:	687b      	ldr	r3, [r7, #4]
2000815a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000815c:	2b00      	cmp	r3, #0
2000815e:	d004      	beq.n	2000816a <read_slave_rx_fifo+0x2e>
            {
                this_spi->frame_rx_handler( rx_frame );
20008160:	687b      	ldr	r3, [r7, #4]
20008162:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20008164:	68fa      	ldr	r2, [r7, #12]
20008166:	4610      	mov	r0, r2
20008168:	4798      	blx	r3
{
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000816a:	687b      	ldr	r3, [r7, #4]
2000816c:	681b      	ldr	r3, [r3, #0]
2000816e:	689b      	ldr	r3, [r3, #8]
20008170:	f003 0340 	and.w	r3, r3, #64	; 0x40
20008174:	2b00      	cmp	r3, #0
20008176:	d0eb      	beq.n	20008150 <read_slave_rx_fifo+0x14>
20008178:	e032      	b.n	200081e0 <read_slave_rx_fifo+0xa4>
            {
                this_spi->frame_rx_handler( rx_frame );
            }
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
2000817a:	687b      	ldr	r3, [r7, #4]
2000817c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20008180:	2b01      	cmp	r3, #1
20008182:	d125      	bne.n	200081d0 <read_slave_rx_fifo+0x94>
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20008184:	e017      	b.n	200081b6 <read_slave_rx_fifo+0x7a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
20008186:	687b      	ldr	r3, [r7, #4]
20008188:	681b      	ldr	r3, [r3, #0]
2000818a:	691b      	ldr	r3, [r3, #16]
2000818c:	60fb      	str	r3, [r7, #12]
            if(this_spi->slave_rx_idx < this_spi->slave_rx_size)
2000818e:	687b      	ldr	r3, [r7, #4]
20008190:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20008192:	687b      	ldr	r3, [r7, #4]
20008194:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008196:	429a      	cmp	r2, r3
20008198:	d207      	bcs.n	200081aa <read_slave_rx_fifo+0x6e>
            {
                this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
2000819a:	687b      	ldr	r3, [r7, #4]
2000819c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000819e:	687b      	ldr	r3, [r7, #4]
200081a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200081a2:	4413      	add	r3, r2
200081a4:	68fa      	ldr	r2, [r7, #12]
200081a6:	b2d2      	uxtb	r2, r2
200081a8:	701a      	strb	r2, [r3, #0]
            }

            ++this_spi->slave_rx_idx;
200081aa:	687b      	ldr	r3, [r7, #4]
200081ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200081ae:	f103 0201 	add.w	r2, r3, #1
200081b2:	687b      	ldr	r3, [r7, #4]
200081b4:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200081b6:	687b      	ldr	r3, [r7, #4]
200081b8:	681b      	ldr	r3, [r3, #0]
200081ba:	689b      	ldr	r3, [r3, #8]
200081bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
200081c0:	2b00      	cmp	r3, #0
200081c2:	d0e0      	beq.n	20008186 <read_slave_rx_fifo+0x4a>
200081c4:	e00c      	b.n	200081e0 <read_slave_rx_fifo+0xa4>
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
200081c6:	687b      	ldr	r3, [r7, #4]
200081c8:	681b      	ldr	r3, [r3, #0]
200081ca:	691b      	ldr	r3, [r3, #16]
200081cc:	60fb      	str	r3, [r7, #12]
200081ce:	e000      	b.n	200081d2 <read_slave_rx_fifo+0x96>
        }
    }
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200081d0:	bf00      	nop
200081d2:	687b      	ldr	r3, [r7, #4]
200081d4:	681b      	ldr	r3, [r3, #0]
200081d6:	689b      	ldr	r3, [r3, #8]
200081d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
200081dc:	2b00      	cmp	r3, #0
200081de:	d0f2      	beq.n	200081c6 <read_slave_rx_fifo+0x8a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
        }
    }
}
200081e0:	f107 0710 	add.w	r7, r7, #16
200081e4:	46bd      	mov	sp, r7
200081e6:	bd80      	pop	{r7, pc}

200081e8 <mss_spi_isr>:
 */
static void mss_spi_isr
(
    mss_spi_instance_t * this_spi
)
{    
200081e8:	b580      	push	{r7, lr}
200081ea:	b086      	sub	sp, #24
200081ec:	af00      	add	r7, sp, #0
200081ee:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    __I  uint32_t *this_mis = &this_spi->hw_reg->MIS;
200081f0:	687b      	ldr	r3, [r7, #4]
200081f2:	681b      	ldr	r3, [r3, #0]
200081f4:	f103 0320 	add.w	r3, r3, #32
200081f8:	613b      	str	r3, [r7, #16]

    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200081fa:	687a      	ldr	r2, [r7, #4]
200081fc:	f24d 5304 	movw	r3, #54532	; 0xd504
20008200:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008204:	429a      	cmp	r2, r3
20008206:	d007      	beq.n	20008218 <mss_spi_isr+0x30>
20008208:	687a      	ldr	r2, [r7, #4]
2000820a:	f24d 4380 	movw	r3, #54400	; 0xd480
2000820e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008212:	429a      	cmp	r2, r3
20008214:	d000      	beq.n	20008218 <mss_spi_isr+0x30>
20008216:	be00      	bkpt	0x0000
  
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
20008218:	693b      	ldr	r3, [r7, #16]
2000821a:	681b      	ldr	r3, [r3, #0]
2000821c:	f003 0302 	and.w	r3, r3, #2
20008220:	2b00      	cmp	r3, #0
20008222:	d052      	beq.n	200082ca <mss_spi_isr+0xe2>
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20008224:	687b      	ldr	r3, [r7, #4]
20008226:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
2000822a:	2b02      	cmp	r3, #2
2000822c:	d115      	bne.n	2000825a <mss_spi_isr+0x72>
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000822e:	e00c      	b.n	2000824a <mss_spi_isr+0x62>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
20008230:	687b      	ldr	r3, [r7, #4]
20008232:	681b      	ldr	r3, [r3, #0]
20008234:	691b      	ldr	r3, [r3, #16]
20008236:	60fb      	str	r3, [r7, #12]
                if(0u != this_spi->frame_rx_handler)
20008238:	687b      	ldr	r3, [r7, #4]
2000823a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000823c:	2b00      	cmp	r3, #0
2000823e:	d004      	beq.n	2000824a <mss_spi_isr+0x62>
                {
                    this_spi->frame_rx_handler( rx_frame );
20008240:	687b      	ldr	r3, [r7, #4]
20008242:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20008244:	68fa      	ldr	r2, [r7, #12]
20008246:	4610      	mov	r0, r2
20008248:	4798      	blx	r3
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000824a:	687b      	ldr	r3, [r7, #4]
2000824c:	681b      	ldr	r3, [r3, #0]
2000824e:	689b      	ldr	r3, [r3, #8]
20008250:	f003 0340 	and.w	r3, r3, #64	; 0x40
20008254:	2b00      	cmp	r3, #0
20008256:	d0eb      	beq.n	20008230 <mss_spi_isr+0x48>
20008258:	e032      	b.n	200082c0 <mss_spi_isr+0xd8>
                {
                    this_spi->frame_rx_handler( rx_frame );
                }
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
2000825a:	687b      	ldr	r3, [r7, #4]
2000825c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20008260:	2b01      	cmp	r3, #1
20008262:	d125      	bne.n	200082b0 <mss_spi_isr+0xc8>
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20008264:	e017      	b.n	20008296 <mss_spi_isr+0xae>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;                /* Read from FIFO irrespective */
20008266:	687b      	ldr	r3, [r7, #4]
20008268:	681b      	ldr	r3, [r3, #0]
2000826a:	691b      	ldr	r3, [r3, #16]
2000826c:	60fb      	str	r3, [r7, #12]
                if(this_spi->slave_rx_idx < this_spi->slave_rx_size) /* Write to array if required */
2000826e:	687b      	ldr	r3, [r7, #4]
20008270:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20008272:	687b      	ldr	r3, [r7, #4]
20008274:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008276:	429a      	cmp	r2, r3
20008278:	d207      	bcs.n	2000828a <mss_spi_isr+0xa2>
                {
                    this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
2000827a:	687b      	ldr	r3, [r7, #4]
2000827c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000827e:	687b      	ldr	r3, [r7, #4]
20008280:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008282:	4413      	add	r3, r2
20008284:	68fa      	ldr	r2, [r7, #12]
20008286:	b2d2      	uxtb	r2, r2
20008288:	701a      	strb	r2, [r3, #0]
                }

                ++this_spi->slave_rx_idx;            
2000828a:	687b      	ldr	r3, [r7, #4]
2000828c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000828e:	f103 0201 	add.w	r2, r3, #1
20008292:	687b      	ldr	r3, [r7, #4]
20008294:	631a      	str	r2, [r3, #48]	; 0x30
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20008296:	687b      	ldr	r3, [r7, #4]
20008298:	681b      	ldr	r3, [r3, #0]
2000829a:	689b      	ldr	r3, [r3, #8]
2000829c:	f003 0340 	and.w	r3, r3, #64	; 0x40
200082a0:	2b00      	cmp	r3, #0
200082a2:	d0e0      	beq.n	20008266 <mss_spi_isr+0x7e>
200082a4:	e00c      	b.n	200082c0 <mss_spi_isr+0xd8>
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
200082a6:	687b      	ldr	r3, [r7, #4]
200082a8:	681b      	ldr	r3, [r3, #0]
200082aa:	691b      	ldr	r3, [r3, #16]
200082ac:	60fb      	str	r3, [r7, #12]
200082ae:	e000      	b.n	200082b2 <mss_spi_isr+0xca>
            }
        }
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200082b0:	bf00      	nop
200082b2:	687b      	ldr	r3, [r7, #4]
200082b4:	681b      	ldr	r3, [r3, #0]
200082b6:	689b      	ldr	r3, [r3, #8]
200082b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
200082bc:	2b00      	cmp	r3, #0
200082be:	d0f2      	beq.n	200082a6 <mss_spi_isr+0xbe>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
            }
        }

        this_spi->hw_reg->INT_CLEAR = RXDONE_IRQ_MASK;
200082c0:	687b      	ldr	r3, [r7, #4]
200082c2:	681b      	ldr	r3, [r3, #0]
200082c4:	f04f 0202 	mov.w	r2, #2
200082c8:	60da      	str	r2, [r3, #12]
    }

   /* Handle transmit. */
    if(0u != (*this_mis & TXDONE_IRQ_MASK))
200082ca:	693b      	ldr	r3, [r7, #16]
200082cc:	681b      	ldr	r3, [r3, #0]
200082ce:	f003 0301 	and.w	r3, r3, #1
200082d2:	b2db      	uxtb	r3, r3
200082d4:	2b00      	cmp	r3, #0
200082d6:	d012      	beq.n	200082fe <mss_spi_isr+0x116>
    {
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
200082d8:	687b      	ldr	r3, [r7, #4]
200082da:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200082de:	2b02      	cmp	r3, #2
200082e0:	d105      	bne.n	200082ee <mss_spi_isr+0x106>
        {
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
200082e2:	687b      	ldr	r3, [r7, #4]
200082e4:	681b      	ldr	r3, [r3, #0]
200082e6:	687a      	ldr	r2, [r7, #4]
200082e8:	6f92      	ldr	r2, [r2, #120]	; 0x78
200082ea:	615a      	str	r2, [r3, #20]
200082ec:	e002      	b.n	200082f4 <mss_spi_isr+0x10c>
        }
        else /* Must be block mode so load FIFO to the max */
        {
            fill_slave_tx_fifo(this_spi);
200082ee:	6878      	ldr	r0, [r7, #4]
200082f0:	f7ff feb4 	bl	2000805c <fill_slave_tx_fifo>
        }

        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
200082f4:	687b      	ldr	r3, [r7, #4]
200082f6:	681b      	ldr	r3, [r3, #0]
200082f8:	f04f 0201 	mov.w	r2, #1
200082fc:	60da      	str	r2, [r3, #12]
    }
    
    /* Handle command interrupt. */
    if(0u != (*this_mis & CMD_IRQ_MASK))
200082fe:	693b      	ldr	r3, [r7, #16]
20008300:	681b      	ldr	r3, [r3, #0]
20008302:	f003 0310 	and.w	r3, r3, #16
20008306:	2b00      	cmp	r3, #0
20008308:	d023      	beq.n	20008352 <mss_spi_isr+0x16a>
    {
        read_slave_rx_fifo(this_spi);
2000830a:	6878      	ldr	r0, [r7, #4]
2000830c:	f7ff ff16 	bl	2000813c <read_slave_rx_fifo>
        
        /*
         * Call the command handler if one exists.
         */
        if(0u != this_spi->cmd_handler)
20008310:	687b      	ldr	r3, [r7, #4]
20008312:	6a1b      	ldr	r3, [r3, #32]
20008314:	2b00      	cmp	r3, #0
20008316:	d00b      	beq.n	20008330 <mss_spi_isr+0x148>
        {
            (*this_spi->cmd_handler)(this_spi->slave_rx_buffer, this_spi->slave_rx_idx);
20008318:	687b      	ldr	r3, [r7, #4]
2000831a:	6a1b      	ldr	r3, [r3, #32]
2000831c:	687a      	ldr	r2, [r7, #4]
2000831e:	6a91      	ldr	r1, [r2, #40]	; 0x28
20008320:	687a      	ldr	r2, [r7, #4]
20008322:	6b12      	ldr	r2, [r2, #48]	; 0x30
20008324:	4608      	mov	r0, r1
20008326:	4611      	mov	r1, r2
20008328:	4798      	blx	r3
            fill_slave_tx_fifo(this_spi);
2000832a:	6878      	ldr	r0, [r7, #4]
2000832c:	f7ff fe96 	bl	2000805c <fill_slave_tx_fifo>
        }
        /* Set cmd_done to indicate it is now safe to 0 fill TX FIFO */
        this_spi->cmd_done = 1u;
20008330:	687b      	ldr	r3, [r7, #4]
20008332:	f04f 0201 	mov.w	r2, #1
20008336:	625a      	str	r2, [r3, #36]	; 0x24
        /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
20008338:	687b      	ldr	r3, [r7, #4]
2000833a:	681b      	ldr	r3, [r3, #0]
2000833c:	687a      	ldr	r2, [r7, #4]
2000833e:	6812      	ldr	r2, [r2, #0]
20008340:	6a92      	ldr	r2, [r2, #40]	; 0x28
20008342:	f022 0210 	bic.w	r2, r2, #16
20008346:	629a      	str	r2, [r3, #40]	; 0x28
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20008348:	687b      	ldr	r3, [r7, #4]
2000834a:	681b      	ldr	r3, [r3, #0]
2000834c:	f04f 0210 	mov.w	r2, #16
20008350:	60da      	str	r2, [r3, #12]
    }

    if(0u != (*this_mis & RXOVFLOW_IRQ_MASK))
20008352:	693b      	ldr	r3, [r7, #16]
20008354:	681b      	ldr	r3, [r3, #0]
20008356:	f003 0304 	and.w	r3, r3, #4
2000835a:	2b00      	cmp	r3, #0
2000835c:	d00f      	beq.n	2000837e <mss_spi_isr+0x196>
    {
        /*
         * Receive overflow, not a lot we can do for this. Reset the receive
         *  FIFO, clear the interrupt and hope it doesn't happen again...
         */
        this_spi->hw_reg->COMMAND |= RX_FIFO_RESET_MASK;
2000835e:	687b      	ldr	r3, [r7, #4]
20008360:	681b      	ldr	r3, [r3, #0]
20008362:	687a      	ldr	r2, [r7, #4]
20008364:	6812      	ldr	r2, [r2, #0]
20008366:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20008368:	f042 0204 	orr.w	r2, r2, #4
2000836c:	62da      	str	r2, [r3, #44]	; 0x2c
        recover_from_rx_overflow(this_spi);
2000836e:	6878      	ldr	r0, [r7, #4]
20008370:	f7ff fadc 	bl	2000792c <recover_from_rx_overflow>
        this_spi->hw_reg->INT_CLEAR = RXOVFLOW_IRQ_MASK;
20008374:	687b      	ldr	r3, [r7, #4]
20008376:	681b      	ldr	r3, [r3, #0]
20008378:	f04f 0204 	mov.w	r2, #4
2000837c:	60da      	str	r2, [r3, #12]
     * slave TX FIFO data setup (if there is one).
     * In block mode this will probably not be very successful as we will
     * be out of synch with the master but the reset on SSEND will hopefully
     * take care of that for the next transfer.
     */
    if(0u != (*this_mis & TXURUN_IRQ_MASK))
2000837e:	693b      	ldr	r3, [r7, #16]
20008380:	681b      	ldr	r3, [r3, #0]
20008382:	f003 0308 	and.w	r3, r3, #8
20008386:	2b00      	cmp	r3, #0
20008388:	d031      	beq.n	200083ee <mss_spi_isr+0x206>
    {
        this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
2000838a:	687b      	ldr	r3, [r7, #4]
2000838c:	681b      	ldr	r3, [r3, #0]
2000838e:	687a      	ldr	r2, [r7, #4]
20008390:	6812      	ldr	r2, [r2, #0]
20008392:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20008394:	f042 0208 	orr.w	r2, r2, #8
20008398:	62da      	str	r2, [r3, #44]	; 0x2c
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
2000839a:	687b      	ldr	r3, [r7, #4]
2000839c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200083a0:	2b02      	cmp	r3, #2
200083a2:	d113      	bne.n	200083cc <mss_spi_isr+0x1e4>
        {
            this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
200083a4:	687b      	ldr	r3, [r7, #4]
200083a6:	681a      	ldr	r2, [r3, #0]
200083a8:	687b      	ldr	r3, [r7, #4]
200083aa:	681b      	ldr	r3, [r3, #0]
200083ac:	6819      	ldr	r1, [r3, #0]
200083ae:	f240 03ff 	movw	r3, #255	; 0xff
200083b2:	f6cf 7300 	movt	r3, #65280	; 0xff00
200083b6:	ea01 0303 	and.w	r3, r1, r3
200083ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200083be:	6013      	str	r3, [r2, #0]
                                        | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
200083c0:	687b      	ldr	r3, [r7, #4]
200083c2:	681b      	ldr	r3, [r3, #0]
200083c4:	687a      	ldr	r2, [r7, #4]
200083c6:	6f92      	ldr	r2, [r2, #120]	; 0x78
200083c8:	615a      	str	r2, [r3, #20]
200083ca:	e00b      	b.n	200083e4 <mss_spi_isr+0x1fc>
        }
        else if( MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode )
200083cc:	687b      	ldr	r3, [r7, #4]
200083ce:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200083d2:	2b01      	cmp	r3, #1
200083d4:	d106      	bne.n	200083e4 <mss_spi_isr+0x1fc>
        {
            /* Block mode so reload FIFO to the max */
            this_spi->slave_tx_idx = 0u;
200083d6:	687b      	ldr	r3, [r7, #4]
200083d8:	f04f 0200 	mov.w	r2, #0
200083dc:	611a      	str	r2, [r3, #16]
            fill_slave_tx_fifo(this_spi);
200083de:	6878      	ldr	r0, [r7, #4]
200083e0:	f7ff fe3c 	bl	2000805c <fill_slave_tx_fifo>
        else
        {
            /* Not frame or block mode? Can't do anything here... */
        }

        this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK;
200083e4:	687b      	ldr	r3, [r7, #4]
200083e6:	681b      	ldr	r3, [r3, #0]
200083e8:	f04f 0208 	mov.w	r2, #8
200083ec:	60da      	str	r2, [r3, #12]
    /*
     * Handle slave select becoming de-asserted. Only enables if
     * we are operating in block mode, in frame mode we do everything
     * in the receive and transmit interrupt handlers.
     */
    if(0u != (*this_mis & SSEND_IRQ_MASK))
200083ee:	693b      	ldr	r3, [r7, #16]
200083f0:	681b      	ldr	r3, [r3, #0]
200083f2:	f003 0320 	and.w	r3, r3, #32
200083f6:	2b00      	cmp	r3, #0
200083f8:	d049      	beq.n	2000848e <mss_spi_isr+0x2a6>
    {
        uint32_t rx_size;
        
        read_slave_rx_fifo(this_spi);
200083fa:	6878      	ldr	r0, [r7, #4]
200083fc:	f7ff fe9e 	bl	2000813c <read_slave_rx_fifo>
        rx_size = this_spi->slave_rx_idx;
20008400:	687b      	ldr	r3, [r7, #4]
20008402:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008404:	617b      	str	r3, [r7, #20]
        /*
         * Re-enable command interrupt if required and clear all the response
         * buffer state in readiness for next response. This must be done
         * before reloading the TX FIFO.
         */
        if(0 != this_spi->cmd_handler)
20008406:	687b      	ldr	r3, [r7, #4]
20008408:	6a1b      	ldr	r3, [r3, #32]
2000840a:	2b00      	cmp	r3, #0
2000840c:	d01c      	beq.n	20008448 <mss_spi_isr+0x260>
        {
            this_spi->cmd_done = 0u;
2000840e:	687b      	ldr	r3, [r7, #4]
20008410:	f04f 0200 	mov.w	r2, #0
20008414:	625a      	str	r2, [r3, #36]	; 0x24
            this_spi->resp_tx_buffer = 0u;
20008416:	687b      	ldr	r3, [r7, #4]
20008418:	f04f 0200 	mov.w	r2, #0
2000841c:	615a      	str	r2, [r3, #20]
            this_spi->resp_buff_size = 0u;
2000841e:	687b      	ldr	r3, [r7, #4]
20008420:	f04f 0200 	mov.w	r2, #0
20008424:	619a      	str	r2, [r3, #24]
            this_spi->resp_buff_tx_idx = 0u;
20008426:	687b      	ldr	r3, [r7, #4]
20008428:	f04f 0200 	mov.w	r2, #0
2000842c:	61da      	str	r2, [r3, #28]
            this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
2000842e:	687b      	ldr	r3, [r7, #4]
20008430:	681b      	ldr	r3, [r3, #0]
20008432:	f04f 0210 	mov.w	r2, #16
20008436:	60da      	str	r2, [r3, #12]
            this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
20008438:	687b      	ldr	r3, [r7, #4]
2000843a:	681b      	ldr	r3, [r3, #0]
2000843c:	687a      	ldr	r2, [r7, #4]
2000843e:	6812      	ldr	r2, [r2, #0]
20008440:	6a92      	ldr	r2, [r2, #40]	; 0x28
20008442:	f042 0210 	orr.w	r2, r2, #16
20008446:	629a      	str	r2, [r3, #40]	; 0x28
        /* 
         * Reset the transmit index to 0 to restart transmit at the start of the
         * transmit buffer in the next transaction. This also requires flushing
         * the Tx FIFO and refilling it with the start of Tx data buffer.
         */
        this_spi->slave_tx_idx = 0u;
20008448:	687b      	ldr	r3, [r7, #4]
2000844a:	f04f 0200 	mov.w	r2, #0
2000844e:	611a      	str	r2, [r3, #16]
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20008450:	687b      	ldr	r3, [r7, #4]
20008452:	681b      	ldr	r3, [r3, #0]
20008454:	687a      	ldr	r2, [r7, #4]
20008456:	6812      	ldr	r2, [r2, #0]
20008458:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
2000845a:	f042 020c 	orr.w	r2, r2, #12
2000845e:	62da      	str	r2, [r3, #44]	; 0x2c
        fill_slave_tx_fifo(this_spi);
20008460:	6878      	ldr	r0, [r7, #4]
20008462:	f7ff fdfb 	bl	2000805c <fill_slave_tx_fifo>
        
        /* Prepare to receive next packet. */
        this_spi->slave_rx_idx = 0u;
20008466:	687b      	ldr	r3, [r7, #4]
20008468:	f04f 0200 	mov.w	r2, #0
2000846c:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * Call the receive handler if one exists.
         */
        if(0u != this_spi->block_rx_handler)
2000846e:	687b      	ldr	r3, [r7, #4]
20008470:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
20008472:	2b00      	cmp	r3, #0
20008474:	d006      	beq.n	20008484 <mss_spi_isr+0x29c>
        {
            (*this_spi->block_rx_handler)(this_spi->slave_rx_buffer, rx_size);
20008476:	687b      	ldr	r3, [r7, #4]
20008478:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2000847a:	687a      	ldr	r2, [r7, #4]
2000847c:	6a92      	ldr	r2, [r2, #40]	; 0x28
2000847e:	4610      	mov	r0, r2
20008480:	6979      	ldr	r1, [r7, #20]
20008482:	4798      	blx	r3
        }
        
        this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
20008484:	687b      	ldr	r3, [r7, #4]
20008486:	681b      	ldr	r3, [r3, #0]
20008488:	f04f 0220 	mov.w	r2, #32
2000848c:	60da      	str	r2, [r3, #12]
    }
}
2000848e:	f107 0718 	add.w	r7, r7, #24
20008492:	46bd      	mov	sp, r7
20008494:	bd80      	pop	{r7, pc}
20008496:	bf00      	nop

20008498 <SPI0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI0_IRQHandler(void)
#else
void SPI0_IRQHandler( void )
#endif
{
20008498:	4668      	mov	r0, sp
2000849a:	f020 0107 	bic.w	r1, r0, #7
2000849e:	468d      	mov	sp, r1
200084a0:	b589      	push	{r0, r3, r7, lr}
200084a2:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi0);
200084a4:	f24d 5004 	movw	r0, #54532	; 0xd504
200084a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200084ac:	f7ff fe9c 	bl	200081e8 <mss_spi_isr>
}
200084b0:	46bd      	mov	sp, r7
200084b2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
200084b6:	4685      	mov	sp, r0
200084b8:	4770      	bx	lr
200084ba:	bf00      	nop

200084bc <SPI1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI1_IRQHandler(void)
#else
void SPI1_IRQHandler(void)
#endif
{
200084bc:	4668      	mov	r0, sp
200084be:	f020 0107 	bic.w	r1, r0, #7
200084c2:	468d      	mov	sp, r1
200084c4:	b589      	push	{r0, r3, r7, lr}
200084c6:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi1);
200084c8:	f24d 4080 	movw	r0, #54400	; 0xd480
200084cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200084d0:	f7ff fe8a 	bl	200081e8 <mss_spi_isr>
}
200084d4:	46bd      	mov	sp, r7
200084d6:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
200084da:	4685      	mov	sp, r0
200084dc:	4770      	bx	lr
200084de:	bf00      	nop

200084e0 <NVM_write>:
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
200084e0:	b580      	push	{r7, lr}
200084e2:	b08e      	sub	sp, #56	; 0x38
200084e4:	af02      	add	r7, sp, #8
200084e6:	60f8      	str	r0, [r7, #12]
200084e8:	60b9      	str	r1, [r7, #8]
200084ea:	607a      	str	r2, [r7, #4]
200084ec:	603b      	str	r3, [r7, #0]
    nvm_status_t status;
    nvm_status_t lock_status = NVM_SUCCESS;
200084ee:	f04f 0300 	mov.w	r3, #0
200084f2:	75fb      	strb	r3, [r7, #23]
    uint32_t nvm_offset;
    uint32_t device_version;
    uint32_t initial_nvm_config;

    g_do_not_lock_page = OFF;
200084f4:	f24c 3318 	movw	r3, #49944	; 0xc318
200084f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200084fc:	f04f 0200 	mov.w	r2, #0
20008500:	701a      	strb	r2, [r3, #0]
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
20008502:	f248 0300 	movw	r3, #32768	; 0x8000
20008506:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000850a:	68db      	ldr	r3, [r3, #12]
2000850c:	623b      	str	r3, [r7, #32]
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
2000850e:	f248 0300 	movw	r3, #32768	; 0x8000
20008512:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008516:	6a3a      	ldr	r2, [r7, #32]
20008518:	f442 52ff 	orr.w	r2, r2, #8160	; 0x1fe0
2000851c:	60da      	str	r2, [r3, #12]

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) ||
2000851e:	68fa      	ldr	r2, [r7, #12]
20008520:	f64f 73fe 	movw	r3, #65534	; 0xfffe
20008524:	f2c6 0307 	movt	r3, #24583	; 0x6007
20008528:	429a      	cmp	r2, r3
2000852a:	d814      	bhi.n	20008556 <NVM_write+0x76>
2000852c:	68fa      	ldr	r2, [r7, #12]
2000852e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
20008532:	f2c0 0307 	movt	r3, #7
20008536:	429a      	cmp	r2, r3
20008538:	d904      	bls.n	20008544 <NVM_write+0x64>
2000853a:	68fa      	ldr	r2, [r7, #12]
2000853c:	f06f 4320 	mvn.w	r3, #2684354560	; 0xa0000000
20008540:	429a      	cmp	r2, r3
20008542:	d908      	bls.n	20008556 <NVM_write+0x76>
20008544:	68bb      	ldr	r3, [r7, #8]
20008546:	2b00      	cmp	r3, #0
20008548:	d005      	beq.n	20008556 <NVM_write+0x76>
2000854a:	687b      	ldr	r3, [r7, #4]
2000854c:	2b00      	cmp	r3, #0
2000854e:	d002      	beq.n	20008556 <NVM_write+0x76>
20008550:	683b      	ldr	r3, [r7, #0]
20008552:	2b02      	cmp	r3, #2
20008554:	d903      	bls.n	2000855e <NVM_write+0x7e>
        (start_addr < NVM_BASE_ADDRESS)) ||
        (0u == pidata) ||
        (0u == length) ||
        (lock_page > PARAM_LOCK_PAGE_FLAG))
    {
        status =  NVM_INVALID_PARAMETER;
20008556:	f04f 0307 	mov.w	r3, #7
2000855a:	75bb      	strb	r3, [r7, #22]
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) ||
2000855c:	e0c1      	b.n	200086e2 <NVM_write+0x202>

        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
2000855e:	f248 0300 	movw	r3, #32768	; 0x8000
20008562:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008566:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
2000856a:	61fb      	str	r3, [r7, #28]
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
2000856c:	69fa      	ldr	r2, [r7, #28]
2000856e:	f64f 0302 	movw	r3, #63490	; 0xf802
20008572:	429a      	cmp	r2, r3
20008574:	d006      	beq.n	20008584 <NVM_write+0xa4>
20008576:	69fa      	ldr	r2, [r7, #28]
20008578:	f64f 0302 	movw	r3, #63490	; 0xf802
2000857c:	f2c0 0301 	movt	r3, #1
20008580:	429a      	cmp	r2, r3
20008582:	d102      	bne.n	2000858a <NVM_write+0xaa>
        {
            lock_page = NVM_DO_NOT_LOCK_PAGE;
20008584:	f04f 0300 	mov.w	r3, #0
20008588:	603b      	str	r3, [r7, #0]
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  
2000858a:	68fb      	ldr	r3, [r7, #12]
2000858c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20008590:	f423 0378 	bic.w	r3, r3, #16252928	; 0xf80000
20008594:	61bb      	str	r3, [r7, #24]
        
        /* 
         * SAR 70908.
         * Check nvm offset is in protection or reserved area of eNVM
         */
        status = check_protection_reserved_nvm(nvm_offset, length);
20008596:	69b8      	ldr	r0, [r7, #24]
20008598:	6879      	ldr	r1, [r7, #4]
2000859a:	f000 fb5b 	bl	20008c54 <check_protection_reserved_nvm>
2000859e:	4603      	mov	r3, r0
200085a0:	75bb      	strb	r3, [r7, #22]

        if(NVM_SUCCESS == status)
200085a2:	7dbb      	ldrb	r3, [r7, #22]
200085a4:	2b00      	cmp	r3, #0
200085a6:	f040 809c 	bne.w	200086e2 <NVM_write+0x202>
        {
            /* 
             * SAR 79545. 
             * If eNVM write or No R/W protected is enabled, then don't lock the page
             */
            if((g_do_not_lock_page == ON)  && (NVM_LOCK_PAGE == lock_page)) 
200085aa:	f24c 3318 	movw	r3, #49944	; 0xc318
200085ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200085b2:	781b      	ldrb	r3, [r3, #0]
200085b4:	2b01      	cmp	r3, #1
200085b6:	d108      	bne.n	200085ca <NVM_write+0xea>
200085b8:	683b      	ldr	r3, [r7, #0]
200085ba:	2b01      	cmp	r3, #1
200085bc:	d105      	bne.n	200085ca <NVM_write+0xea>
            {
                lock_page = NVM_DO_NOT_LOCK_PAGE;
200085be:	f04f 0300 	mov.w	r3, #0
200085c2:	603b      	str	r3, [r7, #0]
                lock_status = NVM_PAGE_LOCK_WARNING;
200085c4:	f04f 0304 	mov.w	r3, #4
200085c8:	75fb      	strb	r3, [r7, #23]
            }
            
            device_version = device_version & 0xFFFFu;
200085ca:	69fb      	ldr	r3, [r7, #28]
200085cc:	ea4f 4303 	mov.w	r3, r3, lsl #16
200085d0:	ea4f 4313 	mov.w	r3, r3, lsr #16
200085d4:	61fb      	str	r3, [r7, #28]
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
200085d6:	69fa      	ldr	r2, [r7, #28]
200085d8:	f64f 0307 	movw	r3, #63495	; 0xf807
200085dc:	429a      	cmp	r2, r3
200085de:	d004      	beq.n	200085ea <NVM_write+0x10a>
200085e0:	69fa      	ldr	r2, [r7, #28]
200085e2:	f64f 0306 	movw	r3, #63494	; 0xf806
200085e6:	429a      	cmp	r2, r3
200085e8:	d116      	bne.n	20008618 <NVM_write+0x138>
            {
                if(((nvm_offset >= NVM1_BOTTOM_OFFSET) || ((nvm_offset + length) > NVM1_BOTTOM_OFFSET))
200085ea:	69ba      	ldr	r2, [r7, #24]
200085ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
200085f0:	f2c0 0303 	movt	r3, #3
200085f4:	429a      	cmp	r2, r3
200085f6:	d805      	bhi.n	20008604 <NVM_write+0x124>
200085f8:	69ba      	ldr	r2, [r7, #24]
200085fa:	687b      	ldr	r3, [r7, #4]
200085fc:	4413      	add	r3, r2
200085fe:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20008602:	d918      	bls.n	20008636 <NVM_write+0x156>
20008604:	683b      	ldr	r3, [r7, #0]
20008606:	2b01      	cmp	r3, #1
20008608:	d117      	bne.n	2000863a <NVM_write+0x15a>
                            && (NVM_LOCK_PAGE == lock_page)) 
                {
                    lock_page = NVM_DO_NOT_LOCK_PAGE;
2000860a:	f04f 0300 	mov.w	r3, #0
2000860e:	603b      	str	r3, [r7, #0]
                    lock_status = NVM_PAGE_LOCK_WARNING;
20008610:	f04f 0304 	mov.w	r3, #4
20008614:	75fb      	strb	r3, [r7, #23]
            }
            
            device_version = device_version & 0xFFFFu;
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
20008616:	e011      	b.n	2000863c <NVM_write+0x15c>
                    lock_page = NVM_DO_NOT_LOCK_PAGE;
                    lock_status = NVM_PAGE_LOCK_WARNING;
                }
            }
            /* Don't lock pages of 060 device */
            else if((0xF808u == device_version) && (NVM_LOCK_PAGE == lock_page)) 
20008618:	69fa      	ldr	r2, [r7, #28]
2000861a:	f64f 0308 	movw	r3, #63496	; 0xf808
2000861e:	429a      	cmp	r2, r3
20008620:	d10c      	bne.n	2000863c <NVM_write+0x15c>
20008622:	683b      	ldr	r3, [r7, #0]
20008624:	2b01      	cmp	r3, #1
20008626:	d109      	bne.n	2000863c <NVM_write+0x15c>
            {
                lock_page = NVM_DO_NOT_LOCK_PAGE;
20008628:	f04f 0300 	mov.w	r3, #0
2000862c:	603b      	str	r3, [r7, #0]
                lock_status = NVM_PAGE_LOCK_WARNING;
2000862e:	f04f 0304 	mov.w	r3, #4
20008632:	75fb      	strb	r3, [r7, #23]
20008634:	e002      	b.n	2000863c <NVM_write+0x15c>
            }
            
            device_version = device_version & 0xFFFFu;
            
            /* Don't lock pages of 090/150  device -eNVM1 memory */
            if((0xF807u == device_version) || (0xF806u == device_version))
20008636:	bf00      	nop
20008638:	e000      	b.n	2000863c <NVM_write+0x15c>
2000863a:	bf00      	nop
                lock_page = NVM_DO_NOT_LOCK_PAGE;
                lock_status = NVM_PAGE_LOCK_WARNING;
            }
            
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);
2000863c:	69b8      	ldr	r0, [r7, #24]
2000863e:	6879      	ldr	r1, [r7, #4]
20008640:	f000 f8f0 	bl	20008824 <get_ctrl_access>
20008644:	4603      	mov	r3, r0
20008646:	75bb      	strb	r3, [r7, #22]

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
20008648:	7dbb      	ldrb	r3, [r7, #22]
2000864a:	2b00      	cmp	r3, #0
2000864c:	d149      	bne.n	200086e2 <NVM_write+0x202>
            {
                uint32_t remaining_length = length;
2000864e:	687b      	ldr	r3, [r7, #4]
20008650:	627b      	str	r3, [r7, #36]	; 0x24
                uint32_t errors_and_warnings;
                
                while(remaining_length > 0u)
20008652:	e041      	b.n	200086d8 <NVM_write+0x1f8>
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;
20008654:	f04f 0300 	mov.w	r3, #0
20008658:	613b      	str	r3, [r7, #16]

                    length_written = write_nvm(start_addr + (length - remaining_length),
2000865a:	687a      	ldr	r2, [r7, #4]
2000865c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000865e:	ebc3 0202 	rsb	r2, r3, r2
20008662:	68fb      	ldr	r3, [r7, #12]
20008664:	441a      	add	r2, r3
                                                &pidata[length - remaining_length],
20008666:	6879      	ldr	r1, [r7, #4]
20008668:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000866a:	ebc3 0101 	rsb	r1, r3, r1
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
2000866e:	68bb      	ldr	r3, [r7, #8]
20008670:	440b      	add	r3, r1
20008672:	f107 0110 	add.w	r1, r7, #16
20008676:	9100      	str	r1, [sp, #0]
20008678:	4610      	mov	r0, r2
2000867a:	4619      	mov	r1, r3
2000867c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2000867e:	683b      	ldr	r3, [r7, #0]
20008680:	f000 f982 	bl	20008988 <write_nvm>
20008684:	4603      	mov	r3, r0
20008686:	62fb      	str	r3, [r7, #44]	; 0x2c
                                                remaining_length,
                                                lock_page,
                                                &nvm_hw_status);

                    /* Check for errors and warnings. */
                    errors_and_warnings = nvm_hw_status & (WRITE_ERROR_MASK | MSS_NVM_WRCNT_OVER);
20008688:	693a      	ldr	r2, [r7, #16]
2000868a:	f240 033e 	movw	r3, #62	; 0x3e
2000868e:	f2c0 0304 	movt	r3, #4
20008692:	ea02 0303 	and.w	r3, r2, r3
20008696:	62bb      	str	r3, [r7, #40]	; 0x28
                    if(errors_and_warnings)
20008698:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000869a:	2b00      	cmp	r3, #0
2000869c:	d005      	beq.n	200086aa <NVM_write+0x1ca>
                        * Ensure that the status returned by the NVM_write()
                        * function is NVM_WRITE_THRESHOLD_WARNING if at least one
                        * of the written eNVM pages indicate a write over
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
2000869e:	693b      	ldr	r3, [r7, #16]
200086a0:	4618      	mov	r0, r3
200086a2:	f000 f839 	bl	20008718 <get_error_code>
200086a6:	4603      	mov	r3, r0
200086a8:	75bb      	strb	r3, [r7, #22]
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
200086aa:	7dbb      	ldrb	r3, [r7, #22]
200086ac:	2b00      	cmp	r3, #0
200086ae:	d002      	beq.n	200086b6 <NVM_write+0x1d6>
200086b0:	7dbb      	ldrb	r3, [r7, #22]
200086b2:	2b05      	cmp	r3, #5
200086b4:	d10d      	bne.n	200086d2 <NVM_write+0x1f2>
                    {
                        if(remaining_length > length_written)
200086b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
200086b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
200086ba:	429a      	cmp	r2, r3
200086bc:	d905      	bls.n	200086ca <NVM_write+0x1ea>
                        {
                            remaining_length -= length_written;
200086be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
200086c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
200086c2:	ebc3 0302 	rsb	r3, r3, r2
200086c6:	627b      	str	r3, [r7, #36]	; 0x24
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
200086c8:	e006      	b.n	200086d8 <NVM_write+0x1f8>
                        {
                            remaining_length -= length_written;
                        }
                        else
                        {
                            remaining_length = 0u;
200086ca:	f04f 0300 	mov.w	r3, #0
200086ce:	627b      	str	r3, [r7, #36]	; 0x24
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
200086d0:	e002      	b.n	200086d8 <NVM_write+0x1f8>
                            remaining_length = 0u;
                        }
                    }
                    else
                    {
                        remaining_length = 0u;
200086d2:	f04f 0300 	mov.w	r3, #0
200086d6:	627b      	str	r3, [r7, #36]	; 0x24
            if(NVM_SUCCESS == status)
            {
                uint32_t remaining_length = length;
                uint32_t errors_and_warnings;
                
                while(remaining_length > 0u)
200086d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200086da:	2b00      	cmp	r3, #0
200086dc:	d1ba      	bne.n	20008654 <NVM_write+0x174>
                    }

                }

                /* Release eNVM controllers so that other masters can gain access to it. */
                release_ctrl_access();
200086de:	f000 f8e1 	bl	200088a4 <release_ctrl_access>
            }
        }
    }

    g_do_not_lock_page = OFF;
200086e2:	f24c 3318 	movw	r3, #49944	; 0xc318
200086e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200086ea:	f04f 0200 	mov.w	r2, #0
200086ee:	701a      	strb	r2, [r3, #0]

    /* Restore back to original value. */
    SYSREG->ENVM_CR = initial_nvm_config;
200086f0:	f248 0300 	movw	r3, #32768	; 0x8000
200086f4:	f2c4 0303 	movt	r3, #16387	; 0x4003
200086f8:	6a3a      	ldr	r2, [r7, #32]
200086fa:	60da      	str	r2, [r3, #12]
    
    if((NVM_SUCCESS == status) && (NVM_PAGE_LOCK_WARNING == lock_status))
200086fc:	7dbb      	ldrb	r3, [r7, #22]
200086fe:	2b00      	cmp	r3, #0
20008700:	d104      	bne.n	2000870c <NVM_write+0x22c>
20008702:	7dfb      	ldrb	r3, [r7, #23]
20008704:	2b04      	cmp	r3, #4
20008706:	d101      	bne.n	2000870c <NVM_write+0x22c>
    {
        status = lock_status;
20008708:	7dfb      	ldrb	r3, [r7, #23]
2000870a:	75bb      	strb	r3, [r7, #22]
    }
    return status;
2000870c:	7dbb      	ldrb	r3, [r7, #22]
}
2000870e:	4618      	mov	r0, r3
20008710:	f107 0730 	add.w	r7, r7, #48	; 0x30
20008714:	46bd      	mov	sp, r7
20008716:	bd80      	pop	{r7, pc}

20008718 <get_error_code>:
                 MSS_NVM_WRCNT_OVER | \
                 MSS_NVM_WR_DENIED)
  
 */
static nvm_status_t get_error_code(uint32_t nvm_hw_status)
{
20008718:	b480      	push	{r7}
2000871a:	b085      	sub	sp, #20
2000871c:	af00      	add	r7, sp, #0
2000871e:	6078      	str	r0, [r7, #4]
    nvm_status_t status;
    
    if(nvm_hw_status & MSS_NVM_WR_DENIED)
20008720:	687b      	ldr	r3, [r7, #4]
20008722:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20008726:	2b00      	cmp	r3, #0
20008728:	d003      	beq.n	20008732 <get_error_code+0x1a>
    {
        status = NVM_PROTECTION_ERROR;
2000872a:	f04f 0301 	mov.w	r3, #1
2000872e:	73fb      	strb	r3, [r7, #15]
20008730:	e01d      	b.n	2000876e <get_error_code+0x56>
    }
    else if(nvm_hw_status & MSS_NVM_PEFAIL_LOCK)
20008732:	687b      	ldr	r3, [r7, #4]
20008734:	f003 0310 	and.w	r3, r3, #16
20008738:	2b00      	cmp	r3, #0
2000873a:	d003      	beq.n	20008744 <get_error_code+0x2c>
    {
        status = NVM_PAGE_LOCK_ERROR;
2000873c:	f04f 0303 	mov.w	r3, #3
20008740:	73fb      	strb	r3, [r7, #15]
20008742:	e014      	b.n	2000876e <get_error_code+0x56>
    }
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
20008744:	687b      	ldr	r3, [r7, #4]
20008746:	f003 030e 	and.w	r3, r3, #14
2000874a:	2b00      	cmp	r3, #0
2000874c:	d003      	beq.n	20008756 <get_error_code+0x3e>
            MSS_NVM_EVERIFY_FAIL | MSS_NVM_WVERIFY_FAIL))
    {
        status = NVM_VERIFY_FAILURE;
2000874e:	f04f 0302 	mov.w	r3, #2
20008752:	73fb      	strb	r3, [r7, #15]
20008754:	e00b      	b.n	2000876e <get_error_code+0x56>
    }
    else if(nvm_hw_status & MSS_NVM_WRCNT_OVER)
20008756:	687b      	ldr	r3, [r7, #4]
20008758:	f003 0320 	and.w	r3, r3, #32
2000875c:	2b00      	cmp	r3, #0
2000875e:	d003      	beq.n	20008768 <get_error_code+0x50>
    {
        status = NVM_WRITE_THRESHOLD_WARNING;
20008760:	f04f 0305 	mov.w	r3, #5
20008764:	73fb      	strb	r3, [r7, #15]
20008766:	e002      	b.n	2000876e <get_error_code+0x56>
    }
    else
    {
        status = NVM_SUCCESS;
20008768:	f04f 0300 	mov.w	r3, #0
2000876c:	73fb      	strb	r3, [r7, #15]
    }
    
    return status;
2000876e:	7bfb      	ldrb	r3, [r7, #15]
}
20008770:	4618      	mov	r0, r3
20008772:	f107 0714 	add.w	r7, r7, #20
20008776:	46bd      	mov	sp, r7
20008778:	bc80      	pop	{r7}
2000877a:	4770      	bx	lr

2000877c <request_nvm_access>:
#define CORTEX_M3_ACCESS_GRANTED    0x05u

static uint8_t g_envm_ctrl_locks = 0x00u;

static nvm_status_t request_nvm_access(uint32_t nvm_block_id)
{
2000877c:	b480      	push	{r7}
2000877e:	b087      	sub	sp, #28
20008780:	af00      	add	r7, sp, #0
20008782:	6078      	str	r0, [r7, #4]
    nvm_status_t status = NVM_SUCCESS;
20008784:	f04f 0300 	mov.w	r3, #0
20008788:	74fb      	strb	r3, [r7, #19]
    
    /*
     * Use the SystemCoreClock frequency to compute a delay counter value giving
     * us a delay in the 500ms range. This is a very approximate delay.
     */
    timeout_counter = SystemCoreClock / 16u;
2000878a:	f24c 23b4 	movw	r3, #49844	; 0xc2b4
2000878e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008792:	681b      	ldr	r3, [r3, #0]
20008794:	ea4f 1313 	mov.w	r3, r3, lsr #4
20008798:	60fb      	str	r3, [r7, #12]
    
    /*
     * Gain access to eNVM controller.
     */
    do {
        g_nvm[nvm_block_id]->REQ_ACCESS = REQUEST_NVM_ACCESS;
2000879a:	687a      	ldr	r2, [r7, #4]
2000879c:	f64b 639c 	movw	r3, #48796	; 0xbe9c
200087a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200087a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200087a8:	f04f 0201 	mov.w	r2, #1
200087ac:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        access = g_nvm[nvm_block_id]->REQ_ACCESS;
200087b0:	687a      	ldr	r2, [r7, #4]
200087b2:	f64b 639c 	movw	r3, #48796	; 0xbe9c
200087b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200087ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200087be:	f8d3 31fc 	ldr.w	r3, [r3, #508]	; 0x1fc
200087c2:	617b      	str	r3, [r7, #20]
        if(access != CORTEX_M3_ACCESS_GRANTED)
200087c4:	697b      	ldr	r3, [r7, #20]
200087c6:	2b05      	cmp	r3, #5
200087c8:	d009      	beq.n	200087de <request_nvm_access+0x62>
            /*
             * Time out if another AHB master locked access to eNVM to prevent
             * the Cortex-M3 from locking up on eNVM write if some other part
             * of the system fails from releasing the eNVM.
             */
            --timeout_counter;
200087ca:	68fb      	ldr	r3, [r7, #12]
200087cc:	f103 33ff 	add.w	r3, r3, #4294967295
200087d0:	60fb      	str	r3, [r7, #12]
            if(0u == timeout_counter)
200087d2:	68fb      	ldr	r3, [r7, #12]
200087d4:	2b00      	cmp	r3, #0
200087d6:	d102      	bne.n	200087de <request_nvm_access+0x62>
            {
                status = NVM_IN_USE_BY_OTHER_MASTER;
200087d8:	f04f 0306 	mov.w	r3, #6
200087dc:	74fb      	strb	r3, [r7, #19]
            }
        }
    } while((access != CORTEX_M3_ACCESS_GRANTED) && (NVM_SUCCESS == status));
200087de:	697b      	ldr	r3, [r7, #20]
200087e0:	2b05      	cmp	r3, #5
200087e2:	d002      	beq.n	200087ea <request_nvm_access+0x6e>
200087e4:	7cfb      	ldrb	r3, [r7, #19]
200087e6:	2b00      	cmp	r3, #0
200087e8:	d0d7      	beq.n	2000879a <request_nvm_access+0x1e>
    
    /*
     * Mark controller as locked if successful so that it will be unlocked by a
     * call to release_ctrl_access.
     */
    if(NVM_SUCCESS == status)
200087ea:	7cfb      	ldrb	r3, [r7, #19]
200087ec:	2b00      	cmp	r3, #0
200087ee:	d112      	bne.n	20008816 <request_nvm_access+0x9a>
    {
        g_envm_ctrl_locks |= (uint8_t)((uint32_t)0x01 << nvm_block_id);
200087f0:	687b      	ldr	r3, [r7, #4]
200087f2:	f04f 0201 	mov.w	r2, #1
200087f6:	fa02 f303 	lsl.w	r3, r2, r3
200087fa:	b2da      	uxtb	r2, r3
200087fc:	f24c 3319 	movw	r3, #49945	; 0xc319
20008800:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008804:	781b      	ldrb	r3, [r3, #0]
20008806:	ea42 0303 	orr.w	r3, r2, r3
2000880a:	b2da      	uxtb	r2, r3
2000880c:	f24c 3319 	movw	r3, #49945	; 0xc319
20008810:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008814:	701a      	strb	r2, [r3, #0]
    }
    
    return status;
20008816:	7cfb      	ldrb	r3, [r7, #19]
}
20008818:	4618      	mov	r0, r3
2000881a:	f107 071c 	add.w	r7, r7, #28
2000881e:	46bd      	mov	sp, r7
20008820:	bc80      	pop	{r7}
20008822:	4770      	bx	lr

20008824 <get_ctrl_access>:

/**************************************************************************//**
 * Get access to eNVM controller for eNVM0 and eNVM1
 */
static nvm_status_t get_ctrl_access(uint32_t nvm_offset, uint32_t length)
{
20008824:	b580      	push	{r7, lr}
20008826:	b084      	sub	sp, #16
20008828:	af00      	add	r7, sp, #0
2000882a:	6078      	str	r0, [r7, #4]
2000882c:	6039      	str	r1, [r7, #0]
    nvm_status_t access_req_status;
    
    /*
     * Gain access to eNVM controller(s).
     */
    if(nvm_offset < NVM1_BOTTOM_OFFSET)
2000882e:	687a      	ldr	r2, [r7, #4]
20008830:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008834:	f2c0 0303 	movt	r3, #3
20008838:	429a      	cmp	r2, r3
2000883a:	d821      	bhi.n	20008880 <get_ctrl_access+0x5c>
    {
        access_req_status = request_nvm_access(NVM_BLOCK_0);
2000883c:	f04f 0000 	mov.w	r0, #0
20008840:	f7ff ff9c 	bl	2000877c <request_nvm_access>
20008844:	4603      	mov	r3, r0
20008846:	72fb      	strb	r3, [r7, #11]
        if(NVM_SUCCESS == access_req_status)
20008848:	7afb      	ldrb	r3, [r7, #11]
2000884a:	2b00      	cmp	r3, #0
2000884c:	d11f      	bne.n	2000888e <get_ctrl_access+0x6a>
        {
            uint32_t last_offset;
            last_offset = nvm_offset + (length - 0x1u);
2000884e:	683a      	ldr	r2, [r7, #0]
20008850:	687b      	ldr	r3, [r7, #4]
20008852:	4413      	add	r3, r2
20008854:	f103 33ff 	add.w	r3, r3, #4294967295
20008858:	60fb      	str	r3, [r7, #12]
            if(last_offset >= NVM1_BOTTOM_OFFSET)
2000885a:	68fa      	ldr	r2, [r7, #12]
2000885c:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008860:	f2c0 0303 	movt	r3, #3
20008864:	429a      	cmp	r2, r3
20008866:	d914      	bls.n	20008892 <get_ctrl_access+0x6e>
            {
                access_req_status = request_nvm_access(NVM_BLOCK_1);
20008868:	f04f 0001 	mov.w	r0, #1
2000886c:	f7ff ff86 	bl	2000877c <request_nvm_access>
20008870:	4603      	mov	r3, r0
20008872:	72fb      	strb	r3, [r7, #11]
                if(NVM_IN_USE_BY_OTHER_MASTER == access_req_status)
20008874:	7afb      	ldrb	r3, [r7, #11]
20008876:	2b06      	cmp	r3, #6
20008878:	d10d      	bne.n	20008896 <get_ctrl_access+0x72>
                {
                    release_ctrl_access();
2000887a:	f000 f813 	bl	200088a4 <release_ctrl_access>
2000887e:	e00b      	b.n	20008898 <get_ctrl_access+0x74>
            }
        }
    }
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
20008880:	f04f 0001 	mov.w	r0, #1
20008884:	f7ff ff7a 	bl	2000877c <request_nvm_access>
20008888:	4603      	mov	r3, r0
2000888a:	72fb      	strb	r3, [r7, #11]
2000888c:	e004      	b.n	20008898 <get_ctrl_access+0x74>
            if(last_offset >= NVM1_BOTTOM_OFFSET)
            {
                access_req_status = request_nvm_access(NVM_BLOCK_1);
                if(NVM_IN_USE_BY_OTHER_MASTER == access_req_status)
                {
                    release_ctrl_access();
2000888e:	bf00      	nop
20008890:	e002      	b.n	20008898 <get_ctrl_access+0x74>
20008892:	bf00      	nop
20008894:	e000      	b.n	20008898 <get_ctrl_access+0x74>
20008896:	bf00      	nop
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    }
    
    return access_req_status;
20008898:	7afb      	ldrb	r3, [r7, #11]
}
2000889a:	4618      	mov	r0, r3
2000889c:	f107 0710 	add.w	r7, r7, #16
200088a0:	46bd      	mov	sp, r7
200088a2:	bd80      	pop	{r7, pc}

200088a4 <release_ctrl_access>:
 */
#define NVM_BLOCK_0_LOCK_MASK   0x01u
#define NVM_BLOCK_1_LOCK_MASK   0x02u

static void release_ctrl_access(void)
{
200088a4:	b480      	push	{r7}
200088a6:	b083      	sub	sp, #12
200088a8:	af00      	add	r7, sp, #0
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
200088aa:	f24c 3319 	movw	r3, #49945	; 0xc319
200088ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200088b2:	781b      	ldrb	r3, [r3, #0]
200088b4:	f003 0301 	and.w	r3, r3, #1
200088b8:	71fb      	strb	r3, [r7, #7]
    if(block_locked)
200088ba:	79fb      	ldrb	r3, [r7, #7]
200088bc:	2b00      	cmp	r3, #0
200088be:	d015      	beq.n	200088ec <release_ctrl_access+0x48>
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
200088c0:	f64b 639c 	movw	r3, #48796	; 0xbe9c
200088c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200088c8:	681b      	ldr	r3, [r3, #0]
200088ca:	f04f 0200 	mov.w	r2, #0
200088ce:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
200088d2:	f24c 3319 	movw	r3, #49945	; 0xc319
200088d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200088da:	781b      	ldrb	r3, [r3, #0]
200088dc:	461a      	mov	r2, r3
200088de:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
200088e2:	f24c 3319 	movw	r3, #49945	; 0xc319
200088e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200088ea:	701a      	strb	r2, [r3, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
200088ec:	f24c 3319 	movw	r3, #49945	; 0xc319
200088f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200088f4:	781b      	ldrb	r3, [r3, #0]
200088f6:	f003 0302 	and.w	r3, r3, #2
200088fa:	71fb      	strb	r3, [r7, #7]
    if(block_locked)
200088fc:	79fb      	ldrb	r3, [r7, #7]
200088fe:	2b00      	cmp	r3, #0
20008900:	d015      	beq.n	2000892e <release_ctrl_access+0x8a>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
20008902:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008906:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000890a:	685b      	ldr	r3, [r3, #4]
2000890c:	f04f 0200 	mov.w	r2, #0
20008910:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
20008914:	f24c 3319 	movw	r3, #49945	; 0xc319
20008918:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000891c:	781b      	ldrb	r3, [r3, #0]
2000891e:	461a      	mov	r2, r3
20008920:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
20008924:	f24c 3319 	movw	r3, #49945	; 0xc319
20008928:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000892c:	701a      	strb	r2, [r3, #0]
    }
}
2000892e:	f107 070c 	add.w	r7, r7, #12
20008932:	46bd      	mov	sp, r7
20008934:	bc80      	pop	{r7}
20008936:	4770      	bx	lr

20008938 <wait_nvm_ready>:

/**************************************************************************//**
 * Wait for NVM to become ready from busy state
 */
static uint32_t wait_nvm_ready(uint32_t block) 
{
20008938:	b480      	push	{r7}
2000893a:	b087      	sub	sp, #28
2000893c:	af00      	add	r7, sp, #0
2000893e:	6078      	str	r0, [r7, #4]
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
20008940:	f04f 0300 	mov.w	r3, #0
20008944:	617b      	str	r3, [r7, #20]
20008946:	e014      	b.n	20008972 <wait_nvm_ready+0x3a>
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
20008948:	687a      	ldr	r2, [r7, #4]
2000894a:	f64b 639c 	movw	r3, #48796	; 0xbe9c
2000894e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008952:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008956:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
2000895a:	60fb      	str	r3, [r7, #12]
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
2000895c:	68fb      	ldr	r3, [r7, #12]
2000895e:	f003 0301 	and.w	r3, r3, #1
20008962:	613b      	str	r3, [r7, #16]
        } while(0u == ctrl_ready);
20008964:	693b      	ldr	r3, [r7, #16]
20008966:	2b00      	cmp	r3, #0
20008968:	d0ee      	beq.n	20008948 <wait_nvm_ready+0x10>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
2000896a:	697b      	ldr	r3, [r7, #20]
2000896c:	f103 0301 	add.w	r3, r3, #1
20008970:	617b      	str	r3, [r7, #20]
20008972:	697b      	ldr	r3, [r7, #20]
20008974:	2b01      	cmp	r3, #1
20008976:	d9e7      	bls.n	20008948 <wait_nvm_ready+0x10>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
20008978:	68fb      	ldr	r3, [r7, #12]
}
2000897a:	4618      	mov	r0, r3
2000897c:	f107 071c 	add.w	r7, r7, #28
20008980:	46bd      	mov	sp, r7
20008982:	bc80      	pop	{r7}
20008984:	4770      	bx	lr
20008986:	bf00      	nop

20008988 <write_nvm>:
    const uint8_t * pidata,
    uint32_t  length,
    uint32_t  lock_page,
    uint32_t * p_status
)
{
20008988:	b580      	push	{r7, lr}
2000898a:	b08a      	sub	sp, #40	; 0x28
2000898c:	af00      	add	r7, sp, #0
2000898e:	60f8      	str	r0, [r7, #12]
20008990:	60b9      	str	r1, [r7, #8]
20008992:	607a      	str	r2, [r7, #4]
20008994:	603b      	str	r3, [r7, #0]
    uint32_t length_written;
    uint32_t offset;
   
    *p_status = 0u;
20008996:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20008998:	f04f 0200 	mov.w	r2, #0
2000899c:	601a      	str	r2, [r3, #0]
    
    /* Ignore upper address bits to ignore remapping setting. */    
    offset = addr & NVM_OFFSET_SIGNIFICANT_BITS;
2000899e:	68fb      	ldr	r3, [r7, #12]
200089a0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
200089a4:	f423 0378 	bic.w	r3, r3, #16252928	; 0xf80000
200089a8:	61fb      	str	r3, [r7, #28]
    
    ASSERT(offset <= NVM1_TOP_OFFSET);
200089aa:	69fa      	ldr	r2, [r7, #28]
200089ac:	f64f 73ff 	movw	r3, #65535	; 0xffff
200089b0:	f2c0 0307 	movt	r3, #7
200089b4:	429a      	cmp	r2, r3
200089b6:	d900      	bls.n	200089ba <write_nvm+0x32>
200089b8:	be00      	bkpt	0x0000
    
    /* Adjust length to fit within one page. */
    length_written = get_remaining_page_length(offset, length);
200089ba:	69f8      	ldr	r0, [r7, #28]
200089bc:	6879      	ldr	r1, [r7, #4]
200089be:	f000 f88f 	bl	20008ae0 <get_remaining_page_length>
200089c2:	4603      	mov	r3, r0
200089c4:	61bb      	str	r3, [r7, #24]
    
    if(offset <= NVM1_TOP_OFFSET)
200089c6:	69fa      	ldr	r2, [r7, #28]
200089c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
200089cc:	f2c0 0307 	movt	r3, #7
200089d0:	429a      	cmp	r2, r3
200089d2:	d87e      	bhi.n	20008ad2 <write_nvm+0x14a>
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
200089d4:	69fa      	ldr	r2, [r7, #28]
200089d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
200089da:	f2c0 0303 	movt	r3, #3
200089de:	429a      	cmp	r2, r3
200089e0:	d803      	bhi.n	200089ea <write_nvm+0x62>
        {
            block = NVM_BLOCK_0;
200089e2:	f04f 0300 	mov.w	r3, #0
200089e6:	623b      	str	r3, [r7, #32]
200089e8:	e006      	b.n	200089f8 <write_nvm+0x70>
        }
        else
        {
            block = NVM_BLOCK_1;
200089ea:	f04f 0301 	mov.w	r3, #1
200089ee:	623b      	str	r3, [r7, #32]
            offset = offset - NVM1_BOTTOM_OFFSET;
200089f0:	69fb      	ldr	r3, [r7, #28]
200089f2:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
200089f6:	61fb      	str	r3, [r7, #28]
        }
        
        if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
200089f8:	6a3a      	ldr	r2, [r7, #32]
200089fa:	f64b 639c 	movw	r3, #48796	; 0xbe9c
200089fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008a02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008a06:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
20008a0a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20008a0e:	2b00      	cmp	r3, #0
20008a10:	d013      	beq.n	20008a3a <write_nvm+0xb2>
        {
            /* Clear the access denied flag */
            g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
20008a12:	6a3a      	ldr	r2, [r7, #32]
20008a14:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008a1c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
20008a20:	6a39      	ldr	r1, [r7, #32]
20008a22:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008a2a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
20008a2e:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
20008a32:	f043 0302 	orr.w	r3, r3, #2
20008a36:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
        }

        fill_wd_buffer(pidata, length_written, block, offset);
20008a3a:	68b8      	ldr	r0, [r7, #8]
20008a3c:	69b9      	ldr	r1, [r7, #24]
20008a3e:	6a3a      	ldr	r2, [r7, #32]
20008a40:	69fb      	ldr	r3, [r7, #28]
20008a42:	f000 f86f 	bl	20008b24 <fill_wd_buffer>

        /* Set requested locking option. */
        g_nvm[block]->PAGE_LOCK = lock_page;
20008a46:	6a3a      	ldr	r2, [r7, #32]
20008a48:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008a50:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008a54:	683a      	ldr	r2, [r7, #0]
20008a56:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
20008a5a:	6a3a      	ldr	r2, [r7, #32]
20008a5c:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008a64:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
20008a68:	69fb      	ldr	r3, [r7, #28]
20008a6a:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
20008a6e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20008a72:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
20008a76:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
        
        /* Wait for NVM to become ready. */
        ctrl_status = wait_nvm_ready(block);
20008a7a:	6a38      	ldr	r0, [r7, #32]
20008a7c:	f7ff ff5c 	bl	20008938 <wait_nvm_ready>
20008a80:	4603      	mov	r3, r0
20008a82:	617b      	str	r3, [r7, #20]

        /* Check for errors. */
        errors = ctrl_status & WRITE_ERROR_MASK;
20008a84:	697a      	ldr	r2, [r7, #20]
20008a86:	f240 031e 	movw	r3, #30
20008a8a:	f2c0 0304 	movt	r3, #4
20008a8e:	ea02 0303 	and.w	r3, r2, r3
20008a92:	627b      	str	r3, [r7, #36]	; 0x24
        if(errors)
20008a94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008a96:	2b00      	cmp	r3, #0
20008a98:	d003      	beq.n	20008aa2 <write_nvm+0x11a>
        {
            *p_status = ctrl_status;
20008a9a:	697a      	ldr	r2, [r7, #20]
20008a9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20008a9e:	601a      	str	r2, [r3, #0]
20008aa0:	e017      	b.n	20008ad2 <write_nvm+0x14a>
        }
        else
        {
            /* Perform a verify. */
            g_nvm[block]->CMD = VERIFY_ADS | (offset & PAGE_ADDR_MASK);
20008aa2:	6a3a      	ldr	r2, [r7, #32]
20008aa4:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008aac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
20008ab0:	69fb      	ldr	r3, [r7, #28]
20008ab2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20008ab6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20008aba:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20008abe:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
            /* Wait for NVM to become ready. */
            ctrl_status = wait_nvm_ready(block);
20008ac2:	6a38      	ldr	r0, [r7, #32]
20008ac4:	f7ff ff38 	bl	20008938 <wait_nvm_ready>
20008ac8:	4603      	mov	r3, r0
20008aca:	617b      	str	r3, [r7, #20]

            *p_status = ctrl_status;
20008acc:	697a      	ldr	r2, [r7, #20]
20008ace:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20008ad0:	601a      	str	r2, [r3, #0]
        }
    }
    
    return length_written;
20008ad2:	69bb      	ldr	r3, [r7, #24]
}
20008ad4:	4618      	mov	r0, r3
20008ad6:	f107 0728 	add.w	r7, r7, #40	; 0x28
20008ada:	46bd      	mov	sp, r7
20008adc:	bd80      	pop	{r7, pc}
20008ade:	bf00      	nop

20008ae0 <get_remaining_page_length>:
  indicates that the WD[] buffer will have to be seeded with the existing
  content of the eNVM before copying the data to program to eNVM into the WD[]
  buffer.
 */
static uint32_t get_remaining_page_length(uint32_t offset, uint32_t length)
{
20008ae0:	b480      	push	{r7}
20008ae2:	b085      	sub	sp, #20
20008ae4:	af00      	add	r7, sp, #0
20008ae6:	6078      	str	r0, [r7, #4]
20008ae8:	6039      	str	r1, [r7, #0]
    uint32_t start_page_plus_one;
    uint32_t last_page;
    
    start_page_plus_one = (offset / BYTES_PER_PAGE) + 1u;
20008aea:	687b      	ldr	r3, [r7, #4]
20008aec:	ea4f 13d3 	mov.w	r3, r3, lsr #7
20008af0:	f103 0301 	add.w	r3, r3, #1
20008af4:	60bb      	str	r3, [r7, #8]
    last_page = (offset + length) / BYTES_PER_PAGE;
20008af6:	687a      	ldr	r2, [r7, #4]
20008af8:	683b      	ldr	r3, [r7, #0]
20008afa:	4413      	add	r3, r2
20008afc:	ea4f 13d3 	mov.w	r3, r3, lsr #7
20008b00:	60fb      	str	r3, [r7, #12]
    if(last_page >= start_page_plus_one)
20008b02:	68fa      	ldr	r2, [r7, #12]
20008b04:	68bb      	ldr	r3, [r7, #8]
20008b06:	429a      	cmp	r2, r3
20008b08:	d305      	bcc.n	20008b16 <get_remaining_page_length+0x36>
    {
        length = BYTES_PER_PAGE - (offset % BYTES_PER_PAGE);
20008b0a:	687b      	ldr	r3, [r7, #4]
20008b0c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20008b10:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
20008b14:	603b      	str	r3, [r7, #0]
    }
    
    return length;
20008b16:	683b      	ldr	r3, [r7, #0]
}
20008b18:	4618      	mov	r0, r3
20008b1a:	f107 0714 	add.w	r7, r7, #20
20008b1e:	46bd      	mov	sp, r7
20008b20:	bc80      	pop	{r7}
20008b22:	4770      	bx	lr

20008b24 <fill_wd_buffer>:
    const uint8_t * p_data,
    uint32_t  length,
    uint32_t block,
    uint32_t offset
)
{
20008b24:	b480      	push	{r7}
20008b26:	b08b      	sub	sp, #44	; 0x2c
20008b28:	af00      	add	r7, sp, #0
20008b2a:	60f8      	str	r0, [r7, #12]
20008b2c:	60b9      	str	r1, [r7, #8]
20008b2e:	607a      	str	r2, [r7, #4]
20008b30:	603b      	str	r3, [r7, #0]
    uint32_t inc;
    uint32_t wd_offset;
    
    if(length != BYTES_PER_PAGE)
20008b32:	68bb      	ldr	r3, [r7, #8]
20008b34:	2b80      	cmp	r3, #128	; 0x80
20008b36:	d067      	beq.n	20008c08 <fill_wd_buffer+0xe4>
        uint32_t first_non_written_word;
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
20008b38:	687b      	ldr	r3, [r7, #4]
20008b3a:	ea4f 4283 	mov.w	r2, r3, lsl #18
20008b3e:	683b      	ldr	r3, [r7, #0]
20008b40:	4413      	add	r3, r2
20008b42:	f103 43c0 	add.w	r3, r3, #1610612736	; 0x60000000
20008b46:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20008b4a:	61fb      	str	r3, [r7, #28]
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
20008b4c:	683b      	ldr	r3, [r7, #0]
20008b4e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20008b52:	ea4f 0393 	mov.w	r3, r3, lsr #2
20008b56:	623b      	str	r3, [r7, #32]
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
20008b58:	683b      	ldr	r3, [r7, #0]
20008b5a:	f003 0303 	and.w	r3, r3, #3
20008b5e:	2b00      	cmp	r3, #0
20008b60:	d003      	beq.n	20008b6a <fill_wd_buffer+0x46>
        {
            ++nb_non_written_words;
20008b62:	6a3b      	ldr	r3, [r7, #32]
20008b64:	f103 0301 	add.w	r3, r3, #1
20008b68:	623b      	str	r3, [r7, #32]
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
20008b6a:	f04f 0300 	mov.w	r3, #0
20008b6e:	617b      	str	r3, [r7, #20]
20008b70:	e015      	b.n	20008b9e <fill_wd_buffer+0x7a>
        {
            g_nvm32[block]->WD[inc] = p_nvm32[inc];
20008b72:	687a      	ldr	r2, [r7, #4]
20008b74:	f64b 63a4 	movw	r3, #48804	; 0xbea4
20008b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008b7c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008b80:	697a      	ldr	r2, [r7, #20]
20008b82:	6979      	ldr	r1, [r7, #20]
20008b84:	ea4f 0081 	mov.w	r0, r1, lsl #2
20008b88:	69f9      	ldr	r1, [r7, #28]
20008b8a:	4401      	add	r1, r0
20008b8c:	6809      	ldr	r1, [r1, #0]
20008b8e:	f102 0220 	add.w	r2, r2, #32
20008b92:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
20008b96:	697b      	ldr	r3, [r7, #20]
20008b98:	f103 0301 	add.w	r3, r3, #1
20008b9c:	617b      	str	r3, [r7, #20]
20008b9e:	697b      	ldr	r3, [r7, #20]
20008ba0:	2b1f      	cmp	r3, #31
20008ba2:	d803      	bhi.n	20008bac <fill_wd_buffer+0x88>
20008ba4:	697a      	ldr	r2, [r7, #20]
20008ba6:	6a3b      	ldr	r3, [r7, #32]
20008ba8:	429a      	cmp	r2, r3
20008baa:	d3e2      	bcc.n	20008b72 <fill_wd_buffer+0x4e>
        
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
20008bac:	683a      	ldr	r2, [r7, #0]
20008bae:	68bb      	ldr	r3, [r7, #8]
20008bb0:	4413      	add	r3, r2
20008bb2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20008bb6:	ea4f 0393 	mov.w	r3, r3, lsr #2
20008bba:	627b      	str	r3, [r7, #36]	; 0x24
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
20008bbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008bbe:	f1c3 0320 	rsb	r3, r3, #32
20008bc2:	623b      	str	r3, [r7, #32]
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
20008bc4:	f04f 0300 	mov.w	r3, #0
20008bc8:	617b      	str	r3, [r7, #20]
20008bca:	e019      	b.n	20008c00 <fill_wd_buffer+0xdc>
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
20008bcc:	687a      	ldr	r2, [r7, #4]
20008bce:	f64b 63a4 	movw	r3, #48804	; 0xbea4
20008bd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008bd6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008bda:	6a79      	ldr	r1, [r7, #36]	; 0x24
20008bdc:	697a      	ldr	r2, [r7, #20]
20008bde:	440a      	add	r2, r1
20008be0:	6a78      	ldr	r0, [r7, #36]	; 0x24
20008be2:	6979      	ldr	r1, [r7, #20]
20008be4:	4401      	add	r1, r0
20008be6:	ea4f 0081 	mov.w	r0, r1, lsl #2
20008bea:	69f9      	ldr	r1, [r7, #28]
20008bec:	4401      	add	r1, r0
20008bee:	6809      	ldr	r1, [r1, #0]
20008bf0:	f102 0220 	add.w	r2, r2, #32
20008bf4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
20008bf8:	697b      	ldr	r3, [r7, #20]
20008bfa:	f103 0301 	add.w	r3, r3, #1
20008bfe:	617b      	str	r3, [r7, #20]
20008c00:	697a      	ldr	r2, [r7, #20]
20008c02:	6a3b      	ldr	r3, [r7, #32]
20008c04:	429a      	cmp	r2, r3
20008c06:	d3e1      	bcc.n	20008bcc <fill_wd_buffer+0xa8>
    }
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
20008c08:	683b      	ldr	r3, [r7, #0]
20008c0a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20008c0e:	61bb      	str	r3, [r7, #24]
    for(inc = 0u; inc < length; ++inc)
20008c10:	f04f 0300 	mov.w	r3, #0
20008c14:	617b      	str	r3, [r7, #20]
20008c16:	e014      	b.n	20008c42 <fill_wd_buffer+0x11e>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
20008c18:	687a      	ldr	r2, [r7, #4]
20008c1a:	f64b 639c 	movw	r3, #48796	; 0xbe9c
20008c1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008c22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20008c26:	69b9      	ldr	r1, [r7, #24]
20008c28:	697a      	ldr	r2, [r7, #20]
20008c2a:	4411      	add	r1, r2
20008c2c:	68f8      	ldr	r0, [r7, #12]
20008c2e:	697a      	ldr	r2, [r7, #20]
20008c30:	4402      	add	r2, r0
20008c32:	7812      	ldrb	r2, [r2, #0]
20008c34:	440b      	add	r3, r1
20008c36:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
20008c3a:	697b      	ldr	r3, [r7, #20]
20008c3c:	f103 0301 	add.w	r3, r3, #1
20008c40:	617b      	str	r3, [r7, #20]
20008c42:	697a      	ldr	r2, [r7, #20]
20008c44:	68bb      	ldr	r3, [r7, #8]
20008c46:	429a      	cmp	r2, r3
20008c48:	d3e6      	bcc.n	20008c18 <fill_wd_buffer+0xf4>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    }
}
20008c4a:	f107 072c 	add.w	r7, r7, #44	; 0x2c
20008c4e:	46bd      	mov	sp, r7
20008c50:	bc80      	pop	{r7}
20008c52:	4770      	bx	lr

20008c54 <check_protection_reserved_nvm>:
 *  0x7C000 - 0x7CFFF - 4KB(32 pages) user lower1(bottom) protected area of eNVM1 memory.
 *  0x7B000 - 0x7BFFF - 4KB(32 pages) user upper1(top) protected area of eNVM1 memory.          
 *
 */
static nvm_status_t check_protection_reserved_nvm(uint32_t offset, uint32_t length)
{
20008c54:	b580      	push	{r7, lr}
20008c56:	b08c      	sub	sp, #48	; 0x30
20008c58:	af00      	add	r7, sp, #0
20008c5a:	6078      	str	r0, [r7, #4]
20008c5c:	6039      	str	r1, [r7, #0]
    uint32_t protection_user0;
    uint32_t protection_user1;
    uint32_t protection_user2;
    uint32_t protection_user3;
    uint32_t protection_flag;
    uint32_t length_minus_one = 0u;
20008c5e:	f04f 0300 	mov.w	r3, #0
20008c62:	62bb      	str	r3, [r7, #40]	; 0x28
    nvm_status_t status = NVM_SUCCESS;
20008c64:	f04f 0300 	mov.w	r3, #0
20008c68:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    if(0u != length)
20008c6c:	683b      	ldr	r3, [r7, #0]
20008c6e:	2b00      	cmp	r3, #0
20008c70:	d003      	beq.n	20008c7a <check_protection_reserved_nvm+0x26>
    {
        length_minus_one = length - 1u;
20008c72:	683b      	ldr	r3, [r7, #0]
20008c74:	f103 33ff 	add.w	r3, r3, #4294967295
20008c78:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
20008c7a:	f248 0300 	movw	r3, #32768	; 0x8000
20008c7e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008c82:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
20008c86:	ea4f 4303 	mov.w	r3, r3, lsl #16
20008c8a:	ea4f 4313 	mov.w	r3, r3, lsr #16
20008c8e:	60fb      	str	r3, [r7, #12]
    
    protection_flag = PROTECTION_OFF;
20008c90:	f04f 0300 	mov.w	r3, #0
20008c94:	627b      	str	r3, [r7, #36]	; 0x24
    
    /* 005 device */
    if(0xF805u == device_version)
20008c96:	68fa      	ldr	r2, [r7, #12]
20008c98:	f64f 0305 	movw	r3, #63493	; 0xf805
20008c9c:	429a      	cmp	r2, r3
20008c9e:	f040 80a6 	bne.w	20008dee <check_protection_reserved_nvm+0x19a>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
20008ca2:	f248 0300 	movw	r3, #32768	; 0x8000
20008ca6:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008caa:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
20008cae:	f649 1399 	movw	r3, #39321	; 0x9999
20008cb2:	f2c0 0300 	movt	r3, #0
20008cb6:	ea02 0303 	and.w	r3, r2, r3
20008cba:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
20008cbc:	693a      	ldr	r2, [r7, #16]
20008cbe:	f649 1399 	movw	r3, #39321	; 0x9999
20008cc2:	429a      	cmp	r2, r3
20008cc4:	d054      	beq.n	20008d70 <check_protection_reserved_nvm+0x11c>
        {
            protection_user0 = (protection_data & 0x000Fu);
20008cc6:	693b      	ldr	r3, [r7, #16]
20008cc8:	f003 030f 	and.w	r3, r3, #15
20008ccc:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
20008cce:	693b      	ldr	r3, [r7, #16]
20008cd0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20008cd4:	ea4f 1313 	mov.w	r3, r3, lsr #4
20008cd8:	61bb      	str	r3, [r7, #24]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (WRITE_ONLY == protection_user1) ||
20008cda:	697b      	ldr	r3, [r7, #20]
20008cdc:	2b08      	cmp	r3, #8
20008cde:	d008      	beq.n	20008cf2 <check_protection_reserved_nvm+0x9e>
20008ce0:	69bb      	ldr	r3, [r7, #24]
20008ce2:	2b08      	cmp	r3, #8
20008ce4:	d005      	beq.n	20008cf2 <check_protection_reserved_nvm+0x9e>
20008ce6:	697b      	ldr	r3, [r7, #20]
20008ce8:	2b00      	cmp	r3, #0
20008cea:	d002      	beq.n	20008cf2 <check_protection_reserved_nvm+0x9e>
20008cec:	69bb      	ldr	r3, [r7, #24]
20008cee:	2b00      	cmp	r3, #0
20008cf0:	d106      	bne.n	20008d00 <check_protection_reserved_nvm+0xac>
               (NO_READ_WRITE == protection_user0) || (NO_READ_WRITE == protection_user1))
            {
                g_do_not_lock_page = ON;
20008cf2:	f24c 3318 	movw	r3, #49944	; 0xc318
20008cf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008cfa:	f04f 0201 	mov.w	r2, #1
20008cfe:	701a      	strb	r2, [r3, #0]
            
            /* 
             * SAR 70908.
             * Checking NVM0 lower protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0)
20008d00:	697b      	ldr	r3, [r7, #20]
20008d02:	2b09      	cmp	r3, #9
20008d04:	d00a      	beq.n	20008d1c <check_protection_reserved_nvm+0xc8>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
20008d06:	687a      	ldr	r2, [r7, #4]
20008d08:	f640 73ff 	movw	r3, #4095	; 0xfff
20008d0c:	429a      	cmp	r2, r3
20008d0e:	d805      	bhi.n	20008d1c <check_protection_reserved_nvm+0xc8>
                {
                    protection_flag = protection_check(protection_user0, length);
20008d10:	6978      	ldr	r0, [r7, #20]
20008d12:	6839      	ldr	r1, [r7, #0]
20008d14:	f000 fade 	bl	200092d4 <protection_check>
20008d18:	4603      	mov	r3, r0
20008d1a:	627b      	str	r3, [r7, #36]	; 0x24
            
            /*
             * SAR 70908.
             * Checking NVM0 upper protected area is Read or Write or 'No R/W' access 
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
20008d1c:	69bb      	ldr	r3, [r7, #24]
20008d1e:	2b09      	cmp	r3, #9
20008d20:	d026      	beq.n	20008d70 <check_protection_reserved_nvm+0x11c>
20008d22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008d24:	2b00      	cmp	r3, #0
20008d26:	d123      	bne.n	20008d70 <check_protection_reserved_nvm+0x11c>
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) && 
20008d28:	687a      	ldr	r2, [r7, #4]
20008d2a:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008d2e:	f2c0 0301 	movt	r3, #1
20008d32:	429a      	cmp	r2, r3
20008d34:	d906      	bls.n	20008d44 <check_protection_reserved_nvm+0xf0>
20008d36:	687a      	ldr	r2, [r7, #4]
20008d38:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008d3c:	f2c0 0301 	movt	r3, #1
20008d40:	429a      	cmp	r2, r3
20008d42:	d90f      	bls.n	20008d64 <check_protection_reserved_nvm+0x110>
                    (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) &&
20008d44:	687a      	ldr	r2, [r7, #4]
20008d46:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008d48:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) && 
20008d4a:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008d4e:	f2c0 0301 	movt	r3, #1
20008d52:	429a      	cmp	r2, r3
20008d54:	d90c      	bls.n	20008d70 <check_protection_reserved_nvm+0x11c>
20008d56:	687a      	ldr	r2, [r7, #4]
20008d58:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008d5c:	f2c0 0301 	movt	r3, #1
20008d60:	429a      	cmp	r2, r3
20008d62:	d805      	bhi.n	20008d70 <check_protection_reserved_nvm+0x11c>
                    (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < OO5_UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
20008d64:	69b8      	ldr	r0, [r7, #24]
20008d66:	6839      	ldr	r1, [r7, #0]
20008d68:	f000 fab4 	bl	200092d4 <protection_check>
20008d6c:	4603      	mov	r3, r0
20008d6e:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }
        }
        
        /* Check the eNVM memory is protected or not */
        if(PROTECTION_ON == protection_flag)
20008d70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008d72:	2b01      	cmp	r3, #1
20008d74:	d104      	bne.n	20008d80 <check_protection_reserved_nvm+0x12c>
        {
            /* Status is protection error if lower or upper area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
20008d76:	f04f 0301 	mov.w	r3, #1
20008d7a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
20008d7e:	e2a2      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > OO5_UPPER0_PROTECT_TOP_OFFSET)
20008d80:	687a      	ldr	r2, [r7, #4]
20008d82:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008d84:	441a      	add	r2, r3
20008d86:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008d8a:	f2c0 0301 	movt	r3, #1
20008d8e:	429a      	cmp	r2, r3
20008d90:	d904      	bls.n	20008d9c <check_protection_reserved_nvm+0x148>
            {
                status = NVM_INVALID_PARAMETER;
20008d92:	f04f 0307 	mov.w	r3, #7
20008d96:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
20008d9a:	e294      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
20008d9c:	687a      	ldr	r2, [r7, #4]
20008d9e:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008da2:	f2c0 0301 	movt	r3, #1
20008da6:	429a      	cmp	r2, r3
20008da8:	d906      	bls.n	20008db8 <check_protection_reserved_nvm+0x164>
20008daa:	687a      	ldr	r2, [r7, #4]
20008dac:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008db0:	f2c0 0301 	movt	r3, #1
20008db4:	429a      	cmp	r2, r3
20008db6:	d90f      	bls.n	20008dd8 <check_protection_reserved_nvm+0x184>
                    (((offset + length_minus_one) >= OO5_NVM_RSV_OFFSET) &&
20008db8:	687a      	ldr	r2, [r7, #4]
20008dba:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008dbc:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
20008dbe:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008dc2:	f2c0 0301 	movt	r3, #1
20008dc6:	429a      	cmp	r2, r3
20008dc8:	d90c      	bls.n	20008de4 <check_protection_reserved_nvm+0x190>
20008dca:	687a      	ldr	r2, [r7, #4]
20008dcc:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008dd0:	f2c0 0301 	movt	r3, #1
20008dd4:	429a      	cmp	r2, r3
20008dd6:	d805      	bhi.n	20008de4 <check_protection_reserved_nvm+0x190>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
20008dd8:	f04f 0301 	mov.w	r3, #1
20008ddc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) ||
20008de0:	bf00      	nop
20008de2:	e270      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if the offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
20008de4:	f04f 0300 	mov.w	r3, #0
20008de8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
20008dec:	e26b      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
20008dee:	68fa      	ldr	r2, [r7, #12]
20008df0:	f64f 0302 	movw	r3, #63490	; 0xf802
20008df4:	429a      	cmp	r2, r3
20008df6:	d00a      	beq.n	20008e0e <check_protection_reserved_nvm+0x1ba>
20008df8:	68fa      	ldr	r2, [r7, #12]
20008dfa:	f64f 0303 	movw	r3, #63491	; 0xf803
20008dfe:	429a      	cmp	r2, r3
20008e00:	d005      	beq.n	20008e0e <check_protection_reserved_nvm+0x1ba>
20008e02:	68fa      	ldr	r2, [r7, #12]
20008e04:	f64f 0304 	movw	r3, #63492	; 0xf804
20008e08:	429a      	cmp	r2, r3
20008e0a:	f040 80a6 	bne.w	20008f5a <check_protection_reserved_nvm+0x306>
    {    
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
20008e0e:	f248 0300 	movw	r3, #32768	; 0x8000
20008e12:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008e16:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
20008e1a:	f649 1399 	movw	r3, #39321	; 0x9999
20008e1e:	f2c0 0300 	movt	r3, #0
20008e22:	ea02 0303 	and.w	r3, r2, r3
20008e26:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
20008e28:	693a      	ldr	r2, [r7, #16]
20008e2a:	f649 1399 	movw	r3, #39321	; 0x9999
20008e2e:	429a      	cmp	r2, r3
20008e30:	d054      	beq.n	20008edc <check_protection_reserved_nvm+0x288>
        {
            protection_user0 = (protection_data & 0x000Fu);
20008e32:	693b      	ldr	r3, [r7, #16]
20008e34:	f003 030f 	and.w	r3, r3, #15
20008e38:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
20008e3a:	693b      	ldr	r3, [r7, #16]
20008e3c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20008e40:	ea4f 1313 	mov.w	r3, r3, lsr #4
20008e44:	61bb      	str	r3, [r7, #24]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (WRITE_ONLY == protection_user1) ||
20008e46:	697b      	ldr	r3, [r7, #20]
20008e48:	2b08      	cmp	r3, #8
20008e4a:	d008      	beq.n	20008e5e <check_protection_reserved_nvm+0x20a>
20008e4c:	69bb      	ldr	r3, [r7, #24]
20008e4e:	2b08      	cmp	r3, #8
20008e50:	d005      	beq.n	20008e5e <check_protection_reserved_nvm+0x20a>
20008e52:	697b      	ldr	r3, [r7, #20]
20008e54:	2b00      	cmp	r3, #0
20008e56:	d002      	beq.n	20008e5e <check_protection_reserved_nvm+0x20a>
20008e58:	69bb      	ldr	r3, [r7, #24]
20008e5a:	2b00      	cmp	r3, #0
20008e5c:	d106      	bne.n	20008e6c <check_protection_reserved_nvm+0x218>
               (NO_READ_WRITE == protection_user0) || (NO_READ_WRITE == protection_user1))
            {
                g_do_not_lock_page = ON;
20008e5e:	f24c 3318 	movw	r3, #49944	; 0xc318
20008e62:	f2c2 0300 	movt	r3, #8192	; 0x2000
20008e66:	f04f 0201 	mov.w	r2, #1
20008e6a:	701a      	strb	r2, [r3, #0]
            
            /* 
             * SAR 70908.
             * Check NVM0 lower protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0)
20008e6c:	697b      	ldr	r3, [r7, #20]
20008e6e:	2b09      	cmp	r3, #9
20008e70:	d00a      	beq.n	20008e88 <check_protection_reserved_nvm+0x234>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
20008e72:	687a      	ldr	r2, [r7, #4]
20008e74:	f640 73ff 	movw	r3, #4095	; 0xfff
20008e78:	429a      	cmp	r2, r3
20008e7a:	d805      	bhi.n	20008e88 <check_protection_reserved_nvm+0x234>
                {
                    protection_flag = protection_check(protection_user0, length);
20008e7c:	6978      	ldr	r0, [r7, #20]
20008e7e:	6839      	ldr	r1, [r7, #0]
20008e80:	f000 fa28 	bl	200092d4 <protection_check>
20008e84:	4603      	mov	r3, r0
20008e86:	627b      	str	r3, [r7, #36]	; 0x24
            
            /* 
             * SAR 70908.
             * Check NVM0 upper protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
20008e88:	69bb      	ldr	r3, [r7, #24]
20008e8a:	2b09      	cmp	r3, #9
20008e8c:	d026      	beq.n	20008edc <check_protection_reserved_nvm+0x288>
20008e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008e90:	2b00      	cmp	r3, #0
20008e92:	d123      	bne.n	20008edc <check_protection_reserved_nvm+0x288>
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
20008e94:	687a      	ldr	r2, [r7, #4]
20008e96:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008e9a:	f2c0 0303 	movt	r3, #3
20008e9e:	429a      	cmp	r2, r3
20008ea0:	d906      	bls.n	20008eb0 <check_protection_reserved_nvm+0x25c>
20008ea2:	687a      	ldr	r2, [r7, #4]
20008ea4:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008ea8:	f2c0 0303 	movt	r3, #3
20008eac:	429a      	cmp	r2, r3
20008eae:	d90f      	bls.n	20008ed0 <check_protection_reserved_nvm+0x27c>
                    (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
20008eb0:	687a      	ldr	r2, [r7, #4]
20008eb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008eb4:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
20008eb6:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008eba:	f2c0 0303 	movt	r3, #3
20008ebe:	429a      	cmp	r2, r3
20008ec0:	d90c      	bls.n	20008edc <check_protection_reserved_nvm+0x288>
20008ec2:	687a      	ldr	r2, [r7, #4]
20008ec4:	f64e 73ff 	movw	r3, #61439	; 0xefff
20008ec8:	f2c0 0303 	movt	r3, #3
20008ecc:	429a      	cmp	r2, r3
20008ece:	d805      	bhi.n	20008edc <check_protection_reserved_nvm+0x288>
                    (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
20008ed0:	69b8      	ldr	r0, [r7, #24]
20008ed2:	6839      	ldr	r1, [r7, #0]
20008ed4:	f000 f9fe 	bl	200092d4 <protection_check>
20008ed8:	4603      	mov	r3, r0
20008eda:	627b      	str	r3, [r7, #36]	; 0x24
                }
            } 
        }
        
        /* Check eNVM lower or upper area of memory is protected or not */
        if(PROTECTION_ON == protection_flag)
20008edc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008ede:	2b01      	cmp	r3, #1
20008ee0:	d104      	bne.n	20008eec <check_protection_reserved_nvm+0x298>
        {
            /* Status is protection error if lower or upper area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
20008ee2:	f04f 0301 	mov.w	r3, #1
20008ee6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
20008eea:	e1ec      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
             /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
20008eec:	687a      	ldr	r2, [r7, #4]
20008eee:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008ef0:	441a      	add	r2, r3
20008ef2:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008ef6:	f2c0 0303 	movt	r3, #3
20008efa:	429a      	cmp	r2, r3
20008efc:	d904      	bls.n	20008f08 <check_protection_reserved_nvm+0x2b4>
            {
                status = NVM_INVALID_PARAMETER;
20008efe:	f04f 0307 	mov.w	r3, #7
20008f02:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
20008f06:	e1de      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20008f08:	687a      	ldr	r2, [r7, #4]
20008f0a:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008f0e:	f2c0 0303 	movt	r3, #3
20008f12:	429a      	cmp	r2, r3
20008f14:	d906      	bls.n	20008f24 <check_protection_reserved_nvm+0x2d0>
20008f16:	687a      	ldr	r2, [r7, #4]
20008f18:	f64f 73ff 	movw	r3, #65535	; 0xffff
20008f1c:	f2c0 0303 	movt	r3, #3
20008f20:	429a      	cmp	r2, r3
20008f22:	d90f      	bls.n	20008f44 <check_protection_reserved_nvm+0x2f0>
                    (((offset + length_minus_one) >= NVM0_RSV_OFFSET) && (offset < NVM0_RSV_OFFSET)))
20008f24:	687a      	ldr	r2, [r7, #4]
20008f26:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008f28:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20008f2a:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008f2e:	f2c0 0303 	movt	r3, #3
20008f32:	429a      	cmp	r2, r3
20008f34:	d90c      	bls.n	20008f50 <check_protection_reserved_nvm+0x2fc>
20008f36:	687a      	ldr	r2, [r7, #4]
20008f38:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
20008f3c:	f2c0 0303 	movt	r3, #3
20008f40:	429a      	cmp	r2, r3
20008f42:	d805      	bhi.n	20008f50 <check_protection_reserved_nvm+0x2fc>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
20008f44:	f04f 0301 	mov.w	r3, #1
20008f48:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20008f4c:	bf00      	nop
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
20008f4e:	e1ba      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if offset or (offset + length) is 
                     * in RW access of eNVM memory(not protected)
                     */
                    status = NVM_SUCCESS;
20008f50:	f04f 0300 	mov.w	r3, #0
20008f54:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }
    
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
20008f58:	e1b5      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            }
        }
    }
    
    /* 060 device */
    else if(0xF808u == device_version)
20008f5a:	68fa      	ldr	r2, [r7, #12]
20008f5c:	f64f 0308 	movw	r3, #63496	; 0xf808
20008f60:	429a      	cmp	r2, r3
20008f62:	f040 809f 	bne.w	200090a4 <check_protection_reserved_nvm+0x450>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
20008f66:	f248 0300 	movw	r3, #32768	; 0x8000
20008f6a:	f2c4 0303 	movt	r3, #16387	; 0x4003
20008f6e:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
20008f72:	f649 1399 	movw	r3, #39321	; 0x9999
20008f76:	f2c0 0300 	movt	r3, #0
20008f7a:	ea02 0303 	and.w	r3, r2, r3
20008f7e:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 lower0/1 or upper0/1 area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
20008f80:	693a      	ldr	r2, [r7, #16]
20008f82:	f649 1399 	movw	r3, #39321	; 0x9999
20008f86:	429a      	cmp	r2, r3
20008f88:	d04d      	beq.n	20009026 <check_protection_reserved_nvm+0x3d2>
        {
            protection_user0 = (protection_data & 0x000Fu);
20008f8a:	693b      	ldr	r3, [r7, #16]
20008f8c:	f003 030f 	and.w	r3, r3, #15
20008f90:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
20008f92:	693b      	ldr	r3, [r7, #16]
20008f94:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20008f98:	ea4f 1313 	mov.w	r3, r3, lsr #4
20008f9c:	61bb      	str	r3, [r7, #24]
            protection_user2 = ((protection_data & 0x0F00u) >> 8u);
20008f9e:	693b      	ldr	r3, [r7, #16]
20008fa0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
20008fa4:	ea4f 2313 	mov.w	r3, r3, lsr #8
20008fa8:	61fb      	str	r3, [r7, #28]
            protection_user3 = ((protection_data & 0xF000u) >> 12u);
20008faa:	693b      	ldr	r3, [r7, #16]
20008fac:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
20008fb0:	ea4f 3313 	mov.w	r3, r3, lsr #12
20008fb4:	623b      	str	r3, [r7, #32]
            
            /* 
             * SAR 70908.
             * Check NVM0 lower0 protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0) 
20008fb6:	697b      	ldr	r3, [r7, #20]
20008fb8:	2b09      	cmp	r3, #9
20008fba:	d00a      	beq.n	20008fd2 <check_protection_reserved_nvm+0x37e>
            {
                /* Check the offset is in the range of lower protected memory area,
                 * if it is then the memory is protected.
                 */  
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
20008fbc:	687a      	ldr	r2, [r7, #4]
20008fbe:	f640 73ff 	movw	r3, #4095	; 0xfff
20008fc2:	429a      	cmp	r2, r3
20008fc4:	d805      	bhi.n	20008fd2 <check_protection_reserved_nvm+0x37e>
                {
                    protection_flag = protection_check(protection_user0, length);
20008fc6:	6978      	ldr	r0, [r7, #20]
20008fc8:	6839      	ldr	r1, [r7, #0]
20008fca:	f000 f983 	bl	200092d4 <protection_check>
20008fce:	4603      	mov	r3, r0
20008fd0:	627b      	str	r3, [r7, #36]	; 0x24
            
            /* 
             * SAR 70908.
             * Check NVM0 upper1 protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
20008fd2:	6a3b      	ldr	r3, [r7, #32]
20008fd4:	2b09      	cmp	r3, #9
20008fd6:	d026      	beq.n	20009026 <check_protection_reserved_nvm+0x3d2>
20008fd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20008fda:	2b00      	cmp	r3, #0
20008fdc:	d123      	bne.n	20009026 <check_protection_reserved_nvm+0x3d2>
            {
                /* Check the offset or (offset + length) is in the range of upper1 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
20008fde:	687a      	ldr	r2, [r7, #4]
20008fe0:	f64c 73ff 	movw	r3, #53247	; 0xcfff
20008fe4:	f2c0 0303 	movt	r3, #3
20008fe8:	429a      	cmp	r2, r3
20008fea:	d906      	bls.n	20008ffa <check_protection_reserved_nvm+0x3a6>
20008fec:	687a      	ldr	r2, [r7, #4]
20008fee:	f64d 73ff 	movw	r3, #57343	; 0xdfff
20008ff2:	f2c0 0303 	movt	r3, #3
20008ff6:	429a      	cmp	r2, r3
20008ff8:	d90f      	bls.n	2000901a <check_protection_reserved_nvm+0x3c6>
                    (offset <= NVM0_UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
20008ffa:	687a      	ldr	r2, [r7, #4]
20008ffc:	6abb      	ldr	r3, [r7, #40]	; 0x28
20008ffe:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper1 
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
20009000:	f64c 73ff 	movw	r3, #53247	; 0xcfff
20009004:	f2c0 0303 	movt	r3, #3
20009008:	429a      	cmp	r2, r3
2000900a:	d90c      	bls.n	20009026 <check_protection_reserved_nvm+0x3d2>
2000900c:	687a      	ldr	r2, [r7, #4]
2000900e:	f64c 73ff 	movw	r3, #53247	; 0xcfff
20009012:	f2c0 0303 	movt	r3, #3
20009016:	429a      	cmp	r2, r3
20009018:	d805      	bhi.n	20009026 <check_protection_reserved_nvm+0x3d2>
                    (offset <= NVM0_UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < NVM0_UPPER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user3, length);
2000901a:	6a38      	ldr	r0, [r7, #32]
2000901c:	6839      	ldr	r1, [r7, #0]
2000901e:	f000 f959 	bl	200092d4 <protection_check>
20009022:	4603      	mov	r3, r0
20009024:	627b      	str	r3, [r7, #36]	; 0x24
        
        /* Check eNVM lower0 or upper1 memory is protected or not.
         * No protection check for  0x3F000 - 0x3FFFF and 0x3E000 - 0x3EFFF lower1/upper0 
         * protected area of eNVM0 memory because it's fall under eNVM reserved area    
         */
        if(PROTECTION_ON == protection_flag)
20009026:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20009028:	2b01      	cmp	r3, #1
2000902a:	d104      	bne.n	20009036 <check_protection_reserved_nvm+0x3e2>
        {
            /* Status is protection error if lower0 or upper1 area of eNVM is protected */
            status = NVM_PROTECTION_ERROR;
2000902c:	f04f 0301 	mov.w	r3, #1
20009030:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
20009034:	e147      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory*/
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
20009036:	687a      	ldr	r2, [r7, #4]
20009038:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000903a:	441a      	add	r2, r3
2000903c:	f64f 73ff 	movw	r3, #65535	; 0xffff
20009040:	f2c0 0303 	movt	r3, #3
20009044:	429a      	cmp	r2, r3
20009046:	d904      	bls.n	20009052 <check_protection_reserved_nvm+0x3fe>
            {
                status = NVM_INVALID_PARAMETER;
20009048:	f04f 0307 	mov.w	r3, #7
2000904c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
20009050:	e139      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20009052:	687a      	ldr	r2, [r7, #4]
20009054:	f64d 73ff 	movw	r3, #57343	; 0xdfff
20009058:	f2c0 0303 	movt	r3, #3
2000905c:	429a      	cmp	r2, r3
2000905e:	d906      	bls.n	2000906e <check_protection_reserved_nvm+0x41a>
20009060:	687a      	ldr	r2, [r7, #4]
20009062:	f64f 73ff 	movw	r3, #65535	; 0xffff
20009066:	f2c0 0303 	movt	r3, #3
2000906a:	429a      	cmp	r2, r3
2000906c:	d90f      	bls.n	2000908e <check_protection_reserved_nvm+0x43a>
                    (((offset + length_minus_one) >= O60_NVM_RSV_OFFSET) &&
2000906e:	687a      	ldr	r2, [r7, #4]
20009070:	6abb      	ldr	r3, [r7, #40]	; 0x28
20009072:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20009074:	f64d 73ff 	movw	r3, #57343	; 0xdfff
20009078:	f2c0 0303 	movt	r3, #3
2000907c:	429a      	cmp	r2, r3
2000907e:	d90c      	bls.n	2000909a <check_protection_reserved_nvm+0x446>
20009080:	687a      	ldr	r2, [r7, #4]
20009082:	f64d 73ff 	movw	r3, #57343	; 0xdfff
20009086:	f2c0 0303 	movt	r3, #3
2000908a:	429a      	cmp	r2, r3
2000908c:	d805      	bhi.n	2000909a <check_protection_reserved_nvm+0x446>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
2000908e:	f04f 0301 	mov.w	r3, #1
20009092:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) ||
20009096:	bf00      	nop
20009098:	e115      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                     */
                    status = NVM_PROTECTION_ERROR;
                }
                else
                {
                    status = NVM_SUCCESS;
2000909a:	f04f 0300 	mov.w	r3, #0
2000909e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
200090a2:	e110      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            }
        }    
    }
    
    /* 090/150 device */
    else if((0xF807u == device_version) || (0xF806u == device_version))
200090a4:	68fa      	ldr	r2, [r7, #12]
200090a6:	f64f 0307 	movw	r3, #63495	; 0xf807
200090aa:	429a      	cmp	r2, r3
200090ac:	d005      	beq.n	200090ba <check_protection_reserved_nvm+0x466>
200090ae:	68fa      	ldr	r2, [r7, #12]
200090b0:	f64f 0306 	movw	r3, #63494	; 0xf806
200090b4:	429a      	cmp	r2, r3
200090b6:	f040 8106 	bne.w	200092c6 <check_protection_reserved_nvm+0x672>
    {
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
200090ba:	f248 0300 	movw	r3, #32768	; 0x8000
200090be:	f2c4 0303 	movt	r3, #16387	; 0x4003
200090c2:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
200090c6:	f649 1399 	movw	r3, #39321	; 0x9999
200090ca:	f2c0 0300 	movt	r3, #0
200090ce:	ea02 0303 	and.w	r3, r2, r3
200090d2:	613b      	str	r3, [r7, #16]
        
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
200090d4:	693a      	ldr	r2, [r7, #16]
200090d6:	f649 1399 	movw	r3, #39321	; 0x9999
200090da:	429a      	cmp	r2, r3
200090dc:	f000 80b6 	beq.w	2000924c <check_protection_reserved_nvm+0x5f8>
        {
            protection_user0 = (protection_data & 0x000Fu);
200090e0:	693b      	ldr	r3, [r7, #16]
200090e2:	f003 030f 	and.w	r3, r3, #15
200090e6:	617b      	str	r3, [r7, #20]
            protection_user1 = ((protection_data & 0x00F0u) >> 4u);
200090e8:	693b      	ldr	r3, [r7, #16]
200090ea:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
200090ee:	ea4f 1313 	mov.w	r3, r3, lsr #4
200090f2:	61bb      	str	r3, [r7, #24]
            protection_user2 = ((protection_data & 0x0F00u) >> 8u);
200090f4:	693b      	ldr	r3, [r7, #16]
200090f6:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
200090fa:	ea4f 2313 	mov.w	r3, r3, lsr #8
200090fe:	61fb      	str	r3, [r7, #28]
            protection_user3 = ((protection_data & 0xF000u) >> 12u);
20009100:	693b      	ldr	r3, [r7, #16]
20009102:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
20009106:	ea4f 3313 	mov.w	r3, r3, lsr #12
2000910a:	623b      	str	r3, [r7, #32]
            /* 
             * SAR 79545. 
             * Check write or No read/write protection is enabled then don't lock pages
             * of that eNVM block
             */
            if((WRITE_ONLY == protection_user0) || (NO_READ_WRITE == protection_user0))
2000910c:	697b      	ldr	r3, [r7, #20]
2000910e:	2b08      	cmp	r3, #8
20009110:	d002      	beq.n	20009118 <check_protection_reserved_nvm+0x4c4>
20009112:	697b      	ldr	r3, [r7, #20]
20009114:	2b00      	cmp	r3, #0
20009116:	d10d      	bne.n	20009134 <check_protection_reserved_nvm+0x4e0>
            {
              if(offset < NVM1_BOTTOM_OFFSET)
20009118:	687a      	ldr	r2, [r7, #4]
2000911a:	f64f 73ff 	movw	r3, #65535	; 0xffff
2000911e:	f2c0 0303 	movt	r3, #3
20009122:	429a      	cmp	r2, r3
20009124:	d806      	bhi.n	20009134 <check_protection_reserved_nvm+0x4e0>
              {
                 g_do_not_lock_page = ON;
20009126:	f24c 3318 	movw	r3, #49944	; 0xc318
2000912a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000912e:	f04f 0201 	mov.w	r2, #1
20009132:	701a      	strb	r2, [r3, #0]

            /* 
             * SAR 70908.
             * Check NVM0 lower0 protected area is Read or Write or 'No R/W' access
             */
            if(WRITE_ENABLED != protection_user0) 
20009134:	697b      	ldr	r3, [r7, #20]
20009136:	2b09      	cmp	r3, #9
20009138:	d00a      	beq.n	20009150 <check_protection_reserved_nvm+0x4fc>
            {
                /* Check the offset is in the range of lower0 protect memory area,
                 * if it is then the memory is protected.
                 */
                if(offset <= LOWER0_PROTECT_TOP_OFFSET)
2000913a:	687a      	ldr	r2, [r7, #4]
2000913c:	f640 73ff 	movw	r3, #4095	; 0xfff
20009140:	429a      	cmp	r2, r3
20009142:	d805      	bhi.n	20009150 <check_protection_reserved_nvm+0x4fc>
                {
                    protection_flag = protection_check(protection_user0, length);
20009144:	6978      	ldr	r0, [r7, #20]
20009146:	6839      	ldr	r1, [r7, #0]
20009148:	f000 f8c4 	bl	200092d4 <protection_check>
2000914c:	4603      	mov	r3, r0
2000914e:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check NVM1 upper1 protected area is Read or Write or 'No R/W' access
             */            
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
20009150:	6a3b      	ldr	r3, [r7, #32]
20009152:	2b09      	cmp	r3, #9
20009154:	d026      	beq.n	200091a4 <check_protection_reserved_nvm+0x550>
20009156:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20009158:	2b00      	cmp	r3, #0
2000915a:	d123      	bne.n	200091a4 <check_protection_reserved_nvm+0x550>
            {
                /* Check the offset or (offset + length)is in the range of upper1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
2000915c:	687a      	ldr	r2, [r7, #4]
2000915e:	f64a 73ff 	movw	r3, #45055	; 0xafff
20009162:	f2c0 0307 	movt	r3, #7
20009166:	429a      	cmp	r2, r3
20009168:	d906      	bls.n	20009178 <check_protection_reserved_nvm+0x524>
2000916a:	687a      	ldr	r2, [r7, #4]
2000916c:	f64b 73ff 	movw	r3, #49151	; 0xbfff
20009170:	f2c0 0307 	movt	r3, #7
20009174:	429a      	cmp	r2, r3
20009176:	d90f      	bls.n	20009198 <check_protection_reserved_nvm+0x544>
                    (offset <= UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
20009178:	687a      	ldr	r2, [r7, #4]
2000917a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000917c:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user3) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length)is in the range of upper1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
2000917e:	f64a 73ff 	movw	r3, #45055	; 0xafff
20009182:	f2c0 0307 	movt	r3, #7
20009186:	429a      	cmp	r2, r3
20009188:	d90c      	bls.n	200091a4 <check_protection_reserved_nvm+0x550>
2000918a:	687a      	ldr	r2, [r7, #4]
2000918c:	f64a 73ff 	movw	r3, #45055	; 0xafff
20009190:	f2c0 0307 	movt	r3, #7
20009194:	429a      	cmp	r2, r3
20009196:	d805      	bhi.n	200091a4 <check_protection_reserved_nvm+0x550>
                    (offset <= UPPER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= UPPER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < UPPER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user3, length);
20009198:	6a38      	ldr	r0, [r7, #32]
2000919a:	6839      	ldr	r1, [r7, #0]
2000919c:	f000 f89a 	bl	200092d4 <protection_check>
200091a0:	4603      	mov	r3, r0
200091a2:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check NVM1 lower1 protected area is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user2) && (OFF == protection_flag))
200091a4:	69fb      	ldr	r3, [r7, #28]
200091a6:	2b09      	cmp	r3, #9
200091a8:	d026      	beq.n	200091f8 <check_protection_reserved_nvm+0x5a4>
200091aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
200091ac:	2b00      	cmp	r3, #0
200091ae:	d123      	bne.n	200091f8 <check_protection_reserved_nvm+0x5a4>
            {
                /* Check the offset or (offset + length)is in the range of lower1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
200091b0:	687a      	ldr	r2, [r7, #4]
200091b2:	f64b 73ff 	movw	r3, #49151	; 0xbfff
200091b6:	f2c0 0307 	movt	r3, #7
200091ba:	429a      	cmp	r2, r3
200091bc:	d906      	bls.n	200091cc <check_protection_reserved_nvm+0x578>
200091be:	687a      	ldr	r2, [r7, #4]
200091c0:	f64c 73ff 	movw	r3, #53247	; 0xcfff
200091c4:	f2c0 0307 	movt	r3, #7
200091c8:	429a      	cmp	r2, r3
200091ca:	d90f      	bls.n	200091ec <check_protection_reserved_nvm+0x598>
                    (offset <= LOWER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
200091cc:	687a      	ldr	r2, [r7, #4]
200091ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
200091d0:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user2) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length)is in the range of lower1 
                 * protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
200091d2:	f64b 73ff 	movw	r3, #49151	; 0xbfff
200091d6:	f2c0 0307 	movt	r3, #7
200091da:	429a      	cmp	r2, r3
200091dc:	d90c      	bls.n	200091f8 <check_protection_reserved_nvm+0x5a4>
200091de:	687a      	ldr	r2, [r7, #4]
200091e0:	f64b 73ff 	movw	r3, #49151	; 0xbfff
200091e4:	f2c0 0307 	movt	r3, #7
200091e8:	429a      	cmp	r2, r3
200091ea:	d805      	bhi.n	200091f8 <check_protection_reserved_nvm+0x5a4>
                    (offset <= LOWER1_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= LOWER1_PROTECT_BOTTOM_OFFSET) &&
                    (offset < LOWER1_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user2, length);
200091ec:	69f8      	ldr	r0, [r7, #28]
200091ee:	6839      	ldr	r1, [r7, #0]
200091f0:	f000 f870 	bl	200092d4 <protection_check>
200091f4:	4603      	mov	r3, r0
200091f6:	627b      	str	r3, [r7, #36]	; 0x24
            }
            /* 
             * SAR 70908.
             * Check eNVM0 upper0 protected area(in eNVM1) is Read or Write or 'No R/W' access
             */
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
200091f8:	69bb      	ldr	r3, [r7, #24]
200091fa:	2b09      	cmp	r3, #9
200091fc:	d026      	beq.n	2000924c <check_protection_reserved_nvm+0x5f8>
200091fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20009200:	2b00      	cmp	r3, #0
20009202:	d123      	bne.n	2000924c <check_protection_reserved_nvm+0x5f8>
            {
                /* Check the offset or (offset + length) is in the range of upper0
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
20009204:	687a      	ldr	r2, [r7, #4]
20009206:	f64c 73ff 	movw	r3, #53247	; 0xcfff
2000920a:	f2c0 0307 	movt	r3, #7
2000920e:	429a      	cmp	r2, r3
20009210:	d906      	bls.n	20009220 <check_protection_reserved_nvm+0x5cc>
20009212:	687a      	ldr	r2, [r7, #4]
20009214:	f64d 73ff 	movw	r3, #57343	; 0xdfff
20009218:	f2c0 0307 	movt	r3, #7
2000921c:	429a      	cmp	r2, r3
2000921e:	d90f      	bls.n	20009240 <check_protection_reserved_nvm+0x5ec>
                    (offset <= NVM0_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
20009220:	687a      	ldr	r2, [r7, #4]
20009222:	6abb      	ldr	r3, [r7, #40]	; 0x28
20009224:	441a      	add	r2, r3
            if((WRITE_ENABLED != protection_user1) && (OFF == protection_flag))
            {
                /* Check the offset or (offset + length) is in the range of upper0
                 *  protect memory area, if it is then the memory is protected.
                 */
                if(((offset >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
20009226:	f64c 73ff 	movw	r3, #53247	; 0xcfff
2000922a:	f2c0 0307 	movt	r3, #7
2000922e:	429a      	cmp	r2, r3
20009230:	d90c      	bls.n	2000924c <check_protection_reserved_nvm+0x5f8>
20009232:	687a      	ldr	r2, [r7, #4]
20009234:	f64c 73ff 	movw	r3, #53247	; 0xcfff
20009238:	f2c0 0307 	movt	r3, #7
2000923c:	429a      	cmp	r2, r3
2000923e:	d805      	bhi.n	2000924c <check_protection_reserved_nvm+0x5f8>
                    (offset <= NVM0_UPPER0_PROTECT_TOP_OFFSET)) ||
                    (((offset + length_minus_one) >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) &&
                    (offset < NVM0_UPPER0_PROTECT_BOTTOM_OFFSET)))
                {
                    protection_flag = protection_check(protection_user1, length);
20009240:	69b8      	ldr	r0, [r7, #24]
20009242:	6839      	ldr	r1, [r7, #0]
20009244:	f000 f846 	bl	200092d4 <protection_check>
20009248:	4603      	mov	r3, r0
2000924a:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }
        }

        /* Check eNVM lower0/1 and upper0/1 memory is protected or not */
        if(PROTECTION_ON == protection_flag)
2000924c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000924e:	2b01      	cmp	r3, #1
20009250:	d104      	bne.n	2000925c <check_protection_reserved_nvm+0x608>
        {
           /* Status is protection error if lower or upper area of eNVM0 or 
            * eNVM1 is protected 
            */
            status = NVM_PROTECTION_ERROR;
20009252:	f04f 0301 	mov.w	r3, #1
20009256:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
2000925a:	e034      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > NVM1_TOP_OFFSET)
2000925c:	687a      	ldr	r2, [r7, #4]
2000925e:	6abb      	ldr	r3, [r7, #40]	; 0x28
20009260:	441a      	add	r2, r3
20009262:	f64f 73ff 	movw	r3, #65535	; 0xffff
20009266:	f2c0 0307 	movt	r3, #7
2000926a:	429a      	cmp	r2, r3
2000926c:	d904      	bls.n	20009278 <check_protection_reserved_nvm+0x624>
            {
                status = NVM_INVALID_PARAMETER;
2000926e:	f04f 0307 	mov.w	r3, #7
20009272:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
20009276:	e026      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
20009278:	687a      	ldr	r2, [r7, #4]
2000927a:	f64d 73ff 	movw	r3, #57343	; 0xdfff
2000927e:	f2c0 0307 	movt	r3, #7
20009282:	429a      	cmp	r2, r3
20009284:	d906      	bls.n	20009294 <check_protection_reserved_nvm+0x640>
20009286:	687a      	ldr	r2, [r7, #4]
20009288:	f64f 73ff 	movw	r3, #65535	; 0xffff
2000928c:	f2c0 0307 	movt	r3, #7
20009290:	429a      	cmp	r2, r3
20009292:	d90f      	bls.n	200092b4 <check_protection_reserved_nvm+0x660>
                    (((offset + length_minus_one) >= NVM1_RSV_OFFSET) &&
20009294:	687a      	ldr	r2, [r7, #4]
20009296:	6abb      	ldr	r3, [r7, #40]	; 0x28
20009298:	441a      	add	r2, r3
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
2000929a:	f64d 73ff 	movw	r3, #57343	; 0xdfff
2000929e:	f2c0 0307 	movt	r3, #7
200092a2:	429a      	cmp	r2, r3
200092a4:	d90b      	bls.n	200092be <check_protection_reserved_nvm+0x66a>
200092a6:	687a      	ldr	r2, [r7, #4]
200092a8:	f64d 73ff 	movw	r3, #57343	; 0xdfff
200092ac:	f2c0 0307 	movt	r3, #7
200092b0:	429a      	cmp	r2, r3
200092b2:	d804      	bhi.n	200092be <check_protection_reserved_nvm+0x66a>
                    /* 
                     * SAR 70908.
                     * Status is protection error if the offset or (offset + length) is 
                     * in reserved area of eNVM
                     */
                    status = NVM_PROTECTION_ERROR;
200092b4:	f04f 0301 	mov.w	r3, #1
200092b8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check the offset is in eNVM reserved memory area - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) ||
200092bc:	e003      	b.n	200092c6 <check_protection_reserved_nvm+0x672>
                else
                {
                    /* Status is success if offset or (offset + length) is 
                     * in RW access of eNVM memory
                     */
                    status = NVM_SUCCESS;
200092be:	f04f 0300 	mov.w	r3, #0
200092c2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                }
            }
        }
    }
    return status;
200092c6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
200092ca:	4618      	mov	r0, r3
200092cc:	f107 0730 	add.w	r7, r7, #48	; 0x30
200092d0:	46bd      	mov	sp, r7
200092d2:	bd80      	pop	{r7, pc}

200092d4 <protection_check>:
 *
 * if the eNVM0 or eNVM1 lower/upper protected area with W-Only or No_RW
 * access then return with protection on
 */
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
200092d4:	b480      	push	{r7}
200092d6:	b085      	sub	sp, #20
200092d8:	af00      	add	r7, sp, #0
200092da:	6078      	str	r0, [r7, #4]
200092dc:	6039      	str	r1, [r7, #0]
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
200092de:	687b      	ldr	r3, [r7, #4]
200092e0:	2b01      	cmp	r3, #1
200092e2:	d106      	bne.n	200092f2 <protection_check+0x1e>
200092e4:	683b      	ldr	r3, [r7, #0]
200092e6:	2b00      	cmp	r3, #0
200092e8:	d103      	bne.n	200092f2 <protection_check+0x1e>
    {
        protect_flag = PROTECTION_OFF;
200092ea:	f04f 0300 	mov.w	r3, #0
200092ee:	60fb      	str	r3, [r7, #12]
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
200092f0:	e002      	b.n	200092f8 <protection_check+0x24>
    {
        protect_flag = PROTECTION_OFF;
    }
    else
    {
        protect_flag = PROTECTION_ON;
200092f2:	f04f 0301 	mov.w	r3, #1
200092f6:	60fb      	str	r3, [r7, #12]
    }
    return protect_flag;
200092f8:	68fb      	ldr	r3, [r7, #12]
}
200092fa:	4618      	mov	r0, r3
200092fc:	f107 0714 	add.w	r7, r7, #20
20009300:	46bd      	mov	sp, r7
20009302:	bc80      	pop	{r7}
20009304:	4770      	bx	lr
20009306:	bf00      	nop

20009308 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20009308:	b480      	push	{r7}
2000930a:	b083      	sub	sp, #12
2000930c:	af00      	add	r7, sp, #0
2000930e:	4603      	mov	r3, r0
20009310:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20009312:	f24e 1300 	movw	r3, #57600	; 0xe100
20009316:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000931a:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000931e:	ea4f 1252 	mov.w	r2, r2, lsr #5
20009322:	79f9      	ldrb	r1, [r7, #7]
20009324:	f001 011f 	and.w	r1, r1, #31
20009328:	f04f 0001 	mov.w	r0, #1
2000932c:	fa00 f101 	lsl.w	r1, r0, r1
20009330:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20009334:	f107 070c 	add.w	r7, r7, #12
20009338:	46bd      	mov	sp, r7
2000933a:	bc80      	pop	{r7}
2000933c:	4770      	bx	lr
2000933e:	bf00      	nop

20009340 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20009340:	b480      	push	{r7}
20009342:	b083      	sub	sp, #12
20009344:	af00      	add	r7, sp, #0
20009346:	4603      	mov	r3, r0
20009348:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
2000934a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000934e:	f2ce 0300 	movt	r3, #57344	; 0xe000
20009352:	f997 2007 	ldrsb.w	r2, [r7, #7]
20009356:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000935a:	79f9      	ldrb	r1, [r7, #7]
2000935c:	f001 011f 	and.w	r1, r1, #31
20009360:	f04f 0001 	mov.w	r0, #1
20009364:	fa00 f101 	lsl.w	r1, r0, r1
20009368:	f102 0220 	add.w	r2, r2, #32
2000936c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20009370:	f107 070c 	add.w	r7, r7, #12
20009374:	46bd      	mov	sp, r7
20009376:	bc80      	pop	{r7}
20009378:	4770      	bx	lr
2000937a:	bf00      	nop

2000937c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
2000937c:	b480      	push	{r7}
2000937e:	b083      	sub	sp, #12
20009380:	af00      	add	r7, sp, #0
20009382:	4603      	mov	r3, r0
20009384:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20009386:	f24e 1300 	movw	r3, #57600	; 0xe100
2000938a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000938e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20009392:	ea4f 1252 	mov.w	r2, r2, lsr #5
20009396:	79f9      	ldrb	r1, [r7, #7]
20009398:	f001 011f 	and.w	r1, r1, #31
2000939c:	f04f 0001 	mov.w	r0, #1
200093a0:	fa00 f101 	lsl.w	r1, r0, r1
200093a4:	f102 0260 	add.w	r2, r2, #96	; 0x60
200093a8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200093ac:	f107 070c 	add.w	r7, r7, #12
200093b0:	46bd      	mov	sp, r7
200093b2:	bc80      	pop	{r7}
200093b4:	4770      	bx	lr
200093b6:	bf00      	nop

200093b8 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
200093b8:	b580      	push	{r7, lr}
200093ba:	b082      	sub	sp, #8
200093bc:	af00      	add	r7, sp, #0
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
200093be:	f248 0300 	movw	r3, #32768	; 0x8000
200093c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200093c6:	f248 0200 	movw	r2, #32768	; 0x8000
200093ca:	f2c4 0203 	movt	r2, #16387	; 0x4003
200093ce:	6c92      	ldr	r2, [r2, #72]	; 0x48
200093d0:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
200093d4:	649a      	str	r2, [r3, #72]	; 0x48
    SYSREG->SOFT_RST_CR |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
200093d6:	f248 0300 	movw	r3, #32768	; 0x8000
200093da:	f2c4 0303 	movt	r3, #16387	; 0x4003
200093de:	f248 0200 	movw	r2, #32768	; 0x8000
200093e2:	f2c4 0203 	movt	r2, #16387	; 0x4003
200093e6:	6c92      	ldr	r2, [r2, #72]	; 0x48
200093e8:	f042 72f0 	orr.w	r2, r2, #31457280	; 0x1e00000
200093ec:	649a      	str	r2, [r3, #72]	; 0x48
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
200093ee:	f04f 0300 	mov.w	r3, #0
200093f2:	607b      	str	r3, [r7, #4]
200093f4:	e017      	b.n	20009426 <MSS_GPIO_init+0x6e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
200093f6:	687a      	ldr	r2, [r7, #4]
200093f8:	f64b 732c 	movw	r3, #48940	; 0xbf2c
200093fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009400:	5c9b      	ldrb	r3, [r3, r2]
20009402:	b25b      	sxtb	r3, r3
20009404:	4618      	mov	r0, r3
20009406:	f7ff ff9b 	bl	20009340 <NVIC_DisableIRQ>
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
2000940a:	687a      	ldr	r2, [r7, #4]
2000940c:	f64b 732c 	movw	r3, #48940	; 0xbf2c
20009410:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009414:	5c9b      	ldrb	r3, [r3, r2]
20009416:	b25b      	sxtb	r3, r3
20009418:	4618      	mov	r0, r3
2000941a:	f7ff ffaf 	bl	2000937c <NVIC_ClearPendingIRQ>
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
2000941e:	687b      	ldr	r3, [r7, #4]
20009420:	f103 0301 	add.w	r3, r3, #1
20009424:	607b      	str	r3, [r7, #4]
20009426:	687b      	ldr	r3, [r7, #4]
20009428:	2b1f      	cmp	r3, #31
2000942a:	d9e4      	bls.n	200093f6 <MSS_GPIO_init+0x3e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
2000942c:	f248 0300 	movw	r3, #32768	; 0x8000
20009430:	f2c4 0303 	movt	r3, #16387	; 0x4003
20009434:	f248 0200 	movw	r2, #32768	; 0x8000
20009438:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000943c:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000943e:	f022 72f0 	bic.w	r2, r2, #31457280	; 0x1e00000
20009442:	649a      	str	r2, [r3, #72]	; 0x48
                             SYSREG_GPIO_15_8_SOFTRESET_MASK |
                             SYSREG_GPIO_23_16_SOFTRESET_MASK |
                             SYSREG_GPIO_31_24_SOFTRESET_MASK);
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
20009444:	f248 0300 	movw	r3, #32768	; 0x8000
20009448:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000944c:	f248 0200 	movw	r2, #32768	; 0x8000
20009450:	f2c4 0203 	movt	r2, #16387	; 0x4003
20009454:	6c92      	ldr	r2, [r2, #72]	; 0x48
20009456:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
2000945a:	649a      	str	r2, [r3, #72]	; 0x48
}
2000945c:	f107 0708 	add.w	r7, r7, #8
20009460:	46bd      	mov	sp, r7
20009462:	bd80      	pop	{r7, pc}

20009464 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
20009464:	b480      	push	{r7}
20009466:	b085      	sub	sp, #20
20009468:	af00      	add	r7, sp, #0
2000946a:	4603      	mov	r3, r0
2000946c:	6039      	str	r1, [r7, #0]
2000946e:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
20009470:	79fb      	ldrb	r3, [r7, #7]
20009472:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
20009474:	68fb      	ldr	r3, [r7, #12]
20009476:	2b1f      	cmp	r3, #31
20009478:	d900      	bls.n	2000947c <MSS_GPIO_config+0x18>
2000947a:	be00      	bkpt	0x0000

    if(gpio_idx < NB_OF_GPIO)
2000947c:	68fb      	ldr	r3, [r7, #12]
2000947e:	2b1f      	cmp	r3, #31
20009480:	d808      	bhi.n	20009494 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
20009482:	68fa      	ldr	r2, [r7, #12]
20009484:	f64b 63ac 	movw	r3, #48812	; 0xbeac
20009488:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000948c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20009490:	683a      	ldr	r2, [r7, #0]
20009492:	601a      	str	r2, [r3, #0]
    }
}
20009494:	f107 0714 	add.w	r7, r7, #20
20009498:	46bd      	mov	sp, r7
2000949a:	bc80      	pop	{r7}
2000949c:	4770      	bx	lr
2000949e:	bf00      	nop

200094a0 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t port_id,
    uint8_t value
)
{
200094a0:	b480      	push	{r7}
200094a2:	b085      	sub	sp, #20
200094a4:	af00      	add	r7, sp, #0
200094a6:	4602      	mov	r2, r0
200094a8:	460b      	mov	r3, r1
200094aa:	71fa      	strb	r2, [r7, #7]
200094ac:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_setting;
    uint32_t gpio_idx = (uint32_t)port_id;
200094ae:	79fb      	ldrb	r3, [r7, #7]
200094b0:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
200094b2:	68fb      	ldr	r3, [r7, #12]
200094b4:	2b1f      	cmp	r3, #31
200094b6:	d900      	bls.n	200094ba <MSS_GPIO_set_output+0x1a>
200094b8:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
200094ba:	68fb      	ldr	r3, [r7, #12]
200094bc:	2b1f      	cmp	r3, #31
200094be:	d822      	bhi.n	20009506 <MSS_GPIO_set_output+0x66>
    {
        gpio_setting = GPIO->GPIO_OUT;
200094c0:	f243 0300 	movw	r3, #12288	; 0x3000
200094c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
200094c8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200094cc:	60bb      	str	r3, [r7, #8]
        gpio_setting &= ~((uint32_t)0x01u << gpio_idx);
200094ce:	68fb      	ldr	r3, [r7, #12]
200094d0:	f04f 0201 	mov.w	r2, #1
200094d4:	fa02 f303 	lsl.w	r3, r2, r3
200094d8:	ea6f 0303 	mvn.w	r3, r3
200094dc:	68ba      	ldr	r2, [r7, #8]
200094de:	ea02 0303 	and.w	r3, r2, r3
200094e2:	60bb      	str	r3, [r7, #8]
        gpio_setting |= ((uint32_t)value & 0x01u) << gpio_idx;
200094e4:	79bb      	ldrb	r3, [r7, #6]
200094e6:	f003 0201 	and.w	r2, r3, #1
200094ea:	68fb      	ldr	r3, [r7, #12]
200094ec:	fa02 f303 	lsl.w	r3, r2, r3
200094f0:	68ba      	ldr	r2, [r7, #8]
200094f2:	ea42 0303 	orr.w	r3, r2, r3
200094f6:	60bb      	str	r3, [r7, #8]
        GPIO->GPIO_OUT = gpio_setting;
200094f8:	f243 0300 	movw	r3, #12288	; 0x3000
200094fc:	f2c4 0301 	movt	r3, #16385	; 0x4001
20009500:	68ba      	ldr	r2, [r7, #8]
20009502:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }
}
20009506:	f107 0714 	add.w	r7, r7, #20
2000950a:	46bd      	mov	sp, r7
2000950c:	bc80      	pop	{r7}
2000950e:	4770      	bx	lr

20009510 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
20009510:	b580      	push	{r7, lr}
20009512:	b084      	sub	sp, #16
20009514:	af00      	add	r7, sp, #0
20009516:	4603      	mov	r3, r0
20009518:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
2000951a:	79fb      	ldrb	r3, [r7, #7]
2000951c:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
2000951e:	68fb      	ldr	r3, [r7, #12]
20009520:	2b1f      	cmp	r3, #31
20009522:	d900      	bls.n	20009526 <MSS_GPIO_enable_irq+0x16>
20009524:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
20009526:	68fb      	ldr	r3, [r7, #12]
20009528:	2b1f      	cmp	r3, #31
2000952a:	d81d      	bhi.n	20009568 <MSS_GPIO_enable_irq+0x58>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
2000952c:	68fa      	ldr	r2, [r7, #12]
2000952e:	f64b 63ac 	movw	r3, #48812	; 0xbeac
20009532:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009536:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
2000953a:	681b      	ldr	r3, [r3, #0]
2000953c:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
2000953e:	68fa      	ldr	r2, [r7, #12]
20009540:	f64b 63ac 	movw	r3, #48812	; 0xbeac
20009544:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009548:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
2000954c:	68ba      	ldr	r2, [r7, #8]
2000954e:	f042 0208 	orr.w	r2, r2, #8
20009552:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ(g_gpio_irqn_lut[gpio_idx]);
20009554:	68fa      	ldr	r2, [r7, #12]
20009556:	f64b 732c 	movw	r3, #48940	; 0xbf2c
2000955a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000955e:	5c9b      	ldrb	r3, [r3, r2]
20009560:	b25b      	sxtb	r3, r3
20009562:	4618      	mov	r0, r3
20009564:	f7ff fed0 	bl	20009308 <NVIC_EnableIRQ>
    }
}
20009568:	f107 0710 	add.w	r7, r7, #16
2000956c:	46bd      	mov	sp, r7
2000956e:	bd80      	pop	{r7, pc}

20009570 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
20009570:	b480      	push	{r7}
20009572:	b085      	sub	sp, #20
20009574:	af00      	add	r7, sp, #0
20009576:	4603      	mov	r3, r0
20009578:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
2000957a:	79fb      	ldrb	r3, [r7, #7]
2000957c:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
2000957e:	68fb      	ldr	r3, [r7, #12]
20009580:	2b1f      	cmp	r3, #31
20009582:	d900      	bls.n	20009586 <MSS_GPIO_clear_irq+0x16>
20009584:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
20009586:	68fb      	ldr	r3, [r7, #12]
20009588:	2b1f      	cmp	r3, #31
2000958a:	d80a      	bhi.n	200095a2 <MSS_GPIO_clear_irq+0x32>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
2000958c:	f243 0300 	movw	r3, #12288	; 0x3000
20009590:	f2c4 0301 	movt	r3, #16385	; 0x4001
20009594:	68fa      	ldr	r2, [r7, #12]
20009596:	f04f 0101 	mov.w	r1, #1
2000959a:	fa01 f202 	lsl.w	r2, r1, r2
2000959e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
    __ASM volatile ("dsb");
200095a2:	f3bf 8f4f 	dsb	sy

}
200095a6:	f107 0714 	add.w	r7, r7, #20
200095aa:	46bd      	mov	sp, r7
200095ac:	bc80      	pop	{r7}
200095ae:	4770      	bx	lr

200095b0 <TMR_init>:
    addr_t address,
    uint8_t mode,
    uint32_t prescale,
    uint32_t load_value
)
{
200095b0:	b580      	push	{r7, lr}
200095b2:	b084      	sub	sp, #16
200095b4:	af00      	add	r7, sp, #0
200095b6:	60f8      	str	r0, [r7, #12]
200095b8:	60b9      	str	r1, [r7, #8]
200095ba:	603b      	str	r3, [r7, #0]
200095bc:	4613      	mov	r3, r2
200095be:	71fb      	strb	r3, [r7, #7]
    HAL_ASSERT( this_timer != NULL_timer_instance )
200095c0:	f24c 331c 	movw	r3, #49948	; 0xc31c
200095c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200095c8:	681b      	ldr	r3, [r3, #0]
200095ca:	68fa      	ldr	r2, [r7, #12]
200095cc:	429a      	cmp	r2, r3
200095ce:	d100      	bne.n	200095d2 <TMR_init+0x22>
200095d0:	be00      	bkpt	0x0000
    HAL_ASSERT( prescale <= PRESCALER_DIV_1024 )
200095d2:	683b      	ldr	r3, [r7, #0]
200095d4:	2b09      	cmp	r3, #9
200095d6:	d900      	bls.n	200095da <TMR_init+0x2a>
200095d8:	be00      	bkpt	0x0000
    HAL_ASSERT( load_value != 0 )
200095da:	69bb      	ldr	r3, [r7, #24]
200095dc:	2b00      	cmp	r3, #0
200095de:	d100      	bne.n	200095e2 <TMR_init+0x32>
200095e0:	be00      	bkpt	0x0000
    
    this_timer->base_address = address;
200095e2:	68fb      	ldr	r3, [r7, #12]
200095e4:	68ba      	ldr	r2, [r7, #8]
200095e6:	601a      	str	r2, [r3, #0]

    /* Disable interrupts. */
    HAL_set_32bit_reg_field( address, InterruptEnable,0 );
200095e8:	68bb      	ldr	r3, [r7, #8]
200095ea:	f103 0308 	add.w	r3, r3, #8
200095ee:	4618      	mov	r0, r3
200095f0:	f04f 0101 	mov.w	r1, #1
200095f4:	f04f 0202 	mov.w	r2, #2
200095f8:	f04f 0300 	mov.w	r3, #0
200095fc:	f7fc fdae 	bl	2000615c <HW_set_32bit_reg_field>

    /* Disable timer. */
    HAL_set_32bit_reg_field( address, TimerEnable, 0 );
20009600:	68bb      	ldr	r3, [r7, #8]
20009602:	f103 0308 	add.w	r3, r3, #8
20009606:	4618      	mov	r0, r3
20009608:	f04f 0100 	mov.w	r1, #0
2000960c:	f04f 0201 	mov.w	r2, #1
20009610:	f04f 0300 	mov.w	r3, #0
20009614:	f7fc fda2 	bl	2000615c <HW_set_32bit_reg_field>

    /* Clear pending interrupt. */
    HAL_set_32bit_reg( address, TimerIntClr, 1 );
20009618:	68bb      	ldr	r3, [r7, #8]
2000961a:	f103 0310 	add.w	r3, r3, #16
2000961e:	4618      	mov	r0, r3
20009620:	f04f 0101 	mov.w	r1, #1
20009624:	f7fc fd96 	bl	20006154 <HW_set_32bit_reg>

    /* Configure prescaler and load value. */    
    HAL_set_32bit_reg( address, TimerPrescale, prescale );
20009628:	68bb      	ldr	r3, [r7, #8]
2000962a:	f103 030c 	add.w	r3, r3, #12
2000962e:	4618      	mov	r0, r3
20009630:	6839      	ldr	r1, [r7, #0]
20009632:	f7fc fd8f 	bl	20006154 <HW_set_32bit_reg>
    HAL_set_32bit_reg( address, TimerLoad, load_value );
20009636:	68b8      	ldr	r0, [r7, #8]
20009638:	69b9      	ldr	r1, [r7, #24]
2000963a:	f7fc fd8b 	bl	20006154 <HW_set_32bit_reg>

    /* Set the interrupt mode. */
    if ( mode == TMR_CONTINUOUS_MODE )
2000963e:	79fb      	ldrb	r3, [r7, #7]
20009640:	2b00      	cmp	r3, #0
20009642:	d10c      	bne.n	2000965e <TMR_init+0xae>
    {
        HAL_set_32bit_reg_field( address, TimerMode, 0 );
20009644:	68bb      	ldr	r3, [r7, #8]
20009646:	f103 0308 	add.w	r3, r3, #8
2000964a:	4618      	mov	r0, r3
2000964c:	f04f 0102 	mov.w	r1, #2
20009650:	f04f 0204 	mov.w	r2, #4
20009654:	f04f 0300 	mov.w	r3, #0
20009658:	f7fc fd80 	bl	2000615c <HW_set_32bit_reg_field>
2000965c:	e00b      	b.n	20009676 <TMR_init+0xc6>
    }
    else
    {
        /* TMR_ONE_SHOT_MODE */
        HAL_set_32bit_reg_field( address, TimerMode, 1 );
2000965e:	68bb      	ldr	r3, [r7, #8]
20009660:	f103 0308 	add.w	r3, r3, #8
20009664:	4618      	mov	r0, r3
20009666:	f04f 0102 	mov.w	r1, #2
2000966a:	f04f 0204 	mov.w	r2, #4
2000966e:	f04f 0301 	mov.w	r3, #1
20009672:	f7fc fd73 	bl	2000615c <HW_set_32bit_reg_field>
    }
}
20009676:	f107 0710 	add.w	r7, r7, #16
2000967a:	46bd      	mov	sp, r7
2000967c:	bd80      	pop	{r7, pc}
2000967e:	bf00      	nop

20009680 <TMR_start>:
void
TMR_start
(
    timer_instance_t * this_timer
)
{
20009680:	b580      	push	{r7, lr}
20009682:	b082      	sub	sp, #8
20009684:	af00      	add	r7, sp, #0
20009686:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
20009688:	f24c 331c 	movw	r3, #49948	; 0xc31c
2000968c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009690:	681b      	ldr	r3, [r3, #0]
20009692:	687a      	ldr	r2, [r7, #4]
20009694:	429a      	cmp	r2, r3
20009696:	d100      	bne.n	2000969a <TMR_start+0x1a>
20009698:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, TimerEnable, 1 );
2000969a:	687b      	ldr	r3, [r7, #4]
2000969c:	681b      	ldr	r3, [r3, #0]
2000969e:	f103 0308 	add.w	r3, r3, #8
200096a2:	4618      	mov	r0, r3
200096a4:	f04f 0100 	mov.w	r1, #0
200096a8:	f04f 0201 	mov.w	r2, #1
200096ac:	f04f 0301 	mov.w	r3, #1
200096b0:	f7fc fd54 	bl	2000615c <HW_set_32bit_reg_field>
}
200096b4:	f107 0708 	add.w	r7, r7, #8
200096b8:	46bd      	mov	sp, r7
200096ba:	bd80      	pop	{r7, pc}

200096bc <TMR_stop>:
void
TMR_stop
(
    timer_instance_t * this_timer
)
{
200096bc:	b580      	push	{r7, lr}
200096be:	b082      	sub	sp, #8
200096c0:	af00      	add	r7, sp, #0
200096c2:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
200096c4:	f24c 331c 	movw	r3, #49948	; 0xc31c
200096c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200096cc:	681b      	ldr	r3, [r3, #0]
200096ce:	687a      	ldr	r2, [r7, #4]
200096d0:	429a      	cmp	r2, r3
200096d2:	d100      	bne.n	200096d6 <TMR_stop+0x1a>
200096d4:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, TimerEnable, 0 );
200096d6:	687b      	ldr	r3, [r7, #4]
200096d8:	681b      	ldr	r3, [r3, #0]
200096da:	f103 0308 	add.w	r3, r3, #8
200096de:	4618      	mov	r0, r3
200096e0:	f04f 0100 	mov.w	r1, #0
200096e4:	f04f 0201 	mov.w	r2, #1
200096e8:	f04f 0300 	mov.w	r3, #0
200096ec:	f7fc fd36 	bl	2000615c <HW_set_32bit_reg_field>
}
200096f0:	f107 0708 	add.w	r7, r7, #8
200096f4:	46bd      	mov	sp, r7
200096f6:	bd80      	pop	{r7, pc}

200096f8 <TMR_enable_int>:
void
TMR_enable_int
(
    timer_instance_t * this_timer
)
{
200096f8:	b580      	push	{r7, lr}
200096fa:	b082      	sub	sp, #8
200096fc:	af00      	add	r7, sp, #0
200096fe:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
20009700:	f24c 331c 	movw	r3, #49948	; 0xc31c
20009704:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009708:	681b      	ldr	r3, [r3, #0]
2000970a:	687a      	ldr	r2, [r7, #4]
2000970c:	429a      	cmp	r2, r3
2000970e:	d100      	bne.n	20009712 <TMR_enable_int+0x1a>
20009710:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg_field( this_timer->base_address, InterruptEnable, 1 );
20009712:	687b      	ldr	r3, [r7, #4]
20009714:	681b      	ldr	r3, [r3, #0]
20009716:	f103 0308 	add.w	r3, r3, #8
2000971a:	4618      	mov	r0, r3
2000971c:	f04f 0101 	mov.w	r1, #1
20009720:	f04f 0202 	mov.w	r2, #2
20009724:	f04f 0301 	mov.w	r3, #1
20009728:	f7fc fd18 	bl	2000615c <HW_set_32bit_reg_field>
}
2000972c:	f107 0708 	add.w	r7, r7, #8
20009730:	46bd      	mov	sp, r7
20009732:	bd80      	pop	{r7, pc}

20009734 <TMR_clear_int>:
void
TMR_clear_int
(
    timer_instance_t * this_timer
)
{
20009734:	b580      	push	{r7, lr}
20009736:	b082      	sub	sp, #8
20009738:	af00      	add	r7, sp, #0
2000973a:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( this_timer != NULL_timer_instance )
2000973c:	f24c 331c 	movw	r3, #49948	; 0xc31c
20009740:	f2c2 0300 	movt	r3, #8192	; 0x2000
20009744:	681b      	ldr	r3, [r3, #0]
20009746:	687a      	ldr	r2, [r7, #4]
20009748:	429a      	cmp	r2, r3
2000974a:	d100      	bne.n	2000974e <TMR_clear_int+0x1a>
2000974c:	be00      	bkpt	0x0000
    
    HAL_set_32bit_reg( this_timer->base_address, TimerIntClr, 0x01 );
2000974e:	687b      	ldr	r3, [r7, #4]
20009750:	681b      	ldr	r3, [r3, #0]
20009752:	f103 0310 	add.w	r3, r3, #16
20009756:	4618      	mov	r0, r3
20009758:	f04f 0101 	mov.w	r1, #1
2000975c:	f7fc fcfa 	bl	20006154 <HW_set_32bit_reg>
}
20009760:	f107 0708 	add.w	r7, r7, #8
20009764:	46bd      	mov	sp, r7
20009766:	bd80      	pop	{r7, pc}

20009768 <SPI_init>:
(
    spi_instance_t * this_spi,
    addr_t base_addr,
    uint16_t fifo_depth
)
{
20009768:	b580      	push	{r7, lr}
2000976a:	b084      	sub	sp, #16
2000976c:	af00      	add	r7, sp, #0
2000976e:	60f8      	str	r0, [r7, #12]
20009770:	60b9      	str	r1, [r7, #8]
20009772:	4613      	mov	r3, r2
20009774:	80fb      	strh	r3, [r7, #6]
    HAL_ASSERT( NULL_INSTANCE != this_spi );
20009776:	68fb      	ldr	r3, [r7, #12]
20009778:	2b00      	cmp	r3, #0
2000977a:	d100      	bne.n	2000977e <SPI_init+0x16>
2000977c:	be00      	bkpt	0x0000
    HAL_ASSERT( NULL_ADDR != base_addr );
2000977e:	68bb      	ldr	r3, [r7, #8]
20009780:	2b00      	cmp	r3, #0
20009782:	d100      	bne.n	20009786 <SPI_init+0x1e>
20009784:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_FIFO_DEPTH  >= fifo_depth );
20009786:	88fb      	ldrh	r3, [r7, #6]
20009788:	2b20      	cmp	r3, #32
2000978a:	d900      	bls.n	2000978e <SPI_init+0x26>
2000978c:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MIN_FIFO_DEPTH  <= fifo_depth );
2000978e:	88fb      	ldrh	r3, [r7, #6]
20009790:	2b00      	cmp	r3, #0
20009792:	d100      	bne.n	20009796 <SPI_init+0x2e>
20009794:	be00      	bkpt	0x0000

    if( ( NULL_INSTANCE != this_spi ) && ( base_addr != NULL_ADDR ) )
20009796:	68fb      	ldr	r3, [r7, #12]
20009798:	2b00      	cmp	r3, #0
2000979a:	d052      	beq.n	20009842 <SPI_init+0xda>
2000979c:	68bb      	ldr	r3, [r7, #8]
2000979e:	2b00      	cmp	r3, #0
200097a0:	d04f      	beq.n	20009842 <SPI_init+0xda>
         * Relies on the fact that byte filling with 0x00 will equate
         * to 0 for any non byte sized items too.
         */

        /* First fill struct with 0s */
        memset( this_spi, 0, sizeof(spi_instance_t) );
200097a2:	68f8      	ldr	r0, [r7, #12]
200097a4:	f04f 0100 	mov.w	r1, #0
200097a8:	f04f 0248 	mov.w	r2, #72	; 0x48
200097ac:	f002 faf4 	bl	2000bd98 <memset>

        /* Configure CoreSPI instance attributes */
        this_spi->base_addr = (addr_t)base_addr;
200097b0:	68fb      	ldr	r3, [r7, #12]
200097b2:	68ba      	ldr	r2, [r7, #8]
200097b4:	601a      	str	r2, [r3, #0]

        /* Store FIFO depth or fall back to minimum if out of range */
        if( ( SPI_MAX_FIFO_DEPTH  >= fifo_depth ) && ( SPI_MIN_FIFO_DEPTH  <= fifo_depth ) )
200097b6:	88fb      	ldrh	r3, [r7, #6]
200097b8:	2b20      	cmp	r3, #32
200097ba:	d807      	bhi.n	200097cc <SPI_init+0x64>
200097bc:	88fb      	ldrh	r3, [r7, #6]
200097be:	2b00      	cmp	r3, #0
200097c0:	d004      	beq.n	200097cc <SPI_init+0x64>
        {
            this_spi->fifo_depth = fifo_depth;
200097c2:	68fb      	ldr	r3, [r7, #12]
200097c4:	88fa      	ldrh	r2, [r7, #6]
200097c6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

        /* Configure CoreSPI instance attributes */
        this_spi->base_addr = (addr_t)base_addr;

        /* Store FIFO depth or fall back to minimum if out of range */
        if( ( SPI_MAX_FIFO_DEPTH  >= fifo_depth ) && ( SPI_MIN_FIFO_DEPTH  <= fifo_depth ) )
200097ca:	e004      	b.n	200097d6 <SPI_init+0x6e>
        {
            this_spi->fifo_depth = fifo_depth;
        }
        else
        {
            this_spi->fifo_depth = SPI_MIN_FIFO_DEPTH;
200097cc:	68fb      	ldr	r3, [r7, #12]
200097ce:	f04f 0201 	mov.w	r2, #1
200097d2:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        }
        /* Make sure the CoreSPI is disabled while we configure it */
        HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
200097d6:	68fb      	ldr	r3, [r7, #12]
200097d8:	681b      	ldr	r3, [r3, #0]
200097da:	4618      	mov	r0, r3
200097dc:	f04f 0100 	mov.w	r1, #0
200097e0:	f04f 0201 	mov.w	r2, #1
200097e4:	f04f 0300 	mov.w	r3, #0
200097e8:	f7fc fce8 	bl	200061bc <HW_set_8bit_reg_field>

        /* Ensure all slaves are deselected */
        HAL_set_8bit_reg( this_spi->base_addr, SSEL, 0u );
200097ec:	68fb      	ldr	r3, [r7, #12]
200097ee:	681b      	ldr	r3, [r3, #0]
200097f0:	f103 0324 	add.w	r3, r3, #36	; 0x24
200097f4:	4618      	mov	r0, r3
200097f6:	f04f 0100 	mov.w	r1, #0
200097fa:	f7fc fcdb 	bl	200061b4 <HW_set_8bit_reg>

        /* Flush the receive and transmit FIFOs*/
        HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
200097fe:	68fb      	ldr	r3, [r7, #12]
20009800:	681b      	ldr	r3, [r3, #0]
20009802:	f103 031c 	add.w	r3, r3, #28
20009806:	4618      	mov	r0, r3
20009808:	f04f 0103 	mov.w	r1, #3
2000980c:	f7fc fcd2 	bl	200061b4 <HW_set_8bit_reg>

        /* Clear all interrupts */
        HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
20009810:	68fb      	ldr	r3, [r7, #12]
20009812:	681b      	ldr	r3, [r3, #0]
20009814:	f103 0304 	add.w	r3, r3, #4
20009818:	4618      	mov	r0, r3
2000981a:	f04f 01ff 	mov.w	r1, #255	; 0xff
2000981e:	f7fc fcc9 	bl	200061b4 <HW_set_8bit_reg>

        /* Ensure RXAVAIL, TXRFM, SSEND and CMDINT are disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL2, 0u );
20009822:	68fb      	ldr	r3, [r7, #12]
20009824:	681b      	ldr	r3, [r3, #0]
20009826:	f103 0318 	add.w	r3, r3, #24
2000982a:	4618      	mov	r0, r3
2000982c:	f04f 0100 	mov.w	r1, #0
20009830:	f7fc fcc0 	bl	200061b4 <HW_set_8bit_reg>
        /*
         * Enable the CoreSPI in the reset default of master mode
         * with TXUNDERRUN, RXOVFLOW and TXDONE interrupts disabled.
         * The driver does not currently use interrupts in master mode.
         */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL1,  ENABLE | CTRL1_MASTER_MASK );
20009834:	68fb      	ldr	r3, [r7, #12]
20009836:	681b      	ldr	r3, [r3, #0]
20009838:	4618      	mov	r0, r3
2000983a:	f04f 0103 	mov.w	r1, #3
2000983e:	f7fc fcb9 	bl	200061b4 <HW_set_8bit_reg>
    }
}
20009842:	f107 0710 	add.w	r7, r7, #16
20009846:	46bd      	mov	sp, r7
20009848:	bd80      	pop	{r7, pc}
2000984a:	bf00      	nop

2000984c <SPI_configure_master_mode>:
 */
void SPI_configure_master_mode
(
    spi_instance_t * this_spi
)
{
2000984c:	b580      	push	{r7, lr}
2000984e:	b082      	sub	sp, #8
20009850:	af00      	add	r7, sp, #0
20009852:	6078      	str	r0, [r7, #4]
    HAL_ASSERT( NULL_INSTANCE != this_spi );
20009854:	687b      	ldr	r3, [r7, #4]
20009856:	2b00      	cmp	r3, #0
20009858:	d100      	bne.n	2000985c <SPI_configure_master_mode+0x10>
2000985a:	be00      	bkpt	0x0000
    
    if( NULL_INSTANCE != this_spi )
2000985c:	687b      	ldr	r3, [r7, #4]
2000985e:	2b00      	cmp	r3, #0
20009860:	d031      	beq.n	200098c6 <SPI_configure_master_mode+0x7a>
    {
        /* Disable the CoreSPI for a little while, while we configure the CoreSPI */
        HAL_set_8bit_reg_field(this_spi->base_addr, CTRL1_ENABLE, DISABLE);
20009862:	687b      	ldr	r3, [r7, #4]
20009864:	681b      	ldr	r3, [r3, #0]
20009866:	4618      	mov	r0, r3
20009868:	f04f 0100 	mov.w	r1, #0
2000986c:	f04f 0201 	mov.w	r2, #1
20009870:	f04f 0300 	mov.w	r3, #0
20009874:	f7fc fca2 	bl	200061bc <HW_set_8bit_reg_field>

        /* Reset slave transfer mode to unknown in case it has been set previously */
        this_spi->slave_xfer_mode = SPI_SLAVE_XFER_NONE;
20009878:	687b      	ldr	r3, [r7, #4]
2000987a:	f04f 0200 	mov.w	r2, #0
2000987e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

        /* Flush the receive and transmit FIFOs*/
        HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
20009882:	687b      	ldr	r3, [r7, #4]
20009884:	681b      	ldr	r3, [r3, #0]
20009886:	f103 031c 	add.w	r3, r3, #28
2000988a:	4618      	mov	r0, r3
2000988c:	f04f 0103 	mov.w	r1, #3
20009890:	f7fc fc90 	bl	200061b4 <HW_set_8bit_reg>

        /* Clear all interrupts */
        HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
20009894:	687b      	ldr	r3, [r7, #4]
20009896:	681b      	ldr	r3, [r3, #0]
20009898:	f103 0304 	add.w	r3, r3, #4
2000989c:	4618      	mov	r0, r3
2000989e:	f04f 01ff 	mov.w	r1, #255	; 0xff
200098a2:	f7fc fc87 	bl	200061b4 <HW_set_8bit_reg>

        /* Ensure RXAVAIL, TXRFM, SSEND and CMDINT are disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL2, 0u );
200098a6:	687b      	ldr	r3, [r7, #4]
200098a8:	681b      	ldr	r3, [r3, #0]
200098aa:	f103 0318 	add.w	r3, r3, #24
200098ae:	4618      	mov	r0, r3
200098b0:	f04f 0100 	mov.w	r1, #0
200098b4:	f7fc fc7e 	bl	200061b4 <HW_set_8bit_reg>

        /* Enable the CoreSPI in master mode with TXUNDERRUN, RXOVFLOW and TXDONE interrupts disabled */
        HAL_set_8bit_reg( this_spi->base_addr, CTRL1, ENABLE | CTRL1_MASTER_MASK );
200098b8:	687b      	ldr	r3, [r7, #4]
200098ba:	681b      	ldr	r3, [r3, #0]
200098bc:	4618      	mov	r0, r3
200098be:	f04f 0103 	mov.w	r1, #3
200098c2:	f7fc fc77 	bl	200061b4 <HW_set_8bit_reg>
    }
}
200098c6:	f107 0708 	add.w	r7, r7, #8
200098ca:	46bd      	mov	sp, r7
200098cc:	bd80      	pop	{r7, pc}
200098ce:	bf00      	nop

200098d0 <SPI_set_slave_select>:
void SPI_set_slave_select
(
    spi_instance_t * this_spi,
    spi_slave_t slave
)
{
200098d0:	b580      	push	{r7, lr}
200098d2:	b084      	sub	sp, #16
200098d4:	af00      	add	r7, sp, #0
200098d6:	6078      	str	r0, [r7, #4]
200098d8:	460b      	mov	r3, r1
200098da:	70fb      	strb	r3, [r7, #3]
    spi_slave_t temp = (spi_slave_t)(0x00u) ;
200098dc:	f04f 0300 	mov.w	r3, #0
200098e0:	73fb      	strb	r3, [r7, #15]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
200098e2:	687b      	ldr	r3, [r7, #4]
200098e4:	2b00      	cmp	r3, #0
200098e6:	d100      	bne.n	200098ea <SPI_set_slave_select+0x1a>
200098e8:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_NB_OF_SLAVES > slave );
200098ea:	78fb      	ldrb	r3, [r7, #3]
200098ec:	2b07      	cmp	r3, #7
200098ee:	d900      	bls.n	200098f2 <SPI_set_slave_select+0x22>
200098f0:	be00      	bkpt	0x0000
    
    if( ( NULL_INSTANCE != this_spi ) && ( SPI_MAX_NB_OF_SLAVES > slave ) )
200098f2:	687b      	ldr	r3, [r7, #4]
200098f4:	2b00      	cmp	r3, #0
200098f6:	d03a      	beq.n	2000996e <SPI_set_slave_select+0x9e>
200098f8:	78fb      	ldrb	r3, [r7, #3]
200098fa:	2b07      	cmp	r3, #7
200098fc:	d837      	bhi.n	2000996e <SPI_set_slave_select+0x9e>
    {
        /* This function is only intended to be used with an SPI master */
        if( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) )
200098fe:	687b      	ldr	r3, [r7, #4]
20009900:	681b      	ldr	r3, [r3, #0]
20009902:	4618      	mov	r0, r3
20009904:	f04f 0101 	mov.w	r1, #1
20009908:	f04f 0202 	mov.w	r2, #2
2000990c:	f7fc fc64 	bl	200061d8 <HW_get_8bit_reg_field>
20009910:	4603      	mov	r3, r0
20009912:	2b00      	cmp	r3, #0
20009914:	d02b      	beq.n	2000996e <SPI_set_slave_select+0x9e>
        {
            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW ) )
20009916:	687b      	ldr	r3, [r7, #4]
20009918:	681b      	ldr	r3, [r3, #0]
2000991a:	f103 0320 	add.w	r3, r3, #32
2000991e:	4618      	mov	r0, r3
20009920:	f04f 0104 	mov.w	r1, #4
20009924:	f04f 0210 	mov.w	r2, #16
20009928:	f7fc fc56 	bl	200061d8 <HW_get_8bit_reg_field>
2000992c:	4603      	mov	r3, r0
2000992e:	2b01      	cmp	r3, #1
20009930:	d102      	bne.n	20009938 <SPI_set_slave_select+0x68>
            {
                 recover_from_rx_overflow( this_spi );
20009932:	6878      	ldr	r0, [r7, #4]
20009934:	f000 fa76 	bl	20009e24 <recover_from_rx_overflow>
            }
            /* Set the correct slave select bit */
            temp = (spi_slave_t)( HAL_get_8bit_reg( this_spi->base_addr, SSEL ) | ((uint32_t)1u << (uint32_t)slave) );
20009938:	687b      	ldr	r3, [r7, #4]
2000993a:	681b      	ldr	r3, [r3, #0]
2000993c:	f103 0324 	add.w	r3, r3, #36	; 0x24
20009940:	4618      	mov	r0, r3
20009942:	f7fc fc39 	bl	200061b8 <HW_get_8bit_reg>
20009946:	4603      	mov	r3, r0
20009948:	461a      	mov	r2, r3
2000994a:	78fb      	ldrb	r3, [r7, #3]
2000994c:	f04f 0101 	mov.w	r1, #1
20009950:	fa01 f303 	lsl.w	r3, r1, r3
20009954:	b2db      	uxtb	r3, r3
20009956:	ea42 0303 	orr.w	r3, r2, r3
2000995a:	73fb      	strb	r3, [r7, #15]
            HAL_set_8bit_reg( this_spi->base_addr, SSEL, (uint_fast8_t)temp );
2000995c:	687b      	ldr	r3, [r7, #4]
2000995e:	681b      	ldr	r3, [r3, #0]
20009960:	f103 0224 	add.w	r2, r3, #36	; 0x24
20009964:	7bfb      	ldrb	r3, [r7, #15]
20009966:	4610      	mov	r0, r2
20009968:	4619      	mov	r1, r3
2000996a:	f7fc fc23 	bl	200061b4 <HW_set_8bit_reg>
        }
    }
}
2000996e:	f107 0710 	add.w	r7, r7, #16
20009972:	46bd      	mov	sp, r7
20009974:	bd80      	pop	{r7, pc}
20009976:	bf00      	nop

20009978 <SPI_clear_slave_select>:
void SPI_clear_slave_select
(
    spi_instance_t * this_spi,
    spi_slave_t slave
)
{
20009978:	b580      	push	{r7, lr}
2000997a:	b084      	sub	sp, #16
2000997c:	af00      	add	r7, sp, #0
2000997e:	6078      	str	r0, [r7, #4]
20009980:	460b      	mov	r3, r1
20009982:	70fb      	strb	r3, [r7, #3]
    spi_slave_t temp = (spi_slave_t) (0x00u) ;
20009984:	f04f 0300 	mov.w	r3, #0
20009988:	73fb      	strb	r3, [r7, #15]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
2000998a:	687b      	ldr	r3, [r7, #4]
2000998c:	2b00      	cmp	r3, #0
2000998e:	d100      	bne.n	20009992 <SPI_clear_slave_select+0x1a>
20009990:	be00      	bkpt	0x0000
    HAL_ASSERT( SPI_MAX_NB_OF_SLAVES > slave );
20009992:	78fb      	ldrb	r3, [r7, #3]
20009994:	2b07      	cmp	r3, #7
20009996:	d900      	bls.n	2000999a <SPI_clear_slave_select+0x22>
20009998:	be00      	bkpt	0x0000
    
    if( ( NULL_INSTANCE != this_spi ) && ( SPI_MAX_NB_OF_SLAVES > slave ) )
2000999a:	687b      	ldr	r3, [r7, #4]
2000999c:	2b00      	cmp	r3, #0
2000999e:	d03d      	beq.n	20009a1c <SPI_clear_slave_select+0xa4>
200099a0:	78fb      	ldrb	r3, [r7, #3]
200099a2:	2b07      	cmp	r3, #7
200099a4:	d83a      	bhi.n	20009a1c <SPI_clear_slave_select+0xa4>
    {
        /* This function is only intended to be used with an SPI master. */
        if( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) )
200099a6:	687b      	ldr	r3, [r7, #4]
200099a8:	681b      	ldr	r3, [r3, #0]
200099aa:	4618      	mov	r0, r3
200099ac:	f04f 0101 	mov.w	r1, #1
200099b0:	f04f 0202 	mov.w	r2, #2
200099b4:	f7fc fc10 	bl	200061d8 <HW_get_8bit_reg_field>
200099b8:	4603      	mov	r3, r0
200099ba:	2b00      	cmp	r3, #0
200099bc:	d02e      	beq.n	20009a1c <SPI_clear_slave_select+0xa4>
        {
            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW) )
200099be:	687b      	ldr	r3, [r7, #4]
200099c0:	681b      	ldr	r3, [r3, #0]
200099c2:	f103 0320 	add.w	r3, r3, #32
200099c6:	4618      	mov	r0, r3
200099c8:	f04f 0104 	mov.w	r1, #4
200099cc:	f04f 0210 	mov.w	r2, #16
200099d0:	f7fc fc02 	bl	200061d8 <HW_get_8bit_reg_field>
200099d4:	4603      	mov	r3, r0
200099d6:	2b01      	cmp	r3, #1
200099d8:	d102      	bne.n	200099e0 <SPI_clear_slave_select+0x68>
            {
                 recover_from_rx_overflow( this_spi );
200099da:	6878      	ldr	r0, [r7, #4]
200099dc:	f000 fa22 	bl	20009e24 <recover_from_rx_overflow>
            }
            /* Clear the correct slave select bit */
            temp = (spi_slave_t)( HAL_get_8bit_reg( this_spi->base_addr, SSEL ) & ~((uint32_t)1u << (uint32_t)slave) );
200099e0:	687b      	ldr	r3, [r7, #4]
200099e2:	681b      	ldr	r3, [r3, #0]
200099e4:	f103 0324 	add.w	r3, r3, #36	; 0x24
200099e8:	4618      	mov	r0, r3
200099ea:	f7fc fbe5 	bl	200061b8 <HW_get_8bit_reg>
200099ee:	4603      	mov	r3, r0
200099f0:	461a      	mov	r2, r3
200099f2:	78fb      	ldrb	r3, [r7, #3]
200099f4:	f04f 0101 	mov.w	r1, #1
200099f8:	fa01 f303 	lsl.w	r3, r1, r3
200099fc:	b2db      	uxtb	r3, r3
200099fe:	ea6f 0303 	mvn.w	r3, r3
20009a02:	b2db      	uxtb	r3, r3
20009a04:	ea02 0303 	and.w	r3, r2, r3
20009a08:	73fb      	strb	r3, [r7, #15]
            HAL_set_8bit_reg( this_spi->base_addr, SSEL, (uint_fast8_t)temp ) ;
20009a0a:	687b      	ldr	r3, [r7, #4]
20009a0c:	681b      	ldr	r3, [r3, #0]
20009a0e:	f103 0224 	add.w	r2, r3, #36	; 0x24
20009a12:	7bfb      	ldrb	r3, [r7, #15]
20009a14:	4610      	mov	r0, r2
20009a16:	4619      	mov	r1, r3
20009a18:	f7fc fbcc 	bl	200061b4 <HW_set_8bit_reg>
        }
    }
}
20009a1c:	f107 0710 	add.w	r7, r7, #16
20009a20:	46bd      	mov	sp, r7
20009a22:	bd80      	pop	{r7, pc}

20009a24 <SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rx_buffer,
    uint16_t rx_byte_size
)
{
20009a24:	b590      	push	{r4, r7, lr}
20009a26:	b089      	sub	sp, #36	; 0x24
20009a28:	af00      	add	r7, sp, #0
20009a2a:	60f8      	str	r0, [r7, #12]
20009a2c:	60b9      	str	r1, [r7, #8]
20009a2e:	603b      	str	r3, [r7, #0]
20009a30:	4613      	mov	r3, r2
20009a32:	80fb      	strh	r3, [r7, #6]
    uint32_t transfer_size = 0U;   /* Total number of bytes to  transfer. */
20009a34:	f04f 0300 	mov.w	r3, #0
20009a38:	617b      	str	r3, [r7, #20]
    uint16_t transfer_idx = 0U;    /* Number of bytes transferred so far */
20009a3a:	f04f 0300 	mov.w	r3, #0
20009a3e:	833b      	strh	r3, [r7, #24]
    uint16_t tx_idx = 0u;          /* Number of valid data bytes sent */
20009a40:	f04f 0300 	mov.w	r3, #0
20009a44:	837b      	strh	r3, [r7, #26]
    uint16_t rx_idx = 0u;          /* Number of valid response bytes received */
20009a46:	f04f 0300 	mov.w	r3, #0
20009a4a:	83bb      	strh	r3, [r7, #28]
    uint16_t transit = 0U;         /* Number of bytes "in flight" to avoid FIFO errors */
20009a4c:	f04f 0300 	mov.w	r3, #0
20009a50:	83fb      	strh	r3, [r7, #30]

    HAL_ASSERT( NULL_INSTANCE != this_spi );
20009a52:	68fb      	ldr	r3, [r7, #12]
20009a54:	2b00      	cmp	r3, #0
20009a56:	d100      	bne.n	20009a5a <SPI_transfer_block+0x36>
20009a58:	be00      	bkpt	0x0000

    if( NULL_INSTANCE != this_spi )
20009a5a:	68fb      	ldr	r3, [r7, #12]
20009a5c:	2b00      	cmp	r3, #0
20009a5e:	f000 81dd 	beq.w	20009e1c <SPI_transfer_block+0x3f8>
    {
        /* This function is only intended to be used with an SPI master. */
        if( ( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) ) &&
20009a62:	68fb      	ldr	r3, [r7, #12]
20009a64:	681b      	ldr	r3, [r3, #0]
20009a66:	4618      	mov	r0, r3
20009a68:	f04f 0101 	mov.w	r1, #1
20009a6c:	f04f 0202 	mov.w	r2, #2
20009a70:	f7fc fbb2 	bl	200061d8 <HW_get_8bit_reg_field>
20009a74:	4603      	mov	r3, r0
20009a76:	2b00      	cmp	r3, #0
20009a78:	f000 81d0 	beq.w	20009e1c <SPI_transfer_block+0x3f8>
            /* Check for empty transfer as well */
            ( 0u != ( (uint32_t)cmd_byte_size + (uint32_t)rx_byte_size ) ) )
20009a7c:	88fa      	ldrh	r2, [r7, #6]
20009a7e:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
20009a80:	4413      	add	r3, r2
    HAL_ASSERT( NULL_INSTANCE != this_spi );

    if( NULL_INSTANCE != this_spi )
    {
        /* This function is only intended to be used with an SPI master. */
        if( ( DISABLE != HAL_get_8bit_reg_field(this_spi->base_addr, CTRL1_MASTER ) ) &&
20009a82:	2b00      	cmp	r3, #0
20009a84:	f000 81ca 	beq.w	20009e1c <SPI_transfer_block+0x3f8>
            /*
             * tansfer_size is one less than the real amount as we have to write
             * the last frame separately to trigger the slave deselect in case
             * the SPS option is in place.
             */
            transfer_size = ( (uint32_t)cmd_byte_size + (uint32_t)rx_byte_size ) - 1u;
20009a88:	88fa      	ldrh	r2, [r7, #6]
20009a8a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
20009a8c:	4413      	add	r3, r2
20009a8e:	f103 33ff 	add.w	r3, r3, #4294967295
20009a92:	617b      	str	r3, [r7, #20]
            /* Flush the receive and transmit FIFOs */
            HAL_set_8bit_reg(this_spi->base_addr, CMD, (uint32_t)(CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK ));
20009a94:	68fb      	ldr	r3, [r7, #12]
20009a96:	681b      	ldr	r3, [r3, #0]
20009a98:	f103 031c 	add.w	r3, r3, #28
20009a9c:	4618      	mov	r0, r3
20009a9e:	f04f 0103 	mov.w	r1, #3
20009aa2:	f7fc fb87 	bl	200061b4 <HW_set_8bit_reg>

            /* Recover from receiver overflow because of previous slave */
            if( ENABLE == HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXOVFLOW) )
20009aa6:	68fb      	ldr	r3, [r7, #12]
20009aa8:	681b      	ldr	r3, [r3, #0]
20009aaa:	f103 0320 	add.w	r3, r3, #32
20009aae:	4618      	mov	r0, r3
20009ab0:	f04f 0104 	mov.w	r1, #4
20009ab4:	f04f 0210 	mov.w	r2, #16
20009ab8:	f7fc fb8e 	bl	200061d8 <HW_get_8bit_reg_field>
20009abc:	4603      	mov	r3, r0
20009abe:	2b01      	cmp	r3, #1
20009ac0:	d102      	bne.n	20009ac8 <SPI_transfer_block+0xa4>
            {
                 recover_from_rx_overflow( this_spi );
20009ac2:	68f8      	ldr	r0, [r7, #12]
20009ac4:	f000 f9ae 	bl	20009e24 <recover_from_rx_overflow>
            }

            /* Disable the Core SPI for a little bit, while we load the TX FIFO */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
20009ac8:	68fb      	ldr	r3, [r7, #12]
20009aca:	681b      	ldr	r3, [r3, #0]
20009acc:	4618      	mov	r0, r3
20009ace:	f04f 0100 	mov.w	r1, #0
20009ad2:	f04f 0201 	mov.w	r2, #1
20009ad6:	f04f 0300 	mov.w	r3, #0
20009ada:	f7fc fb6f 	bl	200061bc <HW_set_8bit_reg_field>

            while( ( tx_idx < transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
20009ade:	e021      	b.n	20009b24 <SPI_transfer_block+0x100>
            {
                if( tx_idx < cmd_byte_size )
20009ae0:	8b7a      	ldrh	r2, [r7, #26]
20009ae2:	88fb      	ldrh	r3, [r7, #6]
20009ae4:	429a      	cmp	r2, r3
20009ae6:	d20c      	bcs.n	20009b02 <SPI_transfer_block+0xde>
                {
                    /* Push out valid data */
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, (uint32_t)cmd_buffer[tx_idx] );
20009ae8:	68fb      	ldr	r3, [r7, #12]
20009aea:	681b      	ldr	r3, [r3, #0]
20009aec:	f103 020c 	add.w	r2, r3, #12
20009af0:	8b79      	ldrh	r1, [r7, #26]
20009af2:	68bb      	ldr	r3, [r7, #8]
20009af4:	440b      	add	r3, r1
20009af6:	781b      	ldrb	r3, [r3, #0]
20009af8:	4610      	mov	r0, r2
20009afa:	4619      	mov	r1, r3
20009afc:	f7fc fb2a 	bl	20006154 <HW_set_32bit_reg>
20009b00:	e008      	b.n	20009b14 <SPI_transfer_block+0xf0>
                }
                else
                {
                    /* Push out 0s to get data back from slave */
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
20009b02:	68fb      	ldr	r3, [r7, #12]
20009b04:	681b      	ldr	r3, [r3, #0]
20009b06:	f103 030c 	add.w	r3, r3, #12
20009b0a:	4618      	mov	r0, r3
20009b0c:	f04f 0100 	mov.w	r1, #0
20009b10:	f7fc fb20 	bl	20006154 <HW_set_32bit_reg>
                }
                ++transit;
20009b14:	8bfb      	ldrh	r3, [r7, #30]
20009b16:	f103 0301 	add.w	r3, r3, #1
20009b1a:	83fb      	strh	r3, [r7, #30]
                ++tx_idx;
20009b1c:	8b7b      	ldrh	r3, [r7, #26]
20009b1e:	f103 0301 	add.w	r3, r3, #1
20009b22:	837b      	strh	r3, [r7, #26]
            }

            /* Disable the Core SPI for a little bit, while we load the TX FIFO */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );

            while( ( tx_idx < transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
20009b24:	8b7a      	ldrh	r2, [r7, #26]
20009b26:	697b      	ldr	r3, [r7, #20]
20009b28:	429a      	cmp	r2, r3
20009b2a:	d205      	bcs.n	20009b38 <SPI_transfer_block+0x114>
20009b2c:	68fb      	ldr	r3, [r7, #12]
20009b2e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009b32:	8b7a      	ldrh	r2, [r7, #26]
20009b34:	429a      	cmp	r2, r3
20009b36:	d3d3      	bcc.n	20009ae0 <SPI_transfer_block+0xbc>
                ++transit;
                ++tx_idx;
            }

            /* If room left to put last frame in before the off, then do it */
            if( ( tx_idx == transfer_size ) && ( tx_idx < this_spi->fifo_depth ) )
20009b38:	8b7a      	ldrh	r2, [r7, #26]
20009b3a:	697b      	ldr	r3, [r7, #20]
20009b3c:	429a      	cmp	r2, r3
20009b3e:	d127      	bne.n	20009b90 <SPI_transfer_block+0x16c>
20009b40:	68fb      	ldr	r3, [r7, #12]
20009b42:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009b46:	8b7a      	ldrh	r2, [r7, #26]
20009b48:	429a      	cmp	r2, r3
20009b4a:	d221      	bcs.n	20009b90 <SPI_transfer_block+0x16c>
            {
                if( tx_idx < cmd_byte_size )
20009b4c:	8b7a      	ldrh	r2, [r7, #26]
20009b4e:	88fb      	ldrh	r3, [r7, #6]
20009b50:	429a      	cmp	r2, r3
20009b52:	d20c      	bcs.n	20009b6e <SPI_transfer_block+0x14a>
                {
                    /* Push out valid data, not expecting any reply this time */
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, (uint32_t)cmd_buffer[tx_idx] );
20009b54:	68fb      	ldr	r3, [r7, #12]
20009b56:	681b      	ldr	r3, [r3, #0]
20009b58:	f103 0228 	add.w	r2, r3, #40	; 0x28
20009b5c:	8b79      	ldrh	r1, [r7, #26]
20009b5e:	68bb      	ldr	r3, [r7, #8]
20009b60:	440b      	add	r3, r1
20009b62:	781b      	ldrb	r3, [r3, #0]
20009b64:	4610      	mov	r0, r2
20009b66:	4619      	mov	r1, r3
20009b68:	f7fc faf4 	bl	20006154 <HW_set_32bit_reg>
20009b6c:	e008      	b.n	20009b80 <SPI_transfer_block+0x15c>
                }
                else
                {
                    /* Push out last 0 to get data back from slave */
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, 0U );
20009b6e:	68fb      	ldr	r3, [r7, #12]
20009b70:	681b      	ldr	r3, [r3, #0]
20009b72:	f103 0328 	add.w	r3, r3, #40	; 0x28
20009b76:	4618      	mov	r0, r3
20009b78:	f04f 0100 	mov.w	r1, #0
20009b7c:	f7fc faea 	bl	20006154 <HW_set_32bit_reg>
                }

                ++transit;
20009b80:	8bfb      	ldrh	r3, [r7, #30]
20009b82:	f103 0301 	add.w	r3, r3, #1
20009b86:	83fb      	strh	r3, [r7, #30]
                ++tx_idx;
20009b88:	8b7b      	ldrh	r3, [r7, #26]
20009b8a:	f103 0301 	add.w	r3, r3, #1
20009b8e:	837b      	strh	r3, [r7, #26]
            }

            /* FIFO is all loaded up so enable Core SPI to start transfer */
            HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, ENABLE );
20009b90:	68fb      	ldr	r3, [r7, #12]
20009b92:	681b      	ldr	r3, [r3, #0]
20009b94:	4618      	mov	r0, r3
20009b96:	f04f 0100 	mov.w	r1, #0
20009b9a:	f04f 0201 	mov.w	r2, #1
20009b9e:	f04f 0301 	mov.w	r3, #1
20009ba2:	f7fc fb0b 	bl	200061bc <HW_set_8bit_reg_field>
             *
             * First stage transfers remaining command bytes (if any).
             * At this stage anything in the RX FIFO can be discarded as it is
             * not part of a valid response.
             */
            while( tx_idx < cmd_byte_size )
20009ba6:	e047      	b.n	20009c38 <SPI_transfer_block+0x214>
            {
                if( transit < this_spi->fifo_depth )
20009ba8:	68fb      	ldr	r3, [r7, #12]
20009baa:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009bae:	8bfa      	ldrh	r2, [r7, #30]
20009bb0:	429a      	cmp	r2, r3
20009bb2:	d224      	bcs.n	20009bfe <SPI_transfer_block+0x1da>
                {
                    /* Send another byte. */
                    if( tx_idx == transfer_size ) /* Last frame is special... */
20009bb4:	8b7a      	ldrh	r2, [r7, #26]
20009bb6:	697b      	ldr	r3, [r7, #20]
20009bb8:	429a      	cmp	r2, r3
20009bba:	d10c      	bne.n	20009bd6 <SPI_transfer_block+0x1b2>
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXLAST, (uint32_t)cmd_buffer[tx_idx] );
20009bbc:	68fb      	ldr	r3, [r7, #12]
20009bbe:	681b      	ldr	r3, [r3, #0]
20009bc0:	f103 0228 	add.w	r2, r3, #40	; 0x28
20009bc4:	8b79      	ldrh	r1, [r7, #26]
20009bc6:	68bb      	ldr	r3, [r7, #8]
20009bc8:	440b      	add	r3, r1
20009bca:	781b      	ldrb	r3, [r3, #0]
20009bcc:	4610      	mov	r0, r2
20009bce:	4619      	mov	r1, r3
20009bd0:	f7fc fac0 	bl	20006154 <HW_set_32bit_reg>
20009bd4:	e00b      	b.n	20009bee <SPI_transfer_block+0x1ca>
                    }
                    else
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXDATA, (uint32_t)cmd_buffer[tx_idx] );
20009bd6:	68fb      	ldr	r3, [r7, #12]
20009bd8:	681b      	ldr	r3, [r3, #0]
20009bda:	f103 020c 	add.w	r2, r3, #12
20009bde:	8b79      	ldrh	r1, [r7, #26]
20009be0:	68bb      	ldr	r3, [r7, #8]
20009be2:	440b      	add	r3, r1
20009be4:	781b      	ldrb	r3, [r3, #0]
20009be6:	4610      	mov	r0, r2
20009be8:	4619      	mov	r1, r3
20009bea:	f7fc fab3 	bl	20006154 <HW_set_32bit_reg>
                    }
                    ++tx_idx;
20009bee:	8b7b      	ldrh	r3, [r7, #26]
20009bf0:	f103 0301 	add.w	r3, r3, #1
20009bf4:	837b      	strh	r3, [r7, #26]
                    ++transit;
20009bf6:	8bfb      	ldrh	r3, [r7, #30]
20009bf8:	f103 0301 	add.w	r3, r3, #1
20009bfc:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field( this_spi->base_addr, STATUS_RXEMPTY ) )
20009bfe:	68fb      	ldr	r3, [r7, #12]
20009c00:	681b      	ldr	r3, [r3, #0]
20009c02:	f103 0320 	add.w	r3, r3, #32
20009c06:	4618      	mov	r0, r3
20009c08:	f04f 0102 	mov.w	r1, #2
20009c0c:	f04f 0204 	mov.w	r2, #4
20009c10:	f7fc fae2 	bl	200061d8 <HW_get_8bit_reg_field>
20009c14:	4603      	mov	r3, r0
20009c16:	2b00      	cmp	r3, #0
20009c18:	d10e      	bne.n	20009c38 <SPI_transfer_block+0x214>
                {
                    /* Read and discard. */
                    HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
20009c1a:	68fb      	ldr	r3, [r7, #12]
20009c1c:	681b      	ldr	r3, [r3, #0]
20009c1e:	f103 0308 	add.w	r3, r3, #8
20009c22:	4618      	mov	r0, r3
20009c24:	f7fc fa98 	bl	20006158 <HW_get_32bit_reg>
                    ++transfer_idx;
20009c28:	8b3b      	ldrh	r3, [r7, #24]
20009c2a:	f103 0301 	add.w	r3, r3, #1
20009c2e:	833b      	strh	r3, [r7, #24]
                    --transit;
20009c30:	8bfb      	ldrh	r3, [r7, #30]
20009c32:	f103 33ff 	add.w	r3, r3, #4294967295
20009c36:	83fb      	strh	r3, [r7, #30]
             *
             * First stage transfers remaining command bytes (if any).
             * At this stage anything in the RX FIFO can be discarded as it is
             * not part of a valid response.
             */
            while( tx_idx < cmd_byte_size )
20009c38:	8b7a      	ldrh	r2, [r7, #26]
20009c3a:	88fb      	ldrh	r3, [r7, #6]
20009c3c:	429a      	cmp	r2, r3
20009c3e:	d3b3      	bcc.n	20009ba8 <SPI_transfer_block+0x184>
            /*
             * Now, we are writing dummy bytes to push through the response from
             * the slave but we still have to keep discarding any read data that
             * corresponds with one of our command bytes.
             */
            while( transfer_idx < cmd_byte_size )
20009c40:	e037      	b.n	20009cb2 <SPI_transfer_block+0x28e>
            {
                if( transit < this_spi->fifo_depth )
20009c42:	68fb      	ldr	r3, [r7, #12]
20009c44:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009c48:	8bfa      	ldrh	r2, [r7, #30]
20009c4a:	429a      	cmp	r2, r3
20009c4c:	d214      	bcs.n	20009c78 <SPI_transfer_block+0x254>
                {
                    if( tx_idx < transfer_size )
20009c4e:	8b7a      	ldrh	r2, [r7, #26]
20009c50:	697b      	ldr	r3, [r7, #20]
20009c52:	429a      	cmp	r2, r3
20009c54:	d210      	bcs.n	20009c78 <SPI_transfer_block+0x254>
                    {
                        HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
20009c56:	68fb      	ldr	r3, [r7, #12]
20009c58:	681b      	ldr	r3, [r3, #0]
20009c5a:	f103 030c 	add.w	r3, r3, #12
20009c5e:	4618      	mov	r0, r3
20009c60:	f04f 0100 	mov.w	r1, #0
20009c64:	f7fc fa76 	bl	20006154 <HW_set_32bit_reg>
                        ++tx_idx;
20009c68:	8b7b      	ldrh	r3, [r7, #26]
20009c6a:	f103 0301 	add.w	r3, r3, #1
20009c6e:	837b      	strh	r3, [r7, #26]
                        ++transit;
20009c70:	8bfb      	ldrh	r3, [r7, #30]
20009c72:	f103 0301 	add.w	r3, r3, #1
20009c76:	83fb      	strh	r3, [r7, #30]
                    }
                }
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
20009c78:	68fb      	ldr	r3, [r7, #12]
20009c7a:	681b      	ldr	r3, [r3, #0]
20009c7c:	f103 0320 	add.w	r3, r3, #32
20009c80:	4618      	mov	r0, r3
20009c82:	f04f 0102 	mov.w	r1, #2
20009c86:	f04f 0204 	mov.w	r2, #4
20009c8a:	f7fc faa5 	bl	200061d8 <HW_get_8bit_reg_field>
20009c8e:	4603      	mov	r3, r0
20009c90:	2b00      	cmp	r3, #0
20009c92:	d10e      	bne.n	20009cb2 <SPI_transfer_block+0x28e>
                {
                    /* Read and discard. */
                    HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
20009c94:	68fb      	ldr	r3, [r7, #12]
20009c96:	681b      	ldr	r3, [r3, #0]
20009c98:	f103 0308 	add.w	r3, r3, #8
20009c9c:	4618      	mov	r0, r3
20009c9e:	f7fc fa5b 	bl	20006158 <HW_get_32bit_reg>
                    ++transfer_idx;
20009ca2:	8b3b      	ldrh	r3, [r7, #24]
20009ca4:	f103 0301 	add.w	r3, r3, #1
20009ca8:	833b      	strh	r3, [r7, #24]
                    --transit;
20009caa:	8bfb      	ldrh	r3, [r7, #30]
20009cac:	f103 33ff 	add.w	r3, r3, #4294967295
20009cb0:	83fb      	strh	r3, [r7, #30]
            /*
             * Now, we are writing dummy bytes to push through the response from
             * the slave but we still have to keep discarding any read data that
             * corresponds with one of our command bytes.
             */
            while( transfer_idx < cmd_byte_size )
20009cb2:	8b3a      	ldrh	r2, [r7, #24]
20009cb4:	88fb      	ldrh	r3, [r7, #6]
20009cb6:	429a      	cmp	r2, r3
20009cb8:	d3c3      	bcc.n	20009c42 <SPI_transfer_block+0x21e>
            }
            /*
             * Now we are now only sending dummy data to push through the
             * valid response data which we store in the response buffer.
             */
            while( tx_idx < transfer_size )
20009cba:	e03e      	b.n	20009d3a <SPI_transfer_block+0x316>
            {
                if( transit < this_spi->fifo_depth )
20009cbc:	68fb      	ldr	r3, [r7, #12]
20009cbe:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009cc2:	8bfa      	ldrh	r2, [r7, #30]
20009cc4:	429a      	cmp	r2, r3
20009cc6:	d210      	bcs.n	20009cea <SPI_transfer_block+0x2c6>
                {
                    HAL_set_32bit_reg( this_spi->base_addr, TXDATA, 0U );
20009cc8:	68fb      	ldr	r3, [r7, #12]
20009cca:	681b      	ldr	r3, [r3, #0]
20009ccc:	f103 030c 	add.w	r3, r3, #12
20009cd0:	4618      	mov	r0, r3
20009cd2:	f04f 0100 	mov.w	r1, #0
20009cd6:	f7fc fa3d 	bl	20006154 <HW_set_32bit_reg>
                    ++tx_idx;
20009cda:	8b7b      	ldrh	r3, [r7, #26]
20009cdc:	f103 0301 	add.w	r3, r3, #1
20009ce0:	837b      	strh	r3, [r7, #26]
                    ++transit;
20009ce2:	8bfb      	ldrh	r3, [r7, #30]
20009ce4:	f103 0301 	add.w	r3, r3, #1
20009ce8:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
20009cea:	68fb      	ldr	r3, [r7, #12]
20009cec:	681b      	ldr	r3, [r3, #0]
20009cee:	f103 0320 	add.w	r3, r3, #32
20009cf2:	4618      	mov	r0, r3
20009cf4:	f04f 0102 	mov.w	r1, #2
20009cf8:	f04f 0204 	mov.w	r2, #4
20009cfc:	f7fc fa6c 	bl	200061d8 <HW_get_8bit_reg_field>
20009d00:	4603      	mov	r3, r0
20009d02:	2b00      	cmp	r3, #0
20009d04:	d119      	bne.n	20009d3a <SPI_transfer_block+0x316>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
20009d06:	8bba      	ldrh	r2, [r7, #28]
20009d08:	683b      	ldr	r3, [r7, #0]
20009d0a:	eb02 0403 	add.w	r4, r2, r3
20009d0e:	68fb      	ldr	r3, [r7, #12]
20009d10:	681b      	ldr	r3, [r3, #0]
20009d12:	f103 0308 	add.w	r3, r3, #8
20009d16:	4618      	mov	r0, r3
20009d18:	f7fc fa1e 	bl	20006158 <HW_get_32bit_reg>
20009d1c:	4603      	mov	r3, r0
20009d1e:	b2db      	uxtb	r3, r3
20009d20:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
20009d22:	8bbb      	ldrh	r3, [r7, #28]
20009d24:	f103 0301 	add.w	r3, r3, #1
20009d28:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
20009d2a:	8b3b      	ldrh	r3, [r7, #24]
20009d2c:	f103 0301 	add.w	r3, r3, #1
20009d30:	833b      	strh	r3, [r7, #24]
                    --transit;
20009d32:	8bfb      	ldrh	r3, [r7, #30]
20009d34:	f103 33ff 	add.w	r3, r3, #4294967295
20009d38:	83fb      	strh	r3, [r7, #30]
            }
            /*
             * Now we are now only sending dummy data to push through the
             * valid response data which we store in the response buffer.
             */
            while( tx_idx < transfer_size )
20009d3a:	8b7a      	ldrh	r2, [r7, #26]
20009d3c:	697b      	ldr	r3, [r7, #20]
20009d3e:	429a      	cmp	r2, r3
20009d40:	d3bc      	bcc.n	20009cbc <SPI_transfer_block+0x298>
                    ++transfer_idx;
                    --transit;
                }
            }
            /* If we still need to send the last frame */
            while( tx_idx == transfer_size )
20009d42:	e03e      	b.n	20009dc2 <SPI_transfer_block+0x39e>
            {
                if( transit < this_spi->fifo_depth )
20009d44:	68fb      	ldr	r3, [r7, #12]
20009d46:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20009d4a:	8bfa      	ldrh	r2, [r7, #30]
20009d4c:	429a      	cmp	r2, r3
20009d4e:	d210      	bcs.n	20009d72 <SPI_transfer_block+0x34e>
                {
                    HAL_set_32bit_reg( this_spi->base_addr, TXLAST, 0U );
20009d50:	68fb      	ldr	r3, [r7, #12]
20009d52:	681b      	ldr	r3, [r3, #0]
20009d54:	f103 0328 	add.w	r3, r3, #40	; 0x28
20009d58:	4618      	mov	r0, r3
20009d5a:	f04f 0100 	mov.w	r1, #0
20009d5e:	f7fc f9f9 	bl	20006154 <HW_set_32bit_reg>
                    ++tx_idx;
20009d62:	8b7b      	ldrh	r3, [r7, #26]
20009d64:	f103 0301 	add.w	r3, r3, #1
20009d68:	837b      	strh	r3, [r7, #26]
                    ++transit;
20009d6a:	8bfb      	ldrh	r3, [r7, #30]
20009d6c:	f103 0301 	add.w	r3, r3, #1
20009d70:	83fb      	strh	r3, [r7, #30]
                }
                if( !HAL_get_8bit_reg_field( this_spi->base_addr, STATUS_RXEMPTY ) )
20009d72:	68fb      	ldr	r3, [r7, #12]
20009d74:	681b      	ldr	r3, [r3, #0]
20009d76:	f103 0320 	add.w	r3, r3, #32
20009d7a:	4618      	mov	r0, r3
20009d7c:	f04f 0102 	mov.w	r1, #2
20009d80:	f04f 0204 	mov.w	r2, #4
20009d84:	f7fc fa28 	bl	200061d8 <HW_get_8bit_reg_field>
20009d88:	4603      	mov	r3, r0
20009d8a:	2b00      	cmp	r3, #0
20009d8c:	d119      	bne.n	20009dc2 <SPI_transfer_block+0x39e>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
20009d8e:	8bba      	ldrh	r2, [r7, #28]
20009d90:	683b      	ldr	r3, [r7, #0]
20009d92:	eb02 0403 	add.w	r4, r2, r3
20009d96:	68fb      	ldr	r3, [r7, #12]
20009d98:	681b      	ldr	r3, [r3, #0]
20009d9a:	f103 0308 	add.w	r3, r3, #8
20009d9e:	4618      	mov	r0, r3
20009da0:	f7fc f9da 	bl	20006158 <HW_get_32bit_reg>
20009da4:	4603      	mov	r3, r0
20009da6:	b2db      	uxtb	r3, r3
20009da8:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
20009daa:	8bbb      	ldrh	r3, [r7, #28]
20009dac:	f103 0301 	add.w	r3, r3, #1
20009db0:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
20009db2:	8b3b      	ldrh	r3, [r7, #24]
20009db4:	f103 0301 	add.w	r3, r3, #1
20009db8:	833b      	strh	r3, [r7, #24]
                    --transit;
20009dba:	8bfb      	ldrh	r3, [r7, #30]
20009dbc:	f103 33ff 	add.w	r3, r3, #4294967295
20009dc0:	83fb      	strh	r3, [r7, #30]
                    ++transfer_idx;
                    --transit;
                }
            }
            /* If we still need to send the last frame */
            while( tx_idx == transfer_size )
20009dc2:	8b7a      	ldrh	r2, [r7, #26]
20009dc4:	697b      	ldr	r3, [r7, #20]
20009dc6:	429a      	cmp	r2, r3
20009dc8:	d0bc      	beq.n	20009d44 <SPI_transfer_block+0x320>
            }
            /*
             * Finally, we are now finished sending data and are only reading
             * valid response data which we store in the response buffer.
             */
            while( transfer_idx <= transfer_size )
20009dca:	e023      	b.n	20009e14 <SPI_transfer_block+0x3f0>
            {
                if( !HAL_get_8bit_reg_field(this_spi->base_addr, STATUS_RXEMPTY ) )
20009dcc:	68fb      	ldr	r3, [r7, #12]
20009dce:	681b      	ldr	r3, [r3, #0]
20009dd0:	f103 0320 	add.w	r3, r3, #32
20009dd4:	4618      	mov	r0, r3
20009dd6:	f04f 0102 	mov.w	r1, #2
20009dda:	f04f 0204 	mov.w	r2, #4
20009dde:	f7fc f9fb 	bl	200061d8 <HW_get_8bit_reg_field>
20009de2:	4603      	mov	r3, r0
20009de4:	2b00      	cmp	r3, #0
20009de6:	d115      	bne.n	20009e14 <SPI_transfer_block+0x3f0>
                {
                    /* Process received byte. */
                    rx_buffer[rx_idx] = (uint8_t)HAL_get_32bit_reg( this_spi->base_addr, RXDATA );
20009de8:	8bba      	ldrh	r2, [r7, #28]
20009dea:	683b      	ldr	r3, [r7, #0]
20009dec:	eb02 0403 	add.w	r4, r2, r3
20009df0:	68fb      	ldr	r3, [r7, #12]
20009df2:	681b      	ldr	r3, [r3, #0]
20009df4:	f103 0308 	add.w	r3, r3, #8
20009df8:	4618      	mov	r0, r3
20009dfa:	f7fc f9ad 	bl	20006158 <HW_get_32bit_reg>
20009dfe:	4603      	mov	r3, r0
20009e00:	b2db      	uxtb	r3, r3
20009e02:	7023      	strb	r3, [r4, #0]
                    ++rx_idx;
20009e04:	8bbb      	ldrh	r3, [r7, #28]
20009e06:	f103 0301 	add.w	r3, r3, #1
20009e0a:	83bb      	strh	r3, [r7, #28]
                    ++transfer_idx;
20009e0c:	8b3b      	ldrh	r3, [r7, #24]
20009e0e:	f103 0301 	add.w	r3, r3, #1
20009e12:	833b      	strh	r3, [r7, #24]
            }
            /*
             * Finally, we are now finished sending data and are only reading
             * valid response data which we store in the response buffer.
             */
            while( transfer_idx <= transfer_size )
20009e14:	8b3a      	ldrh	r2, [r7, #24]
20009e16:	697b      	ldr	r3, [r7, #20]
20009e18:	429a      	cmp	r2, r3
20009e1a:	d9d7      	bls.n	20009dcc <SPI_transfer_block+0x3a8>
                    ++transfer_idx;
                }
            }
        }
    }
}
20009e1c:	f107 0724 	add.w	r7, r7, #36	; 0x24
20009e20:	46bd      	mov	sp, r7
20009e22:	bd90      	pop	{r4, r7, pc}

20009e24 <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    const spi_instance_t * this_spi
)
{
20009e24:	b580      	push	{r7, lr}
20009e26:	b082      	sub	sp, #8
20009e28:	af00      	add	r7, sp, #0
20009e2a:	6078      	str	r0, [r7, #4]
    /* Disable CoreSPI */
    HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, DISABLE );
20009e2c:	687b      	ldr	r3, [r7, #4]
20009e2e:	681b      	ldr	r3, [r3, #0]
20009e30:	4618      	mov	r0, r3
20009e32:	f04f 0100 	mov.w	r1, #0
20009e36:	f04f 0201 	mov.w	r2, #1
20009e3a:	f04f 0300 	mov.w	r3, #0
20009e3e:	f7fc f9bd 	bl	200061bc <HW_set_8bit_reg_field>

    /* Reset TX and RX FIFOs */
    HAL_set_8bit_reg( this_spi->base_addr, CMD, CMD_TXFIFORST_MASK | CMD_RXFIFORST_MASK );
20009e42:	687b      	ldr	r3, [r7, #4]
20009e44:	681b      	ldr	r3, [r3, #0]
20009e46:	f103 031c 	add.w	r3, r3, #28
20009e4a:	4618      	mov	r0, r3
20009e4c:	f04f 0103 	mov.w	r1, #3
20009e50:	f7fc f9b0 	bl	200061b4 <HW_set_8bit_reg>

    /* Clear all interrupts */
    HAL_set_8bit_reg( this_spi->base_addr, INTCLR, SPI_ALL_INTS );
20009e54:	687b      	ldr	r3, [r7, #4]
20009e56:	681b      	ldr	r3, [r3, #0]
20009e58:	f103 0304 	add.w	r3, r3, #4
20009e5c:	4618      	mov	r0, r3
20009e5e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20009e62:	f7fc f9a7 	bl	200061b4 <HW_set_8bit_reg>

    /* Enable CoreSPI */
    HAL_set_8bit_reg_field( this_spi->base_addr, CTRL1_ENABLE, ENABLE );
20009e66:	687b      	ldr	r3, [r7, #4]
20009e68:	681b      	ldr	r3, [r3, #0]
20009e6a:	4618      	mov	r0, r3
20009e6c:	f04f 0100 	mov.w	r1, #0
20009e70:	f04f 0201 	mov.w	r2, #1
20009e74:	f04f 0301 	mov.w	r3, #1
20009e78:	f7fc f9a0 	bl	200061bc <HW_set_8bit_reg_field>
}
20009e7c:	f107 0708 	add.w	r7, r7, #8
20009e80:	46bd      	mov	sp, r7
20009e82:	bd80      	pop	{r7, pc}

20009e84 <I2C_init>:
    i2c_instance_t * this_i2c,
    addr_t base_address,
    uint8_t ser_address,
    i2c_clock_divider_t ser_clock_speed
)
{
20009e84:	b580      	push	{r7, lr}
20009e86:	b086      	sub	sp, #24
20009e88:	af00      	add	r7, sp, #0
20009e8a:	60f8      	str	r0, [r7, #12]
20009e8c:	60b9      	str	r1, [r7, #8]
20009e8e:	71fa      	strb	r2, [r7, #7]
20009e90:	71bb      	strb	r3, [r7, #6]
    psr_t saved_psr;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
20009e92:	79bb      	ldrb	r3, [r7, #6]
20009e94:	617b      	str	r3, [r7, #20]
    
    /*
     * We need to disable ints while doing this as there is no guarantee we
     * have not been called already and the ISR is active.
     */
    saved_psr = HAL_disable_interrupts();
20009e96:	f001 f99f 	bl	2000b1d8 <HAL_disable_interrupts>
20009e9a:	4603      	mov	r3, r0
20009e9c:	613b      	str	r3, [r7, #16]
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    memset(this_i2c, 0, sizeof(i2c_instance_t));
20009e9e:	68f8      	ldr	r0, [r7, #12]
20009ea0:	f04f 0100 	mov.w	r1, #0
20009ea4:	f04f 026c 	mov.w	r2, #108	; 0x6c
20009ea8:	f001 ff76 	bl	2000bd98 <memset>
    
    /*
     * Set base address of I2C hardware used by this instance.
     */
    this_i2c->base_address = base_address;
20009eac:	68fb      	ldr	r3, [r7, #12]
20009eae:	68ba      	ldr	r2, [r7, #8]
20009eb0:	601a      	str	r2, [r3, #0]

    /*
     * Update Serial address of the device
     */
    this_i2c->ser_address = ((uint_fast8_t)ser_address << 1u);
20009eb2:	79fb      	ldrb	r3, [r7, #7]
20009eb4:	ea4f 0243 	mov.w	r2, r3, lsl #1
20009eb8:	68fb      	ldr	r3, [r7, #12]
20009eba:	605a      	str	r2, [r3, #4]
    
    /*
     * Configure hardware.
     */
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x00); /* Reset I2C hardware. */
20009ebc:	68fb      	ldr	r3, [r7, #12]
20009ebe:	681b      	ldr	r3, [r3, #0]
20009ec0:	4618      	mov	r0, r3
20009ec2:	f04f 0106 	mov.w	r1, #6
20009ec6:	f04f 0240 	mov.w	r2, #64	; 0x40
20009eca:	f04f 0300 	mov.w	r3, #0
20009ece:	f7fc f975 	bl	200061bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x01); /* set enable bit */
20009ed2:	68fb      	ldr	r3, [r7, #12]
20009ed4:	681b      	ldr	r3, [r3, #0]
20009ed6:	4618      	mov	r0, r3
20009ed8:	f04f 0106 	mov.w	r1, #6
20009edc:	f04f 0240 	mov.w	r2, #64	; 0x40
20009ee0:	f04f 0301 	mov.w	r3, #1
20009ee4:	f7fc f96a 	bl	200061bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR2, ( (clock_speed >> 2) & 0x01) );
20009ee8:	68fb      	ldr	r3, [r7, #12]
20009eea:	681a      	ldr	r2, [r3, #0]
20009eec:	697b      	ldr	r3, [r7, #20]
20009eee:	ea4f 0393 	mov.w	r3, r3, lsr #2
20009ef2:	f003 0301 	and.w	r3, r3, #1
20009ef6:	4610      	mov	r0, r2
20009ef8:	f04f 0107 	mov.w	r1, #7
20009efc:	f04f 0280 	mov.w	r2, #128	; 0x80
20009f00:	f7fc f95c 	bl	200061bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR1, ( (clock_speed >> 1) & 0x01) );
20009f04:	68fb      	ldr	r3, [r7, #12]
20009f06:	681a      	ldr	r2, [r3, #0]
20009f08:	697b      	ldr	r3, [r7, #20]
20009f0a:	ea4f 0353 	mov.w	r3, r3, lsr #1
20009f0e:	f003 0301 	and.w	r3, r3, #1
20009f12:	4610      	mov	r0, r2
20009f14:	f04f 0101 	mov.w	r1, #1
20009f18:	f04f 0202 	mov.w	r2, #2
20009f1c:	f7fc f94e 	bl	200061bc <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR0, ( clock_speed & 0x01) );
20009f20:	68fb      	ldr	r3, [r7, #12]
20009f22:	681a      	ldr	r2, [r3, #0]
20009f24:	697b      	ldr	r3, [r7, #20]
20009f26:	f003 0301 	and.w	r3, r3, #1
20009f2a:	4610      	mov	r0, r2
20009f2c:	f04f 0100 	mov.w	r1, #0
20009f30:	f04f 0201 	mov.w	r2, #1
20009f34:	f7fc f942 	bl	200061bc <HW_set_8bit_reg_field>

    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS, this_i2c->ser_address);
20009f38:	68fb      	ldr	r3, [r7, #12]
20009f3a:	681b      	ldr	r3, [r3, #0]
20009f3c:	f103 020c 	add.w	r2, r3, #12
20009f40:	68fb      	ldr	r3, [r7, #12]
20009f42:	685b      	ldr	r3, [r3, #4]
20009f44:	4610      	mov	r0, r2
20009f46:	4619      	mov	r1, r3
20009f48:	f7fc f934 	bl	200061b4 <HW_set_8bit_reg>
    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS1, this_i2c->ser_address);
20009f4c:	68fb      	ldr	r3, [r7, #12]
20009f4e:	681b      	ldr	r3, [r3, #0]
20009f50:	f103 021c 	add.w	r2, r3, #28
20009f54:	68fb      	ldr	r3, [r7, #12]
20009f56:	685b      	ldr	r3, [r3, #4]
20009f58:	4610      	mov	r0, r2
20009f5a:	4619      	mov	r1, r3
20009f5c:	f7fc f92a 	bl	200061b4 <HW_set_8bit_reg>
    
    /*
     * Finally safe to enable interrupts.
     */
    HAL_restore_interrupts( saved_psr );
20009f60:	6938      	ldr	r0, [r7, #16]
20009f62:	f001 f93d 	bl	2000b1e0 <HAL_restore_interrupts>
}
20009f66:	f107 0718 	add.w	r7, r7, #24
20009f6a:	46bd      	mov	sp, r7
20009f6c:	bd80      	pop	{r7, pc}
20009f6e:	bf00      	nop

20009f70 <I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
20009f70:	b580      	push	{r7, lr}
20009f72:	b086      	sub	sp, #24
20009f74:	af00      	add	r7, sp, #0
20009f76:	60f8      	str	r0, [r7, #12]
20009f78:	607a      	str	r2, [r7, #4]
20009f7a:	460a      	mov	r2, r1
20009f7c:	72fa      	strb	r2, [r7, #11]
20009f7e:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
20009f80:	f001 f92a 	bl	2000b1d8 <HAL_disable_interrupts>
20009f84:	4603      	mov	r3, r0
20009f86:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
20009f88:	68fb      	ldr	r3, [r7, #12]
20009f8a:	7b1b      	ldrb	r3, [r3, #12]
20009f8c:	2b00      	cmp	r3, #0
20009f8e:	d103      	bne.n	20009f98 <I2C_write+0x28>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
20009f90:	68fb      	ldr	r3, [r7, #12]
20009f92:	f04f 0201 	mov.w	r2, #1
20009f96:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
20009f98:	68fb      	ldr	r3, [r7, #12]
20009f9a:	f04f 0201 	mov.w	r2, #1
20009f9e:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
20009fa2:	7afb      	ldrb	r3, [r7, #11]
20009fa4:	ea4f 0243 	mov.w	r2, r3, lsl #1
20009fa8:	68fb      	ldr	r3, [r7, #12]
20009faa:	609a      	str	r2, [r3, #8]
    this_i2c->dir = WRITE_DIR;
20009fac:	68fb      	ldr	r3, [r7, #12]
20009fae:	f04f 0200 	mov.w	r2, #0
20009fb2:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_buffer = write_buffer;
20009fb4:	68fb      	ldr	r3, [r7, #12]
20009fb6:	687a      	ldr	r2, [r7, #4]
20009fb8:	619a      	str	r2, [r3, #24]
    this_i2c->master_tx_size = write_size;
20009fba:	887a      	ldrh	r2, [r7, #2]
20009fbc:	68fb      	ldr	r3, [r7, #12]
20009fbe:	61da      	str	r2, [r3, #28]
    this_i2c->master_tx_idx = 0u;
20009fc0:	68fb      	ldr	r3, [r7, #12]
20009fc2:	f04f 0200 	mov.w	r2, #0
20009fc6:	621a      	str	r2, [r3, #32]

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
20009fc8:	68fb      	ldr	r3, [r7, #12]
20009fca:	f04f 0201 	mov.w	r2, #1
20009fce:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    this_i2c->options = options;
20009fd2:	68fb      	ldr	r3, [r7, #12]
20009fd4:	f897 2020 	ldrb.w	r2, [r7, #32]
20009fd8:	751a      	strb	r2, [r3, #20]

    if(I2C_IN_PROGRESS == this_i2c->slave_status)
20009fda:	68fb      	ldr	r3, [r7, #12]
20009fdc:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
20009fe0:	b2db      	uxtb	r3, r3
20009fe2:	2b01      	cmp	r3, #1
20009fe4:	d105      	bne.n	20009ff2 <I2C_write+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
20009fe6:	68fb      	ldr	r3, [r7, #12]
20009fe8:	f04f 0201 	mov.w	r2, #1
20009fec:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
20009ff0:	e00a      	b.n	2000a008 <I2C_write+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20009ff2:	68fb      	ldr	r3, [r7, #12]
20009ff4:	681b      	ldr	r3, [r3, #0]
20009ff6:	4618      	mov	r0, r3
20009ff8:	f04f 0105 	mov.w	r1, #5
20009ffc:	f04f 0220 	mov.w	r2, #32
2000a000:	f04f 0301 	mov.w	r3, #1
2000a004:	f7fc f8da 	bl	200061bc <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
2000a008:	68fb      	ldr	r3, [r7, #12]
2000a00a:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
2000a00e:	2b01      	cmp	r3, #1
2000a010:	d10a      	bne.n	2000a028 <I2C_write+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
2000a012:	68fb      	ldr	r3, [r7, #12]
2000a014:	681b      	ldr	r3, [r3, #0]
2000a016:	4618      	mov	r0, r3
2000a018:	f04f 0103 	mov.w	r1, #3
2000a01c:	f04f 0208 	mov.w	r2, #8
2000a020:	f04f 0300 	mov.w	r3, #0
2000a024:	f7fc f8ca 	bl	200061bc <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
2000a028:	68fb      	ldr	r3, [r7, #12]
2000a02a:	681b      	ldr	r3, [r3, #0]
2000a02c:	f103 0304 	add.w	r3, r3, #4
2000a030:	4618      	mov	r0, r3
2000a032:	f7fc f8c1 	bl	200061b8 <HW_get_8bit_reg>
2000a036:	4603      	mov	r3, r0
2000a038:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
2000a03a:	7cfb      	ldrb	r3, [r7, #19]
2000a03c:	b2db      	uxtb	r3, r3
2000a03e:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
2000a040:	68f8      	ldr	r0, [r7, #12]
2000a042:	f000 fec9 	bl	2000add8 <I2C_enable_irq>

    HAL_restore_interrupts( saved_psr );
2000a046:	6978      	ldr	r0, [r7, #20]
2000a048:	f001 f8ca 	bl	2000b1e0 <HAL_restore_interrupts>
}
2000a04c:	f107 0718 	add.w	r7, r7, #24
2000a050:	46bd      	mov	sp, r7
2000a052:	bd80      	pop	{r7, pc}

2000a054 <I2C_read>:
    uint8_t serial_addr,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
2000a054:	b580      	push	{r7, lr}
2000a056:	b086      	sub	sp, #24
2000a058:	af00      	add	r7, sp, #0
2000a05a:	60f8      	str	r0, [r7, #12]
2000a05c:	607a      	str	r2, [r7, #4]
2000a05e:	460a      	mov	r2, r1
2000a060:	72fa      	strb	r2, [r7, #11]
2000a062:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
2000a064:	f001 f8b8 	bl	2000b1d8 <HAL_disable_interrupts>
2000a068:	4603      	mov	r3, r0
2000a06a:	617b      	str	r3, [r7, #20]
    
    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
2000a06c:	68fb      	ldr	r3, [r7, #12]
2000a06e:	7b1b      	ldrb	r3, [r3, #12]
2000a070:	2b00      	cmp	r3, #0
2000a072:	d103      	bne.n	2000a07c <I2C_read+0x28>
    {
      this_i2c->transaction = MASTER_READ_TRANSACTION;
2000a074:	68fb      	ldr	r3, [r7, #12]
2000a076:	f04f 0202 	mov.w	r2, #2
2000a07a:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_READ_TRANSACTION ;
2000a07c:	68fb      	ldr	r3, [r7, #12]
2000a07e:	f04f 0202 	mov.w	r2, #2
2000a082:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
2000a086:	7afb      	ldrb	r3, [r7, #11]
2000a088:	ea4f 0243 	mov.w	r2, r3, lsl #1
2000a08c:	68fb      	ldr	r3, [r7, #12]
2000a08e:	609a      	str	r2, [r3, #8]

    this_i2c->dir = READ_DIR;
2000a090:	68fb      	ldr	r3, [r7, #12]
2000a092:	f04f 0201 	mov.w	r2, #1
2000a096:	625a      	str	r2, [r3, #36]	; 0x24

    this_i2c->master_rx_buffer = read_buffer;
2000a098:	68fb      	ldr	r3, [r7, #12]
2000a09a:	687a      	ldr	r2, [r7, #4]
2000a09c:	629a      	str	r2, [r3, #40]	; 0x28
    this_i2c->master_rx_size = read_size;
2000a09e:	887a      	ldrh	r2, [r7, #2]
2000a0a0:	68fb      	ldr	r3, [r7, #12]
2000a0a2:	62da      	str	r2, [r3, #44]	; 0x2c
    this_i2c->master_rx_idx = 0u;
2000a0a4:	68fb      	ldr	r3, [r7, #12]
2000a0a6:	f04f 0200 	mov.w	r2, #0
2000a0aa:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
2000a0ac:	68fb      	ldr	r3, [r7, #12]
2000a0ae:	f04f 0201 	mov.w	r2, #1
2000a0b2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    this_i2c->options = options;
2000a0b6:	68fb      	ldr	r3, [r7, #12]
2000a0b8:	f897 2020 	ldrb.w	r2, [r7, #32]
2000a0bc:	751a      	strb	r2, [r3, #20]
    
    if(I2C_IN_PROGRESS == this_i2c->slave_status)
2000a0be:	68fb      	ldr	r3, [r7, #12]
2000a0c0:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
2000a0c4:	b2db      	uxtb	r3, r3
2000a0c6:	2b01      	cmp	r3, #1
2000a0c8:	d105      	bne.n	2000a0d6 <I2C_read+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
2000a0ca:	68fb      	ldr	r3, [r7, #12]
2000a0cc:	f04f 0201 	mov.w	r2, #1
2000a0d0:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
2000a0d4:	e00a      	b.n	2000a0ec <I2C_read+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000a0d6:	68fb      	ldr	r3, [r7, #12]
2000a0d8:	681b      	ldr	r3, [r3, #0]
2000a0da:	4618      	mov	r0, r3
2000a0dc:	f04f 0105 	mov.w	r1, #5
2000a0e0:	f04f 0220 	mov.w	r2, #32
2000a0e4:	f04f 0301 	mov.w	r3, #1
2000a0e8:	f7fc f868 	bl	200061bc <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
2000a0ec:	68fb      	ldr	r3, [r7, #12]
2000a0ee:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
2000a0f2:	2b01      	cmp	r3, #1
2000a0f4:	d10a      	bne.n	2000a10c <I2C_read+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
2000a0f6:	68fb      	ldr	r3, [r7, #12]
2000a0f8:	681b      	ldr	r3, [r3, #0]
2000a0fa:	4618      	mov	r0, r3
2000a0fc:	f04f 0103 	mov.w	r1, #3
2000a100:	f04f 0208 	mov.w	r2, #8
2000a104:	f04f 0300 	mov.w	r3, #0
2000a108:	f7fc f858 	bl	200061bc <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
2000a10c:	68fb      	ldr	r3, [r7, #12]
2000a10e:	681b      	ldr	r3, [r3, #0]
2000a110:	f103 0304 	add.w	r3, r3, #4
2000a114:	4618      	mov	r0, r3
2000a116:	f7fc f84f 	bl	200061b8 <HW_get_8bit_reg>
2000a11a:	4603      	mov	r3, r0
2000a11c:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
2000a11e:	7cfb      	ldrb	r3, [r7, #19]
2000a120:	b2db      	uxtb	r3, r3
2000a122:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
2000a124:	68f8      	ldr	r0, [r7, #12]
2000a126:	f000 fe57 	bl	2000add8 <I2C_enable_irq>
    HAL_restore_interrupts( saved_psr );
2000a12a:	6978      	ldr	r0, [r7, #20]
2000a12c:	f001 f858 	bl	2000b1e0 <HAL_restore_interrupts>
}
2000a130:	f107 0718 	add.w	r7, r7, #24
2000a134:	46bd      	mov	sp, r7
2000a136:	bd80      	pop	{r7, pc}

2000a138 <I2C_write_read>:
    uint16_t offset_size,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
2000a138:	b580      	push	{r7, lr}
2000a13a:	b086      	sub	sp, #24
2000a13c:	af00      	add	r7, sp, #0
2000a13e:	60f8      	str	r0, [r7, #12]
2000a140:	607a      	str	r2, [r7, #4]
2000a142:	460a      	mov	r2, r1
2000a144:	72fa      	strb	r2, [r7, #11]
2000a146:	807b      	strh	r3, [r7, #2]
    HAL_ASSERT(offset_size > 0u);
2000a148:	887b      	ldrh	r3, [r7, #2]
2000a14a:	2b00      	cmp	r3, #0
2000a14c:	d100      	bne.n	2000a150 <I2C_write_read+0x18>
2000a14e:	be00      	bkpt	0x0000
    HAL_ASSERT(addr_offset != (uint8_t *)0);
2000a150:	687b      	ldr	r3, [r7, #4]
2000a152:	2b00      	cmp	r3, #0
2000a154:	d100      	bne.n	2000a158 <I2C_write_read+0x20>
2000a156:	be00      	bkpt	0x0000
    HAL_ASSERT(read_size > 0u);
2000a158:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000a15a:	2b00      	cmp	r3, #0
2000a15c:	d100      	bne.n	2000a160 <I2C_write_read+0x28>
2000a15e:	be00      	bkpt	0x0000
    HAL_ASSERT(read_buffer != (uint8_t *)0);
2000a160:	6a3b      	ldr	r3, [r7, #32]
2000a162:	2b00      	cmp	r3, #0
2000a164:	d100      	bne.n	2000a168 <I2C_write_read+0x30>
2000a166:	be00      	bkpt	0x0000
    
    this_i2c->master_status = I2C_FAILED;
2000a168:	68fb      	ldr	r3, [r7, #12]
2000a16a:	f04f 0202 	mov.w	r2, #2
2000a16e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    if((read_size > 0u) && (offset_size > 0u))
2000a172:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2000a174:	2b00      	cmp	r3, #0
2000a176:	d072      	beq.n	2000a25e <I2C_write_read+0x126>
2000a178:	887b      	ldrh	r3, [r7, #2]
2000a17a:	2b00      	cmp	r3, #0
2000a17c:	d06f      	beq.n	2000a25e <I2C_write_read+0x126>
    {
        psr_t saved_psr;
        volatile uint8_t stat_ctrl;

        saved_psr = HAL_disable_interrupts();
2000a17e:	f001 f82b 	bl	2000b1d8 <HAL_disable_interrupts>
2000a182:	4603      	mov	r3, r0
2000a184:	617b      	str	r3, [r7, #20]

        /* Update the transaction only when there is no transaction going on I2C */
        if( this_i2c->transaction == NO_TRANSACTION)
2000a186:	68fb      	ldr	r3, [r7, #12]
2000a188:	7b1b      	ldrb	r3, [r3, #12]
2000a18a:	2b00      	cmp	r3, #0
2000a18c:	d103      	bne.n	2000a196 <I2C_write_read+0x5e>
        {
            this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
2000a18e:	68fb      	ldr	r3, [r7, #12]
2000a190:	f04f 0203 	mov.w	r2, #3
2000a194:	731a      	strb	r2, [r3, #12]
        }

        /* Update the Pending transaction information so that transaction can restarted */
        this_i2c->pending_transaction = MASTER_RANDOM_READ_TRANSACTION ;
2000a196:	68fb      	ldr	r3, [r7, #12]
2000a198:	f04f 0203 	mov.w	r2, #3
2000a19c:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

        /* Update target address */
        this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
2000a1a0:	7afb      	ldrb	r3, [r7, #11]
2000a1a2:	ea4f 0243 	mov.w	r2, r3, lsl #1
2000a1a6:	68fb      	ldr	r3, [r7, #12]
2000a1a8:	609a      	str	r2, [r3, #8]

        this_i2c->dir = WRITE_DIR;
2000a1aa:	68fb      	ldr	r3, [r7, #12]
2000a1ac:	f04f 0200 	mov.w	r2, #0
2000a1b0:	625a      	str	r2, [r3, #36]	; 0x24

        this_i2c->master_tx_buffer = addr_offset;
2000a1b2:	68fb      	ldr	r3, [r7, #12]
2000a1b4:	687a      	ldr	r2, [r7, #4]
2000a1b6:	619a      	str	r2, [r3, #24]
        this_i2c->master_tx_size = offset_size;
2000a1b8:	887a      	ldrh	r2, [r7, #2]
2000a1ba:	68fb      	ldr	r3, [r7, #12]
2000a1bc:	61da      	str	r2, [r3, #28]
        this_i2c->master_tx_idx = 0u;
2000a1be:	68fb      	ldr	r3, [r7, #12]
2000a1c0:	f04f 0200 	mov.w	r2, #0
2000a1c4:	621a      	str	r2, [r3, #32]

        this_i2c->master_rx_buffer = read_buffer;
2000a1c6:	68fb      	ldr	r3, [r7, #12]
2000a1c8:	6a3a      	ldr	r2, [r7, #32]
2000a1ca:	629a      	str	r2, [r3, #40]	; 0x28
        this_i2c->master_rx_size = read_size;
2000a1cc:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000a1ce:	68fb      	ldr	r3, [r7, #12]
2000a1d0:	62da      	str	r2, [r3, #44]	; 0x2c
        this_i2c->master_rx_idx = 0u;
2000a1d2:	68fb      	ldr	r3, [r7, #12]
2000a1d4:	f04f 0200 	mov.w	r2, #0
2000a1d8:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* Set I2C status in progress */
        this_i2c->master_status = I2C_IN_PROGRESS;
2000a1da:	68fb      	ldr	r3, [r7, #12]
2000a1dc:	f04f 0201 	mov.w	r2, #1
2000a1e0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        this_i2c->options = options;
2000a1e4:	68fb      	ldr	r3, [r7, #12]
2000a1e6:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
2000a1ea:	751a      	strb	r2, [r3, #20]
        
        if(I2C_IN_PROGRESS == this_i2c->slave_status)
2000a1ec:	68fb      	ldr	r3, [r7, #12]
2000a1ee:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
2000a1f2:	b2db      	uxtb	r3, r3
2000a1f4:	2b01      	cmp	r3, #1
2000a1f6:	d105      	bne.n	2000a204 <I2C_write_read+0xcc>
        {
            this_i2c->is_transaction_pending = 1u;
2000a1f8:	68fb      	ldr	r3, [r7, #12]
2000a1fa:	f04f 0201 	mov.w	r2, #1
2000a1fe:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
2000a202:	e00a      	b.n	2000a21a <I2C_write_read+0xe2>
        }
        else
        {
            HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000a204:	68fb      	ldr	r3, [r7, #12]
2000a206:	681b      	ldr	r3, [r3, #0]
2000a208:	4618      	mov	r0, r3
2000a20a:	f04f 0105 	mov.w	r1, #5
2000a20e:	f04f 0220 	mov.w	r2, #32
2000a212:	f04f 0301 	mov.w	r3, #1
2000a216:	f7fb ffd1 	bl	200061bc <HW_set_8bit_reg_field>
        /*
         * Clear interrupts if required (depends on repeated starts).
         * Since the Bus is on hold, only then prior status needs to
         * be cleared.
         */
        if ( I2C_HOLD_BUS == this_i2c->bus_status )
2000a21a:	68fb      	ldr	r3, [r7, #12]
2000a21c:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
2000a220:	2b01      	cmp	r3, #1
2000a222:	d10a      	bne.n	2000a23a <I2C_write_read+0x102>
        {
            HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
2000a224:	68fb      	ldr	r3, [r7, #12]
2000a226:	681b      	ldr	r3, [r3, #0]
2000a228:	4618      	mov	r0, r3
2000a22a:	f04f 0103 	mov.w	r1, #3
2000a22e:	f04f 0208 	mov.w	r2, #8
2000a232:	f04f 0300 	mov.w	r3, #0
2000a236:	f7fb ffc1 	bl	200061bc <HW_set_8bit_reg_field>
        }

        stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
2000a23a:	68fb      	ldr	r3, [r7, #12]
2000a23c:	681b      	ldr	r3, [r3, #0]
2000a23e:	f103 0304 	add.w	r3, r3, #4
2000a242:	4618      	mov	r0, r3
2000a244:	f7fb ffb8 	bl	200061b8 <HW_get_8bit_reg>
2000a248:	4603      	mov	r3, r0
2000a24a:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
2000a24c:	7cfb      	ldrb	r3, [r7, #19]
2000a24e:	b2db      	uxtb	r3, r3
2000a250:	74fb      	strb	r3, [r7, #19]
            
        /* Enable the interrupt. ( Re-enable) */
        I2C_enable_irq( this_i2c );
2000a252:	68f8      	ldr	r0, [r7, #12]
2000a254:	f000 fdc0 	bl	2000add8 <I2C_enable_irq>

        HAL_restore_interrupts( saved_psr );
2000a258:	6978      	ldr	r0, [r7, #20]
2000a25a:	f000 ffc1 	bl	2000b1e0 <HAL_restore_interrupts>
    }
}
2000a25e:	f107 0718 	add.w	r7, r7, #24
2000a262:	46bd      	mov	sp, r7
2000a264:	bd80      	pop	{r7, pc}
2000a266:	bf00      	nop

2000a268 <I2C_wait_complete>:
i2c_status_t I2C_wait_complete
(
    i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
2000a268:	b580      	push	{r7, lr}
2000a26a:	b084      	sub	sp, #16
2000a26c:	af00      	add	r7, sp, #0
2000a26e:	6078      	str	r0, [r7, #4]
2000a270:	6039      	str	r1, [r7, #0]
     * Because we have no idea of what CPU we are supposed to be running on
     * we need to guard this write to the timeout value to avoid ISR/user code
     * interaction issues. Checking the status below should be fine as only a
     * single byte should change in that.
     */
    saved_psr = HAL_disable_interrupts();
2000a272:	f000 ffb1 	bl	2000b1d8 <HAL_disable_interrupts>
2000a276:	4603      	mov	r3, r0
2000a278:	60fb      	str	r3, [r7, #12]
    this_i2c->master_timeout_ms = timeout_ms;
2000a27a:	687b      	ldr	r3, [r7, #4]
2000a27c:	683a      	ldr	r2, [r7, #0]
2000a27e:	639a      	str	r2, [r3, #56]	; 0x38
    HAL_restore_interrupts( saved_psr );
2000a280:	68f8      	ldr	r0, [r7, #12]
2000a282:	f000 ffad 	bl	2000b1e0 <HAL_restore_interrupts>

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
2000a286:	687b      	ldr	r3, [r7, #4]
2000a288:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2000a28c:	72fb      	strb	r3, [r7, #11]
    } while(I2C_IN_PROGRESS == i2c_status);
2000a28e:	7afb      	ldrb	r3, [r7, #11]
2000a290:	2b01      	cmp	r3, #1
2000a292:	d0f8      	beq.n	2000a286 <I2C_wait_complete+0x1e>
    return i2c_status;
2000a294:	7afb      	ldrb	r3, [r7, #11]
}
2000a296:	4618      	mov	r0, r3
2000a298:	f107 0710 	add.w	r7, r7, #16
2000a29c:	46bd      	mov	sp, r7
2000a29e:	bd80      	pop	{r7, pc}

2000a2a0 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    i2c_instance_t * this_i2c
)
{
2000a2a0:	b580      	push	{r7, lr}
2000a2a2:	b082      	sub	sp, #8
2000a2a4:	af00      	add	r7, sp, #0
2000a2a6:	6078      	str	r0, [r7, #4]
    /*
     * This function is only called from within the ISR and so does not need
     * guarding on the register access.
     */
    if( 0 != this_i2c->is_slave_enabled )
2000a2a8:	687b      	ldr	r3, [r7, #4]
2000a2aa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
2000a2ae:	2b00      	cmp	r3, #0
2000a2b0:	d00a      	beq.n	2000a2c8 <enable_slave_if_required+0x28>
    {
        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
2000a2b2:	687b      	ldr	r3, [r7, #4]
2000a2b4:	681b      	ldr	r3, [r3, #0]
2000a2b6:	4618      	mov	r0, r3
2000a2b8:	f04f 0102 	mov.w	r1, #2
2000a2bc:	f04f 0204 	mov.w	r2, #4
2000a2c0:	f04f 0301 	mov.w	r3, #1
2000a2c4:	f7fb ff7a 	bl	200061bc <HW_set_8bit_reg_field>
    }
}
2000a2c8:	f107 0708 	add.w	r7, r7, #8
2000a2cc:	46bd      	mov	sp, r7
2000a2ce:	bd80      	pop	{r7, pc}

2000a2d0 <I2C_isr>:
 */
void I2C_isr
(
    i2c_instance_t * this_i2c
)
{
2000a2d0:	b5b0      	push	{r4, r5, r7, lr}
2000a2d2:	b084      	sub	sp, #16
2000a2d4:	af00      	add	r7, sp, #0
2000a2d6:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
2000a2d8:	f04f 0301 	mov.w	r3, #1
2000a2dc:	73bb      	strb	r3, [r7, #14]

    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
2000a2de:	687b      	ldr	r3, [r7, #4]
2000a2e0:	681b      	ldr	r3, [r3, #0]
2000a2e2:	f103 0304 	add.w	r3, r3, #4
2000a2e6:	4618      	mov	r0, r3
2000a2e8:	f7fb ff66 	bl	200061b8 <HW_get_8bit_reg>
2000a2ec:	4603      	mov	r3, r0
2000a2ee:	72fb      	strb	r3, [r7, #11]
    
    switch( status )
2000a2f0:	7afb      	ldrb	r3, [r7, #11]
2000a2f2:	b2db      	uxtb	r3, r3
2000a2f4:	f1a3 0308 	sub.w	r3, r3, #8
2000a2f8:	2bd8      	cmp	r3, #216	; 0xd8
2000a2fa:	f200 84e3 	bhi.w	2000acc4 <I2C_isr+0x9f4>
2000a2fe:	a201      	add	r2, pc, #4	; (adr r2, 2000a304 <I2C_isr+0x34>)
2000a300:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000a304:	2000a669 	.word	0x2000a669
2000a308:	2000acc5 	.word	0x2000acc5
2000a30c:	2000acc5 	.word	0x2000acc5
2000a310:	2000acc5 	.word	0x2000acc5
2000a314:	2000acc5 	.word	0x2000acc5
2000a318:	2000acc5 	.word	0x2000acc5
2000a31c:	2000acc5 	.word	0x2000acc5
2000a320:	2000acc5 	.word	0x2000acc5
2000a324:	2000a669 	.word	0x2000a669
2000a328:	2000acc5 	.word	0x2000acc5
2000a32c:	2000acc5 	.word	0x2000acc5
2000a330:	2000acc5 	.word	0x2000acc5
2000a334:	2000acc5 	.word	0x2000acc5
2000a338:	2000acc5 	.word	0x2000acc5
2000a33c:	2000acc5 	.word	0x2000acc5
2000a340:	2000acc5 	.word	0x2000acc5
2000a344:	2000a73f 	.word	0x2000a73f
2000a348:	2000acc5 	.word	0x2000acc5
2000a34c:	2000acc5 	.word	0x2000acc5
2000a350:	2000acc5 	.word	0x2000acc5
2000a354:	2000acc5 	.word	0x2000acc5
2000a358:	2000acc5 	.word	0x2000acc5
2000a35c:	2000acc5 	.word	0x2000acc5
2000a360:	2000acc5 	.word	0x2000acc5
2000a364:	2000a70f 	.word	0x2000a70f
2000a368:	2000acc5 	.word	0x2000acc5
2000a36c:	2000acc5 	.word	0x2000acc5
2000a370:	2000acc5 	.word	0x2000acc5
2000a374:	2000acc5 	.word	0x2000acc5
2000a378:	2000acc5 	.word	0x2000acc5
2000a37c:	2000acc5 	.word	0x2000acc5
2000a380:	2000acc5 	.word	0x2000acc5
2000a384:	2000a73f 	.word	0x2000a73f
2000a388:	2000acc5 	.word	0x2000acc5
2000a38c:	2000acc5 	.word	0x2000acc5
2000a390:	2000acc5 	.word	0x2000acc5
2000a394:	2000acc5 	.word	0x2000acc5
2000a398:	2000acc5 	.word	0x2000acc5
2000a39c:	2000acc5 	.word	0x2000acc5
2000a3a0:	2000acc5 	.word	0x2000acc5
2000a3a4:	2000a7ef 	.word	0x2000a7ef
2000a3a8:	2000acc5 	.word	0x2000acc5
2000a3ac:	2000acc5 	.word	0x2000acc5
2000a3b0:	2000acc5 	.word	0x2000acc5
2000a3b4:	2000acc5 	.word	0x2000acc5
2000a3b8:	2000acc5 	.word	0x2000acc5
2000a3bc:	2000acc5 	.word	0x2000acc5
2000a3c0:	2000acc5 	.word	0x2000acc5
2000a3c4:	2000a6f7 	.word	0x2000a6f7
2000a3c8:	2000acc5 	.word	0x2000acc5
2000a3cc:	2000acc5 	.word	0x2000acc5
2000a3d0:	2000acc5 	.word	0x2000acc5
2000a3d4:	2000acc5 	.word	0x2000acc5
2000a3d8:	2000acc5 	.word	0x2000acc5
2000a3dc:	2000acc5 	.word	0x2000acc5
2000a3e0:	2000acc5 	.word	0x2000acc5
2000a3e4:	2000a81f 	.word	0x2000a81f
2000a3e8:	2000acc5 	.word	0x2000acc5
2000a3ec:	2000acc5 	.word	0x2000acc5
2000a3f0:	2000acc5 	.word	0x2000acc5
2000a3f4:	2000acc5 	.word	0x2000acc5
2000a3f8:	2000acc5 	.word	0x2000acc5
2000a3fc:	2000acc5 	.word	0x2000acc5
2000a400:	2000acc5 	.word	0x2000acc5
2000a404:	2000a89f 	.word	0x2000a89f
2000a408:	2000acc5 	.word	0x2000acc5
2000a40c:	2000acc5 	.word	0x2000acc5
2000a410:	2000acc5 	.word	0x2000acc5
2000a414:	2000acc5 	.word	0x2000acc5
2000a418:	2000acc5 	.word	0x2000acc5
2000a41c:	2000acc5 	.word	0x2000acc5
2000a420:	2000acc5 	.word	0x2000acc5
2000a424:	2000a8cf 	.word	0x2000a8cf
2000a428:	2000acc5 	.word	0x2000acc5
2000a42c:	2000acc5 	.word	0x2000acc5
2000a430:	2000acc5 	.word	0x2000acc5
2000a434:	2000acc5 	.word	0x2000acc5
2000a438:	2000acc5 	.word	0x2000acc5
2000a43c:	2000acc5 	.word	0x2000acc5
2000a440:	2000acc5 	.word	0x2000acc5
2000a444:	2000a91f 	.word	0x2000a91f
2000a448:	2000acc5 	.word	0x2000acc5
2000a44c:	2000acc5 	.word	0x2000acc5
2000a450:	2000acc5 	.word	0x2000acc5
2000a454:	2000acc5 	.word	0x2000acc5
2000a458:	2000acc5 	.word	0x2000acc5
2000a45c:	2000acc5 	.word	0x2000acc5
2000a460:	2000acc5 	.word	0x2000acc5
2000a464:	2000a9e9 	.word	0x2000a9e9
2000a468:	2000acc5 	.word	0x2000acc5
2000a46c:	2000acc5 	.word	0x2000acc5
2000a470:	2000acc5 	.word	0x2000acc5
2000a474:	2000acc5 	.word	0x2000acc5
2000a478:	2000acc5 	.word	0x2000acc5
2000a47c:	2000acc5 	.word	0x2000acc5
2000a480:	2000acc5 	.word	0x2000acc5
2000a484:	2000a9df 	.word	0x2000a9df
2000a488:	2000acc5 	.word	0x2000acc5
2000a48c:	2000acc5 	.word	0x2000acc5
2000a490:	2000acc5 	.word	0x2000acc5
2000a494:	2000acc5 	.word	0x2000acc5
2000a498:	2000acc5 	.word	0x2000acc5
2000a49c:	2000acc5 	.word	0x2000acc5
2000a4a0:	2000acc5 	.word	0x2000acc5
2000a4a4:	2000a9e9 	.word	0x2000a9e9
2000a4a8:	2000acc5 	.word	0x2000acc5
2000a4ac:	2000acc5 	.word	0x2000acc5
2000a4b0:	2000acc5 	.word	0x2000acc5
2000a4b4:	2000acc5 	.word	0x2000acc5
2000a4b8:	2000acc5 	.word	0x2000acc5
2000a4bc:	2000acc5 	.word	0x2000acc5
2000a4c0:	2000acc5 	.word	0x2000acc5
2000a4c4:	2000a9df 	.word	0x2000a9df
2000a4c8:	2000acc5 	.word	0x2000acc5
2000a4cc:	2000acc5 	.word	0x2000acc5
2000a4d0:	2000acc5 	.word	0x2000acc5
2000a4d4:	2000acc5 	.word	0x2000acc5
2000a4d8:	2000acc5 	.word	0x2000acc5
2000a4dc:	2000acc5 	.word	0x2000acc5
2000a4e0:	2000acc5 	.word	0x2000acc5
2000a4e4:	2000aa45 	.word	0x2000aa45
2000a4e8:	2000acc5 	.word	0x2000acc5
2000a4ec:	2000acc5 	.word	0x2000acc5
2000a4f0:	2000acc5 	.word	0x2000acc5
2000a4f4:	2000acc5 	.word	0x2000acc5
2000a4f8:	2000acc5 	.word	0x2000acc5
2000a4fc:	2000acc5 	.word	0x2000acc5
2000a500:	2000acc5 	.word	0x2000acc5
2000a504:	2000a993 	.word	0x2000a993
2000a508:	2000acc5 	.word	0x2000acc5
2000a50c:	2000acc5 	.word	0x2000acc5
2000a510:	2000acc5 	.word	0x2000acc5
2000a514:	2000acc5 	.word	0x2000acc5
2000a518:	2000acc5 	.word	0x2000acc5
2000a51c:	2000acc5 	.word	0x2000acc5
2000a520:	2000acc5 	.word	0x2000acc5
2000a524:	2000aa45 	.word	0x2000aa45
2000a528:	2000acc5 	.word	0x2000acc5
2000a52c:	2000acc5 	.word	0x2000acc5
2000a530:	2000acc5 	.word	0x2000acc5
2000a534:	2000acc5 	.word	0x2000acc5
2000a538:	2000acc5 	.word	0x2000acc5
2000a53c:	2000acc5 	.word	0x2000acc5
2000a540:	2000acc5 	.word	0x2000acc5
2000a544:	2000a993 	.word	0x2000a993
2000a548:	2000acc5 	.word	0x2000acc5
2000a54c:	2000acc5 	.word	0x2000acc5
2000a550:	2000acc5 	.word	0x2000acc5
2000a554:	2000acc5 	.word	0x2000acc5
2000a558:	2000acc5 	.word	0x2000acc5
2000a55c:	2000acc5 	.word	0x2000acc5
2000a560:	2000acc5 	.word	0x2000acc5
2000a564:	2000aab7 	.word	0x2000aab7
2000a568:	2000acc5 	.word	0x2000acc5
2000a56c:	2000acc5 	.word	0x2000acc5
2000a570:	2000acc5 	.word	0x2000acc5
2000a574:	2000acc5 	.word	0x2000acc5
2000a578:	2000acc5 	.word	0x2000acc5
2000a57c:	2000acc5 	.word	0x2000acc5
2000a580:	2000acc5 	.word	0x2000acc5
2000a584:	2000aba9 	.word	0x2000aba9
2000a588:	2000acc5 	.word	0x2000acc5
2000a58c:	2000acc5 	.word	0x2000acc5
2000a590:	2000acc5 	.word	0x2000acc5
2000a594:	2000acc5 	.word	0x2000acc5
2000a598:	2000acc5 	.word	0x2000acc5
2000a59c:	2000acc5 	.word	0x2000acc5
2000a5a0:	2000acc5 	.word	0x2000acc5
2000a5a4:	2000aba9 	.word	0x2000aba9
2000a5a8:	2000acc5 	.word	0x2000acc5
2000a5ac:	2000acc5 	.word	0x2000acc5
2000a5b0:	2000acc5 	.word	0x2000acc5
2000a5b4:	2000acc5 	.word	0x2000acc5
2000a5b8:	2000acc5 	.word	0x2000acc5
2000a5bc:	2000acc5 	.word	0x2000acc5
2000a5c0:	2000acc5 	.word	0x2000acc5
2000a5c4:	2000aba9 	.word	0x2000aba9
2000a5c8:	2000acc5 	.word	0x2000acc5
2000a5cc:	2000acc5 	.word	0x2000acc5
2000a5d0:	2000acc5 	.word	0x2000acc5
2000a5d4:	2000acc5 	.word	0x2000acc5
2000a5d8:	2000acc5 	.word	0x2000acc5
2000a5dc:	2000acc5 	.word	0x2000acc5
2000a5e0:	2000acc5 	.word	0x2000acc5
2000a5e4:	2000ac73 	.word	0x2000ac73
2000a5e8:	2000acc5 	.word	0x2000acc5
2000a5ec:	2000acc5 	.word	0x2000acc5
2000a5f0:	2000acc5 	.word	0x2000acc5
2000a5f4:	2000acc5 	.word	0x2000acc5
2000a5f8:	2000acc5 	.word	0x2000acc5
2000a5fc:	2000acc5 	.word	0x2000acc5
2000a600:	2000acc5 	.word	0x2000acc5
2000a604:	2000ac73 	.word	0x2000ac73
2000a608:	2000acc5 	.word	0x2000acc5
2000a60c:	2000acc5 	.word	0x2000acc5
2000a610:	2000acc5 	.word	0x2000acc5
2000a614:	2000acc5 	.word	0x2000acc5
2000a618:	2000acc5 	.word	0x2000acc5
2000a61c:	2000acc5 	.word	0x2000acc5
2000a620:	2000acc5 	.word	0x2000acc5
2000a624:	2000acc5 	.word	0x2000acc5
2000a628:	2000acc5 	.word	0x2000acc5
2000a62c:	2000acc5 	.word	0x2000acc5
2000a630:	2000acc5 	.word	0x2000acc5
2000a634:	2000acc5 	.word	0x2000acc5
2000a638:	2000acc5 	.word	0x2000acc5
2000a63c:	2000acc5 	.word	0x2000acc5
2000a640:	2000acc5 	.word	0x2000acc5
2000a644:	2000ab7b 	.word	0x2000ab7b
2000a648:	2000acc5 	.word	0x2000acc5
2000a64c:	2000acc5 	.word	0x2000acc5
2000a650:	2000acc5 	.word	0x2000acc5
2000a654:	2000acc5 	.word	0x2000acc5
2000a658:	2000acc5 	.word	0x2000acc5
2000a65c:	2000acc5 	.word	0x2000acc5
2000a660:	2000acc5 	.word	0x2000acc5
2000a664:	2000ad19 	.word	0x2000ad19
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            HAL_set_8bit_reg_field( this_i2c->base_address, STA, 0x00u);
2000a668:	687b      	ldr	r3, [r7, #4]
2000a66a:	681b      	ldr	r3, [r3, #0]
2000a66c:	4618      	mov	r0, r3
2000a66e:	f04f 0105 	mov.w	r1, #5
2000a672:	f04f 0220 	mov.w	r2, #32
2000a676:	f04f 0300 	mov.w	r3, #0
2000a67a:	f7fb fd9f 	bl	200061bc <HW_set_8bit_reg_field>
            HAL_set_8bit_reg( this_i2c->base_address, DATA, this_i2c->target_addr); /* write call address */
2000a67e:	687b      	ldr	r3, [r7, #4]
2000a680:	681b      	ldr	r3, [r3, #0]
2000a682:	f103 0208 	add.w	r2, r3, #8
2000a686:	687b      	ldr	r3, [r7, #4]
2000a688:	689b      	ldr	r3, [r3, #8]
2000a68a:	4610      	mov	r0, r2
2000a68c:	4619      	mov	r1, r3
2000a68e:	f7fb fd91 	bl	200061b4 <HW_set_8bit_reg>
            HAL_set_8bit_reg_field( this_i2c->base_address, DIR, this_i2c->dir); /* set direction bit */
2000a692:	687b      	ldr	r3, [r7, #4]
2000a694:	681b      	ldr	r3, [r3, #0]
2000a696:	f103 0208 	add.w	r2, r3, #8
2000a69a:	687b      	ldr	r3, [r7, #4]
2000a69c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000a69e:	4610      	mov	r0, r2
2000a6a0:	f04f 0100 	mov.w	r1, #0
2000a6a4:	f04f 0201 	mov.w	r2, #1
2000a6a8:	f7fb fd88 	bl	200061bc <HW_set_8bit_reg_field>
            if(this_i2c->dir == WRITE_DIR)
2000a6ac:	687b      	ldr	r3, [r7, #4]
2000a6ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000a6b0:	2b00      	cmp	r3, #0
2000a6b2:	d104      	bne.n	2000a6be <I2C_isr+0x3ee>
            {
                 this_i2c->master_tx_idx = 0u;
2000a6b4:	687b      	ldr	r3, [r7, #4]
2000a6b6:	f04f 0200 	mov.w	r2, #0
2000a6ba:	621a      	str	r2, [r3, #32]
2000a6bc:	e003      	b.n	2000a6c6 <I2C_isr+0x3f6>
            }
            else
            {
                 this_i2c->master_rx_idx = 0u;
2000a6be:	687b      	ldr	r3, [r7, #4]
2000a6c0:	f04f 0200 	mov.w	r2, #0
2000a6c4:	631a      	str	r2, [r3, #48]	; 0x30
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
2000a6c6:	687b      	ldr	r3, [r7, #4]
2000a6c8:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
2000a6cc:	2b00      	cmp	r3, #0
2000a6ce:	d004      	beq.n	2000a6da <I2C_isr+0x40a>
            {
                this_i2c->is_transaction_pending = 0u;
2000a6d0:	687b      	ldr	r3, [r7, #4]
2000a6d2:	f04f 0200 	mov.w	r2, #0
2000a6d6:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
2000a6da:	687b      	ldr	r3, [r7, #4]
2000a6dc:	7b1a      	ldrb	r2, [r3, #12]
2000a6de:	687b      	ldr	r3, [r7, #4]
2000a6e0:	f893 306a 	ldrb.w	r3, [r3, #106]	; 0x6a
2000a6e4:	429a      	cmp	r2, r3
2000a6e6:	f000 8319 	beq.w	2000ad1c <I2C_isr+0xa4c>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
2000a6ea:	687b      	ldr	r3, [r7, #4]
2000a6ec:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
2000a6f0:	687b      	ldr	r3, [r7, #4]
2000a6f2:	731a      	strb	r2, [r3, #12]
            }
            break;
2000a6f4:	e31b      	b.n	2000ad2e <I2C_isr+0xa5e>
            
        case ST_LOST_ARB:
              /* Set start bit.  Let's keep trying!  Don't give up! */
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000a6f6:	687b      	ldr	r3, [r7, #4]
2000a6f8:	681b      	ldr	r3, [r3, #0]
2000a6fa:	4618      	mov	r0, r3
2000a6fc:	f04f 0105 	mov.w	r1, #5
2000a700:	f04f 0220 	mov.w	r2, #32
2000a704:	f04f 0301 	mov.w	r3, #1
2000a708:	f7fb fd58 	bl	200061bc <HW_set_8bit_reg_field>
              break;
2000a70c:	e30f      	b.n	2000ad2e <I2C_isr+0xa5e>
              break;

        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
2000a70e:	687b      	ldr	r3, [r7, #4]
2000a710:	681b      	ldr	r3, [r3, #0]
2000a712:	4618      	mov	r0, r3
2000a714:	f04f 0104 	mov.w	r1, #4
2000a718:	f04f 0210 	mov.w	r2, #16
2000a71c:	f04f 0301 	mov.w	r3, #1
2000a720:	f7fb fd4c 	bl	200061bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
2000a724:	687b      	ldr	r3, [r7, #4]
2000a726:	f04f 0202 	mov.w	r2, #2
2000a72a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            this_i2c->transaction = NO_TRANSACTION;
2000a72e:	687b      	ldr	r3, [r7, #4]
2000a730:	f04f 0200 	mov.w	r2, #0
2000a734:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
2000a736:	6878      	ldr	r0, [r7, #4]
2000a738:	f7ff fdb2 	bl	2000a2a0 <enable_slave_if_required>
            break;
2000a73c:	e2f7      	b.n	2000ad2e <I2C_isr+0xa5e>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
2000a73e:	687b      	ldr	r3, [r7, #4]
2000a740:	6a1a      	ldr	r2, [r3, #32]
2000a742:	687b      	ldr	r3, [r7, #4]
2000a744:	69db      	ldr	r3, [r3, #28]
2000a746:	429a      	cmp	r2, r3
2000a748:	d212      	bcs.n	2000a770 <I2C_isr+0x4a0>
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
2000a74a:	687b      	ldr	r3, [r7, #4]
2000a74c:	681b      	ldr	r3, [r3, #0]
2000a74e:	f103 0108 	add.w	r1, r3, #8
2000a752:	687b      	ldr	r3, [r7, #4]
2000a754:	699a      	ldr	r2, [r3, #24]
2000a756:	687b      	ldr	r3, [r7, #4]
2000a758:	6a1b      	ldr	r3, [r3, #32]
2000a75a:	441a      	add	r2, r3
2000a75c:	7812      	ldrb	r2, [r2, #0]
2000a75e:	f103 0001 	add.w	r0, r3, #1
2000a762:	687b      	ldr	r3, [r7, #4]
2000a764:	6218      	str	r0, [r3, #32]
2000a766:	4608      	mov	r0, r1
2000a768:	4611      	mov	r1, r2
2000a76a:	f7fb fd23 	bl	200061b4 <HW_set_8bit_reg>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
2000a76e:	e2de      	b.n	2000ad2e <I2C_isr+0xa5e>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
2000a770:	687b      	ldr	r3, [r7, #4]
2000a772:	7b1b      	ldrb	r3, [r3, #12]
2000a774:	2b03      	cmp	r3, #3
2000a776:	d10f      	bne.n	2000a798 <I2C_isr+0x4c8>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
2000a778:	687b      	ldr	r3, [r7, #4]
2000a77a:	f04f 0201 	mov.w	r2, #1
2000a77e:	625a      	str	r2, [r3, #36]	; 0x24
                 HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000a780:	687b      	ldr	r3, [r7, #4]
2000a782:	681b      	ldr	r3, [r3, #0]
2000a784:	4618      	mov	r0, r3
2000a786:	f04f 0105 	mov.w	r1, #5
2000a78a:	f04f 0220 	mov.w	r2, #32
2000a78e:	f04f 0301 	mov.w	r3, #1
2000a792:	f7fb fd13 	bl	200061bc <HW_set_8bit_reg_field>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
2000a796:	e2ca      	b.n	2000ad2e <I2C_isr+0xa5e>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
2000a798:	687b      	ldr	r3, [r7, #4]
2000a79a:	f04f 0200 	mov.w	r2, #0
2000a79e:	731a      	strb	r2, [r3, #12]
                hold_bus = this_i2c->options & I2C_HOLD_BUS;
2000a7a0:	687b      	ldr	r3, [r7, #4]
2000a7a2:	7d1b      	ldrb	r3, [r3, #20]
2000a7a4:	f003 0301 	and.w	r3, r3, #1
2000a7a8:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
2000a7aa:	687b      	ldr	r3, [r7, #4]
2000a7ac:	7b7a      	ldrb	r2, [r7, #13]
2000a7ae:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                if ( hold_bus == 0u )
2000a7b2:	7b7b      	ldrb	r3, [r7, #13]
2000a7b4:	2b00      	cmp	r3, #0
2000a7b6:	d10e      	bne.n	2000a7d6 <I2C_isr+0x506>
                { 
                    HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
2000a7b8:	687b      	ldr	r3, [r7, #4]
2000a7ba:	681b      	ldr	r3, [r3, #0]
2000a7bc:	4618      	mov	r0, r3
2000a7be:	f04f 0104 	mov.w	r1, #4
2000a7c2:	f04f 0210 	mov.w	r2, #16
2000a7c6:	f04f 0301 	mov.w	r3, #1
2000a7ca:	f7fb fcf7 	bl	200061bc <HW_set_8bit_reg_field>
                    enable_slave_if_required(this_i2c);
2000a7ce:	6878      	ldr	r0, [r7, #4]
2000a7d0:	f7ff fd66 	bl	2000a2a0 <enable_slave_if_required>
2000a7d4:	e005      	b.n	2000a7e2 <I2C_isr+0x512>
                }
                else
                {
                    I2C_disable_irq( this_i2c );
2000a7d6:	6878      	ldr	r0, [r7, #4]
2000a7d8:	f000 fb48 	bl	2000ae6c <I2C_disable_irq>
                    clear_irq = 0u;
2000a7dc:	f04f 0300 	mov.w	r3, #0
2000a7e0:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = I2C_SUCCESS;
2000a7e2:	687b      	ldr	r3, [r7, #4]
2000a7e4:	f04f 0200 	mov.w	r2, #0
2000a7e8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }
            break;
2000a7ec:	e29f      	b.n	2000ad2e <I2C_isr+0xa5e>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);/* xmt stop condition */
2000a7ee:	687b      	ldr	r3, [r7, #4]
2000a7f0:	681b      	ldr	r3, [r3, #0]
2000a7f2:	4618      	mov	r0, r3
2000a7f4:	f04f 0104 	mov.w	r1, #4
2000a7f8:	f04f 0210 	mov.w	r2, #16
2000a7fc:	f04f 0301 	mov.w	r3, #1
2000a800:	f7fb fcdc 	bl	200061bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
2000a804:	687b      	ldr	r3, [r7, #4]
2000a806:	f04f 0202 	mov.w	r2, #2
2000a80a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000a80e:	687b      	ldr	r3, [r7, #4]
2000a810:	f04f 0200 	mov.w	r2, #0
2000a814:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
2000a816:	6878      	ldr	r0, [r7, #4]
2000a818:	f7ff fd42 	bl	2000a2a0 <enable_slave_if_required>
            break;
2000a81c:	e287      	b.n	2000ad2e <I2C_isr+0xa5e>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
2000a81e:	687b      	ldr	r3, [r7, #4]
2000a820:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a822:	2b01      	cmp	r3, #1
2000a824:	d90b      	bls.n	2000a83e <I2C_isr+0x56e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
2000a826:	687b      	ldr	r3, [r7, #4]
2000a828:	681b      	ldr	r3, [r3, #0]
2000a82a:	4618      	mov	r0, r3
2000a82c:	f04f 0102 	mov.w	r1, #2
2000a830:	f04f 0204 	mov.w	r2, #4
2000a834:	f04f 0301 	mov.w	r3, #1
2000a838:	f7fb fcc0 	bl	200061bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
2000a83c:	e277      	b.n	2000ad2e <I2C_isr+0xa5e>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
            }
            else if(1u == this_i2c->master_rx_size)
2000a83e:	687b      	ldr	r3, [r7, #4]
2000a840:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a842:	2b01      	cmp	r3, #1
2000a844:	d10b      	bne.n	2000a85e <I2C_isr+0x58e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
2000a846:	687b      	ldr	r3, [r7, #4]
2000a848:	681b      	ldr	r3, [r3, #0]
2000a84a:	4618      	mov	r0, r3
2000a84c:	f04f 0102 	mov.w	r1, #2
2000a850:	f04f 0204 	mov.w	r2, #4
2000a854:	f04f 0300 	mov.w	r3, #0
2000a858:	f7fb fcb0 	bl	200061bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
2000a85c:	e267      	b.n	2000ad2e <I2C_isr+0xa5e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
2000a85e:	687b      	ldr	r3, [r7, #4]
2000a860:	681b      	ldr	r3, [r3, #0]
2000a862:	4618      	mov	r0, r3
2000a864:	f04f 0102 	mov.w	r1, #2
2000a868:	f04f 0204 	mov.w	r2, #4
2000a86c:	f04f 0301 	mov.w	r3, #1
2000a870:	f7fb fca4 	bl	200061bc <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
2000a874:	687b      	ldr	r3, [r7, #4]
2000a876:	681b      	ldr	r3, [r3, #0]
2000a878:	4618      	mov	r0, r3
2000a87a:	f04f 0104 	mov.w	r1, #4
2000a87e:	f04f 0210 	mov.w	r2, #16
2000a882:	f04f 0301 	mov.w	r3, #1
2000a886:	f7fb fc99 	bl	200061bc <HW_set_8bit_reg_field>
                this_i2c->master_status = I2C_SUCCESS;
2000a88a:	687b      	ldr	r3, [r7, #4]
2000a88c:	f04f 0200 	mov.w	r2, #0
2000a890:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                this_i2c->transaction = NO_TRANSACTION;
2000a894:	687b      	ldr	r3, [r7, #4]
2000a896:	f04f 0200 	mov.w	r2, #0
2000a89a:	731a      	strb	r2, [r3, #12]
            }
            break;
2000a89c:	e247      	b.n	2000ad2e <I2C_isr+0xa5e>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
2000a89e:	687b      	ldr	r3, [r7, #4]
2000a8a0:	681b      	ldr	r3, [r3, #0]
2000a8a2:	4618      	mov	r0, r3
2000a8a4:	f04f 0104 	mov.w	r1, #4
2000a8a8:	f04f 0210 	mov.w	r2, #16
2000a8ac:	f04f 0301 	mov.w	r3, #1
2000a8b0:	f7fb fc84 	bl	200061bc <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
2000a8b4:	687b      	ldr	r3, [r7, #4]
2000a8b6:	f04f 0202 	mov.w	r2, #2
2000a8ba:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000a8be:	687b      	ldr	r3, [r7, #4]
2000a8c0:	f04f 0200 	mov.w	r2, #0
2000a8c4:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
2000a8c6:	6878      	ldr	r0, [r7, #4]
2000a8c8:	f7ff fcea 	bl	2000a2a0 <enable_slave_if_required>
            break;
2000a8cc:	e22f      	b.n	2000ad2e <I2C_isr+0xa5e>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
2000a8ce:	687b      	ldr	r3, [r7, #4]
2000a8d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000a8d2:	687a      	ldr	r2, [r7, #4]
2000a8d4:	6b14      	ldr	r4, [r2, #48]	; 0x30
2000a8d6:	eb03 0504 	add.w	r5, r3, r4
2000a8da:	687b      	ldr	r3, [r7, #4]
2000a8dc:	681b      	ldr	r3, [r3, #0]
2000a8de:	f103 0308 	add.w	r3, r3, #8
2000a8e2:	4618      	mov	r0, r3
2000a8e4:	f7fb fc68 	bl	200061b8 <HW_get_8bit_reg>
2000a8e8:	4603      	mov	r3, r0
2000a8ea:	702b      	strb	r3, [r5, #0]
2000a8ec:	f104 0201 	add.w	r2, r4, #1
2000a8f0:	687b      	ldr	r3, [r7, #4]
2000a8f2:	631a      	str	r2, [r3, #48]	; 0x30
            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
2000a8f4:	687b      	ldr	r3, [r7, #4]
2000a8f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
2000a8f8:	687b      	ldr	r3, [r7, #4]
2000a8fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a8fc:	f103 33ff 	add.w	r3, r3, #4294967295
2000a900:	429a      	cmp	r2, r3
2000a902:	f0c0 820d 	bcc.w	2000ad20 <I2C_isr+0xa50>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
2000a906:	687b      	ldr	r3, [r7, #4]
2000a908:	681b      	ldr	r3, [r3, #0]
2000a90a:	4618      	mov	r0, r3
2000a90c:	f04f 0102 	mov.w	r1, #2
2000a910:	f04f 0204 	mov.w	r2, #4
2000a914:	f04f 0300 	mov.w	r3, #0
2000a918:	f7fb fc50 	bl	200061bc <HW_set_8bit_reg_field>
            }
            break;
2000a91c:	e207      	b.n	2000ad2e <I2C_isr+0xa5e>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
2000a91e:	687b      	ldr	r3, [r7, #4]
2000a920:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000a922:	687b      	ldr	r3, [r7, #4]
2000a924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000a926:	eb02 0403 	add.w	r4, r2, r3
2000a92a:	687b      	ldr	r3, [r7, #4]
2000a92c:	681b      	ldr	r3, [r3, #0]
2000a92e:	f103 0308 	add.w	r3, r3, #8
2000a932:	4618      	mov	r0, r3
2000a934:	f7fb fc40 	bl	200061b8 <HW_get_8bit_reg>
2000a938:	4603      	mov	r3, r0
2000a93a:	7023      	strb	r3, [r4, #0]
          
            hold_bus = this_i2c->options & I2C_HOLD_BUS; 
2000a93c:	687b      	ldr	r3, [r7, #4]
2000a93e:	7d1b      	ldrb	r3, [r3, #20]
2000a940:	f003 0301 	and.w	r3, r3, #1
2000a944:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
2000a946:	687b      	ldr	r3, [r7, #4]
2000a948:	7b7a      	ldrb	r2, [r7, #13]
2000a94a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
            if ( hold_bus == 0u )
2000a94e:	7b7b      	ldrb	r3, [r7, #13]
2000a950:	2b00      	cmp	r3, #0
2000a952:	d10e      	bne.n	2000a972 <I2C_isr+0x6a2>
            { 
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
2000a954:	687b      	ldr	r3, [r7, #4]
2000a956:	681b      	ldr	r3, [r3, #0]
2000a958:	4618      	mov	r0, r3
2000a95a:	f04f 0104 	mov.w	r1, #4
2000a95e:	f04f 0210 	mov.w	r2, #16
2000a962:	f04f 0301 	mov.w	r3, #1
2000a966:	f7fb fc29 	bl	200061bc <HW_set_8bit_reg_field>

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
2000a96a:	6878      	ldr	r0, [r7, #4]
2000a96c:	f7ff fc98 	bl	2000a2a0 <enable_slave_if_required>
2000a970:	e005      	b.n	2000a97e <I2C_isr+0x6ae>
            }
            else
            {
                I2C_disable_irq( this_i2c );
2000a972:	6878      	ldr	r0, [r7, #4]
2000a974:	f000 fa7a 	bl	2000ae6c <I2C_disable_irq>
                clear_irq = 0u;
2000a978:	f04f 0300 	mov.w	r3, #0
2000a97c:	73bb      	strb	r3, [r7, #14]
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000a97e:	687b      	ldr	r3, [r7, #4]
2000a980:	f04f 0200 	mov.w	r2, #0
2000a984:	731a      	strb	r2, [r3, #12]
            this_i2c->master_status = I2C_SUCCESS;
2000a986:	687b      	ldr	r3, [r7, #4]
2000a988:	f04f 0200 	mov.w	r2, #0
2000a98c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            break;
2000a990:	e1cd      	b.n	2000ad2e <I2C_isr+0xa5e>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
2000a992:	687b      	ldr	r3, [r7, #4]
2000a994:	681b      	ldr	r3, [r3, #0]
2000a996:	4618      	mov	r0, r3
2000a998:	f04f 0102 	mov.w	r1, #2
2000a99c:	f04f 0204 	mov.w	r2, #4
2000a9a0:	f04f 0301 	mov.w	r3, #1
2000a9a4:	f7fb fc0a 	bl	200061bc <HW_set_8bit_reg_field>

            this_i2c->transaction = NO_TRANSACTION;
2000a9a8:	687b      	ldr	r3, [r7, #4]
2000a9aa:	f04f 0200 	mov.w	r2, #0
2000a9ae:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_status = I2C_SUCCESS;
2000a9b0:	687b      	ldr	r3, [r7, #4]
2000a9b2:	f04f 0200 	mov.w	r2, #0
2000a9b6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000a9ba:	687b      	ldr	r3, [r7, #4]
2000a9bc:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
2000a9c0:	2b00      	cmp	r3, #0
2000a9c2:	f000 81af 	beq.w	2000ad24 <I2C_isr+0xa54>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000a9c6:	687b      	ldr	r3, [r7, #4]
2000a9c8:	681b      	ldr	r3, [r3, #0]
2000a9ca:	4618      	mov	r0, r3
2000a9cc:	f04f 0105 	mov.w	r1, #5
2000a9d0:	f04f 0220 	mov.w	r2, #32
2000a9d4:	f04f 0301 	mov.w	r3, #1
2000a9d8:	f7fb fbf0 	bl	200061bc <HW_set_8bit_reg_field>
            }
            break;
2000a9dc:	e1a7      	b.n	2000ad2e <I2C_isr+0xa5e>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
2000a9de:	687b      	ldr	r3, [r7, #4]
2000a9e0:	f04f 0201 	mov.w	r2, #1
2000a9e4:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */
            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
2000a9e8:	687b      	ldr	r3, [r7, #4]
2000a9ea:	f04f 0204 	mov.w	r2, #4
2000a9ee:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_rx_idx = 0u;
2000a9f0:	687b      	ldr	r3, [r7, #4]
2000a9f2:	f04f 0200 	mov.w	r2, #0
2000a9f6:	651a      	str	r2, [r3, #80]	; 0x50
            this_i2c->random_read_addr = 0u;
2000a9f8:	687b      	ldr	r3, [r7, #4]
2000a9fa:	f04f 0200 	mov.w	r2, #0
2000a9fe:	611a      	str	r2, [r3, #16]
            /*
             * If Start Bit is set clear it, but store that information since it is because of
             * pending transaction
             */
            if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
2000aa00:	687b      	ldr	r3, [r7, #4]
2000aa02:	681b      	ldr	r3, [r3, #0]
2000aa04:	4618      	mov	r0, r3
2000aa06:	f04f 0105 	mov.w	r1, #5
2000aa0a:	f04f 0220 	mov.w	r2, #32
2000aa0e:	f7fb fbe3 	bl	200061d8 <HW_get_8bit_reg_field>
2000aa12:	4603      	mov	r3, r0
2000aa14:	2b00      	cmp	r3, #0
2000aa16:	d00f      	beq.n	2000aa38 <I2C_isr+0x768>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
2000aa18:	687b      	ldr	r3, [r7, #4]
2000aa1a:	681b      	ldr	r3, [r3, #0]
2000aa1c:	4618      	mov	r0, r3
2000aa1e:	f04f 0105 	mov.w	r1, #5
2000aa22:	f04f 0220 	mov.w	r2, #32
2000aa26:	f04f 0300 	mov.w	r3, #0
2000aa2a:	f7fb fbc7 	bl	200061bc <HW_set_8bit_reg_field>
                this_i2c->is_transaction_pending = 1u;
2000aa2e:	687b      	ldr	r3, [r7, #4]
2000aa30:	f04f 0201 	mov.w	r2, #1
2000aa34:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            }
            this_i2c->slave_status = I2C_IN_PROGRESS;
2000aa38:	687b      	ldr	r3, [r7, #4]
2000aa3a:	f04f 0201 	mov.w	r2, #1
2000aa3e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
2000aa42:	e174      	b.n	2000ad2e <I2C_isr+0xa5e>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
2000aa44:	687b      	ldr	r3, [r7, #4]
2000aa46:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000aa48:	2b00      	cmp	r3, #0
2000aa4a:	d021      	beq.n	2000aa90 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
2000aa4c:	687b      	ldr	r3, [r7, #4]
2000aa4e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000aa50:	687b      	ldr	r3, [r7, #4]
2000aa52:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
2000aa54:	429a      	cmp	r2, r3
2000aa56:	d21b      	bcs.n	2000aa90 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = HAL_get_8bit_reg(this_i2c->base_address, DATA);
2000aa58:	687b      	ldr	r3, [r7, #4]
2000aa5a:	681b      	ldr	r3, [r3, #0]
2000aa5c:	f103 0308 	add.w	r3, r3, #8
2000aa60:	4618      	mov	r0, r3
2000aa62:	f7fb fba9 	bl	200061b8 <HW_get_8bit_reg>
2000aa66:	4603      	mov	r3, r0
2000aa68:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
2000aa6a:	687b      	ldr	r3, [r7, #4]
2000aa6c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2000aa6e:	687b      	ldr	r3, [r7, #4]
2000aa70:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000aa72:	441a      	add	r2, r3
2000aa74:	7b39      	ldrb	r1, [r7, #12]
2000aa76:	7011      	strb	r1, [r2, #0]
2000aa78:	f103 0201 	add.w	r2, r3, #1
2000aa7c:	687b      	ldr	r3, [r7, #4]
2000aa7e:	651a      	str	r2, [r3, #80]	; 0x50
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
2000aa80:	687b      	ldr	r3, [r7, #4]
2000aa82:	691b      	ldr	r3, [r3, #16]
2000aa84:	ea4f 2203 	mov.w	r2, r3, lsl #8
2000aa88:	7b3b      	ldrb	r3, [r7, #12]
2000aa8a:	441a      	add	r2, r3
2000aa8c:	687b      	ldr	r3, [r7, #4]
2000aa8e:	611a      	str	r2, [r3, #16]
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
2000aa90:	687b      	ldr	r3, [r7, #4]
2000aa92:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000aa94:	687b      	ldr	r3, [r7, #4]
2000aa96:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000aa98:	429a      	cmp	r2, r3
2000aa9a:	f0c0 8145 	bcc.w	2000ad28 <I2C_isr+0xa58>
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
2000aa9e:	687b      	ldr	r3, [r7, #4]
2000aaa0:	681b      	ldr	r3, [r3, #0]
2000aaa2:	4618      	mov	r0, r3
2000aaa4:	f04f 0102 	mov.w	r1, #2
2000aaa8:	f04f 0204 	mov.w	r2, #4
2000aaac:	f04f 0300 	mov.w	r3, #0
2000aab0:	f7fb fb84 	bl	200061bc <HW_set_8bit_reg_field>
            }
            break;
2000aab4:	e13b      	b.n	2000ad2e <I2C_isr+0xa5e>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
2000aab6:	687b      	ldr	r3, [r7, #4]
2000aab8:	7b1b      	ldrb	r3, [r3, #12]
2000aaba:	2b04      	cmp	r3, #4
2000aabc:	d13c      	bne.n	2000ab38 <I2C_isr+0x868>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
2000aabe:	687b      	ldr	r3, [r7, #4]
2000aac0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000aac2:	687b      	ldr	r3, [r7, #4]
2000aac4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000aac6:	429a      	cmp	r2, r3
2000aac8:	d103      	bne.n	2000aad2 <I2C_isr+0x802>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
2000aaca:	687b      	ldr	r3, [r7, #4]
2000aacc:	691a      	ldr	r2, [r3, #16]
2000aace:	687b      	ldr	r3, [r7, #4]
2000aad0:	645a      	str	r2, [r3, #68]	; 0x44
                }
                /* Call the slave's write transaction handler if it exists. */
                if ( this_i2c->slave_write_handler != 0u )
2000aad2:	687b      	ldr	r3, [r7, #4]
2000aad4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000aad6:	2b00      	cmp	r3, #0
2000aad8:	d022      	beq.n	2000ab20 <I2C_isr+0x850>
                {
                    i2c_slave_handler_ret_t h_ret;
                    h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
2000aada:	687b      	ldr	r3, [r7, #4]
2000aadc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000aade:	687a      	ldr	r2, [r7, #4]
2000aae0:	6c91      	ldr	r1, [r2, #72]	; 0x48
2000aae2:	687a      	ldr	r2, [r7, #4]
2000aae4:	6d12      	ldr	r2, [r2, #80]	; 0x50
2000aae6:	b292      	uxth	r2, r2
2000aae8:	6878      	ldr	r0, [r7, #4]
2000aaea:	4798      	blx	r3
2000aaec:	4603      	mov	r3, r0
2000aaee:	73fb      	strb	r3, [r7, #15]
                    if ( I2C_REENABLE_SLAVE_RX == h_ret )
2000aaf0:	7bfb      	ldrb	r3, [r7, #15]
2000aaf2:	2b00      	cmp	r3, #0
2000aaf4:	d103      	bne.n	2000aafe <I2C_isr+0x82e>
                    {
                        /* There is a small risk that the write handler could
                         * call I2C_disable_slave() but return
                         * I2C_REENABLE_SLAVE_RX in error so we only enable
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
2000aaf6:	6878      	ldr	r0, [r7, #4]
2000aaf8:	f7ff fbd2 	bl	2000a2a0 <enable_slave_if_required>
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
2000aafc:	e023      	b.n	2000ab46 <I2C_isr+0x876>
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
                    }
                    else
                    {
                        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x0u );
2000aafe:	687b      	ldr	r3, [r7, #4]
2000ab00:	681b      	ldr	r3, [r3, #0]
2000ab02:	4618      	mov	r0, r3
2000ab04:	f04f 0102 	mov.w	r1, #2
2000ab08:	f04f 0204 	mov.w	r2, #4
2000ab0c:	f04f 0300 	mov.w	r3, #0
2000ab10:	f7fb fb54 	bl	200061bc <HW_set_8bit_reg_field>
                        /* Clear slave mode flag as well otherwise in mixed
                         * master/slave applications, the AA bit will get set by
                         * subsequent master operations. */
                        this_i2c->is_slave_enabled = 0u;
2000ab14:	687b      	ldr	r3, [r7, #4]
2000ab16:	f04f 0200 	mov.w	r2, #0
2000ab1a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
2000ab1e:	e012      	b.n	2000ab46 <I2C_isr+0x876>
2000ab20:	687b      	ldr	r3, [r7, #4]
2000ab22:	681b      	ldr	r3, [r3, #0]
2000ab24:	4618      	mov	r0, r3
2000ab26:	f04f 0102 	mov.w	r1, #2
2000ab2a:	f04f 0204 	mov.w	r2, #4
2000ab2e:	f04f 0301 	mov.w	r3, #1
2000ab32:	f7fb fb43 	bl	200061bc <HW_set_8bit_reg_field>
2000ab36:	e006      	b.n	2000ab46 <I2C_isr+0x876>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
2000ab38:	687b      	ldr	r3, [r7, #4]
2000ab3a:	f04f 0200 	mov.w	r2, #0
2000ab3e:	645a      	str	r2, [r3, #68]	; 0x44
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
2000ab40:	6878      	ldr	r0, [r7, #4]
2000ab42:	f7ff fbad 	bl	2000a2a0 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = I2C_SUCCESS;
2000ab46:	687b      	ldr	r3, [r7, #4]
2000ab48:	f04f 0200 	mov.w	r2, #0
2000ab4c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000ab50:	687b      	ldr	r3, [r7, #4]
2000ab52:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
2000ab56:	2b00      	cmp	r3, #0
2000ab58:	d00a      	beq.n	2000ab70 <I2C_isr+0x8a0>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000ab5a:	687b      	ldr	r3, [r7, #4]
2000ab5c:	681b      	ldr	r3, [r3, #0]
2000ab5e:	4618      	mov	r0, r3
2000ab60:	f04f 0105 	mov.w	r1, #5
2000ab64:	f04f 0220 	mov.w	r2, #32
2000ab68:	f04f 0301 	mov.w	r3, #1
2000ab6c:	f7fb fb26 	bl	200061bc <HW_set_8bit_reg_field>

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000ab70:	687b      	ldr	r3, [r7, #4]
2000ab72:	f04f 0200 	mov.w	r2, #0
2000ab76:	731a      	strb	r2, [r3, #12]

            break;
2000ab78:	e0d9      	b.n	2000ad2e <I2C_isr+0xa5e>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
2000ab7a:	687b      	ldr	r3, [r7, #4]
2000ab7c:	f04f 0200 	mov.w	r2, #0
2000ab80:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
2000ab82:	687b      	ldr	r3, [r7, #4]
2000ab84:	f04f 0200 	mov.w	r2, #0
2000ab88:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->slave_status)
2000ab8a:	687b      	ldr	r3, [r7, #4]
2000ab8c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
2000ab90:	b2db      	uxtb	r3, r3
2000ab92:	2b01      	cmp	r3, #1
2000ab94:	d104      	bne.n	2000aba0 <I2C_isr+0x8d0>
            {
                this_i2c->slave_status = I2C_FAILED;
2000ab96:	687b      	ldr	r3, [r7, #4]
2000ab98:	f04f 0202 	mov.w	r2, #2
2000ab9c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
2000aba0:	6878      	ldr	r0, [r7, #4]
2000aba2:	f7ff fb7d 	bl	2000a2a0 <enable_slave_if_required>

            break;
2000aba6:	e0c2      	b.n	2000ad2e <I2C_isr+0xa5e>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:       /* Arbitration lost, and: */
        case ST_RACK:           /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
2000aba8:	7afb      	ldrb	r3, [r7, #11]
2000abaa:	b2db      	uxtb	r3, r3
2000abac:	2ba8      	cmp	r3, #168	; 0xa8
2000abae:	d128      	bne.n	2000ac02 <I2C_isr+0x932>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
2000abb0:	687b      	ldr	r3, [r7, #4]
2000abb2:	f04f 0205 	mov.w	r2, #5
2000abb6:	731a      	strb	r2, [r3, #12]
                this_i2c->random_read_addr = 0u;
2000abb8:	687b      	ldr	r3, [r7, #4]
2000abba:	f04f 0200 	mov.w	r2, #0
2000abbe:	611a      	str	r2, [r3, #16]
                this_i2c->slave_status = I2C_IN_PROGRESS;
2000abc0:	687b      	ldr	r3, [r7, #4]
2000abc2:	f04f 0201 	mov.w	r2, #1
2000abc6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
                /* If Start Bit is set clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
2000abca:	687b      	ldr	r3, [r7, #4]
2000abcc:	681b      	ldr	r3, [r3, #0]
2000abce:	4618      	mov	r0, r3
2000abd0:	f04f 0105 	mov.w	r1, #5
2000abd4:	f04f 0220 	mov.w	r2, #32
2000abd8:	f7fb fafe 	bl	200061d8 <HW_get_8bit_reg_field>
2000abdc:	4603      	mov	r3, r0
2000abde:	2b00      	cmp	r3, #0
2000abe0:	d00f      	beq.n	2000ac02 <I2C_isr+0x932>
                {
                    HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
2000abe2:	687b      	ldr	r3, [r7, #4]
2000abe4:	681b      	ldr	r3, [r3, #0]
2000abe6:	4618      	mov	r0, r3
2000abe8:	f04f 0105 	mov.w	r1, #5
2000abec:	f04f 0220 	mov.w	r2, #32
2000abf0:	f04f 0300 	mov.w	r3, #0
2000abf4:	f7fb fae2 	bl	200061bc <HW_set_8bit_reg_field>
                    this_i2c->is_transaction_pending = 1u;
2000abf8:	687b      	ldr	r3, [r7, #4]
2000abfa:	f04f 0201 	mov.w	r2, #1
2000abfe:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
                 }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
2000ac02:	687b      	ldr	r3, [r7, #4]
2000ac04:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2000ac06:	687b      	ldr	r3, [r7, #4]
2000ac08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ac0a:	429a      	cmp	r2, r3
2000ac0c:	d309      	bcc.n	2000ac22 <I2C_isr+0x952>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, 0xFFu);
2000ac0e:	687b      	ldr	r3, [r7, #4]
2000ac10:	681b      	ldr	r3, [r3, #0]
2000ac12:	f103 0308 	add.w	r3, r3, #8
2000ac16:	4618      	mov	r0, r3
2000ac18:	f04f 01ff 	mov.w	r1, #255	; 0xff
2000ac1c:	f7fb faca 	bl	200061b4 <HW_set_8bit_reg>
2000ac20:	e011      	b.n	2000ac46 <I2C_isr+0x976>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++]);
2000ac22:	687b      	ldr	r3, [r7, #4]
2000ac24:	681b      	ldr	r3, [r3, #0]
2000ac26:	f103 0108 	add.w	r1, r3, #8
2000ac2a:	687b      	ldr	r3, [r7, #4]
2000ac2c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2000ac2e:	687b      	ldr	r3, [r7, #4]
2000ac30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000ac32:	441a      	add	r2, r3
2000ac34:	7812      	ldrb	r2, [r2, #0]
2000ac36:	f103 0001 	add.w	r0, r3, #1
2000ac3a:	687b      	ldr	r3, [r7, #4]
2000ac3c:	6458      	str	r0, [r3, #68]	; 0x44
2000ac3e:	4608      	mov	r0, r1
2000ac40:	4611      	mov	r1, r2
2000ac42:	f7fb fab7 	bl	200061b4 <HW_set_8bit_reg>
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
2000ac46:	687b      	ldr	r3, [r7, #4]
2000ac48:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2000ac4a:	687b      	ldr	r3, [r7, #4]
2000ac4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000ac4e:	429a      	cmp	r2, r3
2000ac50:	d36c      	bcc.n	2000ad2c <I2C_isr+0xa5c>
            {
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
2000ac52:	687b      	ldr	r3, [r7, #4]
2000ac54:	681b      	ldr	r3, [r3, #0]
2000ac56:	4618      	mov	r0, r3
2000ac58:	f04f 0102 	mov.w	r1, #2
2000ac5c:	f04f 0204 	mov.w	r2, #4
2000ac60:	f04f 0300 	mov.w	r3, #0
2000ac64:	f7fb faaa 	bl	200061bc <HW_set_8bit_reg_field>
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
2000ac68:	687b      	ldr	r3, [r7, #4]
2000ac6a:	f04f 0200 	mov.w	r2, #0
2000ac6e:	645a      	str	r2, [r3, #68]	; 0x44
            }
            break;
2000ac70:	e05d      	b.n	2000ad2e <I2C_isr+0xa5e>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
2000ac72:	687b      	ldr	r3, [r7, #4]
2000ac74:	f04f 0200 	mov.w	r2, #0
2000ac78:	645a      	str	r2, [r3, #68]	; 0x44
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u); 
2000ac7a:	687b      	ldr	r3, [r7, #4]
2000ac7c:	681b      	ldr	r3, [r3, #0]
2000ac7e:	4618      	mov	r0, r3
2000ac80:	f04f 0102 	mov.w	r1, #2
2000ac84:	f04f 0204 	mov.w	r2, #4
2000ac88:	f04f 0301 	mov.w	r3, #1
2000ac8c:	f7fb fa96 	bl	200061bc <HW_set_8bit_reg_field>

            /*  Mark previous state as complete */
            this_i2c->slave_status = I2C_SUCCESS;
2000ac90:	687b      	ldr	r3, [r7, #4]
2000ac92:	f04f 0200 	mov.w	r2, #0
2000ac96:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000ac9a:	687b      	ldr	r3, [r7, #4]
2000ac9c:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
2000aca0:	2b00      	cmp	r3, #0
2000aca2:	d00a      	beq.n	2000acba <I2C_isr+0x9ea>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
2000aca4:	687b      	ldr	r3, [r7, #4]
2000aca6:	681b      	ldr	r3, [r3, #0]
2000aca8:	4618      	mov	r0, r3
2000acaa:	f04f 0105 	mov.w	r1, #5
2000acae:	f04f 0220 	mov.w	r2, #32
2000acb2:	f04f 0301 	mov.w	r3, #1
2000acb6:	f7fb fa81 	bl	200061bc <HW_set_8bit_reg_field>
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000acba:	687b      	ldr	r3, [r7, #4]
2000acbc:	f04f 0200 	mov.w	r2, #0
2000acc0:	731a      	strb	r2, [r3, #12]

            break;
2000acc2:	e034      	b.n	2000ad2e <I2C_isr+0xa5e>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
2000acc4:	687b      	ldr	r3, [r7, #4]
2000acc6:	681b      	ldr	r3, [r3, #0]
2000acc8:	4618      	mov	r0, r3
2000acca:	f04f 0105 	mov.w	r1, #5
2000acce:	f04f 0220 	mov.w	r2, #32
2000acd2:	f04f 0300 	mov.w	r3, #0
2000acd6:	f7fb fa71 	bl	200061bc <HW_set_8bit_reg_field>
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
2000acda:	687b      	ldr	r3, [r7, #4]
2000acdc:	f04f 0200 	mov.w	r2, #0
2000ace0:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
2000ace2:	687b      	ldr	r3, [r7, #4]
2000ace4:	f04f 0200 	mov.w	r2, #0
2000ace8:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->master_status)
2000acea:	687b      	ldr	r3, [r7, #4]
2000acec:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2000acf0:	b2db      	uxtb	r3, r3
2000acf2:	2b01      	cmp	r3, #1
2000acf4:	d104      	bne.n	2000ad00 <I2C_isr+0xa30>
            {
                this_i2c->master_status = I2C_FAILED;
2000acf6:	687b      	ldr	r3, [r7, #4]
2000acf8:	f04f 0202 	mov.w	r2, #2
2000acfc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }

            if(I2C_IN_PROGRESS == this_i2c->slave_status)
2000ad00:	687b      	ldr	r3, [r7, #4]
2000ad02:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
2000ad06:	b2db      	uxtb	r3, r3
2000ad08:	2b01      	cmp	r3, #1
2000ad0a:	d110      	bne.n	2000ad2e <I2C_isr+0xa5e>
            {
                this_i2c->slave_status = I2C_FAILED;
2000ad0c:	687b      	ldr	r3, [r7, #4]
2000ad0e:	f04f 0202 	mov.w	r2, #2
2000ad12:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
2000ad16:	e00a      	b.n	2000ad2e <I2C_isr+0xa5e>
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
              break;

        case ST_STOP_TRANSMIT:
             /* Stop has been transmitted. Do nothing */
              break;
2000ad18:	bf00      	nop
2000ad1a:	e008      	b.n	2000ad2e <I2C_isr+0xa5e>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
2000ad1c:	bf00      	nop
2000ad1e:	e006      	b.n	2000ad2e <I2C_isr+0xa5e>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            break;
2000ad20:	bf00      	nop
2000ad22:	e004      	b.n	2000ad2e <I2C_isr+0xa5e>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
            }
            break;
2000ad24:	bf00      	nop
2000ad26:	e002      	b.n	2000ad2e <I2C_isr+0xa5e>
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
            }
            break;
2000ad28:	bf00      	nop
2000ad2a:	e000      	b.n	2000ad2e <I2C_isr+0xa5e>
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
2000ad2c:	bf00      	nop
            }

            break;
    }
    
    if ( clear_irq )
2000ad2e:	7bbb      	ldrb	r3, [r7, #14]
2000ad30:	2b00      	cmp	r3, #0
2000ad32:	d00a      	beq.n	2000ad4a <I2C_isr+0xa7a>
    {
        /* clear interrupt. */
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
2000ad34:	687b      	ldr	r3, [r7, #4]
2000ad36:	681b      	ldr	r3, [r3, #0]
2000ad38:	4618      	mov	r0, r3
2000ad3a:	f04f 0103 	mov.w	r1, #3
2000ad3e:	f04f 0208 	mov.w	r2, #8
2000ad42:	f04f 0300 	mov.w	r3, #0
2000ad46:	f7fb fa39 	bl	200061bc <HW_set_8bit_reg_field>
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
2000ad4a:	687b      	ldr	r3, [r7, #4]
2000ad4c:	681b      	ldr	r3, [r3, #0]
2000ad4e:	f103 0304 	add.w	r3, r3, #4
2000ad52:	4618      	mov	r0, r3
2000ad54:	f7fb fa30 	bl	200061b8 <HW_get_8bit_reg>
2000ad58:	4603      	mov	r3, r0
2000ad5a:	72fb      	strb	r3, [r7, #11]
}
2000ad5c:	f107 0710 	add.w	r7, r7, #16
2000ad60:	46bd      	mov	sp, r7
2000ad62:	bdb0      	pop	{r4, r5, r7, pc}

2000ad64 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
2000ad64:	b480      	push	{r7}
2000ad66:	b083      	sub	sp, #12
2000ad68:	af00      	add	r7, sp, #0
2000ad6a:	4603      	mov	r3, r0
2000ad6c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000ad6e:	f24e 1300 	movw	r3, #57600	; 0xe100
2000ad72:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000ad76:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000ad7a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000ad7e:	79f9      	ldrb	r1, [r7, #7]
2000ad80:	f001 011f 	and.w	r1, r1, #31
2000ad84:	f04f 0001 	mov.w	r0, #1
2000ad88:	fa00 f101 	lsl.w	r1, r0, r1
2000ad8c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000ad90:	f107 070c 	add.w	r7, r7, #12
2000ad94:	46bd      	mov	sp, r7
2000ad96:	bc80      	pop	{r7}
2000ad98:	4770      	bx	lr
2000ad9a:	bf00      	nop

2000ad9c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000ad9c:	b480      	push	{r7}
2000ad9e:	b083      	sub	sp, #12
2000ada0:	af00      	add	r7, sp, #0
2000ada2:	4603      	mov	r3, r0
2000ada4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
2000ada6:	f24e 1300 	movw	r3, #57600	; 0xe100
2000adaa:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000adae:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000adb2:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000adb6:	79f9      	ldrb	r1, [r7, #7]
2000adb8:	f001 011f 	and.w	r1, r1, #31
2000adbc:	f04f 0001 	mov.w	r0, #1
2000adc0:	fa00 f101 	lsl.w	r1, r0, r1
2000adc4:	f102 0220 	add.w	r2, r2, #32
2000adc8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000adcc:	f107 070c 	add.w	r7, r7, #12
2000add0:	46bd      	mov	sp, r7
2000add2:	bc80      	pop	{r7}
2000add4:	4770      	bx	lr
2000add6:	bf00      	nop

2000add8 <I2C_enable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to enable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_enable_irq( i2c_instance_t * this_i2c )
{
2000add8:	b580      	push	{r7, lr}
2000adda:	b082      	sub	sp, #8
2000addc:	af00      	add	r7, sp, #0
2000adde:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
2000ade0:	687a      	ldr	r2, [r7, #4]
2000ade2:	f24c 33b8 	movw	r3, #50104	; 0xc3b8
2000ade6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000adea:	429a      	cmp	r2, r3
2000adec:	d103      	bne.n	2000adf6 <I2C_enable_irq+0x1e>
	{
		NVIC_EnableIRQ( FabricIrq0_IRQn );
2000adee:	f04f 0022 	mov.w	r0, #34	; 0x22
2000adf2:	f7ff ffb7 	bl	2000ad64 <NVIC_EnableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
2000adf6:	687a      	ldr	r2, [r7, #4]
2000adf8:	f24c 4324 	movw	r3, #50212	; 0xc424
2000adfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae00:	429a      	cmp	r2, r3
2000ae02:	d103      	bne.n	2000ae0c <I2C_enable_irq+0x34>
	{
		NVIC_EnableIRQ( FabricIrq1_IRQn );
2000ae04:	f04f 0023 	mov.w	r0, #35	; 0x23
2000ae08:	f7ff ffac 	bl	2000ad64 <NVIC_EnableIRQ>
	}
	if(this_i2c == &counter_i2c)
2000ae0c:	687a      	ldr	r2, [r7, #4]
2000ae0e:	f64c 73cc 	movw	r3, #53196	; 0xcfcc
2000ae12:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae16:	429a      	cmp	r2, r3
2000ae18:	d103      	bne.n	2000ae22 <I2C_enable_irq+0x4a>
	{
		NVIC_EnableIRQ( FabricIrq2_IRQn );
2000ae1a:	f04f 0024 	mov.w	r0, #36	; 0x24
2000ae1e:	f7ff ffa1 	bl	2000ad64 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c3)
2000ae22:	687a      	ldr	r2, [r7, #4]
2000ae24:	f24c 5348 	movw	r3, #50504	; 0xc548
2000ae28:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae2c:	429a      	cmp	r2, r3
2000ae2e:	d103      	bne.n	2000ae38 <I2C_enable_irq+0x60>
	{
		NVIC_EnableIRQ( FabricIrq3_IRQn );
2000ae30:	f04f 0025 	mov.w	r0, #37	; 0x25
2000ae34:	f7ff ff96 	bl	2000ad64 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c4)
2000ae38:	687a      	ldr	r2, [r7, #4]
2000ae3a:	f24d 0348 	movw	r3, #53320	; 0xd048
2000ae3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae42:	429a      	cmp	r2, r3
2000ae44:	d103      	bne.n	2000ae4e <I2C_enable_irq+0x76>
	{
		NVIC_EnableIRQ( FabricIrq4_IRQn );
2000ae46:	f04f 0026 	mov.w	r0, #38	; 0x26
2000ae4a:	f7ff ff8b 	bl	2000ad64 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c5)
2000ae4e:	687a      	ldr	r2, [r7, #4]
2000ae50:	f24c 43dc 	movw	r3, #50396	; 0xc4dc
2000ae54:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae58:	429a      	cmp	r2, r3
2000ae5a:	d103      	bne.n	2000ae64 <I2C_enable_irq+0x8c>
	{
		NVIC_EnableIRQ( FabricIrq5_IRQn );
2000ae5c:	f04f 0027 	mov.w	r0, #39	; 0x27
2000ae60:	f7ff ff80 	bl	2000ad64 <NVIC_EnableIRQ>
	}
}
2000ae64:	f107 0708 	add.w	r7, r7, #8
2000ae68:	46bd      	mov	sp, r7
2000ae6a:	bd80      	pop	{r7, pc}

2000ae6c <I2C_disable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to disable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_disable_irq( i2c_instance_t * this_i2c )
{
2000ae6c:	b580      	push	{r7, lr}
2000ae6e:	b082      	sub	sp, #8
2000ae70:	af00      	add	r7, sp, #0
2000ae72:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
2000ae74:	687a      	ldr	r2, [r7, #4]
2000ae76:	f24c 33b8 	movw	r3, #50104	; 0xc3b8
2000ae7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae7e:	429a      	cmp	r2, r3
2000ae80:	d103      	bne.n	2000ae8a <I2C_disable_irq+0x1e>
	{
		NVIC_DisableIRQ( FabricIrq0_IRQn );
2000ae82:	f04f 0022 	mov.w	r0, #34	; 0x22
2000ae86:	f7ff ff89 	bl	2000ad9c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
2000ae8a:	687a      	ldr	r2, [r7, #4]
2000ae8c:	f24c 4324 	movw	r3, #50212	; 0xc424
2000ae90:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ae94:	429a      	cmp	r2, r3
2000ae96:	d103      	bne.n	2000aea0 <I2C_disable_irq+0x34>
	{
		NVIC_DisableIRQ( FabricIrq1_IRQn );
2000ae98:	f04f 0023 	mov.w	r0, #35	; 0x23
2000ae9c:	f7ff ff7e 	bl	2000ad9c <NVIC_DisableIRQ>
	}

	if(this_i2c == &counter_i2c)
2000aea0:	687a      	ldr	r2, [r7, #4]
2000aea2:	f64c 73cc 	movw	r3, #53196	; 0xcfcc
2000aea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000aeaa:	429a      	cmp	r2, r3
2000aeac:	d103      	bne.n	2000aeb6 <I2C_disable_irq+0x4a>
	{
		NVIC_DisableIRQ( FabricIrq2_IRQn );
2000aeae:	f04f 0024 	mov.w	r0, #36	; 0x24
2000aeb2:	f7ff ff73 	bl	2000ad9c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c3)
2000aeb6:	687a      	ldr	r2, [r7, #4]
2000aeb8:	f24c 5348 	movw	r3, #50504	; 0xc548
2000aebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000aec0:	429a      	cmp	r2, r3
2000aec2:	d103      	bne.n	2000aecc <I2C_disable_irq+0x60>
	{
		NVIC_DisableIRQ( FabricIrq3_IRQn );
2000aec4:	f04f 0025 	mov.w	r0, #37	; 0x25
2000aec8:	f7ff ff68 	bl	2000ad9c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c4)
2000aecc:	687a      	ldr	r2, [r7, #4]
2000aece:	f24d 0348 	movw	r3, #53320	; 0xd048
2000aed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000aed6:	429a      	cmp	r2, r3
2000aed8:	d103      	bne.n	2000aee2 <I2C_disable_irq+0x76>
	{
		NVIC_DisableIRQ( FabricIrq4_IRQn );
2000aeda:	f04f 0026 	mov.w	r0, #38	; 0x26
2000aede:	f7ff ff5d 	bl	2000ad9c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c5)
2000aee2:	687a      	ldr	r2, [r7, #4]
2000aee4:	f24c 43dc 	movw	r3, #50396	; 0xc4dc
2000aee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000aeec:	429a      	cmp	r2, r3
2000aeee:	d103      	bne.n	2000aef8 <I2C_disable_irq+0x8c>
	{
		NVIC_DisableIRQ( FabricIrq5_IRQn );
2000aef0:	f04f 0027 	mov.w	r0, #39	; 0x27
2000aef4:	f7ff ff52 	bl	2000ad9c <NVIC_DisableIRQ>
	}
}
2000aef8:	f107 0708 	add.w	r7, r7, #8
2000aefc:	46bd      	mov	sp, r7
2000aefe:	bd80      	pop	{r7, pc}

2000af00 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
2000af00:	b580      	push	{r7, lr}
2000af02:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
2000af04:	f000 f936 	bl	2000b174 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
2000af08:	f64e 5300 	movw	r3, #60672	; 0xed00
2000af0c:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000af10:	f64e 5200 	movw	r2, #60672	; 0xed00
2000af14:	f2ce 0200 	movt	r2, #57344	; 0xe000
2000af18:	6952      	ldr	r2, [r2, #20]
2000af1a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2000af1e:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
2000af20:	f7f5 fa88 	bl	20000434 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
2000af24:	bd80      	pop	{r7, pc}
2000af26:	bf00      	nop

2000af28 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
2000af28:	b580      	push	{r7, lr}
2000af2a:	b088      	sub	sp, #32
2000af2c:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
2000af2e:	f248 0300 	movw	r3, #32768	; 0x8000
2000af32:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000af36:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000af3a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2000af3e:	60fb      	str	r3, [r7, #12]

    if(0u == controller_pll_init)
2000af40:	68fb      	ldr	r3, [r7, #12]
2000af42:	2b00      	cmp	r3, #0
2000af44:	f040 808b 	bne.w	2000b05e <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
2000af48:	f248 0300 	movw	r3, #32768	; 0x8000
2000af4c:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000af50:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000af54:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
2000af58:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
2000af5a:	697b      	ldr	r3, [r7, #20]
2000af5c:	2b00      	cmp	r3, #0
2000af5e:	d13f      	bne.n	2000afe0 <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
2000af60:	f24c 23b4 	movw	r3, #49844	; 0xc2b4
2000af64:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000af68:	f24f 0280 	movw	r2, #61568	; 0xf080
2000af6c:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000af70:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
2000af72:	f24c 23b8 	movw	r3, #49848	; 0xc2b8
2000af76:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000af7a:	f24f 0280 	movw	r2, #61568	; 0xf080
2000af7e:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000af82:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
2000af84:	f24c 23bc 	movw	r3, #49852	; 0xc2bc
2000af88:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000af8c:	f24f 0280 	movw	r2, #61568	; 0xf080
2000af90:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000af94:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
2000af96:	f24c 23c0 	movw	r3, #49856	; 0xc2c0
2000af9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000af9e:	f247 02e0 	movw	r2, #28896	; 0x70e0
2000afa2:	f2c0 0272 	movt	r2, #114	; 0x72
2000afa6:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
2000afa8:	f24c 23c4 	movw	r3, #49860	; 0xc2c4
2000afac:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000afb0:	f24f 0280 	movw	r2, #61568	; 0xf080
2000afb4:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000afb8:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
2000afba:	f24c 23c8 	movw	r3, #49864	; 0xc2c8
2000afbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000afc2:	f24f 0280 	movw	r2, #61568	; 0xf080
2000afc6:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000afca:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
2000afcc:	f24c 23cc 	movw	r3, #49868	; 0xc2cc
2000afd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000afd4:	f24f 0280 	movw	r2, #61568	; 0xf080
2000afd8:	f2c0 22fa 	movt	r2, #762	; 0x2fa
2000afdc:	601a      	str	r2, [r3, #0]
                break;

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
2000afde:	e045      	b.n	2000b06c <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
2000afe0:	f64b 734c 	movw	r3, #48972	; 0xbf4c
2000afe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000afe8:	f107 0204 	add.w	r2, r7, #4
2000afec:	e893 0003 	ldmia.w	r3, {r0, r1}
2000aff0:	e882 0003 	stmia.w	r2, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
2000aff4:	f248 0300 	movw	r3, #32768	; 0x8000
2000aff8:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000affc:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
2000b000:	ea4f 1393 	mov.w	r3, r3, lsr #6
2000b004:	f003 0307 	and.w	r3, r3, #7
2000b008:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
2000b00a:	69bb      	ldr	r3, [r7, #24]
2000b00c:	f107 0220 	add.w	r2, r7, #32
2000b010:	4413      	add	r3, r2
2000b012:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
2000b016:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
2000b018:	7ffb      	ldrb	r3, [r7, #31]
2000b01a:	2b01      	cmp	r3, #1
2000b01c:	d00b      	beq.n	2000b036 <SystemCoreClockUpdate+0x10e>
2000b01e:	2b02      	cmp	r3, #2
2000b020:	d00e      	beq.n	2000b040 <SystemCoreClockUpdate+0x118>
2000b022:	2b00      	cmp	r3, #0
2000b024:	d114      	bne.n	2000b050 <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
2000b026:	f000 f825 	bl	2000b074 <get_rcosc_25_50mhz_frequency>
2000b02a:	4603      	mov	r3, r0
2000b02c:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
2000b02e:	6938      	ldr	r0, [r7, #16]
2000b030:	f000 f842 	bl	2000b0b8 <set_clock_frequency_globals>
                break;
2000b034:	e01a      	b.n	2000b06c <SystemCoreClockUpdate+0x144>

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
2000b036:	f44f 4000 	mov.w	r0, #32768	; 0x8000
2000b03a:	f000 f83d 	bl	2000b0b8 <set_clock_frequency_globals>
                break;
2000b03e:	e015      	b.n	2000b06c <SystemCoreClockUpdate+0x144>

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
2000b040:	f244 2040 	movw	r0, #16960	; 0x4240
2000b044:	f2c0 000f 	movt	r0, #15
2000b048:	f000 f836 	bl	2000b0b8 <set_clock_frequency_globals>
                break;
2000b04c:	bf00      	nop
2000b04e:	e00d      	b.n	2000b06c <SystemCoreClockUpdate+0x144>

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
2000b050:	f244 2040 	movw	r0, #16960	; 0x4240
2000b054:	f2c0 000f 	movt	r0, #15
2000b058:	f000 f82e 	bl	2000b0b8 <set_clock_frequency_globals>
2000b05c:	e006      	b.n	2000b06c <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
2000b05e:	f000 f809 	bl	2000b074 <get_rcosc_25_50mhz_frequency>
2000b062:	4603      	mov	r3, r0
2000b064:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
2000b066:	6938      	ldr	r0, [r7, #16]
2000b068:	f000 f826 	bl	2000b0b8 <set_clock_frequency_globals>
    }
}
2000b06c:	f107 0720 	add.w	r7, r7, #32
2000b070:	46bd      	mov	sp, r7
2000b072:	bd80      	pop	{r7, pc}

2000b074 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
2000b074:	b480      	push	{r7}
2000b076:	b083      	sub	sp, #12
2000b078:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
2000b07a:	f248 0300 	movw	r3, #32768	; 0x8000
2000b07e:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000b082:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2000b086:	f003 0304 	and.w	r3, r3, #4
2000b08a:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
2000b08c:	683b      	ldr	r3, [r7, #0]
2000b08e:	2b00      	cmp	r3, #0
2000b090:	d105      	bne.n	2000b09e <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
2000b092:	f647 0340 	movw	r3, #30784	; 0x7840
2000b096:	f2c0 137d 	movt	r3, #381	; 0x17d
2000b09a:	607b      	str	r3, [r7, #4]
2000b09c:	e004      	b.n	2000b0a8 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
2000b09e:	f24f 0380 	movw	r3, #61568	; 0xf080
2000b0a2:	f2c0 23fa 	movt	r3, #762	; 0x2fa
2000b0a6:	607b      	str	r3, [r7, #4]
    }

    return rcosc_frequency;
2000b0a8:	687b      	ldr	r3, [r7, #4]
}
2000b0aa:	4618      	mov	r0, r3
2000b0ac:	f107 070c 	add.w	r7, r7, #12
2000b0b0:	46bd      	mov	sp, r7
2000b0b2:	bc80      	pop	{r7}
2000b0b4:	4770      	bx	lr
2000b0b6:	bf00      	nop

2000b0b8 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
2000b0b8:	b480      	push	{r7}
2000b0ba:	b083      	sub	sp, #12
2000b0bc:	af00      	add	r7, sp, #0
2000b0be:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
2000b0c0:	f24c 23b4 	movw	r3, #49844	; 0xc2b4
2000b0c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b0c8:	687a      	ldr	r2, [r7, #4]
2000b0ca:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
2000b0cc:	f24c 23b8 	movw	r3, #49848	; 0xc2b8
2000b0d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b0d4:	687a      	ldr	r2, [r7, #4]
2000b0d6:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
2000b0d8:	f24c 23bc 	movw	r3, #49852	; 0xc2bc
2000b0dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b0e0:	687a      	ldr	r2, [r7, #4]
2000b0e2:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
2000b0e4:	f24c 23c0 	movw	r3, #49856	; 0xc2c0
2000b0e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b0ec:	f247 02e0 	movw	r2, #28896	; 0x70e0
2000b0f0:	f2c0 0272 	movt	r2, #114	; 0x72
2000b0f4:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
2000b0f6:	f24c 23c4 	movw	r3, #49860	; 0xc2c4
2000b0fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b0fe:	687a      	ldr	r2, [r7, #4]
2000b100:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
2000b102:	f24c 23c8 	movw	r3, #49864	; 0xc2c8
2000b106:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b10a:	687a      	ldr	r2, [r7, #4]
2000b10c:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
2000b10e:	f24c 23cc 	movw	r3, #49868	; 0xc2cc
2000b112:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b116:	687a      	ldr	r2, [r7, #4]
2000b118:	601a      	str	r2, [r3, #0]
}
2000b11a:	f107 070c 	add.w	r7, r7, #12
2000b11e:	46bd      	mov	sp, r7
2000b120:	bc80      	pop	{r7}
2000b122:	4770      	bx	lr

2000b124 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
2000b124:	b480      	push	{r7}
2000b126:	b083      	sub	sp, #12
2000b128:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
2000b12a:	f248 0300 	movw	r3, #32768	; 0x8000
2000b12e:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000b132:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
2000b136:	607b      	str	r3, [r7, #4]
    switch(device_version)
2000b138:	687a      	ldr	r2, [r7, #4]
2000b13a:	f64f 0302 	movw	r3, #63490	; 0xf802
2000b13e:	429a      	cmp	r2, r3
2000b140:	d006      	beq.n	2000b150 <get_silicon_revision+0x2c>
2000b142:	f64f 0302 	movw	r3, #63490	; 0xf802
2000b146:	f2c0 0301 	movt	r3, #1
2000b14a:	429a      	cmp	r2, r3
2000b14c:	d004      	beq.n	2000b158 <get_silicon_revision+0x34>
2000b14e:	e007      	b.n	2000b160 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
2000b150:	f04f 0301 	mov.w	r3, #1
2000b154:	603b      	str	r3, [r7, #0]
            break;
2000b156:	e006      	b.n	2000b166 <get_silicon_revision+0x42>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
2000b158:	f04f 0302 	mov.w	r3, #2
2000b15c:	603b      	str	r3, [r7, #0]
            break;
2000b15e:	e002      	b.n	2000b166 <get_silicon_revision+0x42>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
2000b160:	f04f 0300 	mov.w	r3, #0
2000b164:	603b      	str	r3, [r7, #0]
            break;
    }

    return silicon_revision;
2000b166:	683b      	ldr	r3, [r7, #0]
}
2000b168:	4618      	mov	r0, r3
2000b16a:	f107 070c 	add.w	r7, r7, #12
2000b16e:	46bd      	mov	sp, r7
2000b170:	bc80      	pop	{r7}
2000b172:	4770      	bx	lr

2000b174 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
2000b174:	b580      	push	{r7, lr}
2000b176:	b082      	sub	sp, #8
2000b178:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
2000b17a:	f7ff ffd3 	bl	2000b124 <get_silicon_revision>
2000b17e:	4603      	mov	r3, r0
2000b180:	607b      	str	r3, [r7, #4]

    switch(silicon_revision)
2000b182:	687b      	ldr	r3, [r7, #4]
2000b184:	2b01      	cmp	r3, #1
2000b186:	d101      	bne.n	2000b18c <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
2000b188:	f000 f804 	bl	2000b194 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
2000b18c:	f107 0708 	add.w	r7, r7, #8
2000b190:	46bd      	mov	sp, r7
2000b192:	bd80      	pop	{r7, pc}

2000b194 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
2000b194:	b480      	push	{r7}
2000b196:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
2000b198:	f248 0300 	movw	r3, #32768	; 0x8000
2000b19c:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000b1a0:	f248 0200 	movw	r2, #32768	; 0x8000
2000b1a4:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000b1a8:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
2000b1ac:	f442 7280 	orr.w	r2, r2, #256	; 0x100
2000b1b0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
2000b1b4:	f248 0300 	movw	r3, #32768	; 0x8000
2000b1b8:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000b1bc:	f248 0200 	movw	r2, #32768	; 0x8000
2000b1c0:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000b1c4:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
2000b1c8:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
2000b1cc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
2000b1d0:	46bd      	mov	sp, r7
2000b1d2:	bc80      	pop	{r7}
2000b1d4:	4770      	bx	lr
2000b1d6:	bf00      	nop

2000b1d8 <HAL_disable_interrupts>:
2000b1d8:	f3ef 8010 	mrs	r0, PRIMASK
2000b1dc:	b672      	cpsid	i
2000b1de:	4770      	bx	lr

2000b1e0 <HAL_restore_interrupts>:
2000b1e0:	f380 8810 	msr	PRIMASK, r0
2000b1e4:	4770      	bx	lr
	...

2000b1e8 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
2000b1e8:	b480      	push	{r7}
2000b1ea:	b083      	sub	sp, #12
2000b1ec:	af00      	add	r7, sp, #0
2000b1ee:	4603      	mov	r3, r0
2000b1f0:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000b1f2:	f24e 1300 	movw	r3, #57600	; 0xe100
2000b1f6:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000b1fa:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000b1fe:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000b202:	79f9      	ldrb	r1, [r7, #7]
2000b204:	f001 011f 	and.w	r1, r1, #31
2000b208:	f04f 0001 	mov.w	r0, #1
2000b20c:	fa00 f101 	lsl.w	r1, r0, r1
2000b210:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000b214:	f107 070c 	add.w	r7, r7, #12
2000b218:	46bd      	mov	sp, r7
2000b21a:	bc80      	pop	{r7}
2000b21c:	4770      	bx	lr
2000b21e:	bf00      	nop

2000b220 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000b220:	b480      	push	{r7}
2000b222:	b083      	sub	sp, #12
2000b224:	af00      	add	r7, sp, #0
2000b226:	4603      	mov	r3, r0
2000b228:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
2000b22a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000b22e:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000b232:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000b236:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000b23a:	79f9      	ldrb	r1, [r7, #7]
2000b23c:	f001 011f 	and.w	r1, r1, #31
2000b240:	f04f 0001 	mov.w	r0, #1
2000b244:	fa00 f101 	lsl.w	r1, r0, r1
2000b248:	f102 0220 	add.w	r2, r2, #32
2000b24c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000b250:	f107 070c 	add.w	r7, r7, #12
2000b254:	46bd      	mov	sp, r7
2000b256:	bc80      	pop	{r7}
2000b258:	4770      	bx	lr
2000b25a:	bf00      	nop

2000b25c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
2000b25c:	b480      	push	{r7}
2000b25e:	b083      	sub	sp, #12
2000b260:	af00      	add	r7, sp, #0
2000b262:	4603      	mov	r3, r0
2000b264:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
2000b266:	f24e 1300 	movw	r3, #57600	; 0xe100
2000b26a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000b26e:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000b272:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000b276:	79f9      	ldrb	r1, [r7, #7]
2000b278:	f001 011f 	and.w	r1, r1, #31
2000b27c:	f04f 0001 	mov.w	r0, #1
2000b280:	fa00 f101 	lsl.w	r1, r0, r1
2000b284:	f102 0260 	add.w	r2, r2, #96	; 0x60
2000b288:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000b28c:	f107 070c 	add.w	r7, r7, #12
2000b290:	46bd      	mov	sp, r7
2000b292:	bc80      	pop	{r7}
2000b294:	4770      	bx	lr
2000b296:	bf00      	nop

2000b298 <MSS_COMBLK_init>:
void MSS_COMBLK_init
(
    comblk_async_event_handler_t async_event_handler,
    uint8_t* p_response
)
{
2000b298:	b580      	push	{r7, lr}
2000b29a:	b082      	sub	sp, #8
2000b29c:	af00      	add	r7, sp, #0
2000b29e:	6078      	str	r0, [r7, #4]
2000b2a0:	6039      	str	r1, [r7, #0]
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
2000b2a2:	f04f 0013 	mov.w	r0, #19
2000b2a6:	f7ff ffbb 	bl	2000b220 <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
2000b2aa:	f246 0300 	movw	r3, #24576	; 0x6000
2000b2ae:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b2b2:	f04f 0200 	mov.w	r2, #0
2000b2b6:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
2000b2b8:	f04f 0013 	mov.w	r0, #19
2000b2bc:	f7ff ffce 	bl	2000b25c <NVIC_ClearPendingIRQ>
    
    g_async_event_handler = async_event_handler;
2000b2c0:	f24c 3348 	movw	r3, #49992	; 0xc348
2000b2c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b2c8:	687a      	ldr	r2, [r7, #4]
2000b2ca:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 0u;
2000b2cc:	f24c 3344 	movw	r3, #49988	; 0xc344
2000b2d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b2d4:	f04f 0200 	mov.w	r2, #0
2000b2d8:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = 0u;
2000b2da:	f24c 3320 	movw	r3, #49952	; 0xc320
2000b2de:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b2e2:	f04f 0200 	mov.w	r2, #0
2000b2e6:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = 0u;
2000b2e8:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b2f0:	f04f 0200 	mov.w	r2, #0
2000b2f4:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = 0u;
2000b2f6:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b2fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b2fe:	f04f 0200 	mov.w	r2, #0
2000b302:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = 0u;
2000b304:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b308:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b30c:	f04f 0200 	mov.w	r2, #0
2000b310:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = 0u;
2000b312:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b316:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b31a:	f04f 0200 	mov.w	r2, #0
2000b31e:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
2000b320:	f24c 3334 	movw	r3, #49972	; 0xc334
2000b324:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b328:	683a      	ldr	r2, [r7, #0]
2000b32a:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = 0u;
2000b32c:	f24c 3338 	movw	r3, #49976	; 0xc338
2000b330:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b334:	f04f 0200 	mov.w	r2, #0
2000b338:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
2000b33a:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b33e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b342:	f04f 0200 	mov.w	r2, #0
2000b346:	801a      	strh	r2, [r3, #0]
    g_comblk_completion_handler = 0;
2000b348:	f24c 333c 	movw	r3, #49980	; 0xc33c
2000b34c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b350:	f04f 0200 	mov.w	r2, #0
2000b354:	601a      	str	r2, [r3, #0]
    
    g_comblk_state = COMBLK_IDLE;
2000b356:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b35a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b35e:	f04f 0200 	mov.w	r2, #0
2000b362:	701a      	strb	r2, [r3, #0]
    /*
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controller’s COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
2000b364:	f246 0300 	movw	r3, #24576	; 0x6000
2000b368:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b36c:	f246 0200 	movw	r2, #24576	; 0x6000
2000b370:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b374:	6812      	ldr	r2, [r2, #0]
2000b376:	f022 0220 	bic.w	r2, r2, #32
2000b37a:	601a      	str	r2, [r3, #0]
    COMBLK->CONTROL |= CR_ENABLE_MASK;
2000b37c:	f246 0300 	movw	r3, #24576	; 0x6000
2000b380:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b384:	f246 0200 	movw	r2, #24576	; 0x6000
2000b388:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b38c:	6812      	ldr	r2, [r2, #0]
2000b38e:	f042 0210 	orr.w	r2, r2, #16
2000b392:	601a      	str	r2, [r3, #0]
    
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
2000b394:	f246 0300 	movw	r3, #24576	; 0x6000
2000b398:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b39c:	f246 0200 	movw	r2, #24576	; 0x6000
2000b3a0:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b3a4:	6892      	ldr	r2, [r2, #8]
2000b3a6:	f022 0201 	bic.w	r2, r2, #1
2000b3aa:	609a      	str	r2, [r3, #8]
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
2000b3ac:	f246 0300 	movw	r3, #24576	; 0x6000
2000b3b0:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b3b4:	f246 0200 	movw	r2, #24576	; 0x6000
2000b3b8:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b3bc:	6892      	ldr	r2, [r2, #8]
2000b3be:	f042 0202 	orr.w	r2, r2, #2
2000b3c2:	609a      	str	r2, [r3, #8]
    NVIC_EnableIRQ(ComBlk_IRQn);
2000b3c4:	f04f 0013 	mov.w	r0, #19
2000b3c8:	f7ff ff0e 	bl	2000b1e8 <NVIC_EnableIRQ>
}
2000b3cc:	f107 0708 	add.w	r7, r7, #8
2000b3d0:	46bd      	mov	sp, r7
2000b3d2:	bd80      	pop	{r7, pc}

2000b3d4 <MSS_COMBLK_send_cmd>:
    uint32_t data_size,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
2000b3d4:	b580      	push	{r7, lr}
2000b3d6:	b086      	sub	sp, #24
2000b3d8:	af00      	add	r7, sp, #0
2000b3da:	60f8      	str	r0, [r7, #12]
2000b3dc:	607a      	str	r2, [r7, #4]
2000b3de:	603b      	str	r3, [r7, #0]
2000b3e0:	460b      	mov	r3, r1
2000b3e2:	817b      	strh	r3, [r7, #10]
    uint32_t size_sent;
    
    ASSERT(cmd_size > 0);
2000b3e4:	897b      	ldrh	r3, [r7, #10]
2000b3e6:	2b00      	cmp	r3, #0
2000b3e8:	d100      	bne.n	2000b3ec <MSS_COMBLK_send_cmd+0x18>
2000b3ea:	be00      	bkpt	0x0000
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
2000b3ec:	f04f 0013 	mov.w	r0, #19
2000b3f0:	f7ff ff16 	bl	2000b220 <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
2000b3f4:	f246 0300 	movw	r3, #24576	; 0x6000
2000b3f8:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b3fc:	f04f 0200 	mov.w	r2, #0
2000b400:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
2000b402:	f04f 0013 	mov.w	r0, #19
2000b406:	f7ff ff29 	bl	2000b25c <NVIC_ClearPendingIRQ>
    
    /*
     * Abort current command if any.
     */
    abort_current_cmd();
2000b40a:	f000 fbed 	bl	2000bbe8 <abort_current_cmd>
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
2000b40e:	f24c 3344 	movw	r3, #49988	; 0xc344
2000b412:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b416:	f04f 0201 	mov.w	r2, #1
2000b41a:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = p_cmd[0];
2000b41c:	68fb      	ldr	r3, [r7, #12]
2000b41e:	781a      	ldrb	r2, [r3, #0]
2000b420:	f24c 3320 	movw	r3, #49952	; 0xc320
2000b424:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b428:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = p_cmd;
2000b42a:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b42e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b432:	68fa      	ldr	r2, [r7, #12]
2000b434:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = cmd_size;
2000b436:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b43a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b43e:	897a      	ldrh	r2, [r7, #10]
2000b440:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = p_data;
2000b442:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b446:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b44a:	687a      	ldr	r2, [r7, #4]
2000b44c:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = data_size;
2000b44e:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b452:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b456:	683a      	ldr	r2, [r7, #0]
2000b458:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
2000b45a:	f24c 3334 	movw	r3, #49972	; 0xc334
2000b45e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b462:	6a3a      	ldr	r2, [r7, #32]
2000b464:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = response_size;
2000b466:	f24c 3338 	movw	r3, #49976	; 0xc338
2000b46a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b46e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000b470:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
2000b472:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b476:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b47a:	f04f 0200 	mov.w	r2, #0
2000b47e:	801a      	strh	r2, [r3, #0]
    g_comblk_page_handler = 0u;
2000b480:	f24c 3340 	movw	r3, #49984	; 0xc340
2000b484:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b488:	f04f 0200 	mov.w	r2, #0
2000b48c:	601a      	str	r2, [r3, #0]
    g_comblk_completion_handler = completion_handler;
2000b48e:	f24c 333c 	movw	r3, #49980	; 0xc33c
2000b492:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b496:	6aba      	ldr	r2, [r7, #40]	; 0x28
2000b498:	601a      	str	r2, [r3, #0]
    
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
2000b49a:	f246 0300 	movw	r3, #24576	; 0x6000
2000b49e:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b4a2:	f246 0200 	movw	r2, #24576	; 0x6000
2000b4a6:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b4aa:	6892      	ldr	r2, [r2, #8]
2000b4ac:	f042 0202 	orr.w	r2, r2, #2
2000b4b0:	609a      	str	r2, [r3, #8]

    /*
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
2000b4b2:	f24c 3320 	movw	r3, #49952	; 0xc320
2000b4b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b4ba:	781b      	ldrb	r3, [r3, #0]
2000b4bc:	b2db      	uxtb	r3, r3
2000b4be:	4618      	mov	r0, r3
2000b4c0:	f000 fbc2 	bl	2000bc48 <send_cmd_opcode>
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
2000b4c4:	68fb      	ldr	r3, [r7, #12]
2000b4c6:	f103 0201 	add.w	r2, r3, #1
2000b4ca:	897b      	ldrh	r3, [r7, #10]
2000b4cc:	f103 33ff 	add.w	r3, r3, #4294967295
2000b4d0:	4610      	mov	r0, r2
2000b4d2:	4619      	mov	r1, r3
2000b4d4:	f000 fbe0 	bl	2000bc98 <fill_tx_fifo>
2000b4d8:	4603      	mov	r3, r0
2000b4da:	617b      	str	r3, [r7, #20]
    ++size_sent;    /* Adjust for opcode byte sent. */
2000b4dc:	697b      	ldr	r3, [r7, #20]
2000b4de:	f103 0301 	add.w	r3, r3, #1
2000b4e2:	617b      	str	r3, [r7, #20]
    if(size_sent < cmd_size)
2000b4e4:	897a      	ldrh	r2, [r7, #10]
2000b4e6:	697b      	ldr	r3, [r7, #20]
2000b4e8:	429a      	cmp	r2, r3
2000b4ea:	d923      	bls.n	2000b534 <MSS_COMBLK_send_cmd+0x160>
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
2000b4ec:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b4f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b4f4:	881b      	ldrh	r3, [r3, #0]
2000b4f6:	b29a      	uxth	r2, r3
2000b4f8:	697b      	ldr	r3, [r7, #20]
2000b4fa:	b29b      	uxth	r3, r3
2000b4fc:	ebc3 0302 	rsb	r3, r3, r2
2000b500:	b29a      	uxth	r2, r3
2000b502:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b506:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b50a:	801a      	strh	r2, [r3, #0]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
2000b50c:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b510:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b514:	681a      	ldr	r2, [r3, #0]
2000b516:	697b      	ldr	r3, [r7, #20]
2000b518:	441a      	add	r2, r3
2000b51a:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b51e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b522:	601a      	str	r2, [r3, #0]
        
        g_comblk_state = COMBLK_TX_CMD;
2000b524:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b528:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b52c:	f04f 0201 	mov.w	r2, #1
2000b530:	701a      	strb	r2, [r3, #0]
2000b532:	e01c      	b.n	2000b56e <MSS_COMBLK_send_cmd+0x19a>
    }
    else
    {
        g_comblk_cmd_size = 0u;
2000b534:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b538:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b53c:	f04f 0200 	mov.w	r2, #0
2000b540:	801a      	strh	r2, [r3, #0]
        if(g_comblk_data_size > 0u)
2000b542:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b546:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b54a:	681b      	ldr	r3, [r3, #0]
2000b54c:	2b00      	cmp	r3, #0
2000b54e:	d007      	beq.n	2000b560 <MSS_COMBLK_send_cmd+0x18c>
        {
            g_comblk_state = COMBLK_TX_DATA;
2000b550:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b554:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b558:	f04f 0202 	mov.w	r2, #2
2000b55c:	701a      	strb	r2, [r3, #0]
2000b55e:	e006      	b.n	2000b56e <MSS_COMBLK_send_cmd+0x19a>
        }
        else
        {
            g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b560:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b564:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b568:	f04f 0203 	mov.w	r2, #3
2000b56c:	701a      	strb	r2, [r3, #0]
    }

    /*
     * Enable interrupt.
     */
    NVIC_EnableIRQ(ComBlk_IRQn);
2000b56e:	f04f 0013 	mov.w	r0, #19
2000b572:	f7ff fe39 	bl	2000b1e8 <NVIC_EnableIRQ>
}
2000b576:	f107 0718 	add.w	r7, r7, #24
2000b57a:	46bd      	mov	sp, r7
2000b57c:	bd80      	pop	{r7, pc}
2000b57e:	bf00      	nop

2000b580 <ComBlk_IRQHandler>:

/*==============================================================================
 * COMBLK interrupt handler.
 */
void ComBlk_IRQHandler(void)
{
2000b580:	b580      	push	{r7, lr}
2000b582:	b082      	sub	sp, #8
2000b584:	af00      	add	r7, sp, #0
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
2000b586:	f246 0300 	movw	r3, #24576	; 0x6000
2000b58a:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b58e:	685b      	ldr	r3, [r3, #4]
2000b590:	717b      	strb	r3, [r7, #5]
    
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
2000b592:	f246 0300 	movw	r3, #24576	; 0x6000
2000b596:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b59a:	689b      	ldr	r3, [r3, #8]
2000b59c:	b2da      	uxtb	r2, r3
2000b59e:	797b      	ldrb	r3, [r7, #5]
2000b5a0:	ea02 0303 	and.w	r3, r2, r3
2000b5a4:	717b      	strb	r3, [r7, #5]
    
    rcv_okay = status & RCVOKAY_MASK;
2000b5a6:	797b      	ldrb	r3, [r7, #5]
2000b5a8:	f003 0302 	and.w	r3, r3, #2
2000b5ac:	71fb      	strb	r3, [r7, #7]
    
    if(rcv_okay)
2000b5ae:	79fb      	ldrb	r3, [r7, #7]
2000b5b0:	2b00      	cmp	r3, #0
2000b5b2:	d001      	beq.n	2000b5b8 <ComBlk_IRQHandler+0x38>
    {
        handle_rx_okay_irq();
2000b5b4:	f000 f970 	bl	2000b898 <handle_rx_okay_irq>
    }
        
    tx_okay = status & TXTOKAY_MASK;
2000b5b8:	797b      	ldrb	r3, [r7, #5]
2000b5ba:	f003 0301 	and.w	r3, r3, #1
2000b5be:	71bb      	strb	r3, [r7, #6]
    if(tx_okay)
2000b5c0:	79bb      	ldrb	r3, [r7, #6]
2000b5c2:	2b00      	cmp	r3, #0
2000b5c4:	d001      	beq.n	2000b5ca <ComBlk_IRQHandler+0x4a>
    {
        handle_tx_okay_irq();
2000b5c6:	f000 f805 	bl	2000b5d4 <handle_tx_okay_irq>
    }
}
2000b5ca:	f107 0708 	add.w	r7, r7, #8
2000b5ce:	46bd      	mov	sp, r7
2000b5d0:	bd80      	pop	{r7, pc}
2000b5d2:	bf00      	nop

2000b5d4 <handle_tx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_tx_okay_irq(void)
{
2000b5d4:	b580      	push	{r7, lr}
2000b5d6:	b084      	sub	sp, #16
2000b5d8:	af00      	add	r7, sp, #0
    switch(g_comblk_state)
2000b5da:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b5de:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b5e2:	781b      	ldrb	r3, [r3, #0]
2000b5e4:	2b02      	cmp	r3, #2
2000b5e6:	d067      	beq.n	2000b6b8 <handle_tx_okay_irq+0xe4>
2000b5e8:	2b05      	cmp	r3, #5
2000b5ea:	f000 80b6 	beq.w	2000b75a <handle_tx_okay_irq+0x186>
2000b5ee:	2b01      	cmp	r3, #1
2000b5f0:	f040 8136 	bne.w	2000b860 <handle_tx_okay_irq+0x28c>
        /*----------------------------------------------------------------------
         * The TX_OKAY interrupt should only be enabled for states COMBLK_TX_CMD
         * and COMBLK_TX_DATA.
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
2000b5f4:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b5f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b5fc:	881b      	ldrh	r3, [r3, #0]
2000b5fe:	b29b      	uxth	r3, r3
2000b600:	2b00      	cmp	r3, #0
2000b602:	d055      	beq.n	2000b6b0 <handle_tx_okay_irq+0xdc>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
2000b604:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b608:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b60c:	681a      	ldr	r2, [r3, #0]
2000b60e:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b612:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b616:	881b      	ldrh	r3, [r3, #0]
2000b618:	b29b      	uxth	r3, r3
2000b61a:	4610      	mov	r0, r2
2000b61c:	4619      	mov	r1, r3
2000b61e:	f000 fb3b 	bl	2000bc98 <fill_tx_fifo>
2000b622:	4603      	mov	r3, r0
2000b624:	607b      	str	r3, [r7, #4]
                if(size_sent < g_comblk_cmd_size)
2000b626:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b62a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b62e:	881b      	ldrh	r3, [r3, #0]
2000b630:	b29b      	uxth	r3, r3
2000b632:	461a      	mov	r2, r3
2000b634:	687b      	ldr	r3, [r7, #4]
2000b636:	429a      	cmp	r2, r3
2000b638:	d91c      	bls.n	2000b674 <handle_tx_okay_irq+0xa0>
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
2000b63a:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b63e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b642:	881b      	ldrh	r3, [r3, #0]
2000b644:	b29a      	uxth	r2, r3
2000b646:	687b      	ldr	r3, [r7, #4]
2000b648:	b29b      	uxth	r3, r3
2000b64a:	ebc3 0302 	rsb	r3, r3, r2
2000b64e:	b29a      	uxth	r2, r3
2000b650:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b654:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b658:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
2000b65a:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b65e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b662:	681a      	ldr	r2, [r3, #0]
2000b664:	687b      	ldr	r3, [r7, #4]
2000b666:	441a      	add	r2, r3
2000b668:	f24c 3324 	movw	r3, #49956	; 0xc324
2000b66c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b670:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000b672:	e10c      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
                }
                else
                {
                    g_comblk_cmd_size = 0u;
2000b674:	f24c 3328 	movw	r3, #49960	; 0xc328
2000b678:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b67c:	f04f 0200 	mov.w	r2, #0
2000b680:	801a      	strh	r2, [r3, #0]
                    if(g_comblk_data_size > 0u)
2000b682:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b68a:	681b      	ldr	r3, [r3, #0]
2000b68c:	2b00      	cmp	r3, #0
2000b68e:	d007      	beq.n	2000b6a0 <handle_tx_okay_irq+0xcc>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
2000b690:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b694:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b698:	f04f 0202 	mov.w	r2, #2
2000b69c:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000b69e:	e0f6      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
                    }
                    else
                    {
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b6a0:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b6a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6a8:	f04f 0203 	mov.w	r2, #3
2000b6ac:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000b6ae:	e0ee      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
2000b6b0:	be00      	bkpt	0x0000
                abort_current_cmd();
2000b6b2:	f000 fa99 	bl	2000bbe8 <abort_current_cmd>
            }
        break;
2000b6b6:	e0ea      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
2000b6b8:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b6bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6c0:	681b      	ldr	r3, [r3, #0]
2000b6c2:	2b00      	cmp	r3, #0
2000b6c4:	d045      	beq.n	2000b752 <handle_tx_okay_irq+0x17e>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
2000b6c6:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b6ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6ce:	681a      	ldr	r2, [r3, #0]
2000b6d0:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b6d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6d8:	681b      	ldr	r3, [r3, #0]
2000b6da:	4610      	mov	r0, r2
2000b6dc:	4619      	mov	r1, r3
2000b6de:	f000 fadb 	bl	2000bc98 <fill_tx_fifo>
2000b6e2:	4603      	mov	r3, r0
2000b6e4:	60bb      	str	r3, [r7, #8]
                if(size_sent < g_comblk_data_size)
2000b6e6:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b6ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6ee:	681b      	ldr	r3, [r3, #0]
2000b6f0:	68ba      	ldr	r2, [r7, #8]
2000b6f2:	429a      	cmp	r2, r3
2000b6f4:	d219      	bcs.n	2000b72a <handle_tx_okay_irq+0x156>
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
2000b6f6:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b6fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b6fe:	681a      	ldr	r2, [r3, #0]
2000b700:	68bb      	ldr	r3, [r7, #8]
2000b702:	ebc3 0202 	rsb	r2, r3, r2
2000b706:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b70a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b70e:	601a      	str	r2, [r3, #0]
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
2000b710:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b714:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b718:	681a      	ldr	r2, [r3, #0]
2000b71a:	68bb      	ldr	r3, [r7, #8]
2000b71c:	441a      	add	r2, r3
2000b71e:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b722:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b726:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000b728:	e0b1      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
                    g_comblk_data_size = g_comblk_data_size - size_sent;
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
                }
                else
                {
                    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
2000b72a:	f246 0300 	movw	r3, #24576	; 0x6000
2000b72e:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b732:	f246 0200 	movw	r2, #24576	; 0x6000
2000b736:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b73a:	6892      	ldr	r2, [r2, #8]
2000b73c:	f022 0201 	bic.w	r2, r2, #1
2000b740:	609a      	str	r2, [r3, #8]
                    g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b742:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b746:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b74a:	f04f 0203 	mov.w	r2, #3
2000b74e:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000b750:	e09d      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
2000b752:	be00      	bkpt	0x0000
                abort_current_cmd();
2000b754:	f000 fa48 	bl	2000bbe8 <abort_current_cmd>
            }
        break;
2000b758:	e099      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
           
        case COMBLK_TX_PAGED_DATA:
            /*
             * Read a page of data if required.
             */
            if(0u == g_comblk_data_size)
2000b75a:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b75e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b762:	681b      	ldr	r3, [r3, #0]
2000b764:	2b00      	cmp	r3, #0
2000b766:	d136      	bne.n	2000b7d6 <handle_tx_okay_irq+0x202>
            {
                if(g_comblk_page_handler != 0)
2000b768:	f24c 3340 	movw	r3, #49984	; 0xc340
2000b76c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b770:	681b      	ldr	r3, [r3, #0]
2000b772:	2b00      	cmp	r3, #0
2000b774:	d02a      	beq.n	2000b7cc <handle_tx_okay_irq+0x1f8>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
2000b776:	f24c 3340 	movw	r3, #49984	; 0xc340
2000b77a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b77e:	681b      	ldr	r3, [r3, #0]
2000b780:	f24c 302c 	movw	r0, #49964	; 0xc32c
2000b784:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000b788:	4798      	blx	r3
2000b78a:	4602      	mov	r2, r0
2000b78c:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b790:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b794:	601a      	str	r2, [r3, #0]
                    if(0u == g_comblk_data_size)
2000b796:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b79a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b79e:	681b      	ldr	r3, [r3, #0]
2000b7a0:	2b00      	cmp	r3, #0
2000b7a2:	d117      	bne.n	2000b7d4 <handle_tx_okay_irq+0x200>
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
2000b7a4:	f246 0300 	movw	r3, #24576	; 0x6000
2000b7a8:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b7ac:	f246 0200 	movw	r2, #24576	; 0x6000
2000b7b0:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b7b4:	6892      	ldr	r2, [r2, #8]
2000b7b6:	f022 0201 	bic.w	r2, r2, #1
2000b7ba:	609a      	str	r2, [r3, #8]
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b7bc:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b7c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b7c4:	f04f 0203 	mov.w	r2, #3
2000b7c8:	701a      	strb	r2, [r3, #0]
2000b7ca:	e004      	b.n	2000b7d6 <handle_tx_okay_irq+0x202>
                    }
                }
                else
                {
                    ASSERT(0);
2000b7cc:	be00      	bkpt	0x0000
                    abort_current_cmd();
2000b7ce:	f000 fa0b 	bl	2000bbe8 <abort_current_cmd>
2000b7d2:	e000      	b.n	2000b7d6 <handle_tx_okay_irq+0x202>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
                    if(0u == g_comblk_data_size)
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b7d4:	bf00      	nop
            /*
             * Transmit the page data or move to COMBLK_WAIT_RESPONSE state if
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
2000b7d6:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b7da:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b7de:	681b      	ldr	r3, [r3, #0]
2000b7e0:	2b00      	cmp	r3, #0
2000b7e2:	d113      	bne.n	2000b80c <handle_tx_okay_irq+0x238>
            {
                COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
2000b7e4:	f246 0300 	movw	r3, #24576	; 0x6000
2000b7e8:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b7ec:	f246 0200 	movw	r2, #24576	; 0x6000
2000b7f0:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b7f4:	6892      	ldr	r2, [r2, #8]
2000b7f6:	f022 0201 	bic.w	r2, r2, #1
2000b7fa:	609a      	str	r2, [r3, #8]
                g_comblk_state = COMBLK_WAIT_RESPONSE;
2000b7fc:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b800:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b804:	f04f 0203 	mov.w	r2, #3
2000b808:	701a      	strb	r2, [r3, #0]
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
                g_comblk_p_data = &g_comblk_p_data[size_sent];
            }
        break;
2000b80a:	e040      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
                g_comblk_state = COMBLK_WAIT_RESPONSE;
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
2000b80c:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b810:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b814:	681a      	ldr	r2, [r3, #0]
2000b816:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b81a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b81e:	681b      	ldr	r3, [r3, #0]
2000b820:	4610      	mov	r0, r2
2000b822:	4619      	mov	r1, r3
2000b824:	f000 fa38 	bl	2000bc98 <fill_tx_fifo>
2000b828:	4603      	mov	r3, r0
2000b82a:	60fb      	str	r3, [r7, #12]
                g_comblk_data_size = g_comblk_data_size - size_sent;
2000b82c:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b830:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b834:	681a      	ldr	r2, [r3, #0]
2000b836:	68fb      	ldr	r3, [r7, #12]
2000b838:	ebc3 0202 	rsb	r2, r3, r2
2000b83c:	f24c 3330 	movw	r3, #49968	; 0xc330
2000b840:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b844:	601a      	str	r2, [r3, #0]
                g_comblk_p_data = &g_comblk_p_data[size_sent];
2000b846:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b84a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b84e:	681a      	ldr	r2, [r3, #0]
2000b850:	68fb      	ldr	r3, [r7, #12]
2000b852:	441a      	add	r2, r3
2000b854:	f24c 332c 	movw	r3, #49964	; 0xc32c
2000b858:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b85c:	601a      	str	r2, [r3, #0]
            }
        break;
2000b85e:	e016      	b.n	2000b88e <handle_tx_okay_irq+0x2ba>
        case COMBLK_WAIT_RESPONSE:
            /* Fall through */
        case COMBLK_RX_RESPONSE:
            /* Fall through */
        default:
            COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
2000b860:	f246 0300 	movw	r3, #24576	; 0x6000
2000b864:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b868:	f246 0200 	movw	r2, #24576	; 0x6000
2000b86c:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000b870:	6892      	ldr	r2, [r2, #8]
2000b872:	f022 0201 	bic.w	r2, r2, #1
2000b876:	609a      	str	r2, [r3, #8]
            complete_request(0u);
2000b878:	f04f 0000 	mov.w	r0, #0
2000b87c:	f000 f988 	bl	2000bb90 <complete_request>
            g_comblk_state = COMBLK_IDLE;
2000b880:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b884:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b888:	f04f 0200 	mov.w	r2, #0
2000b88c:	701a      	strb	r2, [r3, #0]
        break;
    }
}
2000b88e:	f107 0710 	add.w	r7, r7, #16
2000b892:	46bd      	mov	sp, r7
2000b894:	bd80      	pop	{r7, pc}
2000b896:	bf00      	nop

2000b898 <handle_rx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_rx_okay_irq(void)
{
2000b898:	b580      	push	{r7, lr}
2000b89a:	b084      	sub	sp, #16
2000b89c:	af00      	add	r7, sp, #0
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
2000b89e:	f246 0300 	movw	r3, #24576	; 0x6000
2000b8a2:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000b8a6:	691b      	ldr	r3, [r3, #16]
2000b8a8:	80bb      	strh	r3, [r7, #4]
    is_command = data16 & DATA8_COMMAND_MASK;
2000b8aa:	88bb      	ldrh	r3, [r7, #4]
2000b8ac:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
2000b8b0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
2000b8b4:	80fb      	strh	r3, [r7, #6]
    data8 = (uint8_t)data16;
2000b8b6:	88bb      	ldrh	r3, [r7, #4]
2000b8b8:	727b      	strb	r3, [r7, #9]
            
    switch(g_comblk_state)
2000b8ba:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b8be:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b8c2:	781b      	ldrb	r3, [r3, #0]
2000b8c4:	2b05      	cmp	r3, #5
2000b8c6:	f200 814b 	bhi.w	2000bb60 <handle_rx_okay_irq+0x2c8>
2000b8ca:	a201      	add	r2, pc, #4	; (adr r2, 2000b8d0 <handle_rx_okay_irq+0x38>)
2000b8cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000b8d0:	2000b8e9 	.word	0x2000b8e9
2000b8d4:	2000bb4d 	.word	0x2000bb4d
2000b8d8:	2000bb4d 	.word	0x2000bb4d
2000b8dc:	2000b979 	.word	0x2000b979
2000b8e0:	2000b9f7 	.word	0x2000b9f7
2000b8e4:	2000bb0f 	.word	0x2000bb0f
        * MSS_COMBLK_init() enables the RCV_OKAY interrupt for the COMBLK_IDLE
        * state to receive the asynchronous power-on-reset from the system
        * controller.
        */
        case COMBLK_IDLE:
            if(is_command)
2000b8e8:	88fb      	ldrh	r3, [r7, #6]
2000b8ea:	2b00      	cmp	r3, #0
2000b8ec:	f000 8144 	beq.w	2000bb78 <handle_rx_okay_irq+0x2e0>
            {
                if(data8 != POR_DIGEST_ERROR_OPCODE)
2000b8f0:	7a7b      	ldrb	r3, [r7, #9]
2000b8f2:	2bf1      	cmp	r3, #241	; 0xf1
2000b8f4:	d006      	beq.n	2000b904 <handle_rx_okay_irq+0x6c>
                {
                    uint8_t rxed_opcode;
                    rxed_opcode = data8;
2000b8f6:	7a7b      	ldrb	r3, [r7, #9]
2000b8f8:	72bb      	strb	r3, [r7, #10]
                    process_sys_ctrl_command(rxed_opcode);
2000b8fa:	7abb      	ldrb	r3, [r7, #10]
2000b8fc:	4618      	mov	r0, r3
2000b8fe:	f000 fa0b 	bl	2000bd18 <process_sys_ctrl_command>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
2000b902:	e140      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                    rxed_opcode = data8;
                    process_sys_ctrl_command(rxed_opcode);
                }
                else
                {  
                    g_comblk_response_idx = 0;
2000b904:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b908:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b90c:	f04f 0200 	mov.w	r2, #0
2000b910:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = data8;
2000b912:	f24c 3334 	movw	r3, #49972	; 0xc334
2000b916:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b91a:	681a      	ldr	r2, [r3, #0]
2000b91c:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b920:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b924:	881b      	ldrh	r3, [r3, #0]
2000b926:	b29b      	uxth	r3, r3
2000b928:	4413      	add	r3, r2
2000b92a:	7a7a      	ldrb	r2, [r7, #9]
2000b92c:	701a      	strb	r2, [r3, #0]
                    g_comblk_response_idx++;
2000b92e:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b932:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b936:	881b      	ldrh	r3, [r3, #0]
2000b938:	b29b      	uxth	r3, r3
2000b93a:	f103 0301 	add.w	r3, r3, #1
2000b93e:	b29a      	uxth	r2, r3
2000b940:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b944:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b948:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
2000b94a:	f24c 3334 	movw	r3, #49972	; 0xc334
2000b94e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b952:	681a      	ldr	r2, [r3, #0]
2000b954:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b958:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b95c:	881b      	ldrh	r3, [r3, #0]
2000b95e:	b29b      	uxth	r3, r3
2000b960:	4413      	add	r3, r2
2000b962:	f04f 0200 	mov.w	r2, #0
2000b966:	701a      	strb	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
2000b968:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b96c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b970:	f04f 0204 	mov.w	r2, #4
2000b974:	701a      	strb	r2, [r3, #0]
                }
            }
        break;
2000b976:	e106      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
        /*----------------------------------------------------------------------
         * The RCV_OKAY interrupt should only be enabled for states
         * COMBLK_WAIT_RESPONSE and COMBLK_RX_RESPONSE. 
         */
        case COMBLK_WAIT_RESPONSE:
            if(is_command)
2000b978:	88fb      	ldrh	r3, [r7, #6]
2000b97a:	2b00      	cmp	r3, #0
2000b97c:	f000 80fe 	beq.w	2000bb7c <handle_rx_okay_irq+0x2e4>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
2000b980:	7a7b      	ldrb	r3, [r7, #9]
2000b982:	72fb      	strb	r3, [r7, #11]
                if(rxed_opcode == g_comblk_cmd_opcode)
2000b984:	f24c 3320 	movw	r3, #49952	; 0xc320
2000b988:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b98c:	781b      	ldrb	r3, [r3, #0]
2000b98e:	b2db      	uxtb	r3, r3
2000b990:	7afa      	ldrb	r2, [r7, #11]
2000b992:	429a      	cmp	r2, r3
2000b994:	d12a      	bne.n	2000b9ec <handle_rx_okay_irq+0x154>
                {
                    g_comblk_response_idx = 0u;
2000b996:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b99a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b99e:	f04f 0200 	mov.w	r2, #0
2000b9a2:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
2000b9a4:	f24c 3334 	movw	r3, #49972	; 0xc334
2000b9a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b9ac:	681a      	ldr	r2, [r3, #0]
2000b9ae:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b9b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b9b6:	881b      	ldrh	r3, [r3, #0]
2000b9b8:	b29b      	uxth	r3, r3
2000b9ba:	4413      	add	r3, r2
2000b9bc:	7afa      	ldrb	r2, [r7, #11]
2000b9be:	701a      	strb	r2, [r3, #0]
                    ++g_comblk_response_idx;
2000b9c0:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b9c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b9c8:	881b      	ldrh	r3, [r3, #0]
2000b9ca:	b29b      	uxth	r3, r3
2000b9cc:	f103 0301 	add.w	r3, r3, #1
2000b9d0:	b29a      	uxth	r2, r3
2000b9d2:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000b9d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b9da:	801a      	strh	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
2000b9dc:	f24c 3345 	movw	r3, #49989	; 0xc345
2000b9e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000b9e4:	f04f 0204 	mov.w	r2, #4
2000b9e8:	701a      	strb	r2, [r3, #0]
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
2000b9ea:	e0cc      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                    ++g_comblk_response_idx;
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
2000b9ec:	7afb      	ldrb	r3, [r7, #11]
2000b9ee:	4618      	mov	r0, r3
2000b9f0:	f000 f992 	bl	2000bd18 <process_sys_ctrl_command>
                }
            }
        break;
2000b9f4:	e0c7      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
            
        case COMBLK_RX_RESPONSE:
            if(is_command)
2000b9f6:	88fb      	ldrh	r3, [r7, #6]
2000b9f8:	2b00      	cmp	r3, #0
2000b9fa:	d006      	beq.n	2000ba0a <handle_rx_okay_irq+0x172>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
2000b9fc:	7a7b      	ldrb	r3, [r7, #9]
2000b9fe:	733b      	strb	r3, [r7, #12]
                process_sys_ctrl_command(rxed_opcode);
2000ba00:	7b3b      	ldrb	r3, [r7, #12]
2000ba02:	4618      	mov	r0, r3
2000ba04:	f000 f988 	bl	2000bd18 <process_sys_ctrl_command>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
2000ba08:	e0bd      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
            else
            {
                if( g_comblk_p_response[g_comblk_response_idx-1] == POR_DIGEST_ERROR_OPCODE)
2000ba0a:	f24c 3334 	movw	r3, #49972	; 0xc334
2000ba0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba12:	681a      	ldr	r2, [r3, #0]
2000ba14:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000ba18:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba1c:	881b      	ldrh	r3, [r3, #0]
2000ba1e:	b29b      	uxth	r3, r3
2000ba20:	f103 33ff 	add.w	r3, r3, #4294967295
2000ba24:	4413      	add	r3, r2
2000ba26:	781b      	ldrb	r3, [r3, #0]
2000ba28:	2bf1      	cmp	r3, #241	; 0xf1
2000ba2a:	d127      	bne.n	2000ba7c <handle_rx_okay_irq+0x1e4>
                {
                    g_comblk_p_response[g_comblk_response_idx] = data8;
2000ba2c:	f24c 3334 	movw	r3, #49972	; 0xc334
2000ba30:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba34:	681a      	ldr	r2, [r3, #0]
2000ba36:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000ba3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba3e:	881b      	ldrh	r3, [r3, #0]
2000ba40:	b29b      	uxth	r3, r3
2000ba42:	4413      	add	r3, r2
2000ba44:	7a7a      	ldrb	r2, [r7, #9]
2000ba46:	701a      	strb	r2, [r3, #0]
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
2000ba48:	f24c 3334 	movw	r3, #49972	; 0xc334
2000ba4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba50:	681a      	ldr	r2, [r3, #0]
2000ba52:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000ba56:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba5a:	881b      	ldrh	r3, [r3, #0]
2000ba5c:	b29b      	uxth	r3, r3
2000ba5e:	f103 33ff 	add.w	r3, r3, #4294967295
2000ba62:	4413      	add	r3, r2
2000ba64:	781b      	ldrb	r3, [r3, #0]
2000ba66:	4618      	mov	r0, r3
2000ba68:	f000 f956 	bl	2000bd18 <process_sys_ctrl_command>
                    g_comblk_state = COMBLK_IDLE;
2000ba6c:	f24c 3345 	movw	r3, #49989	; 0xc345
2000ba70:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba74:	f04f 0200 	mov.w	r2, #0
2000ba78:	701a      	strb	r2, [r3, #0]
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
2000ba7a:	e084      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
                    g_comblk_state = COMBLK_IDLE;
                }
                else
                {
                    if(g_comblk_response_idx < g_comblk_response_size)
2000ba7c:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000ba80:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba84:	881b      	ldrh	r3, [r3, #0]
2000ba86:	b29a      	uxth	r2, r3
2000ba88:	f24c 3338 	movw	r3, #49976	; 0xc338
2000ba8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000ba90:	881b      	ldrh	r3, [r3, #0]
2000ba92:	429a      	cmp	r2, r3
2000ba94:	d21d      	bcs.n	2000bad2 <handle_rx_okay_irq+0x23a>
                    {
                        uint8_t rxed_data;
                        
                        rxed_data = data8;
2000ba96:	7a7b      	ldrb	r3, [r7, #9]
2000ba98:	737b      	strb	r3, [r7, #13]
                        g_comblk_p_response[g_comblk_response_idx] = rxed_data;
2000ba9a:	f24c 3334 	movw	r3, #49972	; 0xc334
2000ba9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000baa2:	681a      	ldr	r2, [r3, #0]
2000baa4:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000baa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000baac:	881b      	ldrh	r3, [r3, #0]
2000baae:	b29b      	uxth	r3, r3
2000bab0:	4413      	add	r3, r2
2000bab2:	7b7a      	ldrb	r2, [r7, #13]
2000bab4:	701a      	strb	r2, [r3, #0]
                        ++g_comblk_response_idx;
2000bab6:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000baba:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000babe:	881b      	ldrh	r3, [r3, #0]
2000bac0:	b29b      	uxth	r3, r3
2000bac2:	f103 0301 	add.w	r3, r3, #1
2000bac6:	b29a      	uxth	r2, r3
2000bac8:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000bacc:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bad0:	801a      	strh	r2, [r3, #0]
                    }
                    
                    if(g_comblk_response_idx == g_comblk_response_size)
2000bad2:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000bad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bada:	881b      	ldrh	r3, [r3, #0]
2000badc:	b29a      	uxth	r2, r3
2000bade:	f24c 3338 	movw	r3, #49976	; 0xc338
2000bae2:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bae6:	881b      	ldrh	r3, [r3, #0]
2000bae8:	429a      	cmp	r2, r3
2000baea:	d149      	bne.n	2000bb80 <handle_rx_okay_irq+0x2e8>
                    {
                        complete_request(g_comblk_response_idx);
2000baec:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000baf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000baf4:	881b      	ldrh	r3, [r3, #0]
2000baf6:	b29b      	uxth	r3, r3
2000baf8:	4618      	mov	r0, r3
2000bafa:	f000 f849 	bl	2000bb90 <complete_request>
                        g_comblk_state = COMBLK_IDLE;
2000bafe:	f24c 3345 	movw	r3, #49989	; 0xc345
2000bb02:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bb06:	f04f 0200 	mov.w	r2, #0
2000bb0a:	701a      	strb	r2, [r3, #0]
                    }
                }
            }
        break;
2000bb0c:	e03b      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
         * The RCV_OKAY interrupt should NOT be enabled for states
         * COMBLK_IDLE, COMBLK_TX_CMD and COMBLK_TX_DATA.
         */
        case COMBLK_TX_PAGED_DATA:
            /* This is needed because when there is an error, we need to terminate loading the data */
            if(!is_command)
2000bb0e:	88fb      	ldrh	r3, [r7, #6]
2000bb10:	2b00      	cmp	r3, #0
2000bb12:	d114      	bne.n	2000bb3e <handle_rx_okay_irq+0x2a6>
            {
                g_comblk_p_response[1] = data8;
2000bb14:	f24c 3334 	movw	r3, #49972	; 0xc334
2000bb18:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bb1c:	681b      	ldr	r3, [r3, #0]
2000bb1e:	f103 0301 	add.w	r3, r3, #1
2000bb22:	7a7a      	ldrb	r2, [r7, #9]
2000bb24:	701a      	strb	r2, [r3, #0]
                complete_request(2u);
2000bb26:	f04f 0002 	mov.w	r0, #2
2000bb2a:	f000 f831 	bl	2000bb90 <complete_request>
                g_comblk_state = COMBLK_IDLE;
2000bb2e:	f24c 3345 	movw	r3, #49989	; 0xc345
2000bb32:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bb36:	f04f 0200 	mov.w	r2, #0
2000bb3a:	701a      	strb	r2, [r3, #0]
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
2000bb3c:	e023      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                g_comblk_state = COMBLK_IDLE;
            }
            else
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
2000bb3e:	7a7b      	ldrb	r3, [r7, #9]
2000bb40:	73bb      	strb	r3, [r7, #14]
                process_sys_ctrl_command(rxed_opcode);
2000bb42:	7bbb      	ldrb	r3, [r7, #14]
2000bb44:	4618      	mov	r0, r3
2000bb46:	f000 f8e7 	bl	2000bd18 <process_sys_ctrl_command>
            }
        break;
2000bb4a:	e01c      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
        
        case COMBLK_TX_CMD:
            /* Fall through */
        case COMBLK_TX_DATA:
            /* Fall through */
            if(is_command)
2000bb4c:	88fb      	ldrh	r3, [r7, #6]
2000bb4e:	2b00      	cmp	r3, #0
2000bb50:	d018      	beq.n	2000bb84 <handle_rx_okay_irq+0x2ec>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
2000bb52:	7a7b      	ldrb	r3, [r7, #9]
2000bb54:	73fb      	strb	r3, [r7, #15]
                process_sys_ctrl_command(rxed_opcode);
2000bb56:	7bfb      	ldrb	r3, [r7, #15]
2000bb58:	4618      	mov	r0, r3
2000bb5a:	f000 f8dd 	bl	2000bd18 <process_sys_ctrl_command>
            }
        break;
2000bb5e:	e012      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
        
        default:
            complete_request(0u);
2000bb60:	f04f 0000 	mov.w	r0, #0
2000bb64:	f000 f814 	bl	2000bb90 <complete_request>
            g_comblk_state = COMBLK_IDLE;
2000bb68:	f24c 3345 	movw	r3, #49989	; 0xc345
2000bb6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bb70:	f04f 0200 	mov.w	r2, #0
2000bb74:	701a      	strb	r2, [r3, #0]
2000bb76:	e006      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
2000bb78:	bf00      	nop
2000bb7a:	e004      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
2000bb7c:	bf00      	nop
2000bb7e:	e002      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
2000bb80:	bf00      	nop
2000bb82:	e000      	b.n	2000bb86 <handle_rx_okay_irq+0x2ee>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
2000bb84:	bf00      	nop
        default:
            complete_request(0u);
            g_comblk_state = COMBLK_IDLE;
        break;
    }
}
2000bb86:	f107 0710 	add.w	r7, r7, #16
2000bb8a:	46bd      	mov	sp, r7
2000bb8c:	bd80      	pop	{r7, pc}
2000bb8e:	bf00      	nop

2000bb90 <complete_request>:
 */
static void complete_request
(
    uint16_t response_length
)
{
2000bb90:	b580      	push	{r7, lr}
2000bb92:	b082      	sub	sp, #8
2000bb94:	af00      	add	r7, sp, #0
2000bb96:	4603      	mov	r3, r0
2000bb98:	80fb      	strh	r3, [r7, #6]
    if(g_comblk_completion_handler != 0)
2000bb9a:	f24c 333c 	movw	r3, #49980	; 0xc33c
2000bb9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bba2:	681b      	ldr	r3, [r3, #0]
2000bba4:	2b00      	cmp	r3, #0
2000bba6:	d01b      	beq.n	2000bbe0 <complete_request+0x50>
    {
        g_comblk_completion_handler(g_comblk_p_response, response_length);
2000bba8:	f24c 333c 	movw	r3, #49980	; 0xc33c
2000bbac:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bbb0:	681a      	ldr	r2, [r3, #0]
2000bbb2:	f24c 3334 	movw	r3, #49972	; 0xc334
2000bbb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bbba:	6819      	ldr	r1, [r3, #0]
2000bbbc:	88fb      	ldrh	r3, [r7, #6]
2000bbbe:	4608      	mov	r0, r1
2000bbc0:	4619      	mov	r1, r3
2000bbc2:	4790      	blx	r2
        g_comblk_completion_handler = 0;
2000bbc4:	f24c 333c 	movw	r3, #49980	; 0xc33c
2000bbc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bbcc:	f04f 0200 	mov.w	r2, #0
2000bbd0:	601a      	str	r2, [r3, #0]
        g_request_in_progress = 0u;
2000bbd2:	f24c 3344 	movw	r3, #49988	; 0xc344
2000bbd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bbda:	f04f 0200 	mov.w	r2, #0
2000bbde:	701a      	strb	r2, [r3, #0]
    }
}
2000bbe0:	f107 0708 	add.w	r7, r7, #8
2000bbe4:	46bd      	mov	sp, r7
2000bbe6:	bd80      	pop	{r7, pc}

2000bbe8 <abort_current_cmd>:

/*==============================================================================
 *
 */
static void abort_current_cmd(void)
{
2000bbe8:	b580      	push	{r7, lr}
2000bbea:	b082      	sub	sp, #8
2000bbec:	af00      	add	r7, sp, #0
    if(g_request_in_progress)
2000bbee:	f24c 3344 	movw	r3, #49988	; 0xc344
2000bbf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bbf6:	781b      	ldrb	r3, [r3, #0]
2000bbf8:	b2db      	uxtb	r3, r3
2000bbfa:	2b00      	cmp	r3, #0
2000bbfc:	d01f      	beq.n	2000bc3e <abort_current_cmd+0x56>
        
        /*
         * Call completion handler just in case we are in a multi threaded system
         * to avoid a task lockup.
         */
        complete_request(g_comblk_response_idx);
2000bbfe:	f24c 333a 	movw	r3, #49978	; 0xc33a
2000bc02:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bc06:	881b      	ldrh	r3, [r3, #0]
2000bc08:	b29b      	uxth	r3, r3
2000bc0a:	4618      	mov	r0, r3
2000bc0c:	f7ff ffc0 	bl	2000bb90 <complete_request>
        
        /*
         * Flush the FIFOs
         */
        COMBLK->CONTROL |= CR_FLUSHOUT_MASK;
2000bc10:	f246 0300 	movw	r3, #24576	; 0x6000
2000bc14:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bc18:	f246 0200 	movw	r2, #24576	; 0x6000
2000bc1c:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000bc20:	6812      	ldr	r2, [r2, #0]
2000bc22:	f042 0201 	orr.w	r2, r2, #1
2000bc26:	601a      	str	r2, [r3, #0]
        do {
            flush_in_progress = COMBLK->CONTROL & CR_FLUSHOUT_MASK;
2000bc28:	f246 0300 	movw	r3, #24576	; 0x6000
2000bc2c:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bc30:	681b      	ldr	r3, [r3, #0]
2000bc32:	f003 0301 	and.w	r3, r3, #1
2000bc36:	607b      	str	r3, [r7, #4]
        } while(flush_in_progress);
2000bc38:	687b      	ldr	r3, [r7, #4]
2000bc3a:	2b00      	cmp	r3, #0
2000bc3c:	d1f4      	bne.n	2000bc28 <abort_current_cmd+0x40>
    }
}
2000bc3e:	f107 0708 	add.w	r7, r7, #8
2000bc42:	46bd      	mov	sp, r7
2000bc44:	bd80      	pop	{r7, pc}
2000bc46:	bf00      	nop

2000bc48 <send_cmd_opcode>:
 */
static void send_cmd_opcode
(
    uint8_t opcode
)
{
2000bc48:	b480      	push	{r7}
2000bc4a:	b085      	sub	sp, #20
2000bc4c:	af00      	add	r7, sp, #0
2000bc4e:	4603      	mov	r3, r0
2000bc50:	71fb      	strb	r3, [r7, #7]
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
2000bc52:	f246 0300 	movw	r3, #24576	; 0x6000
2000bc56:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bc5a:	f246 0200 	movw	r2, #24576	; 0x6000
2000bc5e:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000bc62:	6812      	ldr	r2, [r2, #0]
2000bc64:	f022 0204 	bic.w	r2, r2, #4
2000bc68:	601a      	str	r2, [r3, #0]
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
2000bc6a:	f246 0300 	movw	r3, #24576	; 0x6000
2000bc6e:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bc72:	685b      	ldr	r3, [r3, #4]
2000bc74:	f003 0301 	and.w	r3, r3, #1
2000bc78:	60fb      	str	r3, [r7, #12]
    } while(0u == tx_okay);
2000bc7a:	68fb      	ldr	r3, [r7, #12]
2000bc7c:	2b00      	cmp	r3, #0
2000bc7e:	d0f4      	beq.n	2000bc6a <send_cmd_opcode+0x22>
    
    /* Send command opcode. */
    COMBLK->FRAME_START8 = opcode;
2000bc80:	f246 0300 	movw	r3, #24576	; 0x6000
2000bc84:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bc88:	79fa      	ldrb	r2, [r7, #7]
2000bc8a:	619a      	str	r2, [r3, #24]
}
2000bc8c:	f107 0714 	add.w	r7, r7, #20
2000bc90:	46bd      	mov	sp, r7
2000bc92:	bc80      	pop	{r7}
2000bc94:	4770      	bx	lr
2000bc96:	bf00      	nop

2000bc98 <fill_tx_fifo>:
static uint32_t fill_tx_fifo
(
    const uint8_t * p_cmd,
    uint32_t cmd_size
)
{
2000bc98:	b480      	push	{r7}
2000bc9a:	b085      	sub	sp, #20
2000bc9c:	af00      	add	r7, sp, #0
2000bc9e:	6078      	str	r0, [r7, #4]
2000bca0:	6039      	str	r1, [r7, #0]
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
2000bca2:	f246 0300 	movw	r3, #24576	; 0x6000
2000bca6:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bcaa:	f246 0200 	movw	r2, #24576	; 0x6000
2000bcae:	f2c4 0201 	movt	r2, #16385	; 0x4001
2000bcb2:	6812      	ldr	r2, [r2, #0]
2000bcb4:	f022 0204 	bic.w	r2, r2, #4
2000bcb8:	601a      	str	r2, [r3, #0]
    
    size_sent = 0u;
2000bcba:	f04f 0300 	mov.w	r3, #0
2000bcbe:	60fb      	str	r3, [r7, #12]
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
2000bcc0:	f246 0300 	movw	r3, #24576	; 0x6000
2000bcc4:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bcc8:	685b      	ldr	r3, [r3, #4]
2000bcca:	f003 0301 	and.w	r3, r3, #1
2000bcce:	60bb      	str	r3, [r7, #8]
    while((tx_okay != 0u) && (size_sent < cmd_size))
2000bcd0:	e014      	b.n	2000bcfc <fill_tx_fifo+0x64>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
2000bcd2:	f246 0300 	movw	r3, #24576	; 0x6000
2000bcd6:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bcda:	6879      	ldr	r1, [r7, #4]
2000bcdc:	68fa      	ldr	r2, [r7, #12]
2000bcde:	440a      	add	r2, r1
2000bce0:	7812      	ldrb	r2, [r2, #0]
2000bce2:	611a      	str	r2, [r3, #16]
        ++size_sent;
2000bce4:	68fb      	ldr	r3, [r7, #12]
2000bce6:	f103 0301 	add.w	r3, r3, #1
2000bcea:	60fb      	str	r3, [r7, #12]
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
2000bcec:	f246 0300 	movw	r3, #24576	; 0x6000
2000bcf0:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000bcf4:	685b      	ldr	r3, [r3, #4]
2000bcf6:	f003 0301 	and.w	r3, r3, #1
2000bcfa:	60bb      	str	r3, [r7, #8]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
2000bcfc:	68bb      	ldr	r3, [r7, #8]
2000bcfe:	2b00      	cmp	r3, #0
2000bd00:	d003      	beq.n	2000bd0a <fill_tx_fifo+0x72>
2000bd02:	68fa      	ldr	r2, [r7, #12]
2000bd04:	683b      	ldr	r3, [r7, #0]
2000bd06:	429a      	cmp	r2, r3
2000bd08:	d3e3      	bcc.n	2000bcd2 <fill_tx_fifo+0x3a>
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    }
    
    return size_sent;
2000bd0a:	68fb      	ldr	r3, [r7, #12]
}
2000bd0c:	4618      	mov	r0, r3
2000bd0e:	f107 0714 	add.w	r7, r7, #20
2000bd12:	46bd      	mov	sp, r7
2000bd14:	bc80      	pop	{r7}
2000bd16:	4770      	bx	lr

2000bd18 <process_sys_ctrl_command>:

/*==============================================================================
 *
 */
static void process_sys_ctrl_command(uint8_t cmd_opcode)
{
2000bd18:	b580      	push	{r7, lr}
2000bd1a:	b082      	sub	sp, #8
2000bd1c:	af00      	add	r7, sp, #0
2000bd1e:	4603      	mov	r3, r0
2000bd20:	71fb      	strb	r3, [r7, #7]
    if(g_async_event_handler != 0)
2000bd22:	f24c 3348 	movw	r3, #49992	; 0xc348
2000bd26:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bd2a:	681b      	ldr	r3, [r3, #0]
2000bd2c:	2b00      	cmp	r3, #0
2000bd2e:	d007      	beq.n	2000bd40 <process_sys_ctrl_command+0x28>
    {
        g_async_event_handler(cmd_opcode);
2000bd30:	f24c 3348 	movw	r3, #49992	; 0xc348
2000bd34:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000bd38:	681b      	ldr	r3, [r3, #0]
2000bd3a:	79fa      	ldrb	r2, [r7, #7]
2000bd3c:	4610      	mov	r0, r2
2000bd3e:	4798      	blx	r3
    }
}
2000bd40:	f107 0708 	add.w	r7, r7, #8
2000bd44:	46bd      	mov	sp, r7
2000bd46:	bd80      	pop	{r7, pc}

2000bd48 <__libc_init_array>:
2000bd48:	b570      	push	{r4, r5, r6, lr}
2000bd4a:	f64b 766c 	movw	r6, #49004	; 0xbf6c
2000bd4e:	f64b 756c 	movw	r5, #49004	; 0xbf6c
2000bd52:	f2c2 0600 	movt	r6, #8192	; 0x2000
2000bd56:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000bd5a:	1b76      	subs	r6, r6, r5
2000bd5c:	10b6      	asrs	r6, r6, #2
2000bd5e:	d006      	beq.n	2000bd6e <__libc_init_array+0x26>
2000bd60:	2400      	movs	r4, #0
2000bd62:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
2000bd66:	3401      	adds	r4, #1
2000bd68:	4798      	blx	r3
2000bd6a:	42a6      	cmp	r6, r4
2000bd6c:	d8f9      	bhi.n	2000bd62 <__libc_init_array+0x1a>
2000bd6e:	f64b 756c 	movw	r5, #49004	; 0xbf6c
2000bd72:	f64b 7670 	movw	r6, #49008	; 0xbf70
2000bd76:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000bd7a:	f2c2 0600 	movt	r6, #8192	; 0x2000
2000bd7e:	1b76      	subs	r6, r6, r5
2000bd80:	f000 f8e8 	bl	2000bf54 <_init>
2000bd84:	10b6      	asrs	r6, r6, #2
2000bd86:	d006      	beq.n	2000bd96 <__libc_init_array+0x4e>
2000bd88:	2400      	movs	r4, #0
2000bd8a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
2000bd8e:	3401      	adds	r4, #1
2000bd90:	4798      	blx	r3
2000bd92:	42a6      	cmp	r6, r4
2000bd94:	d8f9      	bhi.n	2000bd8a <__libc_init_array+0x42>
2000bd96:	bd70      	pop	{r4, r5, r6, pc}

2000bd98 <memset>:
2000bd98:	2a03      	cmp	r2, #3
2000bd9a:	b2c9      	uxtb	r1, r1
2000bd9c:	b430      	push	{r4, r5}
2000bd9e:	d807      	bhi.n	2000bdb0 <memset+0x18>
2000bda0:	b122      	cbz	r2, 2000bdac <memset+0x14>
2000bda2:	2300      	movs	r3, #0
2000bda4:	54c1      	strb	r1, [r0, r3]
2000bda6:	3301      	adds	r3, #1
2000bda8:	4293      	cmp	r3, r2
2000bdaa:	d1fb      	bne.n	2000bda4 <memset+0xc>
2000bdac:	bc30      	pop	{r4, r5}
2000bdae:	4770      	bx	lr
2000bdb0:	eb00 0c02 	add.w	ip, r0, r2
2000bdb4:	4603      	mov	r3, r0
2000bdb6:	e001      	b.n	2000bdbc <memset+0x24>
2000bdb8:	f803 1c01 	strb.w	r1, [r3, #-1]
2000bdbc:	f003 0403 	and.w	r4, r3, #3
2000bdc0:	461a      	mov	r2, r3
2000bdc2:	3301      	adds	r3, #1
2000bdc4:	2c00      	cmp	r4, #0
2000bdc6:	d1f7      	bne.n	2000bdb8 <memset+0x20>
2000bdc8:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
2000bdcc:	ebc2 040c 	rsb	r4, r2, ip
2000bdd0:	fb03 f301 	mul.w	r3, r3, r1
2000bdd4:	e01f      	b.n	2000be16 <memset+0x7e>
2000bdd6:	f842 3c40 	str.w	r3, [r2, #-64]
2000bdda:	f842 3c3c 	str.w	r3, [r2, #-60]
2000bdde:	f842 3c38 	str.w	r3, [r2, #-56]
2000bde2:	f842 3c34 	str.w	r3, [r2, #-52]
2000bde6:	f842 3c30 	str.w	r3, [r2, #-48]
2000bdea:	f842 3c2c 	str.w	r3, [r2, #-44]
2000bdee:	f842 3c28 	str.w	r3, [r2, #-40]
2000bdf2:	f842 3c24 	str.w	r3, [r2, #-36]
2000bdf6:	f842 3c20 	str.w	r3, [r2, #-32]
2000bdfa:	f842 3c1c 	str.w	r3, [r2, #-28]
2000bdfe:	f842 3c18 	str.w	r3, [r2, #-24]
2000be02:	f842 3c14 	str.w	r3, [r2, #-20]
2000be06:	f842 3c10 	str.w	r3, [r2, #-16]
2000be0a:	f842 3c0c 	str.w	r3, [r2, #-12]
2000be0e:	f842 3c08 	str.w	r3, [r2, #-8]
2000be12:	f842 3c04 	str.w	r3, [r2, #-4]
2000be16:	4615      	mov	r5, r2
2000be18:	3240      	adds	r2, #64	; 0x40
2000be1a:	2c3f      	cmp	r4, #63	; 0x3f
2000be1c:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
2000be20:	dcd9      	bgt.n	2000bdd6 <memset+0x3e>
2000be22:	462a      	mov	r2, r5
2000be24:	ebc5 040c 	rsb	r4, r5, ip
2000be28:	e007      	b.n	2000be3a <memset+0xa2>
2000be2a:	f842 3c10 	str.w	r3, [r2, #-16]
2000be2e:	f842 3c0c 	str.w	r3, [r2, #-12]
2000be32:	f842 3c08 	str.w	r3, [r2, #-8]
2000be36:	f842 3c04 	str.w	r3, [r2, #-4]
2000be3a:	4615      	mov	r5, r2
2000be3c:	3210      	adds	r2, #16
2000be3e:	2c0f      	cmp	r4, #15
2000be40:	f1a4 0410 	sub.w	r4, r4, #16
2000be44:	dcf1      	bgt.n	2000be2a <memset+0x92>
2000be46:	462a      	mov	r2, r5
2000be48:	ebc5 050c 	rsb	r5, r5, ip
2000be4c:	e001      	b.n	2000be52 <memset+0xba>
2000be4e:	f842 3c04 	str.w	r3, [r2, #-4]
2000be52:	4614      	mov	r4, r2
2000be54:	3204      	adds	r2, #4
2000be56:	2d03      	cmp	r5, #3
2000be58:	f1a5 0504 	sub.w	r5, r5, #4
2000be5c:	dcf7      	bgt.n	2000be4e <memset+0xb6>
2000be5e:	e001      	b.n	2000be64 <memset+0xcc>
2000be60:	f804 1b01 	strb.w	r1, [r4], #1
2000be64:	4564      	cmp	r4, ip
2000be66:	d3fb      	bcc.n	2000be60 <memset+0xc8>
2000be68:	e7a0      	b.n	2000bdac <memset+0x14>
2000be6a:	bf00      	nop
2000be6c:	6f470d0a 	.word	0x6f470d0a
2000be70:	4b482074 	.word	0x4b482074
2000be74:	61655220 	.word	0x61655220
2000be78:	676e6964 	.word	0x676e6964
2000be7c:	00000073 	.word	0x00000073

2000be80 <C.0.1475>:
2000be80:	00fc0f05                                ....

2000be84 <C.8.2448>:
2000be84:	00006a10                                .j..

2000be88 <C.0.2383>:
2000be88:	00006020                                 `..

2000be8c <C.57.5235>:
2000be8c:	71290020                                 .)q

2000be90 <C.58.5236>:
2000be90:	20002971                                q). 

2000be94 <C.59.5237>:
2000be94:	212a0020                                 .*!

2000be98 <C.60.5238>:
2000be98:	20002a21                                !*. 

2000be9c <g_nvm>:
2000be9c:	60080000 600c0000                       ...`...`

2000bea4 <g_nvm32>:
2000bea4:	60080000 600c0000                       ...`...`

2000beac <g_config_reg_lut>:
2000beac:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
2000bebc:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
2000becc:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
2000bedc:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
2000beec:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
2000befc:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
2000bf0c:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
2000bf1c:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

2000bf2c <g_gpio_irqn_lut>:
2000bf2c:	35343332 39383736 3d3c3b3a 41403f3e     23456789:;<=>?@A
2000bf3c:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ

2000bf4c <C.18.3527>:
2000bf4c:	01000100 03030202                       ........

2000bf54 <_init>:
2000bf54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000bf56:	bf00      	nop
2000bf58:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000bf5a:	bc08      	pop	{r3}
2000bf5c:	469e      	mov	lr, r3
2000bf5e:	4770      	bx	lr

2000bf60 <_fini>:
2000bf60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000bf62:	bf00      	nop
2000bf64:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000bf66:	bc08      	pop	{r3}
2000bf68:	469e      	mov	lr, r3
2000bf6a:	4770      	bx	lr

2000bf6c <__frame_dummy_init_array_entry>:
2000bf6c:	04d5 2000                                   ... 

2000bf70 <__do_global_dtors_aux_fini_array_entry>:
2000bf70:	04c1 2000 0000 0000 0000 0000 0000 0000     ... ............
